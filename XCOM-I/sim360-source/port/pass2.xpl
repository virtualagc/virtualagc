   /********************************************************************
   *                                                                   *
   *                 STONY BROOK PASCAL 360 COMPILER                   *
   *             PASS 2 -- GENERATION OF SYMBOLIC TRIPLES              *
   *                                                                   *
   ********************************************************************/

   /*

   COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK.

   */



   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */
DECLARE EJECT_PAGE LITERALLY 'OUTPUT, OUTPUT = ''''';
DECLARE DOUBLE_SPACE LITERALLY 'OUTPUT, OUTPUT = ''''';
DECLARE X1 CHARACTER INITIAL(' ');
DECLARE X2 CHARACTER INITIAL('  ');
DECLARE X4 CHARACTER INITIAL('    ');
DECLARE X70 CHARACTER INITIAL(
   '                                                                      ');

DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';
DECLARE NULL LITERALLY '-1';
DECLARE NUL LITERALLY '"FFFF"';
DECLARE MAXINT FIXED INITIAL(2147483647);

   /* THE SYMBOL TABLE */
DECLARE IDENTITY_LENGTH LITERALLY '500';
DECLARE TABLE_LENGTH LITERALLY '725';
DECLARE IDENTITY(IDENTITY_LENGTH) CHARACTER INITIAL(
   'FALSE', 'TRUE', 'NIL', '(..)', 'INTEGER', 'BOOLEAN', 'REAL', 'CHAR',
   'TEXT', 'INPUT', 'OUTPUT', 'ABS', 'SQR', 'ODD', 'SUCC', 'PRED', 'ORD',
   'CHR', 'TRUNC', 'EOF', 'SIN', 'COS', 'EXP', 'LN', 'SQRT', 'ARCTAN',
   'ROUND', 'EOLN', 'GET', 'PUT', 'RESET', 'REWRITE', 'NEW', 'READ', 'WRITE',
   'PACK', 'UNPACK', 'MAXINT', 'DISPOSE', 'PAGE', 'READLN', 'WRITELN',
   'CLOCK', 'INTFIELDSIZE', 'BOOLFIELDSIZE', 'REALFIELDSIZE',
   'DECIMAL_PLACES');
DECLARE STRUCTYPE(TABLE_LENGTH) BIT(16) INITIAL(
   1, 1, 3, 11, 14, 1, 14, 1, 6, 6,
   6, 10, 10, 10, 10, 10, 10, 10, 10, 10,
   14, 14, 14, 14, 14, 14, 10, 10, 10, 10,
   10, 10, 10, 10, 10, 10, 10, 14, 10, 10,
   10, 10, 10, 14, 14, 14, 14);
DECLARE DATATYPE(TABLE_LENGTH) BIT(16) INITIAL(
   5, 5, 2, 3, 4, 5, 6, 7, 7, 8,
   8, NUL, NUL, 5, NUL, NUL, 4, 7, 4, 5,
   6, 6, 6, 6, 6, 6, 4, 5, NUL, NUL,
   NUL, NUL, NUL, NUL, NUL, NUL, NUL, 4, NUL, NUL,
   NUL, NUL, 4, 4, 4, 4, 4);
DECLARE VAR_TYPE(TABLE_LENGTH) BIT(16) INITIAL(
   2, 2, 2, 2, 4, 4, 4, 4, 4, 1,
   1, 5, 5, 5, 5, 5, 5, 5, 5, 5,
   5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
   5, 5, 5, 5, 5, 5, 5, 2, 5, 5,
   5, 5, 5, 1, 1, 1, 1);
DECLARE OWNER(TABLE_LENGTH) BIT(16);
DECLARE VALUE(TABLE_LENGTH) BIT(32);
DECLARE S_LIST(TABLE_LENGTH) BIT(16);
DECLARE STORAGE_LNGTH(TABLE_LENGTH) FIXED;
DECLARE PSEUDO_REG(TABLE_LENGTH) BIT(16);
DECLARE DISPLACEMENT(TABLE_LENGTH) FIXED;
DECLARE N_DECL_SYMB BIT(16);
DECLARE N_ANONYMOUS_SYMB BIT(16);
DECLARE N_PREDECLARED_SYMB LITERALLY '46';
DECLARE FIRST_LITERAL BIT(16);
DECLARE SYMBOL_TABLE_OVERFLOW CHARACTER INITIAL('SYMBOL TABLE OVERFLOW');
DECLARE IS_NOT_A_TYPE CHARACTER INITIAL(' IS NOT A TYPE');

   /* POINTERS TO THE PREDECLARED CONSTANTS */
DECLARE FALSEPTR BIT(16) INITIAL(00),
   TRUEPTR       BIT(16) INITIAL(01),
   NILPTR        BIT(16) INITIAL(02),
   EMPTYSETPTR   BIT(16) INITIAL(03),
   MAXINTPTR     BIT(16) INITIAL(37);

   /* POINTERS INTO THE SYMBOL TABLE TO THE PREDECLARED TYPES */
DECLARE INTPTR BIT(16) INITIAL(4),
   BOOLPTR     BIT(16) INITIAL(5),
   REALPTR     BIT(16) INITIAL(6),
   CHARPTR     BIT(16) INITIAL(7),
   TEXTPTR     BIT(16) INITIAL(8);

   /* POINTERS TO THE PREDECLARED TEXTFILE VARIABLES */
DECLARE INPUTPTR BIT(16) INITIAL(09),
   OUTPUTPTR     BIT(16) INITIAL(10);

   /* POINTERS TO THE OUTPUT-FORMATTING VARIABLES */
DECLARE INTFIELDSIZEPTR BIT(16) INITIAL(43),
   BOOLFIELDSIZEPTR     BIT(16) INITIAL(44),
   REALFIELDSIZEPTR     BIT(16) INITIAL(45),
   DECIMAL_PLACESPTR    BIT(16) INITIAL(46);

   /* POINTERS TO SOME OF THE STANDARD PROCEDURES */
DECLARE ARCTANPTR BIT(16) INITIAL(25),
   CLOCKPTR       BIT(16) INITIAL(42),
   GETPTR         LITERALLY '28',
   PACKPTR        LITERALLY '35',
   PAGEPTR        LITERALLY '39',
   PUTPTR         LITERALLY '29',
   READPTR        BIT(16) INITIAL(33),
   READLNPTR      BIT(16) INITIAL(40),
   SINPTR         BIT(16) INITIAL(20),
   SUCCPTR        BIT(16) INITIAL(14),
   TRUNCPTR       BIT(16) INITIAL(18),
   WRITEPTR       BIT(16) INITIAL(34),
   WRITELNPTR     BIT(16) INITIAL(41);

   /* CHARACTER BUFFER USED IN SYMBOL TABLE AND PARSE TREE RESTORE ROUTINES */
DECLARE SY_TEXT CHARACTER;

   /* BUFFER WHICH ONE PAGE (80 BYTES) OF THE GLOBAL ACTIVATION RECORD */
DECLARE DATA_BYTES(79) BIT(8);

   /* GAP IS SET IN RESTORE_SY_TABLE AND USED IN READ_TREE TO FIX UP PARSE
      TREES, COMPENSATING FOR SYMBOL TABLE COMPACTIFICATION AT THE END OF
      PASS 1.                                                          */
DECLARE GAP BIT(16);

   /* KEEP COUNT OF ERRORS ENCOUNTERED IN PASS 2 */
DECLARE (ERROR_COUNT, SEVERE_ERRORS) FIXED;

   /* DECLARATIONS FOR THE TREE-TRAVERSAL ALGORITHM */
DECLARE NODE#STACK#OFLO CHARACTER INITIAL(
   'COMPILER ERROR, NODE#STACK OVERFLOW');
DECLARE NULREF CHARACTER INITIAL(
   'ATTEMPT TO ACCESS PARSE TREE BY A NULL REFERENCE POINTER');
DECLARE NODE FIXED;
DECLARE NPMAX LITERALLY '75';
DECLARE NP FIXED;
DECLARE (NODE#STACK, #POS_STACK) (NPMAX) BIT(16);
DECLARE ROOT_OF_SUBTREE FIXED;

   /* BUFFER FOR STORING GENERATED TRIPLES */
DECLARE TRIPLES(3599) BIT(16);                 /* SMALL-CORE VERSION */

   /* THE PARSE TREE */
DECLARE PARSE_TREE(7200) BIT(16);
DECLARE MULTIPLICITY LITERALLY 'PARSE_TREE';
DECLARE TREE_SIZE FIXED;

   /* IC IS THE INSTRUCTION COUNT, THE INDEX INTO THE PROGRAM.
      N_TRIPLES IS THE INDEX OF THE FIRST FREE ELEMENT OF THE ARRAY TRIPLES. */
DECLARE IC FIXED, N_TRIPLES BIT(16);

   /* STACK OF OPERANDS FOR TRIPLES */
DECLARE #OPMAX LITERALLY '100';
DECLARE OPERAND#STK(#OPMAX) BIT(16);
DECLARE #OP FIXED;
DECLARE OP#STACK#ERR CHARACTER INITIAL('OPERAND STACK OVERFLOW');

   /* OPERAND TYPE DEFINITION MASKS */
DECLARE MASK_SYMBOL BIT(16) INITIAL("0000");
DECLARE MASK_IMMEDIATE BIT(16) INITIAL("4000");
DECLARE MASK_TRIPLE BIT(16) INITIAL("8000");
DECLARE MASK_TEMP BIT(16) INITIAL("C000");

   /* LAST_TRIPLE IS SET EQUAL TO (N_TRIPLES - 3) | MASK_TRIPLE THROUGHOUT
      COMPILATION. */
DECLARE LAST_TRIPLE BIT(16);

   /* CURRENT_LINE AND LAST_LINE KEEP TRACK OF OUR POSITION RELATIVE TO
      THE SOURCE TEXT. */
DECLARE (CURRENT_LINE, LAST_LINE) FIXED;

   /* TOGGLES WHICH CONTROL THE AMOUNT OF PRINTOUT FROM PASS 2 */
DECLARE (PRINT_TREES, PRINT_TRIPLES, PRINT_SYMBOLS, PRINT_CODE) BIT(1);
DECLARE PRINT_STATISTICS BIT(1);

   /* MEASURE THE SIZE OF THE PASCAL PROGRAM BEING COMPILED */
DECLARE (PROC_SEQUENCE_NUMBER, BASIC_BLOCKS) FIXED;

   /* LEXICAL LEVEL OF PROCEDURE CURRENTLY BEING PROCESSED */
DECLARE CURRENT_LEVEL BIT(16);

   /* PR_CASES IS A BRANCH TABLE USED TO DIRECT THE ACTION TAKEN WHEN A NON-LEAF
         NODE OF THE PARSE_TREE IS VISITED THE FIRST TIME.             */
DECLARE #_PRODS LITERALLY '81';
   /* TURN OFF $FORMATTING */
DECLARE PR_CASES(#_PRODS) BIT(16) INITIAL(
   0, 3,3,10,3,3, 3,0,3,3,4, 3,3,0,6,7, 0,7,7,1,1, 7,7,0,0,0, 0,0,0,0,0,
   8,0,0,0,0, 0,0,0,0,0, 9,0,0,0,0, 9,7,11,0,0, 0,0,7,0,0, 0,0,0,0,0,
   0,0,5,0,5, 2,0,0,0,0, 5,0,5,2,7, 7,0,0,12,0, 13);
   /* TURN ON $FORMATTING */;
DECLARE ALLOCATE_NEW_ROW BIT(1) INITIAL(TRUE);
DECLARE ALLOCATE_ARRAY_ENTRY BIT(1) INITIAL(TRUE);
DECLARE (OWNER_STACK, ARRAYS_ALLOCATED, STACK_LIMIT,
   HALFWORD_DISP) (64) FIXED;

   /*    THE ABOVE VARIABLES ARE ALL INDEXED BY CURRENT_LEVEL.
         CURRENT_LEVEL IS INCREMENTED IN PRODS. 1, 8, 9, 66, AND 68.
            OWNER_STACK(CURRENT_LEVEL) POINTS TO THE ENTRY IN THE SYMBOL TABLE
                  FOR THE PROCEDURE OR RECORD TYPE THAT PROVIDES THE
                  SURROUNDING CONTEXT OF A DECLARATION;
            ARRAYS_ALLOCATED IS INITIALIZED TO NULL;
            HALFWORD_DISP IS INITIALIZED TO 0;
            STACK_LIMIT IS INITIALIZED IN PROD NO. 1 TO CONST_POOL_SIZE + 12,
                  IN PRODS NO. 8 AND 9 TO THE SIZE OF THE DISPLAY ALLOCATION,
                  AND IN PRODS NO. 66 AND 68 TO 0.
         OWNER_STACK(CURRENT_LEVEL) IS REFERENCED IN NEARLY EVERY PRODUCTION,
            TO SET THE VALUE OF THE OWNER FIELD IN THE SYMBOL TABLE.
         STACK_LIMIT(CURRENT_LEVEL) GIVES THE VALUE, IN BYTES, OF THE NEXT FREE
            STORAGE LOCATION IN EACH ACTIVITION RECORD OR RECORD TYPE SEGMENT.
            SCALAR VARIABLES ARE ALLOCATED AS THEY ARE ENCOUNTERED, AND
            STRUCTURED TYPES REQUIRING MORE THAN 4 BYTES OF STORAGE ARE HELD BY
            A LIST BASED ON ARRAYS_ALLOCATED(CURRENT_LEVEL).
         HALFWORD_DISP RECORDS 'HOLES' OF 2-BYTE SIZE THAT HAVE BEEN LEFT IN THE
            ALLOCATED STORAGE.  THE VALUE OF STACK_LIMIT IS ALWAYS INCREMENTED
            IN MULTIPLES OF 4 BYTES TO SECURE FULLWORD ALIGNMENT.  WHEN A 2-BYTE
            VARIABLE IS ALLOCATED, HALFWORD_DISP IS SET TO POINT TO THE
            REMAINING TWO BYTES, IF ANY.
            BOTH STACK_LIMIT AND HALFWORD_DISP ARE REFERENCED AND SET BY
            PROCEDURES ALLOCATE_STORAGE AND ALLOCATE_ARRAY_STORAGE, WHICH ARE
            CALLED FROM PRODUCTIONS NO. 10, 12, 25, 66, 67 AND 68.
            ALLOCATE_STORAGE IS ALSO CALLED FROM PRODUCTION NO. 25.
         ARRAYS_ALLOCATED IS USED TO MAINTAIN THE HEAD OF A LIST OF STRUCTURED
            VARIABLES THAT ARE TO BE ALLOCATED STORAGE IN A SEGMENT AFTER ALL
            SCALAR VARIABLES IN THAT SEGMENT HAVE BEEN ALLOCATED STORAGE.
            THE PROCEDURE ALLOCATE_STORAGE BUILDS THE LIST AND IT IS PROCESSED
            BY THE PROCEDURE ALLOCATE_ARRAY_STORAGE.
         CURRENT_LEVEL IS DECREMENTED IN PRODS NO. 10 AND 66.  PRIOR TO
            DECREMENTING, A CALL IS MADE TO ALLOCATE_ARRAY_STORAGE.    */

   /* VARIABLES USED IN DGNS ROUTINE FOR EMITTING ADD_DECIMAL INSTRUCTIONS */
DECLARE DGNS#_STACK(NPMAX) BIT(1);
DECLARE (DGNS#_TOP, DGNS#_GOTO) BIT(1);
DECLARE DGNS#_DEPTH BIT(16) INITIAL(NUL);

   /* "WITH" STATEMENTS ARE IMPLEMENTED USING THE FOLLOWING DOUBLE_BARRELLED
      STACK :__   */
DECLARE WITH_LENGTH LITERALLY '31';
DECLARE (WITH_DATATYPE, WITH_VARIABLE) (WITH_LENGTH) BIT(16);
DECLARE WITH_PTR BIT(16) INITIAL(NUL);

   /* A FIXUP LIST CONSISTS OF A CHAIN, THROUGH THE BRANCH ADDRESS (FIRST
         OPERAND) OF BRANCH TRIPLES, OF THOSE BRANCH TRIPLES WHOSE TARGET IS
         UNDETERMINED AS YET.  THE HIGH-ORDER BIT OF EACH FIXUP POINTER
         DETERMINES WHETHER THE BRANCH IS TO BE TAKEN TO A 'TRUE VALUE' TARGET
         (BIT IS ON) OR A 'FALSE VALUE' TARGET (BIT IS OFF).  LISTHEAD HOLDS THE
         HEAD OF ONE FIXUP LIST, AND FIX_LIST STACKS THE HEADS OF LEFT-OPERAND
         FIXUP LISTS (OF BINARY BOOLEAN OPERATORS).  FX HOLDS THE CURRENT
         LOGICAL VALUE ON WHICH TO BRANCH.  VALUES OF FX CORRESPONDING TO
         UNFULFILLED OPERATORS ARE STACKED IN THE FIRST OPERAND POINTERS -
         PARSE_TREE(NODE#STACK(NP) + 2).                                      */
DECLARE BOOLTYPE CHARACTER INITIAL('BOOLEAN EXPRESSION EXPECTED');
DECLARE FIX_LIST(NPMAX) BIT(16);
DECLARE LISTHEAD BIT(16), FX BIT(1);

   /* ENUMERATION TYPES --
      THESE ARE IMPLEMENTED BY READ-ONLY VARIABLES */

   /* TYPE STRUCTYPES =
        (STATEMENT, SCALAR, SUBRANGE, POINTER, ARRAY, PACKED_ARRAY, FILE,
         PACKED_FILE, RECORD, PACKED_RECORD, STANDARD, SET, PACKED_SET,
         ARITHMETIC);   */

DECLARE STATEMENT LITERALLY '0',
   SCALAR         LITERALLY '1',
   SUBRANGE       LITERALLY '2',
   POINTER        LITERALLY '3',
   ARRAY          LITERALLY '4',
   PACKED_ARRAY   LITERALLY '5',
   FILE           LITERALLY '6',
   PACKED_FILE    LITERALLY '7',
   RECORD         LITERALLY '8',
   PACKED_RECORD  LITERALLY '9',
   STANDARD       LITERALLY '10',
   SET            BIT(16) INITIAL(11),
   PACKED_SET     BIT(16) INITIAL(12),
   TAG            BIT(16) INITIAL(13),
   ARITHMETIC     BIT(16) INITIAL(14);

   /* TYPE VAR_TYPES =
        (TYPE_ID, VARIABLE, CONSTANT, LITERAL, TYPE, PROC, VAR_PARAM,
         PROC_PARAM, UNDEFINED, LABLE, TAG, CASELABEL, VARIANT, FIELD_ID,
         FORWARD, MULTDECL, VALUE_PARAM); */

DECLARE TYPE_ID BIT(16) INITIAL(00),
   VARIABLE     BIT(16) INITIAL(01),
   CONSTANT     BIT(16) INITIAL(02),
   LITERAL      BIT(16) INITIAL(03),
   TYPE         BIT(16) INITIAL(04),
   PROC         BIT(16) INITIAL(05),
   VAR_PARAM    BIT(16) INITIAL(06),
   PROC_PARAM   BIT(16) INITIAL(07),
   UNDEFINED    BIT(16) INITIAL(08),
   LABLE        BIT(16) INITIAL(09),
   CASELABEL    BIT(16) INITIAL(11),
   VARIANT      BIT(16) INITIAL(12),
   FIELD_ID     BIT(16) INITIAL(13),
   FORWARD      BIT(16) INITIAL(14),
   MULTDECL     BIT(16) INITIAL(15),
   VALUE_PARAM  BIT(16) INITIAL(16);

   /* TYPE OP_CODES =
        (LOAD, MONITOR, TRUNCATE, FLOAT, BCH_TARGET, INDEX, TEMP, STORE, MOVE,
         ADD, SUBTRACT, MULTIPLY, DIVIDE, COMPARE, ADD_DECIMAL, GREATER, LESS,
         NOT, ADDFLT, SUBFLT, MPYFLT, DIVFLT, COMPAREFLT, GREATERFLT, LESSFLT,
         LOAD_ADDR, AND, OR, XOR, RSHIFT, LSHIFT, BAL, BCH, BNZ, BZ, BCT,
         PCALL, PRETURN, PARM, BLKMARK, PEND, TPOP, REM, ABS, ABSFLT, NEGATE,
         NEGATEFLT, LLESS, LGREATER, LCOMPARE, PROCPARM, CASE, CASE_TARGET, ODD,
         SQR, SQRFLT, ROUND, S_LENGTH, IN, INTO, LINE#, RANGE); */

DECLARE LOAD   BIT(16) INITIAL(00),
   MONITOR     BIT(16) INITIAL(01),
   TRUNCATE    BIT(16) INITIAL(02),
   FLOAT       BIT(16) INITIAL(03),
   BCH_TARGET  BIT(16) INITIAL(04),
   INDEX       BIT(16) INITIAL(05),
   TEMP        BIT(16) INITIAL(06),
   STORE       BIT(16) INITIAL(07),
   MOVE        BIT(16) INITIAL(08),
   ADD         BIT(16) INITIAL(09),
   SUBTRACT    BIT(16) INITIAL(10),
   MULTIPLY    BIT(16) INITIAL(11),
   DIVIDE      BIT(16) INITIAL(12),
   COMPARE     BIT(16) INITIAL(13),
   ADD_DECIMAL BIT(16) INITIAL(14),
   GREATER     BIT(16) INITIAL(15),
   LESS        BIT(16) INITIAL(16),
   NOT         BIT(16) INITIAL(17),
   ADDFLT      BIT(16) INITIAL(18),
   SUBFLT      BIT(16) INITIAL(19),
   MPYFLT      BIT(16) INITIAL(20),
   DIVFLT      BIT(16) INITIAL(21),
   COMPAREFLT  BIT(16) INITIAL(22),
   GREATERFLT  BIT(16) INITIAL(23),
   LESSFLT     BIT(16) INITIAL(24),
   LOAD_ADDR   BIT(16) INITIAL(25),
   AND         BIT(16) INITIAL(26),
   OR          BIT(16) INITIAL(27),
   XOR BIT(16)         INITIAL(28),
   LSHIFT      BIT(16) INITIAL(29),
   RSHIFT      BIT(16) INITIAL(30),
   BAL         BIT(16) INITIAL(31),
   BCH         BIT(16) INITIAL(32),
   BNZ         BIT(16) INITIAL(33),
   BZ          BIT(16) INITIAL(34),
   BCT         BIT(16) INITIAL(35),
   PCALL       BIT(16) INITIAL(36),
   PRETURN     BIT(16) INITIAL(37),
   PARM        BIT(16) INITIAL(38),
   BLKMARK     BIT(16) INITIAL(39),
   PEND        BIT(16) INITIAL(40),
   TPOP        BIT(16) INITIAL(41),
   REM         BIT(16) INITIAL(42),
   ABS         BIT(16) INITIAL(43),
   ABSFLT      BIT(16) INITIAL(44),
   NEGATE      BIT(16) INITIAL(45),
   NEGATEFLT   BIT(16) INITIAL(46),
   LLESS       BIT(16) INITIAL(47),
   LGREATER    BIT(16) INITIAL(48),
   LCOMPARE    BIT(16) INITIAL(49),
   PROCPARM    BIT(16) INITIAL(50),
   CASE_JUMP   BIT(16) INITIAL(51),
   CASE_TARGET BIT(16) INITIAL(52),
   ODD         BIT(16) INITIAL(53),
   SQR         BIT(16) INITIAL(54),
   SQRFLT      BIT(16) INITIAL(55),
   ROUND       BIT(16) INITIAL(56),
   S_LENGTH    BIT(16) INITIAL(57),
   IN          BIT(16) INITIAL(58),
   INTO        BIT(16) INITIAL(59),
   LINE#       BIT(16) INITIAL(60),
   RANGE       BIT(16) INITIAL(61);

   /* TYPE COMPARISONS =
        (EQUAL_TO, GREATER_THAN, LESS_THAN, NOT_EQUAL_TO, LESS_EQ,
         GREATER_EQ); */

DECLARE EQUAL_TO BIT(16) INITIAL(0),
   GREATER_THAN BIT(16) INITIAL(1),
   LESS_THAN    BIT(16) INITIAL(2),
   NOT_EQUAL_TO BIT(16) INITIAL(3),
   LESS_EQ      BIT(16) INITIAL(4),
   GREATER_EQ   BIT(16) INITIAL(5);

   /*  VALUES USED IN THE ALLOCATION OF STORAGE ON THE RUNTIME STACK  */
DECLARE CONST_POOL_SIZE FIXED;
DECLARE DISPLAY_BYTES FIXED INITIAL(20);
   /* SL IS THE VARIABLE SET BY PROCEDURE COMPUTE_STORAGE_LENGTH  */
DECLARE SL FIXED;

   /* LEFT HAND SIDES IN INTERNAL FORM OF GRAMMAR */
DECLARE LEFT_PART(#_PRODS) CHARACTER INITIAL('', '<PROGRAM>', '<BLOCK>',
   '<STATEMENT LIST>', '<LABEL DECL>', '<CONST DECL>', '<TYPE DEFN>',
   '<PROC DECL LIST>', '<PROC DECL>', '<PROC DECL>', '<BODY>',
   '<VAR DECL LIST>', '<VAR DECL>', '<STATEMENT>', '<STATEMENT>',
   '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',
   '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',
   '<FORMAL PARAM>', '<FORMAL PARAM>', '<FORMAL PARAM>', '<CASE INSTANCE>',
   '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
   '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
   '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
   '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
   '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
   '<EXPRESSION>', '<EXPRESSION>', '<VARIABLE>', '<VARIABLE>', '<QUALIFIER>',
   '<QUALIFIER>', '<QUALIFIER>', '<QUALIFIER>', '<CONSTANT>', '<CONSTANT>',
   '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>',
   '<TYPE>', '<FIXED FIELD LIST>', '<VARIANT FIELD>', '<VARIANT INSTANCE>',
   '<STATEMENT>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<ELEMENT>',
   '<ELEMENT>', '<PARAM TYPES>', '<PARAM TYPES>', '<PARAM TYPES>',
   '<PARAM TYPES>', '<ERROR>');

   /*             P R O C E D U R E S                                  */

PAD:
PROCEDURE(STRING, WIDTH) CHARACTER;
   DECLARE STRING CHARACTER, (WIDTH, L) FIXED;

   DO WHILE LENGTH(STRING) + 70 < WIDTH;
      STRING = STRING || X70;
   END;
   L = LENGTH(STRING);
   IF L >= WIDTH THEN RETURN STRING;
   ELSE RETURN STRING || SUBSTR(X70, 0, WIDTH - L);
END PAD;

I_FORMAT:
PROCEDURE(NUMBER, WIDTH) CHARACTER;
   DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;

   STRING = NUMBER;
   L = LENGTH(STRING);
   IF L >= WIDTH THEN RETURN STRING;
   ELSE RETURN SUBSTR(X70, 0, WIDTH - L) || STRING;
END I_FORMAT;

ERROR:
PROCEDURE(MESSAGE, SEVERITY);
   DECLARE MESSAGE CHARACTER, SEVERITY FIXED;

   IF ERROR_COUNT = 0 THEN
      DO;
         EJECT_PAGE;
         OUTPUT = '*** PASS TWO DIAGNOSTICS:';
         DOUBLE_SPACE;
      END;
   ERROR_COUNT = ERROR_COUNT + 1;
   OUTPUT = '*** ERROR, ' || MESSAGE || '. DETECTED NEAR LINE ' ||
      CURRENT_LINE || '. ***';
   IF SEVERITY > 0 THEN SEVERE_ERRORS = SEVERE_ERRORS + 1;
END ERROR;

   /*                  DIAGNOSTIC  DUMP  ROUTINES                     */

SY_TABLE_STAT:
PROCEDURE(J);
   DECLARE J BIT(16);
   DECLARE LINE CHARACTER;
   DECLARE ID_FIELD FIXED INITIAL(12);
   DECLARE STRUCTYPES(14) CHARACTER INITIAL('STATMENT', 'SCALAR  ',
      'SUBRANGE', 'POINTER ', 'ARRAY   ', 'PKDARRAY', 'FILE    ',
      'PKD FILE', 'RECORD  ', 'PKDRECRD', 'STANDARD', 'SET     ',
      'PKD SET ', 'TAG     ', 'ARITHMET');
   DECLARE VAR_TYPES(16) CHARACTER INITIAL('        ', 'VARIABLE',
      'CONSTANT', 'LITERAL ', 'TYPE    ', 'PROC    ', 'VAR PARM',
      'PROCPARM', 'UNDEFINE', 'LABEL   ', '        ', 'CASELABL',
      'VARIANT ', 'FIELD ID', 'FORWARD ', 'MULTDECL', 'VAL PARM');

LJUSTIFY:
   PROCEDURE(X, FIELDWIDTH);
      DECLARE X CHARACTER, FIELDWIDTH FIXED;

      IF LENGTH(X) > FIELDWIDTH THEN
         X = SUBSTR(X, 0, FIELDWIDTH);
      LINE = PAD(LINE || X, LENGTH(LINE) + FIELDWIDTH);
   END LJUSTIFY;

RJUSTIFY:
   PROCEDURE(V, FIELDWIDTH);
      DECLARE X CHARACTER, (V, FIELDWIDTH) FIXED;

      X = V;
      IF LENGTH(X) > FIELDWIDTH + 4 THEN
         X = SUBSTR(X, 0, FIELDWIDTH + 4);
      LINE = PAD(LINE, LENGTH(LINE) + FIELDWIDTH + 4 - LENGTH(X)) || X;
   END RJUSTIFY;

   LINE = I_FORMAT(J, 4) || X2;
   IF J >= N_ANONYMOUS_SYMB THEN LINE = PAD(LINE, ID_FIELD + 6);
   ELSE CALL LJUSTIFY(IDENTITY(J), ID_FIELD);
   CALL RJUSTIFY(DATATYPE(J), 4);
   LINE = LINE || X4 || STRUCTYPES(STRUCTYPE(J)) || X4 ||
      VAR_TYPES(VAR_TYPE(J)) || X4;
   IF OWNER(J) = NULL THEN
      LINE = LINE || SUBSTR(X70, 0, ID_FIELD);
   ELSE IF OWNER(J) < N_ANONYMOUS_SYMB THEN
      CALL LJUSTIFY(IDENTITY(OWNER(J)), ID_FIELD);
   ELSE
      CALL LJUSTIFY('(' || OWNER(J) || ')', ID_FIELD);
   CALL RJUSTIFY(STORAGE_LNGTH(J), 4);
   CALL RJUSTIFY(S_LIST(J), 4);
   CALL RJUSTIFY(VALUE(J), 8);
   CALL RJUSTIFY(PSEUDO_REG(J), 4);
   CALL RJUSTIFY(DISPLACEMENT(J), 8);
   OUTPUT = LINE;
END SY_TABLE_STAT;

SY_DUMP:
PROCEDURE;
   DECLARE I BIT(16);
   EJECT_PAGE;
   OUTPUT = '      IDENTITY      DATATYPE  STRUCTYPE   VAR TYPE    OWNER     
  ST LENGTH   S_LIST      VALUE  PSEUDO_REG    DISP';
   OUTPUT = '';
   DO I = 0 TO N_DECL_SYMB - 1;
      CALL SY_TABLE_STAT(I);
   END;
END SY_DUMP;

PRINT_COMPILE_TIME:
PROCEDURE;
   DECLARE (COMPILE_TIME, L) FIXED, STRING CHARACTER;
   COMPILE_TIME = CLOCK_TRAP(NULL);   /* CANCELS CPU TIMER */
   STRING = COMPILE_TIME;   L = LENGTH(STRING);
   IF L < 5 THEN STRING = SUBSTR('00000', 0, 5 - L) || STRING;
   STRING = SUBSTR(STRING, 0, 3) || '.' || SUBSTR(STRING, 3, 2);
   OUTPUT = STRING || ' SECONDS IN COMPILATION, NO CODE GENERATED.';
END PRINT_COMPILE_TIME;

   /*                TREE - TRAVERSAL  PROCEDURES                     */

LEFTSON:
PROCEDURE;
   IF NODE = NULL THEN CALL ERROR(NULREF, 1);
   ELSE
      DO;
         IF MULTIPLICITY(NODE) = 0 THEN NODE = NULL;
         ELSE
            DO;
               IF NP >= NPMAX THEN
                  DO;
                     CALL ERROR(NODE#STACK#OFLO, 1);
                     NP = 0;
                  END;
               NP = NP + 1;
               NODE#STACK(NP) = NODE;
               #POS_STACK(NP) = 1;
               NODE = PARSE_TREE(NODE + 2);
               IF NODE ~= NULL THEN
                  CURRENT_LINE = PARSE_TREE(NODE + MULTIPLICITY(NODE) + 2);
            END;
      END;
END LEFTSON;

RIGHT_BRO:
PROCEDURE;
   IF MULTIPLICITY(NODE#STACK(NP)) > #POS_STACK(NP) THEN
      DO;
         NODE = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 2);
         #POS_STACK(NP) = #POS_STACK(NP) + 1;
         IF NODE ~= NULL THEN
            CURRENT_LINE = PARSE_TREE(NODE + MULTIPLICITY(NODE) + 2);
      END;
   ELSE NODE = NULL;
END RIGHT_BRO;

FATHER:
PROCEDURE;
   IF NP < 1 THEN CALL ERROR(NULREF, 1);
   ELSE
      DO;
         NODE = NODE#STACK(NP);
         NP = NP - 1;
      END;
END FATHER;

REPLACE:
PROCEDURE(NEWSON);
   DECLARE NEWSON BIT(16);
   IF NP < 1 THEN CALL ERROR(NULREF, 1);
   ELSE PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 1) = NEWSON;
END REPLACE;

REPLACE_LEFT_BRO:
PROCEDURE(NEWSON);
   DECLARE NEWSON BIT(16);
   IF (NP < 1) | (#POS_STACK(NP) < 2) THEN CALL ERROR(NULREF, 1);
   ELSE PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP)) = NEWSON;
END REPLACE_LEFT_BRO;

   /*             TYPE  COMPATIBILITY  CHECKING  PROCEDURE            */

COMPTYPES:
PROCEDURE(TYPE1, TYPE2) BIT(1);
   DECLARE (TYPE1, TYPE2) BIT(16);
   DECLARE COMP_STACKSIZE LITERALLY '50';
   DECLARE STACK1(COMP_STACKSIZE) BIT(16);
   DECLARE STACK2(COMP_STACKSIZE) BIT(16);
   DECLARE SP BIT(16);
   IF TYPE1 = TYPE2 THEN RETURN TRUE;
   SP = 1;  /* FIRST FREE STACK ELEMENT;  0 NOT USED */
   DO WHILE SP > 0;
      IF STRUCTYPE(TYPE1) ~= STRUCTYPE(TYPE2) THEN RETURN FALSE;
      ELSE
         DO CASE STRUCTYPE(TYPE1);
            /* CASE 0 -- STATEMENT */
            RETURN FALSE;
            /* CASE 1 -- SCALAR */
            IF DATATYPE(TYPE1) ~= DATATYPE(TYPE2) THEN
               RETURN FALSE;
            ELSE
               DO;
                  SP = SP - 1;
                  TYPE1 = STACK1(SP);
                  TYPE2 = STACK2(SP);
               END;
            /* CASE 2 -- SUBRANGE */
            IF DATATYPE(TYPE1) ~= DATATYPE(TYPE2) THEN
               RETURN FALSE;  /* UNDERLYING BASE TYPES MUST MATCH */
            ELSE IF VALUE(S_LIST(TYPE1)) ~= VALUE(S_LIST(TYPE2)) THEN
               RETURN FALSE;  /* LOWBOUNDS MUST MATCH */
            ELSE IF STORAGE_LNGTH(TYPE1) ~= STORAGE_LNGTH(TYPE2) THEN
               RETURN FALSE;  /* HIGHBOUNDS MUST MATCH */
            ELSE
               DO;
                  SP = SP - 1;
                  TYPE1 = STACK1(SP);
                  TYPE2 = STACK2(SP);
               END;
            /* CASE 3 -- POINTER */
            DO;
               IF (TYPE1 ~= NILPTR) & (TYPE2 ~= NILPTR) THEN
                  IF (DATATYPE(TYPE1) ~= DATATYPE(TYPE2)) THEN
                     RETURN FALSE;
               /* ALTERNATIVE - CHECK FOR COMPATIBILITY OF REFERENCED
                                TYPES.  MUST BEWARE OF CYCLES, HOWEVER */
               SP = SP - 1;
               TYPE1 = STACK1(SP);
               TYPE2 = STACK2(SP);
            END;
            /* CASE 4 -- ARRAY */
            IF STORAGE_LNGTH(TYPE1) ~= STORAGE_LNGTH(TYPE2) THEN
               RETURN FALSE;
            ELSE
               DO;
                  TYPE1 = DATATYPE(TYPE1);
                  TYPE2 = DATATYPE(TYPE2);
               END;
            /* CASE 5 -- PACKED ARRAY */
            IF STORAGE_LNGTH(TYPE1) ~= STORAGE_LNGTH(TYPE2) THEN
               RETURN FALSE;
            ELSE
               DO;
                  TYPE1 = DATATYPE(TYPE1);
                  TYPE2 = DATATYPE(TYPE2);
               END;
            /* CASE 6 -- FILE */
            DO;
               TYPE1 = DATATYPE(TYPE1);
               TYPE2 = DATATYPE(TYPE2);
            END;
            /* CASE 7 -- PACKED FILE */
            DO;
               TYPE1 = DATATYPE(TYPE1);
               TYPE2 = DATATYPE(TYPE2);
            END;
            /* CASE 8 -- RECORD */
         CASE#8:
            IF TYPE1 = TYPE2 THEN
               DO;
                  SP = SP - 1;
                  TYPE1 = STACK1(SP);
                  TYPE2 = STACK2(SP);
               END;
            ELSE IF STORAGE_LNGTH(TYPE1) ~= STORAGE_LNGTH(TYPE2) THEN
               RETURN FALSE;
            ELSE
               DO;
                  TYPE1 = S_LIST(TYPE1);
                  TYPE2 = S_LIST(TYPE2);
                  DO WHILE (VAR_TYPE(TYPE1) = FIELD_ID)
                        & (VAR_TYPE(TYPE2) = FIELD_ID);
                     STACK1(SP) = DATATYPE(TYPE1);
                     STACK2(SP) = DATATYPE(TYPE2);
                     TYPE1 = S_LIST(TYPE1);
                     TYPE2 = S_LIST(TYPE2);
                     SP = SP + 1;
                  END;
                  IF (TYPE1 ~= NULL) | (TYPE2 ~= NULL) THEN
                     RETURN FALSE;
                  ELSE
                     DO;
                        SP = SP - 1;
                        TYPE1 = STACK1(SP);
                        TYPE2 = STACK2(SP);
                     END;
               END;
            /* CASE 9 -- PACKED RECORD */
            GOTO CASE#8;
            /* CASE 10 -- "STANDARD" */
            RETURN FALSE;
            /* CASE 11 -- SET */
            IF (TYPE1 ~= EMPTYSETPTR) & (TYPE2 ~= EMPTYSETPTR) THEN
               DO;
                  IF VALUE(TYPE1) ~= VALUE(TYPE2) THEN RETURN FALSE;
                  IF STORAGE_LNGTH(TYPE1) ~= STORAGE_LNGTH(TYPE2) THEN
                     RETURN FALSE;
                  TYPE1 = DATATYPE(TYPE1);
                  TYPE2 = DATATYPE(TYPE2);
               END;
            ELSE
               DO;
                  SP = SP - 1;
                  TYPE1 = STACK1(SP);
                  TYPE2 = STACK2(SP);
               END;
            /* CASE 12 -- PACKED SET */
            DO;
               IF VALUE(TYPE1) ~= VALUE(TYPE2) THEN RETURN FALSE;
               IF STORAGE_LNGTH(TYPE1) ~= STORAGE_LNGTH(TYPE2) THEN
                  RETURN FALSE;
               TYPE1 = DATATYPE(TYPE1);
               TYPE2 = DATATYPE(TYPE2);
            END;
            /* CASE 13 -- TAG */
            RETURN FALSE;
            /* CASE 14 -- ARITHMETIC */
            IF DATATYPE(TYPE1) ~= DATATYPE(TYPE2) THEN RETURN FALSE;
            ELSE
               DO;
                  SP = SP - 1;
                  TYPE1 = STACK1(SP);
                  TYPE2 = STACK2(SP);
               END;
         END;  /* CASE */
   END;  /* WHILE */
   RETURN TRUE;
END COMPTYPES;

COMPPROCS:
PROCEDURE(PROC1, PROC2) BIT(1);
   DECLARE (PROC1, PROC2) BIT(16);
   /* RETURNS TRUE IFF PROCEDURE PROC1 CAN BE USED AS ACTUAL PARAMETER
      FOR FORMAL PROCEDURE PROC2.                                   */
   DECLARE PROC_STACKSIZE LITERALLY '32';
   DECLARE (STACK1, STACK2) (PROC_STACKSIZE) BIT(16), SP BIT(16);
   SP = 1;   /* FIRST STACK ELEMENT; 0 NOT USED */
   DO WHILE SP > 0;
      /* RETURN TYPES MUST BE COMPATIBLE */
      IF STRUCTYPE(PROC1) ~= STRUCTYPE(PROC2) THEN RETURN FALSE;
      IF ~COMPTYPES(DATATYPE(PROC1), DATATYPE(PROC2)) THEN RETURN FALSE;
      /* PARAMETER LISTS MUST BE COMPATIBLE */
      IF VAR_TYPE(PROC1) = PROC_PARAM THEN PROC1 = VALUE(PROC1);
      ELSE PROC1 = S_LIST(PROC1);
      IF VAR_TYPE(PROC2) = PROC_PARAM THEN PROC2 = VALUE(PROC2);
      ELSE PROC2 = S_LIST(PROC2);
      DO WHILE (PROC1 ~= NULL) & (PROC2 ~= NULL);
         IF VAR_TYPE(PROC1) ~= VAR_TYPE(PROC2) THEN RETURN FALSE;
         IF VAR_TYPE(PROC1) = PROC_PARAM THEN
            DO;
               STACK1(SP) = PROC1;
               STACK2(SP) = PROC2;
               SP = SP + 1;
            END;
         ELSE IF ~COMPTYPES(DATATYPE(PROC1), DATATYPE(PROC2)) THEN
            RETURN FALSE;
         PROC1 = S_LIST(PROC1);
         PROC2 = S_LIST(PROC2);
      END;
      IF (PROC1 ~= NULL) | (PROC2 ~= NULL) THEN RETURN FALSE;
      SP = SP - 1;
      PROC1 = STACK1(SP);
      PROC2 = STACK2(SP);
   END;
   RETURN TRUE;
END COMPPROCS;

   /*                   THE CODE EMITTING PROCEDURE                   */

EMIT_TRIPLE:
PROCEDURE(OP_CODE, OPND1, OPND2, STOR_LENGTH);
   DECLARE (OP_CODE, OPND1, OPND2, STOR_LENGTH, NEW_LINE, LINE_MASK) BIT(16);
   DECLARE NEW_LINE_TRIPLE BIT(1);
   IF CURRENT_LINE <= LAST_LINE THEN
      NEW_LINE, LINE_MASK, NEW_LINE_TRIPLE = 0;
   ELSE IF (CURRENT_LINE - LAST_LINE) = 1 THEN
      DO;
         LAST_LINE, NEW_LINE = CURRENT_LINE;
         LINE_MASK = "0080";
         NEW_LINE_TRIPLE = FALSE;
      END;
   ELSE
      DO;
         LAST_LINE = CURRENT_LINE;
         NEW_LINE, LINE_MASK = 0;
         NEW_LINE_TRIPLE = TRUE;
      END;
   /* IN SMALL-CORE VERSION, TRIPLES OVERLAPS WITH PARSE_TREE */
   IF N_TRIPLES + 3 * (NEW_LINE_TRIPLE + 1) > 3600 + NODE THEN
      DO;
         CALL ERROR('STATEMENT PART OF BLOCK '
            || IDENTITY(OWNER_STACK(CURRENT_LEVEL))
            || ' IS TOO BIG', 1);
         N_TRIPLES = 0;
      END;
   IF NEW_LINE_TRIPLE THEN
      DO;
         TRIPLES(N_TRIPLES) = LINE#;
         TRIPLES(N_TRIPLES + 1) = CURRENT_LINE;
         TRIPLES(N_TRIPLES + 2) = NULL;
         IC = IC + 1;
         N_TRIPLES = N_TRIPLES + 3;
      END;
   TRIPLES(N_TRIPLES) = SHL(STOR_LENGTH, 8) | LINE_MASK | OP_CODE;
   TRIPLES(N_TRIPLES + 1) = OPND1;
   TRIPLES(N_TRIPLES + 2) = OPND2;
   IC = IC + 1;
   LAST_TRIPLE = N_TRIPLES | MASK_TRIPLE;
   N_TRIPLES = N_TRIPLES + 3;
END EMIT_TRIPLE;

   /*             GENERATE SEQUENTIAL OUTPUT FILES                   */

REWIND:
PROCEDURE(IS_OUTPUT_FILE, FILE#);
   DECLARE IS_OUTPUT_FILE BIT(1), FILE# FIXED;
   CALL INLINE("1B", 0, 0);                   /* SR   0,0               */
   CALL INLINE("43", 0, 0, IS_OUTPUT_FILE);   /* IC   0,IS_OUTPUT_FILE  */
   CALL INLINE("41", 1, 0, 0, 28);            /* LA   1,28              */
   CALL INLINE("58", 2, 0, FILE#);            /* L    2,FILE#           */
   CALL INLINE("05", 12, 15);                 /* BALR 12,15             */
END REWIND;

COREIM_DESCRIPT:
PROCEDURE(ADDRESS, LENGTH) CHARACTER;
   DECLARE (ADDRESS, LENGTH, DESCRIPTOR) FIXED;
   IF LENGTH = 0 THEN DESCRIPTOR = 0;
   ELSE DESCRIPTOR = SHL(LENGTH - 1, 24) + ADDRESS;
   /* WE RETURN DESCRIPTOR IN REGISTER 3 */
   CALL INLINE("58", 3, 0, DESCRIPTOR);          /* L    3,DESCRIPTOR      */
END COREIM_DESCRIPT;

WRITE_TRIPLES:
PROCEDURE;
   /* WRITE A CORE IMAGE OF THE TRIPLES BUFFER OUT TO A SEQUENTIALLY-
         ACCESSED FILE */
   DECLARE I BIT(16), TEXT CHARACTER;
   TEXT = '%TRIPLE';
   IF PRINT_CODE THEN TEXT = TEXT || 'E';
   ELSE TEXT = TEXT || X1;
   IF PRINT_TRIPLES THEN TEXT = TEXT || 'T';
   ELSE TEXT = TEXT || X1;
   TEXT = TEXT || IDENTITY(TRIPLES(0));
   OUTPUT(4) = TEXT;
   I = 0;
   DO WHILE I < N_TRIPLES;
      OUTPUT(4) = COREIM_DESCRIPT(ADDR(TRIPLES(I)), 80);
      I = I + 40;   /* 2 BYTES PER ARRAY ELEMENT */
   END;
   OUTPUT(4) = '%END';
END WRITE_TRIPLES;

WRITE_SYMBOLS:
PROCEDURE;
   DECLARE (I, J) FIXED, (LINE, S1, S2) CHARACTER;
   DECLARE ID CHARACTER;
   CALL REWIND(FALSE, 2);   /* REWIND TREES FILE */
   CALL REWIND(TRUE, 4);   /* REWIND TRIPLES FILE */
   IF PRINT_STATISTICS THEN S1 = 'D';
   ELSE S1 = X1;
   OUTPUT(3) = '%SYMB' || I_FORMAT(N_DECL_SYMB, 5)
      || I_FORMAT(BASIC_BLOCKS, 5)
      || I_FORMAT(PROC_SEQUENCE_NUMBER, 5) || S1;
   I = 0;
   DO WHILE I < N_DECL_SYMB;
      OUTPUT(3) = COREIM_DESCRIPT(ADDR(STORAGE_LNGTH(I)), 80);
      I = I + 20;
   END;
   I = 0;
   DO WHILE I < N_DECL_SYMB;
      OUTPUT(3) = COREIM_DESCRIPT(ADDR(PSEUDO_REG(I)), 80);
      I = I + 40;
   END;
   I = 0;
   DO WHILE I < N_DECL_SYMB;
      OUTPUT(3) = COREIM_DESCRIPT(ADDR(DISPLACEMENT(I)), 80);
      I = I + 20;
   END;
   OUTPUT(3) = '%END';
   CALL REWIND(TRUE, 3);   /* REWIND SYMBOL TABLE FILE */
END WRITE_SYMBOLS;

EMIT_DATA_BYTES:
PROCEDURE(DATA_PTR);
   DECLARE DATA_PTR BIT(16);
   DECLARE (I, J, INDEX) BIT(16);
   /* THIS PROCEDURE CREATES AN ENTRY INTO THE GLOBAL ACTIVATION RECORD
      FOR THE SYMBOL TABLE ENTRY POINTED TO BY DATA_PTR.  ONE PAGE (80 BYTES)
      OF THIS ACTIVATION RECORD IS KEPT IN CORE IN THE GLOBAL ARRAY
      DATA_BYTES.  WHEN DATA_BYTES BECOMES FULL, IT IS OUTPUTTED TO
      OUTPUT(5), AND HALFWORD_DISP(1) BECOMES ZERO.   */

WRITE_DATA:
   PROCEDURE;
      DECLARE J BIT(16);
      OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);
      HALFWORD_DISP(1) = 0;
      CALL INLINE("D7", "4", "F", DATA_BYTES, DATA_BYTES);
      /* XC   DATA_BYTES(80), DATA_BYTES  */
   END WRITE_DATA;

   IF SEVERE_ERRORS + MONITOR_LINK(3) > 0 THEN RETURN;
   INDEX = DISPLACEMENT(DATA_PTR) MOD 80;
   IF VAR_TYPE(DATA_PTR) = CONSTANT THEN
      DO I = 1 TO STORAGE_LNGTH(DATA_PTR);
         IF INDEX = 0 THEN CALL WRITE_DATA;
         J = SHL(STORAGE_LNGTH(DATA_PTR) - I, 3);
         DATA_BYTES(INDEX) = SHR(VALUE(DATA_PTR), J);
         INDEX = (INDEX + 1) MOD 80;
      END;
   ELSE IF VAR_TYPE(DATA_PTR) = LITERAL THEN
      DO I = 0 TO STORAGE_LNGTH(DATA_PTR) - 1;
         IF INDEX = 0 THEN CALL WRITE_DATA;
         DATA_BYTES(INDEX) = BYTE(IDENTITY(DATA_PTR), I);
         INDEX = (INDEX + 1) MOD 80;
      END;
   ELSE  /* VAR_TYPE(DATA_PTR) IN (.VARIABLE, VAR_PARAM, PROC_PARAM.) */
   IF (INDEX = 0) | (INDEX + STORAGE_LNGTH(DATA_PTR) > 80) THEN
      DO;
         CALL WRITE_DATA;
         DO I = 1 TO (STORAGE_LNGTH(DATA_PTR) + INDEX - 1) / 80;
            OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);
         END;
      END;
END EMIT_DATA_BYTES;

PREPARE_POST_MORTEM_TABLES:
PROCEDURE;
   DECLARE (I, OWNER_PTR, RELOCATION_INDEX, PROCSEQ#) FIXED,
      ID_BUFFER CHARACTER, PMD_FILE BIT(16) INITIAL(7),
      SYT_CASE(16) BIT(8) INITIAL(
      0, 2, 4, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
   /* SET_OF_SIMPLE_TYPES INCLUDES SCALAR, SUBRANGE, POINTER AND ARITHMETIC.
      BITS ARE ENUMERATED FROM THE RIGHT.   */
   DECLARE SET_OF_SIMPLE_TYPES BIT(16) INITIAL("(1) 01000000 00001110");
   /* STORAGE OCCUPIED BY THE ARRAYS 'OWNER_STACK', 'ARRAYS_ALLOCATED',
      'STACK_LIMIT' AND 'HALFWORD_DISP' IS OVERLAID TO SAVE SPACE.   */
   DECLARE LIST_END LITERALLY 'OWNER_STACK',
      PROCEDURE_HEADING LITERALLY 'STACK_LIMIT';

IS_STRING:
   PROCEDURE(TYPE_PTR) BIT(1);
      DECLARE TYPE_PTR BIT(16);   /* POINTER TO TYPE ENTRY IN SY_TABLE */
      RETURN (STRUCTYPE(TYPE_PTR) = ARRAY)
         & COMPTYPES(DATATYPE(TYPE_PTR), CHARPTR);
   END IS_STRING;

WRITE_COLUMN:
   PROCEDURE(ARRAY_ADDR, ITEMS_PER_IMAGE, LIMIT);
      DECLARE (ARRAY_ADDR, ITEMS_PER_IMAGE, LIMIT, I, J) FIXED;
      I, J = 0;
      DO WHILE I <= LIMIT;
         OUTPUT(PMD_FILE) = COREIM_DESCRIPT(ARRAY_ADDR + J, 80);
         I = I + ITEMS_PER_IMAGE;
         J = J + 80;
      END;
   END WRITE_COLUMN;

   /* INITIALIZE LIST_END AND PROCEDURE_HEADING */
   DO I = 0 TO PROC_SEQUENCE_NUMBER;
      LIST_END(I), PROCEDURE_HEADING(I) = NULL;
   END;
   DO I = INTFIELDSIZEPTR TO DECIMAL_PLACESPTR;
      /* THESE VARIABLES DO NOT APPEAR IN DUMP */
      VAR_TYPE(I) = LITERAL;
   END;
   RELOCATION_INDEX = -1;
   DO I = 0 TO N_ANONYMOUS_SYMB - 1;
      DO CASE SYT_CASE(VAR_TYPE(I));
         /* CASE 0 -- NOT OT BE COPIED */
         PSEUDO_REG(I) = NULL;
         /* CASE 1 -- A PROCEDURE HEADING */
         IF I > N_PREDECLARED_SYMB THEN
            DO;   /* A USER-DEFINED PROCEDURE */
               IDENTITY(I) = PAD(IDENTITY(I), 12);
               IDENTITY(I) = SUBSTR(IDENTITY(I), 0, 12);
               IF DATATYPE(I) ~= NULL THEN
                  DO;   /* A FUNCTION PROCEDURE */
                     DATATYPE(I) = PSEUDO_REG(DATATYPE(I));
                     OWNER(I) = 4;   /* STORAGE_LNGTH */
                  END;
               ELSE OWNER(I) = 0;
               S_LIST(I) = NULL;
               RELOCATION_INDEX, PSEUDO_REG(I) = RELOCATION_INDEX + 1;
               PROCEDURE_HEADING(VALUE(I)) = RELOCATION_INDEX;
            END;
         ELSE PSEUDO_REG(I) = NULL;
         /* CASE 2 -- A VARIABLE */
         IF (SHR(SET_OF_SIMPLE_TYPES, STRUCTYPE(I)) & 1)
            | IS_STRING(DATATYPE(I)) THEN
            DO;
               IDENTITY(I) = PAD(IDENTITY(I), 12);
               IDENTITY(I) = SUBSTR(IDENTITY(I), 0, 12);
               /* RELOCATE THE DATATYPE POINTER */
               IF STRUCTYPE(I) = SUBRANGE THEN
                  DO;
                     VALUE(I) = VALUE(S_LIST(DATATYPE(I)));
                     DATATYPE(I) = PSEUDO_REG(DATATYPE(DATATYPE(I)));
                  END;
               ELSE
                  DO;
                     VALUE(I) = 0;
                     IF DATATYPE(I) >= N_ANONYMOUS_SYMB THEN
                        DO;
                           IF STRUCTYPE(I) = SCALAR THEN
                              DATATYPE(I) = S_LIST(DATATYPE(I)) +
                                 RELOCATION_INDEX - I + 1;
                           ELSE  /* CHARACTER ARRAY */
                              DATATYPE(I) = PSEUDO_REG(CHARPTR);
                        END;
                     ELSE DATATYPE(I) = PSEUDO_REG(DATATYPE(I));
                  END;
               OWNER_PTR = OWNER(I);
               PROCSEQ# = VALUE(OWNER_PTR);
               RELOCATION_INDEX, PSEUDO_REG(I) = RELOCATION_INDEX + 1;
               /* USE THE OWNER FIELD FOR STORAGE_LNGTH */
               OWNER(I) = STORAGE_LNGTH(I);
               S_LIST(I) = NULL;
               /* ATTACH THIS SYT ENTRY TO THE LIST OF OWNER'S VARIABLES */
               IF LIST_END(PROCSEQ#) = NULL THEN
                  S_LIST(OWNER_PTR) = RELOCATION_INDEX;
               ELSE S_LIST(LIST_END(PROCSEQ#)) = RELOCATION_INDEX;
               LIST_END(PROCSEQ#) = I;
            END;
         ELSE PSEUDO_REG(I) = NULL;
         /* CASE 3 -- A TYPE */
         IF (STRUCTYPE(I) = SCALAR) | (STRUCTYPE(I) = ARITHMETIC) THEN
            DO;
               IDENTITY(I) = PAD(IDENTITY(I), 12);
               IDENTITY(I) = SUBSTR(IDENTITY(I), 0, 12);
               OWNER(I) = STORAGE_LNGTH(I);
               RELOCATION_INDEX, PSEUDO_REG(I), DATATYPE(I) =
                  RELOCATION_INDEX + 1;
            END;
         ELSE PSEUDO_REG(I) = NULL;
         /* CASE 4 -- A CONSTANT */
         IF STRUCTYPE(I) = SCALAR THEN
            DO;
               IDENTITY(I) = PAD(IDENTITY(I), 12);
               IDENTITY(I) = SUBSTR(IDENTITY(I), 0, 12);
               RELOCATION_INDEX, PSEUDO_REG(I) = RELOCATION_INDEX + 1;
               IF VALUE(I) = 0 THEN
                  DO;
                     IF DATATYPE(I) >= N_ANONYMOUS_SYMB THEN
                        DATATYPE(I) = I;
                     S_LIST(DATATYPE(I)) = RELOCATION_INDEX;
                     DATATYPE(I) = PSEUDO_REG(DATATYPE(I));
                  END;
               ELSE DATATYPE(I) = DATATYPE(I - 1);
            END;
         ELSE PSEUDO_REG(I) = NULL;
      END;   /* CASE */
   END;   /* DO I */
   DATATYPE(FALSEPTR), DATATYPE(TRUEPTR) = PSEUDO_REG(BOOLPTR);
   /* COMPRESS THE SYMBOL TABLE */
   N_DECL_SYMB = 2;
   DO I = 3 TO N_ANONYMOUS_SYMB - 1;
      IF PSEUDO_REG(I) ~= NULL THEN
         DO;
            IDENTITY(N_DECL_SYMB) = IDENTITY(I);
            DATATYPE(N_DECL_SYMB) = DATATYPE(I);
            VAR_TYPE(N_DECL_SYMB) = VAR_TYPE(I);
            STRUCTYPE(N_DECL_SYMB) = STRUCTYPE(I);
            OWNER(N_DECL_SYMB) = OWNER(I);
            S_LIST(N_DECL_SYMB) = S_LIST(I);
            DISPLACEMENT(N_DECL_SYMB) = DISPLACEMENT(I);
            VALUE(N_DECL_SYMB) = VALUE(I);
            N_DECL_SYMB = N_DECL_SYMB + 1;
         END;
   END;
   N_DECL_SYMB = N_DECL_SYMB - 1;
   /* OUTPUT THE POST MORTEM INFO */
   OUTPUT(PMD_FILE) = '%PMD ' || I_FORMAT(N_DECL_SYMB, 5)
      || I_FORMAT(PROC_SEQUENCE_NUMBER, 5);
   /* WRITE OUT THE IDENTITY COLUMN */
   ID_BUFFER = '';
   DO I = 0 TO N_DECL_SYMB;
      ID_BUFFER = ID_BUFFER || IDENTITY(I);
      IF LENGTH(ID_BUFFER) > 80 THEN
         DO;
            OUTPUT(PMD_FILE) = SUBSTR(ID_BUFFER, 0, 80);
            ID_BUFFER = SUBSTR(ID_BUFFER, 80);
         END;
   END;
   OUTPUT(PMD_FILE) = ID_BUFFER;
   /* WRITE OUT THE OTHER SYMBOL TABLE COLUMNS OF INTEREST */
   CALL WRITE_COLUMN(ADDR(DATATYPE), 40, N_DECL_SYMB);
   CALL WRITE_COLUMN(ADDR(VAR_TYPE), 40, N_DECL_SYMB);
   CALL WRITE_COLUMN(ADDR(STRUCTYPE), 40, N_DECL_SYMB);
   CALL WRITE_COLUMN(ADDR(OWNER), 40, N_DECL_SYMB);
   CALL WRITE_COLUMN(ADDR(S_LIST), 40, N_DECL_SYMB);
   CALL WRITE_COLUMN(ADDR(DISPLACEMENT), 20, N_DECL_SYMB);
   CALL WRITE_COLUMN(ADDR(VALUE), 20, N_DECL_SYMB);
   /* WRITE THE PROCEDURE HEADING TABLE */
   CALL WRITE_COLUMN(ADDR(PROCEDURE_HEADING), 20, PROC_SEQUENCE_NUMBER);
   OUTPUT(PMD_FILE) = '%END';
   CALL REWIND(TRUE, PMD_FILE);
END PREPARE_POST_MORTEM_TABLES;

   /*       PROCEDURES FOR EMITTING BLOCK COUNTERS FOR FLOW SUMMARY       */

DGNS#_PUSH:
PROCEDURE;
   DGNS#_DEPTH = DGNS#_DEPTH + 1;
   DGNS#_GOTO, DGNS#_TOP, DGNS#_STACK(DGNS#_DEPTH) = FALSE;
END DGNS#_PUSH;

DGNS#_POP:
PROCEDURE;
   DGNS#_GOTO = DGNS#_TOP & (DGNS#_DEPTH > 0);
   DGNS#_DEPTH = DGNS#_DEPTH - 1;
   IF DGNS#_DEPTH >= 0 THEN
      DO;
         DGNS#_TOP = DGNS#_TOP | DGNS#_STACK(DGNS#_DEPTH);
         DGNS#_STACK(DGNS#_DEPTH) = DGNS#_TOP;
      END;
END DGNS#_POP;

EMIT_ADD_DECIMAL:
PROCEDURE;
   IF MONITOR_LINK(2) < 2 THEN RETURN;
   CALL EMIT_TRIPLE(ADD_DECIMAL, BASIC_BLOCKS, 1 | MASK_IMMEDIATE, 0);
   BASIC_BLOCKS = BASIC_BLOCKS + 1;
END EMIT_ADD_DECIMAL;

NEXT_FREE_ROW:
PROCEDURE FIXED;
   /* THIS PROCEDURE ALLOCATES A NEW SYMBOL TABLE ENTRY.  IT REFERS TO,
         AND UPDATES, THE GLOBAL VARIABLE N_DECL_SYMB.   */
   IF N_DECL_SYMB < TABLE_LENGTH THEN N_DECL_SYMB = N_DECL_SYMB + 1;
   ELSE CALL ERROR(SYMBOL_TABLE_OVERFLOW, 1);
   RETURN N_DECL_SYMB - 1;
END NEXT_FREE_ROW;

   /*           PROCEDURE FOR CREATING AN OPERAND OUT OF AN            */
   /*                        INTEGER CONSTANT.                         */

FINDCONST:
PROCEDURE(INTCONST) BIT(16);
   /* WE CREATE AN INTEGER CONSTANT OPERAND FOR A TRIPLE.  IF IT IS
      TOO LARGE TO BE AN IMMEDIATE OPERAND, WE SEARCH THE SYMBOL TABLE
      FOR THE INTEGER CONSTANT INTCONST.  IF WE THEN DO NOT FIND IT,
      WE ENTER IT, AND RETURN ITS INDEX.                          */
   DECLARE INTCONST FIXED, INDEX BIT(16);
   IF (0 <= INTCONST) & (INTCONST < 4096) THEN
      /* RETURN AN IMMEDIATE OPERAND */
      RETURN INTCONST | MASK_IMMEDIATE;
   INDEX = S_LIST(INTPTR);
   DO WHILE INDEX ~= NULL;
      IF VALUE(INDEX) = INTCONST THEN RETURN INDEX | MASK_SYMBOL;
      INDEX = S_LIST(INDEX);
   END;
   INDEX = N_DECL_SYMB;
   N_DECL_SYMB = N_DECL_SYMB + 1;
   IF N_DECL_SYMB > TABLE_LENGTH THEN
      DO;
         CALL ERROR(SYMBOL_TABLE_OVERFLOW, 1);
         RETURN;
      END;
   S_LIST(INDEX) = S_LIST(INTPTR);
   S_LIST(INTPTR) = INDEX;
   DATATYPE(INDEX) = INTPTR;
   VAR_TYPE(INDEX) = CONSTANT;
   STRUCTYPE(INDEX) = ARITHMETIC;
   VALUE(INDEX) = INTCONST;
   STORAGE_LNGTH(INDEX) = 4;
   PSEUDO_REG(INDEX) = 0;
   DISPLACEMENT(INDEX) = STACK_LIMIT(1);
   STACK_LIMIT(1) = STACK_LIMIT(1) + 4;
   CALL EMIT_DATA_BYTES(INDEX);
   RETURN INDEX | MASK_SYMBOL;
END FINDCONST;

FINDREAL:
PROCEDURE(REALCONST) BIT(16);
   /* WE CREATE A REAL CONSTANT OPERAND FOR A TRIPLE.  FIRST WE SEARCH THE
      SYMBOL TABLE FOR THE REAL CONSTANT "REALCONST".  IF WE THEN DO NOT
      FIND IT WE ENTER IT AND RETURN ITS INDEX.                        */
   DECLARE REALCONST FIXED, INDEX BIT(16);
   INDEX = S_LIST(REALPTR);
   DO WHILE INDEX ~= NULL;
      IF VALUE(INDEX) = REALCONST THEN RETURN INDEX | MASK_SYMBOL;
      INDEX = S_LIST(INDEX);
   END;
   INDEX = N_DECL_SYMB;
   N_DECL_SYMB = N_DECL_SYMB + 1;
   IF N_DECL_SYMB > TABLE_LENGTH THEN
      DO;
         CALL ERROR(SYMBOL_TABLE_OVERFLOW, 1);
         RETURN;
      END;
   S_LIST(INDEX) = S_LIST(REALPTR);
   S_LIST(REALPTR) = INDEX;
   DATATYPE(INDEX) = REALPTR;
   VAR_TYPE(INDEX) = CONSTANT;
   STRUCTYPE(INDEX) = ARITHMETIC;
   VALUE(INDEX) = REALCONST;
   STORAGE_LNGTH(INDEX) = 4;
   PSEUDO_REG(INDEX) = 0;
   DISPLACEMENT(INDEX) = STACK_LIMIT(1);
   STACK_LIMIT(1) = STACK_LIMIT(1) + 4;
   CALL EMIT_DATA_BYTES(INDEX);
   RETURN INDEX | MASK_SYMBOL;
END FINDREAL;

   /*                   THE TRIPLES - SYNTHESIZER                     */

RANGE_CHECK:
PROCEDURE(TYPE, LOWBOUND, HIGHBOUND);
   /* WHEN THIS PROCEDURE IS CALLED, THE TOP ELEMENT OF OPERAND#STK
      HAS JUST BEEN COERCED TO A SUBRANGE TYPE, AND NODE HAS BEEN
      REPLACED IN PARSE_TREE BY A POINTER TO THAT TYPE.  WE EMIT
      TRIPLES TO CHECK WHETHER THE COERCION HAS INDEED RESULTED IN
      A VALUE WITHIN THE TARGET RANGE.                             */
   DECLARE (TYPE, OPND) BIT(16), (LOWBOUND, HIGHBOUND) BIT(1);
   IF MONITOR_LINK(2) = 0 THEN  /* DEBUG LEVEL = 0 */ RETURN;
   HIGHBOUND = HIGHBOUND & (STORAGE_LNGTH(TYPE) ~= MAXINT);
   IF ~(LOWBOUND | HIGHBOUND) THEN RETURN;
   OPND = OPERAND#STK(#OP);
   /* IF OPND IS NOT IN A REGISTER, LOAD IT */
   IF (OPND & "C000") ~= (MASK_TRIPLE & "C000") THEN
      DO;
         CALL EMIT_TRIPLE(LOAD, OPND, NULL, 3);
         OPND, OPERAND#STK(#OP) = LAST_TRIPLE;
      END;
   IF LOWBOUND THEN
      DO;  /* SEE IF OPERAND IS LESS THAN ZERO */
         CALL EMIT_TRIPLE(LESS, OPND | MASK_TEMP, 0 | MASK_IMMEDIATE, 0);
         IF HIGHBOUND THEN
            CALL EMIT_TRIPLE(BNZ, (N_TRIPLES + 9) | MASK_TRIPLE,
               LAST_TRIPLE, 0);
         ELSE CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 6) | MASK_TRIPLE,
               LAST_TRIPLE, 0);
      END;
   IF HIGHBOUND THEN
      DO;  /* SEE IF OPERAND IS GREATER THAN HIGHBOUND */
         CALL EMIT_TRIPLE(GREATER, OPND | MASK_TEMP,
            FINDCONST(STORAGE_LNGTH(TYPE) - 1), 0);
         CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 3 * LOWBOUND + 6) | MASK_TRIPLE,
            LAST_TRIPLE, 0);
         IF LOWBOUND THEN CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
      END;
   /* VALUE OUT OF RANGE -- CALL THE MONITOR */
   CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
   CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
END RANGE_CHECK;

COERCE_ASSIGNMENT:
PROCEDURE(TYPE1, TYPE2);
   /* WE HAVE TWO OPERANDS, OPND1 AND OPND2, OF TYPES TYPE1 AND TYPE2
      RESPECTIVELY.  OPND2 IS THE TOP ELEMENT OF OPERAND#STK.  WE WISH
      TO ASSIGN THE VALUE OF OPND2 TO OPND1.  THIS PROCEDURE WILL PER-
      FORM A LEGAL IMPLICIT TYPE COERCION FROM TYPE2 TO TYPE1 IF
      NECESSARY.                                                         */
   DECLARE (TYPE1, TYPE2, OPND2) BIT(16);
   DECLARE (LOW1, LOW2) FIXED;
   DECLARE RANGE_ERR CHARACTER INITIAL('VALUE OUT OF RANGE');
   DECLARE INCOMPATIBLE_DATATYPES CHARACTER INITIAL(
      'INCOMPATIBLE DATATYPES');
   DECLARE ERROR_FLAG BIT(1);
   DECLARE I FIXED, OFFSET FIXED;
   IF COMPTYPES(TYPE1, TYPE2) THEN
      /* NO COERCION IS NECESSARY */ RETURN;
   OPND2 = OPERAND#STK(#OP);
   IF STRUCTYPE(TYPE1) ~= STRUCTYPE(TYPE2) THEN
      DO;
         IF ((STRUCTYPE(TYPE2) = SCALAR) | (STRUCTYPE(TYPE2) = ARITHMETIC)) &
            (STRUCTYPE(TYPE1) = SUBRANGE) THEN
            DO;
               LOW1 = VALUE(S_LIST(TYPE1));
               IF COMPTYPES(TYPE2, DATATYPE(TYPE1)) THEN
                  DO;  /* COERCE SCALAR TO SUBRANGE */
                     IF (OPND2 & "C000") = MASK_IMMEDIATE THEN
                        OPND2, OPERAND#STK(#OP) =
                           FINDCONST((OPND2 & "3FFF") - LOW1);
                     ELSE IF ((OPND2 & "C000") = MASK_SYMBOL) &
                           (VAR_TYPE(OPND2) = CONSTANT) THEN
                        OPND2, OPERAND#STK(#OP) =
                           FINDCONST(VALUE(OPND2) - LOW1);
                     ELSE IF LOW1 ~= 0 THEN
                        DO;
                           CALL EMIT_TRIPLE(SUBTRACT, OPND2,
                              FINDCONST(LOW1), 3);
                           OPND2, OPERAND#STK(#OP) = LAST_TRIPLE;
                        END;
                     IF (OPND2 & "C000") = MASK_IMMEDIATE THEN
                        DO;
                           IF (OPND2 & "3FFF") + LOW1 > VALUE(TYPE1) THEN
                              DO;
                                 CALL ERROR(RANGE_ERR, 0);
                                 CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
                              END;
                        END;
                     ELSE IF ((OPND2 & "C000") = MASK_SYMBOL) &
                           (VAR_TYPE(OPND2) = CONSTANT) THEN
                        DO;
                           IF (VALUE(OPND2) > STORAGE_LNGTH(TYPE1)) |
                              (VALUE(OPND2) < 0) THEN
                              DO;
                                 CALL ERROR(RANGE_ERR, 0);
                                 CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
                              END;
                        END;
                     ELSE CALL RANGE_CHECK(TYPE1, TRUE, TRUE);
                     CALL REPLACE(TYPE1);
                     RETURN;
                  END;
               ELSE
                  DO;
                     CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
                     RETURN;
                  END;
            END;
         ELSE IF ((STRUCTYPE(TYPE1) = SCALAR) |
               (STRUCTYPE(TYPE1) = ARITHMETIC)) &
               (STRUCTYPE(TYPE2) = SUBRANGE) THEN
            DO;  /* COERCE SUBRANGE TO SCALAR */
               LOW2 = VALUE(S_LIST(TYPE2));
               IF LOW2 ~= 0 THEN
                  DO;
                     CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOW2), 3);
                     OPERAND#STK(#OP) = LAST_TRIPLE;
                  END;
               TYPE2 = DATATYPE(TYPE2);
               CALL REPLACE(TYPE1);
               IF COMPTYPES(TYPE1, TYPE2) THEN RETURN;
               /* ELSE DO NOT RETURN;  MAY HAVE TO FLOAT OPND2 */
               OPND2 = OPERAND#STK(#OP);
            END;
         ELSE
            DO;
               CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
               RETURN;
            END;
      END;
   /* NOW STRUCTYPE(TYPE1) = STRUCTYPE(TYPE2), AND ~COMPTYPES(TYPE1,TYPE2) */
   IF STRUCTYPE(TYPE1) = ARITHMETIC THEN
      DO;
         IF COMPTYPES(TYPE1, REALPTR) & COMPTYPES(TYPE2, INTPTR) THEN
            DO;  /* FLOAT OPERAND 2 */
               CALL EMIT_TRIPLE(FLOAT, OPND2, NULL, 3);
               OPERAND#STK(#OP) = LAST_TRIPLE;
               CALL REPLACE(REALPTR);
            END;
         ELSE CALL ERROR('ILLEGAL REAL EXPRESSION', 1);
      END;
   ELSE IF STRUCTYPE(TYPE1) = SUBRANGE THEN
      DO;
         IF ~COMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2)) THEN
            DO;
               CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
               RETURN;
            END;
         /* COERCE TYPE2 TO TYPE1 */
         LOW1 = VALUE(S_LIST(TYPE1));
         LOW2 = VALUE(S_LIST(TYPE2));
         IF LOW1 ~= LOW2 THEN
            DO;
               CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOW2 - LOW1), 3);
               OPERAND#STK(#OP) = LAST_TRIPLE;
            END;
         CALL RANGE_CHECK(TYPE1, (LOW1 > LOW2),
            (VALUE(TYPE1) < VALUE(TYPE2)));
         CALL REPLACE(TYPE1);
      END;
   ELSE IF STRUCTYPE(TYPE1) = SET THEN
      DO;
         ERROR_FLAG = ~COMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2));
         IF ~ERROR_FLAG THEN
            DO;
               LOW1 = VALUE(TYPE1);
               LOW2 = VALUE(TYPE2);
               OFFSET =
                  LOW1 + STORAGE_LNGTH(TYPE1) - LOW2 - STORAGE_LNGTH(TYPE2);
               ERROR_FLAG = (LOW1 > LOW2) | (OFFSET < 0);
            END;
         IF ERROR_FLAG THEN
            DO;
               CALL REPLACE(EMPTYSETPTR);
               CALL ERROR('INCOMPATIBLE SET TYPES', 1);
               RETURN;
            END;
         /* COERCE TYPE2 TO TYPE1 */
         I = N_TRIPLES | MASK_TEMP;
         CALL EMIT_TRIPLE(TEMP, NULL, 0, STORAGE_LNGTH(TYPE1) - 1);
         CALL EMIT_TRIPLE( XOR, I, I, 0);
         CALL EMIT_TRIPLE(INDEX, I, FINDCONST(LOW2 - LOW1),
            STORAGE_LNGTH(TYPE2) - 1);
         CALL EMIT_TRIPLE(MOVE, LAST_TRIPLE, OPND2, 0);
         OPERAND#STK(#OP) = I & "BFFF";
         CALL REPLACE(TYPE1);
      END;
   ELSE CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
END COERCE_ASSIGNMENT;

COERCE_PARAMETER:
PROCEDURE(ACTUAL, FORMAL, ACTUAL_TYPE);
   DECLARE (ACTUAL, FORMAL, ACTUAL_TYPE) BIT(16);
   DECLARE VAR_ERR CHARACTER INITIAL('VAR PARAMETER MUST BE A VARIABLE');
   IF VAR_TYPE(FORMAL) = VARIABLE THEN
      DO;
         IF (ACTUAL & "C000") = MASK_SYMBOL THEN
            IF VAR_TYPE(ACTUAL) = VAR_PARAM THEN
               DO;
                  CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE, ACTUAL,
                     STORAGE_LNGTH(FORMAL) - 1);
                  OPERAND#STK(#OP) = LAST_TRIPLE;
                  IF STORAGE_LNGTH(FORMAL) > 255 THEN
                     CALL EMIT_TRIPLE(S_LENGTH, SHR(STORAGE_LNGTH(FORMAL),
                        16), STORAGE_LNGTH(FORMAL), 0);
               END;
            ELSE IF ACTUAL = EMPTYSETPTR THEN
               DO;
                  CALL EMIT_TRIPLE(TEMP, NULL, 0, STORAGE_LNGTH(FORMAL) - 1);
                  ACTUAL, OPERAND#STK(#OP) = LAST_TRIPLE;
                  CALL EMIT_TRIPLE( XOR, ACTUAL | MASK_TEMP, ACTUAL | MASK_TEMP,
                     0);
               END;
         CALL COERCE_ASSIGNMENT(DATATYPE(FORMAL), ACTUAL_TYPE);
      END;
   ELSE IF VAR_TYPE(FORMAL) = VAR_PARAM THEN
      DO;
         IF ~COMPTYPES(DATATYPE(FORMAL), ACTUAL_TYPE) THEN
            CALL ERROR('VAR PARAMETER NOT COMPATIBLE WITH TYPE '
               || IDENTITY(DATATYPE(FORMAL)), 1);
         IF (ACTUAL & "C000") = MASK_SYMBOL THEN
            DO;
               IF VAR_TYPE(ACTUAL) = VARIABLE THEN
                  DO;
                     CALL EMIT_TRIPLE(LOAD_ADDR, ACTUAL, NULL, 3);
                     OPERAND#STK(#OP) = LAST_TRIPLE;
                  END;
               ELSE IF VAR_TYPE(ACTUAL) ~= VAR_PARAM THEN
                  CALL ERROR('VAR PARAMETER MUST BE A VARIABLE', 1);
            END;
         ELSE IF (ACTUAL & "C000") = MASK_IMMEDIATE THEN
            CALL ERROR(VAR_ERR, 1);
         ELSE
            DO;   /* ACTUAL PARAMETER MUST BE AN INDEX TRIPLE */
               IF (TRIPLES(ACTUAL & "3FFF") & "7F") ~= INDEX THEN
                  CALL ERROR(VAR_ERR, 1);
               ELSE IF (STRUCTYPE(ACTUAL_TYPE) = SCALAR)
                     | (STRUCTYPE(ACTUAL_TYPE) = SUBRANGE) THEN
                  IF SHR(TRIPLES(ACTUAL & "3FFF"), 8) = 0 THEN
                     CALL ERROR(
             'VAR PARAMETER MUST NOT BE A SCALAR OR SUBRANGE ARRAY ELEMENT', 1);
               CALL EMIT_TRIPLE(LOAD_ADDR, ACTUAL, NULL, 3);
               OPERAND#STK(#OP) = LAST_TRIPLE;
            END;
      END;
   ELSE   /* VAR_TYPE(FORMAL) = PROC_PARAM */
      DO;
         IF ((ACTUAL & "C000") ~= MASK_SYMBOL)
            | ((ACTUAL & "3FFF") >= N_ANONYMOUS_SYMB) THEN
            CALL ERROR('IN PARAMETER LIST - PROCEDURE/FUNCTION NAME EXPECTED'
               , 1);
         ELSE IF (SHL(1, VAR_TYPE(ACTUAL)) & "(1)01000000010100000") = 0 THEN
            /* ~(VAR_TYPE(ACTUAL) IN (.PROC, PROC_PARAM, MULTDECL.)) */
            CALL ERROR(IDENTITY(ACTUAL) || ' IS NOT A PROCEDURE/FUNCTION', 1);
         ELSE IF STRUCTYPE(ACTUAL) = STANDARD THEN
            CALL ERROR('ATTEMPT TO PASS STANDARD PROCEDURE/FUNCTION '
               || IDENTITY(ACTUAL), 1);
         ELSE IF ~COMPPROCS(ACTUAL, FORMAL) THEN
            CALL ERROR(IDENTITY(ACTUAL) || ' IS NOT COMPATIBLE WITH '
               || IDENTITY(FORMAL), 1);
         ELSE IF VAR_TYPE(ACTUAL) ~= PROC_PARAM THEN
            DO;
               CALL EMIT_TRIPLE(PROCPARM, ACTUAL, FINDCONST(VALUE(ACTUAL)),
                  0);
               OPERAND#STK(#OP) = LAST_TRIPLE;
            END;
      END;
END COERCE_PARAMETER;

COERCE_OP:
PROCEDURE;
   /* WE ARE GIVEN TWO OPERANDS, OPND1 AND OPND2, OF TYPES TYPE1 AND TYPE2
      RESPECTIVELY.  OPND1 AND OPND2 ARE THE TOP TWO ELEMENTS OF OPERAND#STK.
      WE WISH TO COMBINE THEM USING SOME ARITHMETIC OR COMPARISON OPERATOR.
      IN DOING SO, HOWEVER, WE MAY FIRST HAVE TO COERCE SUBRANGE TO SCALAR OR
      INTEGER TO REAL, IN ACCORDANCE WITH THE AXIOMATIC DEFINITION OF PASCAL.
      */
   DECLARE (OPND1, OPND2, TYPE1, TYPE2) BIT(16);
   DECLARE INCOMPATIBLE_DATATYPES CHARACTER INITIAL(
      'INCOMPATIBLE DATATYPES');
   DECLARE LOWBOUND FIXED;
   DECLARE (I, ST_LNGTH, HIGHBOUND) FIXED, SET_TYPE_PTR BIT(16);
   OPND1 = OPERAND#STK(#OP - 1);
   OPND2 = OPERAND#STK(#OP);
   TYPE1 = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP));
   TYPE2 = PARSE_TREE(NODE#STACK(NP) + #POS_STACK(NP) + 1);
   IF STRUCTYPE(TYPE1) = SUBRANGE THEN
      DO;   /* COERCE OPERAND 1 FROM SUBRANGE TO SCALAR */
         LOWBOUND = VALUE(S_LIST(TYPE1));
         IF LOWBOUND ~= 0 THEN
            DO;
               CALL EMIT_TRIPLE(ADD, OPND1, FINDCONST(LOWBOUND), 3);
               OPND1, OPERAND#STK(#OP - 1) = LAST_TRIPLE;
            END;
         TYPE1 = DATATYPE(TYPE1);
         CALL REPLACE_LEFT_BRO(TYPE1);
      END;
   IF STRUCTYPE(TYPE2) = SUBRANGE THEN
      DO;   /* COERCE OPERAND 2 FROM SUBRANGE TO SCALAR */
         LOWBOUND = VALUE(S_LIST(TYPE2));
         IF LOWBOUND ~= 0 THEN
            DO;
               CALL EMIT_TRIPLE(ADD, OPND2, FINDCONST(LOWBOUND), 3);
               OPND2, OPERAND#STK(#OP) = LAST_TRIPLE;
            END;
         TYPE2 = DATATYPE(TYPE2);
         CALL REPLACE(TYPE2);
      END;
   IF COMPTYPES(TYPE1, TYPE2) THEN RETURN;
   IF (STRUCTYPE(TYPE1) = SET) & (STRUCTYPE(TYPE2) = SET) THEN
      DO;
         IF ~COMPTYPES(DATATYPE(TYPE1), DATATYPE(TYPE2)) THEN
            DO;
               CALL ERROR('INCOMPATIBLE SET TYPES', 1);
               CALL REPLACE(EMPTYSETPTR);
               CALL REPLACE_LEFT_BRO(EMPTYSETPTR);
               RETURN;
            END;
         IF VALUE(TYPE1) < VALUE(TYPE2) THEN
            LOWBOUND = VALUE(TYPE1);
         ELSE LOWBOUND = VALUE(TYPE2);
         IF (VALUE(TYPE1) + STORAGE_LNGTH(TYPE1))
            > (VALUE(TYPE2) + STORAGE_LNGTH(TYPE2)) THEN
            HIGHBOUND = VALUE(TYPE1) + STORAGE_LNGTH(TYPE1);
         ELSE HIGHBOUND = VALUE(TYPE2) + STORAGE_LNGTH(TYPE2);
         ST_LNGTH = HIGHBOUND - LOWBOUND;
         IF ST_LNGTH > 256 THEN
            DO;
               CALL ERROR('SET EXPRESSION REQUIRES MORE THAN 256 BYTES', 1);
               CALL REPLACE(EMPTYSETPTR);
               CALL REPLACE_LEFT_BRO(EMPTYSETPTR);
               RETURN;
            END;
         SET_TYPE_PTR = NEXT_FREE_ROW;
         DATATYPE(SET_TYPE_PTR) = DATATYPE(TYPE1);
         VALUE(SET_TYPE_PTR) = LOWBOUND;
         STORAGE_LNGTH(SET_TYPE_PTR) = ST_LNGTH;
         STRUCTYPE(SET_TYPE_PTR) = SET;
         VAR_TYPE(SET_TYPE_PTR) = TYPE;
         IF COMPTYPES(TYPE1, SET_TYPE_PTR) THEN
            DO;
               N_DECL_SYMB = N_DECL_SYMB - 1;
               SET_TYPE_PTR = TYPE1;
            END;
         ELSE IF COMPTYPES(TYPE2, SET_TYPE_PTR) THEN
            DO;
               N_DECL_SYMB = N_DECL_SYMB - 1;
               SET_TYPE_PTR = TYPE2;
            END;
         IF ~COMPTYPES(TYPE1, SET_TYPE_PTR) THEN
            DO;   /* COERCE OPND1 TO SET_TYPE_PTR */
               CALL EMIT_TRIPLE(TEMP, NULL, 0, ST_LNGTH - 1);
               I = LAST_TRIPLE | MASK_TEMP;
               CALL EMIT_TRIPLE( XOR, I, I, 0);
               CALL EMIT_TRIPLE(INDEX, I, FINDCONST(VALUE(TYPE1) - LOWBOUND),
                  STORAGE_LNGTH(TYPE1) - 1);
               CALL EMIT_TRIPLE(MOVE, LAST_TRIPLE, OPND1, 0);
               OPERAND#STK(#OP - 1) = I & "BFFF";
               CALL REPLACE_LEFT_BRO(SET_TYPE_PTR);
            END;
         IF ~COMPTYPES(TYPE2, SET_TYPE_PTR) THEN
            CALL COERCE_ASSIGNMENT(SET_TYPE_PTR, TYPE2);
         RETURN;
      END;
   ELSE IF (STRUCTYPE(TYPE1) ~= ARITHMETIC)
         | (STRUCTYPE(TYPE2) ~= ARITHMETIC) THEN
      DO;
         CALL ERROR(INCOMPATIBLE_DATATYPES, 1);
         RETURN;
      END;
   /* NOW OPERAND 1 AND OPERAND 2 ARE OF INCOMPATIBLE ARITHMETIC TYPES, I.E.,
      ONE IS INTEGER, THE OTHER REAL.  FLOAT THE INTEGER OPERAND. */
   IF DATATYPE(TYPE1) = INTPTR THEN
      DO;   /* FLOAT OPERAND 1 */
         CALL EMIT_TRIPLE(FLOAT, OPND1, NULL, 3);
         OPERAND#STK(#OP - 1) = LAST_TRIPLE;
         CALL REPLACE_LEFT_BRO(REALPTR);
      END;
   ELSE
      DO;   /* FLOAT OPERAND 2 */
         CALL EMIT_TRIPLE(FLOAT, OPND2, NULL, 3);
         OPERAND#STK(#OP) = LAST_TRIPLE;
         CALL REPLACE(REALPTR);
      END;
END COERCE_OP;

COERCE_SET_ELEMENT:
PROCEDURE(ELEMENT_TYPE, MIN);
   DECLARE (ELEMENT_TYPE, MIN, ELT) BIT(16);
   ELT = OPERAND#STK(#OP);
   IF (ELT & "C000") = MASK_IMMEDIATE THEN
      OPERAND#STK(#OP) = FINDCONST((ELT & "3FFF") - MIN);
   ELSE IF ((ELT & "C000") = MASK_SYMBOL) & (VAR_TYPE(ELT) = CONSTANT) THEN
      OPERAND#STK(#OP) = FINDCONST(VALUE(ELT) - MIN);
   ELSE IF (STRUCTYPE(ELEMENT_TYPE) = SUBRANGE) &
         (VALUE(S_LIST(ELEMENT_TYPE)) ~= MIN) THEN
      DO;
         CALL EMIT_TRIPLE(ADD, ELT,
            FINDCONST(VALUE(S_LIST(ELEMENT_TYPE)) - MIN), 3);
         OPERAND#STK(#OP) = LAST_TRIPLE;
      END;
END COERCE_SET_ELEMENT;

   /*       S T O R A G E   A L L O C A T I O N   P R O C E D U R E S     */

COMPUTE_STORAGE_LENGTH:
PROCEDURE(TYPE_PTR);
   DECLARE TYPE_PTR FIXED;
   DECLARE STRUCTYPECASE(14) BIT(16) INITIAL(
      0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 0, 5, 5, 0, 3);
   DO CASE STRUCTYPECASE(STRUCTYPE(TYPE_PTR));
      /*  0   STATEMENT, STANDARD   */
      ;
      /*  1   SCALAR   */
      IF STORAGE_LNGTH(TYPE_PTR) <= 256 THEN SL = 1;
      ELSE SL = 2;
      /*  2   SUBRANGE   */
      IF STORAGE_LNGTH(TYPE_PTR) > 32768 THEN SL = 4;
      ELSE IF STORAGE_LNGTH(TYPE_PTR) <= 256 THEN SL = 1;
      ELSE SL = 2;
      /*  3   POINTER, ARITHMETIC   */
      SL = 4;
      /*  4   ARRAY, FILE, RECORD  */
      SL = STORAGE_LNGTH(TYPE_PTR);
      /*  5   SET   */
      SL = STORAGE_LNGTH(TYPE_PTR);
   END;
END COMPUTE_STORAGE_LENGTH;

ALLOCATE_STORAGE:
PROCEDURE(VAR_PTR);
   DECLARE VAR_PTR FIXED;
   /* THIS PROCEDURE REFERS TO THE GLOBAL VARIABLE SL, WHICH IS PRESUMED
      TO HAVE BEEN SET BY A PRIOR CALL TO COMPUTE_STORAGE_LENGTH.  IT
      SETS VALUES OF DISPLACEMENT(VAR_PTR), STACK_LIMIT(CURRENT_LEVEL),
      HALFWORD_DISP(CURRENT_LEVEL) AND ARRAYS_ALLOCATED(CURRENT_LEVEL). */
   IF SL <= 2 THEN
      DO;
         IF HALFWORD_DISP(CURRENT_LEVEL) ~= 0 THEN
            DO;
               DISPLACEMENT(VAR_PTR) = HALFWORD_DISP(CURRENT_LEVEL);
               HALFWORD_DISP(CURRENT_LEVEL) = 0;
            END;
         ELSE
            DO;
               DISPLACEMENT(VAR_PTR) = STACK_LIMIT(CURRENT_LEVEL);
               HALFWORD_DISP(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 2;
               STACK_LIMIT(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 4;
            END;
         IF STRUCTYPE(VAR_PTR) = SET THEN
            STORAGE_LNGTH(VAR_PTR) = SL;
         ELSE STORAGE_LNGTH(VAR_PTR) = 2;
         IF CURRENT_LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);
      END;
   ELSE IF SL <= 4 THEN
      DO;
         DISPLACEMENT(VAR_PTR) = STACK_LIMIT(CURRENT_LEVEL);
         STACK_LIMIT(CURRENT_LEVEL) = STACK_LIMIT(CURRENT_LEVEL) + 4;
         STORAGE_LNGTH(VAR_PTR) = SL;
         IF CURRENT_LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);
      END;
   ELSE
      DO;  /* CHAIN STRUCTURED VARIABLES THROUGH THE VALUE FIELD */
         STORAGE_LNGTH(VAR_PTR) = SL;
         VALUE(VAR_PTR) = ARRAYS_ALLOCATED(CURRENT_LEVEL);
         ARRAYS_ALLOCATED(CURRENT_LEVEL) = VAR_PTR;
      END;
END ALLOCATE_STORAGE;

ALLOCATE_ARRAY_STORAGE:
PROCEDURE(LEVEL);
   DECLARE (VAR_PTR, LEVEL, I) BIT(16);
   /* THIS PROCEDURE IS CALLED WHENEVER CURRENT_LEVEL IS ABOUT TO BE DECREMENTED
      (AT THE CLOSE OF A BLOCK OR A RECORD DECLARATION) IN ORDER TO ALLOCATE
      STORAGE FOR THE STRUCTURED VARIABLES, AFTER ALL STORAGE FOR SCALAR
      VARIABLES HAS BEEN ALLOCATED.  THIS IS DONE TO SECURE EFFICIENCY IN
      ADDRESS COMPUTATION AT RUNTIME.                               */
   VAR_PTR = ARRAYS_ALLOCATED(LEVEL);
   DO WHILE VAR_PTR > N_PREDECLARED_SYMB;
      SL = STORAGE_LNGTH(VAR_PTR);
      DISPLACEMENT(VAR_PTR) = STACK_LIMIT(LEVEL);
      SL = SHL(SHR(SL, 2) + ((SL & 3) > 0), 2);
      STACK_LIMIT(LEVEL) = STACK_LIMIT(LEVEL) + SL;
      IF LEVEL = 1 THEN CALL EMIT_DATA_BYTES(VAR_PTR);
      I = VAR_PTR;
      VAR_PTR = VALUE(VAR_PTR);
      VALUE(I) = 0;
   END;
   ARRAYS_ALLOCATED(LEVEL) = NULL;
   HALFWORD_DISP(LEVEL) = 0;
END ALLOCATE_ARRAY_STORAGE;

   /*      T R A V E R S E   P A R S E   T R E E S           */

VISIT_NODES:
PROCEDURE;
   DECLARE FIRST_VISIT BIT(1);
   DECLARE IS_LEAF LITERALLY 'PARSE_TREE(NODE)=0';
   DECLARE FATHERS_PROD_NO LITERALLY 'PARSE_TREE(NODE#STACK(NP)+1)';
   DECLARE GREAT_GRANDFATHERS_PROD_NO LITERALLY
      'PARSE_TREE(NODE#STACK(NP-2)+1)';
   DECLARE(FATHERS_MULTIPLICITY, #MP, #TP) FIXED;
   DECLARE IS_DECLARATION BIT(1);
   DECLARE (LHS, PARAMLIST) BIT(1);
   DECLARE FIRST_PARAM_TYPES BIT(1);
   /* SYMBOL TABLE POINTERS USED IN PROCESSING DECLARATION TREES */
   DECLARE (TABLE_PTR, ID_PTR, TP_ID_PTR) FIXED;
   /*  GLOBAL TEMPORARIES USED IN TRAVERSING SYMBOL TABLE ENTRIES  */
   DECLARE (I, LINK, NP1) FIXED;
   DECLARE J FIXED;
   DECLARE (MIN, MAX, CASE_LABEL_VALUE) FIXED;
   DECLARE (CASE_INSTANCE_PTR, CASE_LABEL_PTR, CASE_PTR) BIT(16);
   /*  STRINGS USED IN ERROR MESSAGES     */
   DECLARE SUBRANGE_SIZE CHARACTER INITIAL
      ('IMPLEMENTATION RESTRICTS LENGTH OF A SET TO 256 BYTES');
   DECLARE TAG_TYPE CHARACTER INITIAL(
      'TYPE OF CASE LABEL DOES NOT AGREE WITH TYPE OF TAG FIELD');
   DECLARE (BOUND1_IS_CONST, BOUND2_IS_CONST) BIT(1);
   DECLARE (BOUND1_VALUE, BOUND2_VALUE) FIXED;
   DECLARE (MUST_CHECK_LOWBOUND, MUST_CHECK_HIGHBOUND) BIT(1);
   DECLARE ERROR_FLAG BIT(1);
   DECLARE ERROR_EXIT LABEL;

IS_VALID_ROOT_PRODUCTION:
   PROCEDURE(PRODUCTION#) BIT(1);
      DECLARE PRODUCTION# BIT(16);
      IF (PRODUCTION# < 0) | (PRODUCTION# > 10) THEN RETURN FALSE;
      RETURN (SHL(1, PRODUCTION#) & "(1)11100 00011 0") ~= 0;
      /* RETURN PRODUCTION# IN (.1,2,8,9,10.) */
   END IS_VALID_ROOT_PRODUCTION;

SIZE:
   PROCEDURE(OPND) FIXED;
      DECLARE (OPND, OPCD) BIT(16);
      IF (OPND & "C000") = MASK_SYMBOL THEN
         RETURN STORAGE_LNGTH(OPND);
      ELSE IF (OPND & "C000") = MASK_IMMEDIATE THEN
         RETURN 4;   /* ASSUME LOADED IN A REGISTER */
      /* ELSE OPERAND IS A TRIPLE */
      OPND = OPND & "3FFF";
      OPCD = TRIPLES(OPND) & "7F";
      IF OPCD = INDEX THEN
         IF TRIPLES(OPND + 3) = S_LENGTH THEN
            RETURN SHL(TRIPLES(OPND + 4), 16) + TRIPLES(OPND + 5);
      RETURN SHR(TRIPLES(OPND), 8) + 1;
   END SIZE;

SUBSET:
   PROCEDURE(OPND1, OPND2);
      /* CHECK TO SEE IF OPND1 IS A SUBSET OF OPND2.  OPND1 AND OPND2
         ARE THE TOP TWO ELEMENTS ON OPERAND#STK, BUT WE CANNOT TELL
         WHICH ONE IS ON TOP. */
      DECLARE (OPND1, OPND2, OPCD) BIT(16);
      IF OPND1 = EMPTYSETPTR THEN
         DO;
            IF (OPND2 & MASK_TRIPLE) ~= 0 THEN
               CALL EMIT_TRIPLE(TPOP, OPND2, NULL, 0);
            OPERAND#STK(#OP - 1) = TRUE | MASK_IMMEDIATE;
         END;
      ELSE IF OPND2 = EMPTYSETPTR THEN
         DO;
            CALL EMIT_TRIPLE(AND, OPND1, OPND1, 0);
            IF FX THEN OPCD = BZ;  ELSE OPCD = BNZ;
            CALL EMIT_TRIPLE(OPCD, LISTHEAD, NULL, 0);
            LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
            OPERAND#STK(#OP - 1) = LAST_TRIPLE;
         END;
      ELSE
         DO;
            CALL EMIT_TRIPLE(TEMP, OPND1, 0, SIZE(OPND1) - 1);
            IF (OPND1 & MASK_TRIPLE) ~= 0 THEN  /* FLAG OPND1 AS REUSABLE */
               TRIPLES(N_TRIPLES - 2) = OPND1 | MASK_TEMP;
            CALL EMIT_TRIPLE(AND, LAST_TRIPLE | MASK_TEMP, OPND2, 0);
            CALL EMIT_TRIPLE(LCOMPARE, (N_TRIPLES - 6) | MASK_TRIPLE,
               OPND1, 0);
            IF FX THEN OPCD = BNZ;   ELSE OPCD = BZ;
            CALL EMIT_TRIPLE(OPCD, LISTHEAD, LAST_TRIPLE, 0);
            LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
            OPERAND#STK(#OP - 1) = LAST_TRIPLE;
         END;
      #OP = #OP - 1;
      #TP = BOOLPTR;
   END SUBSET;

IS_CONDITION:
   PROCEDURE(OP_PTR) BIT(1);
      /* TESTS OPERAND TO SEE IF BZ OR BNZ TRIPLE */
      DECLARE (OP_PTR, OPCD) BIT(16);
      IF (OP_PTR & "C000") = (MASK_TRIPLE & "C000") THEN
         DO;
            OPCD = TRIPLES(OP_PTR & "3FFF") & "7F";
            IF (OPCD = BZ) | (OPCD = BNZ) THEN RETURN TRUE;
         END;
      RETURN FALSE;
   END IS_CONDITION;

IS_NEGATION:
   PROCEDURE(OP_PTR) BIT(1);
      /* DETERMINES IF OPERAND IS A "NOT" TRIPLE */
      DECLARE (OP_PTR, OPCD) BIT(16);
      IF (OP_PTR & "C000") = (MASK_TRIPLE & "C000") THEN
         DO;
            OPCD = TRIPLES(OP_PTR & "3FFF") & "7F";
            IF OPCD = NOT THEN RETURN TRUE;
         END;
      RETURN FALSE;
   END IS_NEGATION;

FIXUP:
   PROCEDURE(HEAD_PTR, TARGET_TRIPLE);
      /* ASSUMES TRIPLES ARE ALL IN TRIPLES BUFFER */
      DECLARE (HEAD_PTR, TARGET_TRIPLE, NEXT) BIT(16);
      IF MONITOR_LINK(3) + SEVERE_ERRORS > 0 THEN RETURN;
      DO WHILE HEAD_PTR ~= NULL;
         HEAD_PTR = HEAD_PTR & "3FFF";
         NEXT = TRIPLES(HEAD_PTR + 1);
         TRIPLES(HEAD_PTR + 1) = TARGET_TRIPLE | MASK_TRIPLE;
         HEAD_PTR = NEXT;
      END;
   END FIXUP;

EMIT_CONDITIONAL_BRANCH:
   PROCEDURE(FX);
      DECLARE FX BIT(1), OPND BIT(16);
      OPND = OPERAND#STK(#OP);
      IF IS_NEGATION(OPND) THEN
         DO;
            N_TRIPLES = N_TRIPLES - 3;
            IC = IC - 1;
            OPND = TRIPLES(N_TRIPLES + 1);
            FX = ~FX;
         END;
      IF FX THEN CALL EMIT_TRIPLE(BNZ, NULL, OPND, 0);
      ELSE CALL EMIT_TRIPLE(BZ, NULL, OPND, 0);
   END EMIT_CONDITIONAL_BRANCH;

COND_TO_REGISTER:
   PROCEDURE;
      /* ASSUMES OPERAND#STK(#OP) POINTS TO A CONDITIONAL BRANCH TRIPLE */
      IF LISTHEAD = NULL THEN RETURN;
      CALL EMIT_TRIPLE(TEMP, (1 - FX) | MASK_IMMEDIATE, NULL, 3);
      OPERAND#STK(#OP) = LAST_TRIPLE;
      CALL EMIT_TRIPLE(BCH, (N_TRIPLES + 9) | MASK_TRIPLE, NULL, 0);
      CALL FIXUP(LISTHEAD, N_TRIPLES);
      CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
      CALL EMIT_TRIPLE(STORE, (N_TRIPLES - 9) | MASK_TEMP,
         FX | MASK_IMMEDIATE, 0);
      CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
      LISTHEAD = NULL;
   END COND_TO_REGISTER;

EMIT_COMPARE:
   PROCEDURE(OP);
      DECLARE OP BIT(16);   /* OP IS OF TYPE COMPARISONS */
      DECLARE COMPARE_ERROR CHARACTER INITIAL('ILLEGAL COMPARISON');
      DECLARE CONTAINS_ERROR CHARACTER INITIAL(
         'STRICT INCLUSION IS NOT ALLOWED');
      IF #TP = BOOLPTR THEN
         IF IS_CONDITION(OPERAND#STK(#OP)) THEN
            CALL COND_TO_REGISTER;
      CALL REPLACE(#TP);
      IF #MP = 1 THEN RETURN;
      IF ~COMPTYPES(#TP, PARSE_TREE(NODE#STACK(NP) + 2)) THEN
         CALL COERCE_OP;
      #TP = PARSE_TREE(NODE#STACK(NP) + 2);
      IF COMPTYPES(#TP, REALPTR) THEN
         DO CASE OP MOD 3;
            /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
            CALL EMIT_TRIPLE(COMPAREFLT, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
            /* CASE 1 -- GREATER_THAN, LESS_EQ */
            CALL EMIT_TRIPLE(GREATERFLT, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
            /* CASE 2 -- LESS_THAN, GREATER_EQ */
            CALL EMIT_TRIPLE(LESSFLT, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
         END;
      ELSE IF (STRUCTYPE(#TP) = SET) | (STRUCTYPE(#TP) = PACKED_SET) THEN
         DO CASE OP MOD 3;
            /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
            IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
               DO;
                  CALL EMIT_TRIPLE(AND, OPERAND#STK(#OP - 1),
                     OPERAND#STK(#OP - 1), 0);
                  OPERAND#STK(#OP - 1) = NULL;
                  IF OP = EQUAL_TO THEN OP = NOT_EQUAL_TO;  ELSE OP = EQUAL_TO;
               END;
            ELSE IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN
               DO;
                  CALL EMIT_TRIPLE(AND, OPERAND#STK(#OP),
                     OPERAND#STK(#OP), 0);
                  OPERAND#STK(#OP - 1) = NULL;
                  IF OP = EQUAL_TO THEN OP = NOT_EQUAL_TO;  ELSE OP = EQUAL_TO;
               END;
            ELSE
               DO;
                  CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),
                     OPERAND#STK(#OP), 0);
                  OPERAND#STK(#OP - 1) = LAST_TRIPLE;
               END;
            /* CASE 1 -- GREATER_THAN, LESS_EQ */
            IF OP = GREATER_THAN THEN
               CALL ERROR(CONTAINS_ERROR, 1);
            ELSE
               DO;
                  CALL SUBSET(OPERAND#STK(#OP - 1), OPERAND#STK(#OP));
                  RETURN;
               END;
            /* CASE 2 -- LESS_THAN, GREATER_EQ */
            IF OP = LESS_THAN THEN
               CALL ERROR(CONTAINS_ERROR, 1);
            ELSE
               DO;
                  CALL SUBSET(OPERAND#STK(#OP), OPERAND#STK(#OP - 1));
                  RETURN;
               END;
         END;
      ELSE IF ((STRUCTYPE(#TP) = ARRAY) | (STRUCTYPE(#TP) = PACKED_ARRAY)) &
            (DATATYPE(#TP) = CHARPTR) THEN
         DO CASE OP MOD 3;
            /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
            CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
            /* CASE 1 -- GREATER_THAN, LESS_EQ */
            CALL EMIT_TRIPLE(LGREATER, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
            /* CASE 2 -- LESS_THAN, GREATER_EQ */
            CALL EMIT_TRIPLE(LLESS, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
         END;
      ELSE IF (SHL(1, STRUCTYPE(#TP)) & "(1)00000 11001 11000") ~= 0 THEN
         /* STRUCTYPE(#TP) IN (.POINTER, ARRAY, PACKED_ARRAY,
                                      RECORD, PACKED_RECORD.) */
         DO;
            IF (OP MOD 3) = 0 THEN
               CALL EMIT_TRIPLE(LCOMPARE, OPERAND#STK(#OP - 1),
                  OPERAND#STK(#OP), 0);
            ELSE CALL ERROR(COMPARE_ERROR, 1);
         END;
      ELSE IF (SHL(1, STRUCTYPE(#TP)) & "(1)10000 00000 00110") ~= 0 THEN
         /* STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, ARITHMETIC.) */
         DO CASE OP MOD 3;
            /* CASE 0 -- EQUAL_TO, NOT_EQUAL_TO */
            CALL EMIT_TRIPLE(COMPARE, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
            /* CASE 1 -- GREATER_THAN, LESS_EQ */
            CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
            /* CASE 2 -- LESS_THAN, GREATER_EQ */
            CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP - 1),
               OPERAND#STK(#OP), 0);
         END;
      ELSE CALL ERROR(COMPARE_ERROR, 1);
      #OP = #OP - 1;
      IF (FX & (OP < NOT_EQUAL_TO)) THEN
         CALL EMIT_TRIPLE(BNZ, LISTHEAD, LAST_TRIPLE, 0);
      ELSE IF (~FX & (OP >= NOT_EQUAL_TO)) THEN
         CALL EMIT_TRIPLE(BNZ, LISTHEAD, LAST_TRIPLE, 0);
      ELSE CALL EMIT_TRIPLE(BZ, LISTHEAD, LAST_TRIPLE, 0);
      IF (STRUCTYPE(#TP) = SET) | (STRUCTYPE(#TP) = PACKED_SET) THEN
         TRIPLES(N_TRIPLES - 1) = OPERAND#STK(#OP);
      OPERAND#STK(#OP) = LAST_TRIPLE;
      LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
      #TP = BOOLPTR;
   END EMIT_COMPARE;

EMIT_BOUND_CHECK:
   PROCEDURE(OPND, VALUE, COMPARISON);
      DECLARE (OPND, OPCD, COMPARISON) BIT(16), VALUE FIXED;
      IF COMPARISON = LESS_EQ THEN OPCD = GREATER;
      ELSE  /* COMPARISON = GREATER_EQ */ OPCD = LESS;
      CALL EMIT_TRIPLE(OPCD, OPND, FINDCONST(VALUE), 0);
      CALL EMIT_TRIPLE(BNZ, LISTHEAD, LAST_TRIPLE, 0);
      LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
   END EMIT_BOUND_CHECK;

PROCFUNC:
   PROCEDURE(IS_PROC);
      DECLARE IS_PROC BIT(1);
      DECLARE PARAM_ERROR CHARACTER INITIAL(
         'ILLEGAL PARAMETER TYPE IN CALL TO STANDARD PROCEDURE/FUNCTION');
      DECLARE #_PARAMS CHARACTER INITIAL(
         'WRONG NUMBER OF PARAMETERS IN CALL TO STANDARD PROCEDURE');
      DECLARE STD_FILE_ERR CHARACTER INITIAL(
         'ILLEGAL USE OF STANDARD FILE');
      DECLARE ERROR_FLAG BIT(1);
      DECLARE MONITOR_CODE(N_PREDECLARED_SYMB) BIT(8) INITIAL(
         "FF", "FF", "FF", "FF", "FF", "FF", "FF", "FF", "FF", "FF",
         "FF", 10, 11, 12, "FF", "FF", "FF", "FF", 9, 14,
         0, 1, 3, 4, 5, 2, 8, 13, 17, 18,
         19, 20, 15, "FF", "FF", "FF", "FF", "FF", 16, 31,
         29, 30, 35, "FF", "FF", "FF", "FF");
      /* OTHER MONITOR CODES */
      DECLARE READ_INT BIT(16) INITIAL(21),
         READ_REAL     BIT(16) INITIAL(22),
         READ_CHAR     BIT(16) INITIAL(23),
         WRITE_INT     BIT(16) INITIAL(24),
         WRITE_REAL    BIT(16) INITIAL(25),
         WRITE_BOOL    BIT(16) INITIAL(26),
         WRITE_CHAR    BIT(16) INITIAL(27),
         WRITE_STRING  BIT(16) INITIAL(28);
      DECLARE (I, J) FIXED;
      DECLARE FILE_PTR BIT(16);
      DECLARE #TP1 BIT(16);
      DECLARE TAG_PTR BIT(16);
      DECLARE VARIANT_NOT_FOUND BIT(1);
      DECLARE RECORD_LENGTH FIXED;
      DECLARE (ARRAY1, ARRAY2) BIT(16);
      DECLARE (ARRAY1_TYPE, ARRAY2_TYPE) BIT(16);
      DECLARE FIRST_PROC BIT(16) INITIAL(11);  /* INDEX OF 1ST STD. PROC */
      DECLARE PROPER BIT(N_PREDECLARED_SYMB) INITIAL
         ("(1)0 00000 00000 00000 00000 00000 00111 11111 10111 10000 0");
      DECLARE PARAMETERLESS BIT(N_PREDECLARED_SYMB) INITIAL
         ("(1)0 00000 00000 00000 00010 00000 01000 00000 00011 11000 0");

   IS_PROPER:
      PROCEDURE(STD_PROC) BIT(1);
         DECLARE STD_PROC BIT(16);  /* INDEX OF A STANDARD PROC */
         /* RETURN TRUE IFF STD_PROC IS A PROPER STANDARD PROCEDURE */
         RETURN (SHL(BYTE(PROPER, SHR(STD_PROC, 3)), STD_PROC & "7") & "80")
            ~= 0;
      END IS_PROPER;

   IS_PARAMETERLESS:
      PROCEDURE(STD_PROC) BIT(1);
         DECLARE STD_PROC BIT(16);  /* INDEX OF A STANDARD PROC */
         /* RETURN TRUE IFF STD_PROC CAN BE CALLED WITH NO PARAMETERS */
         RETURN (SHL(BYTE(PARAMETERLESS, SHR(STD_PROC, 3)), STD_PROC & "7")
            & "80") ~= 0;
      END IS_PARAMETERLESS;

      IF #MP = 1 THEN
         DO;
            ERROR_FLAG = (SHL(1, VAR_TYPE(TABLE_PTR)) &
               "(1)01 00000 00101 00000") = 0;
            /* ERROR_FLAG = ~(VAR_TYPE(TABLE_PTR) IN (.PROC, PROC_PARAM,
                     MULTDECL.)); */
            IF TABLE_PTR > N_PREDECLARED_SYMB THEN
               DO;
                  IF IS_PROC THEN
                     ERROR_FLAG = ERROR_FLAG | (DATATYPE(TABLE_PTR) ~= NULL);
                  ELSE ERROR_FLAG = ERROR_FLAG | (DATATYPE(TABLE_PTR) = NULL);
               END;
            ELSE
               ERROR_FLAG = ERROR_FLAG | (IS_PROC ~= IS_PROPER(TABLE_PTR));
            IF ERROR_FLAG THEN
               DO;
                  CALL ERROR('ILLEGAL PROCEDURE/FUNCTION IDENTIFIER', 1);
                  #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                  IF IS_PROC THEN #OP = #OP - 1;
                  RETURN;
               END;
            IF TABLE_PTR > N_PREDECLARED_SYMB THEN
               DO;
                  IF VAR_TYPE(TABLE_PTR) = PROC_PARAM THEN
                     DO;
                        ID_PTR = VALUE(TABLE_PTR);
                        J = NULL;
                     END;
                  ELSE
                     DO;
                        ID_PTR = S_LIST(TABLE_PTR);
                        J = FINDCONST(VALUE(TABLE_PTR));
                     END;
                  CALL EMIT_TRIPLE(BLKMARK, TABLE_PTR, J, 0);
                  I = 1;
                  DO WHILE ID_PTR ~= NULL;
                     I = I + 1;
                     ID_PTR = S_LIST(ID_PTR);
                  END;
                  IF I ~= FATHERS_MULTIPLICITY THEN
                     DO;
                        CALL ERROR('WRONG NUMBER OF PARAMETERS', 1);
                        #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                        IF IS_PROC THEN #OP = #OP - 1;
                        RETURN;
                     END;
                  IF FATHERS_MULTIPLICITY = 1 THEN
                     DO;   /* PARAMETERLESS CALL */
                        CALL EMIT_TRIPLE(PCALL, TABLE_PTR, J, 3);
                        IF IS_PROC THEN
                           DO;
                              CALL EMIT_TRIPLE(TPOP, LAST_TRIPLE, NULL, 0);
                              #OP = #OP - 1;
                           END;
                        ELSE OPERAND#STK(#OP) = LAST_TRIPLE;
                     END;   /* FATHERS_MULTIPLICITY = 1 */
                  ELSE IF VAR_TYPE(S_LIST(TABLE_PTR)) ~= VARIABLE THEN
                     PARAMLIST = TRUE;
               END;   /* USER-DEFINED PROC/FUNC */
            ELSE IF FATHERS_MULTIPLICITY = 1 THEN
               DO;   /* PARAMETERLESS STANDARD PROC/FUNC CALL */
                  IF TABLE_PTR = CLOCKPTR THEN
                     DO;
                        CALL EMIT_TRIPLE(MONITOR, NULL, NULL,
                           MONITOR_CODE(CLOCKPTR));
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        #TP = INTPTR;
                        RETURN;
                     END;
                  IF (TABLE_PTR = PAGEPTR) | (TABLE_PTR = WRITELNPTR) THEN
                     I = OUTPUTPTR;
                  ELSE I = INPUTPTR;
                  CALL EMIT_TRIPLE(LOAD_ADDR, I, NULL, 3);
                  IF IS_PROC THEN #OP = #OP - 1;
                  ELSE OPERAND#STK(#OP) = LAST_TRIPLE;
                  CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE,
                     NULL, MONITOR_CODE(TABLE_PTR));
                  IF ~IS_PARAMETERLESS(TABLE_PTR) THEN CALL ERROR(
                 'MISSING PARAMETER IN CALL TO STANDARD PROCEDURE/FUNCTION', 1);
               END;
            ELSE   /* THERE ARE PARAMETERS */
               DO;
                  IF (~IS_PROC) & (FATHERS_MULTIPLICITY > 2) THEN
                     DO;
                        CALL ERROR(
                         'TOO MANY PARAMETERS IN CALL TO STANDARD FUNCTION', 1);
                        #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                     END;
               END;
         END;   /* #MP = 1 */
      ELSE
         DO;
            ID_PTR = OPERAND#STK(#OP - 1);
            IF #TP = BOOLPTR THEN
               IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                  CALL COND_TO_REGISTER;
            TABLE_PTR = OPERAND#STK(#OP);
            IF ID_PTR > N_PREDECLARED_SYMB THEN
               DO;
                  IF VAR_TYPE(ID_PTR) = PROC_PARAM THEN
                     DO;
                        J = NULL;
                        ID_PTR = VALUE(ID_PTR);
                     END;
                  ELSE
                     DO;
                        J = FINDCONST(VALUE(ID_PTR));
                        ID_PTR = S_LIST(ID_PTR);
                     END;
                  DO I = 3 TO #MP;
                     ID_PTR = S_LIST(ID_PTR);
                  END;
                  CALL COERCE_PARAMETER(TABLE_PTR, ID_PTR, #TP);
                  CALL EMIT_TRIPLE(PARM, ID_PTR, OPERAND#STK(#OP), 0);
                  #OP = #OP - 1;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        CALL EMIT_TRIPLE(PCALL, OPERAND#STK(#OP), J, 3);
                        IF IS_PROC THEN
                           DO;
                              CALL EMIT_TRIPLE(TPOP, LAST_TRIPLE, NULL, 0);
                              #OP = #OP - 1;
                           END;
                        ELSE
                           DO;
                              #TP = DATATYPE(OPERAND#STK(#OP));
                              OPERAND#STK(#OP) = LAST_TRIPLE;
                           END;
                     END;
                  ELSE PARAMLIST = (VAR_TYPE(S_LIST(ID_PTR)) ~= VARIABLE);
                  RETURN;
               END;   /* USER-DEFINED PROC/FUNC */
            DO CASE ID_PTR - FIRST_PROC;
               /* CASE 0 -- ABS() */
               DO;
                  IF COMPTYPES(#TP, REALPTR) THEN
                     CALL EMIT_TRIPLE(ABSFLT, TABLE_PTR, NULL, 3);
                  ELSE
                     DO;
                        CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                        CALL EMIT_TRIPLE(ABS, OPERAND#STK(#OP), NULL, 3);
                        #TP = INTPTR;
                     END;
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = LAST_TRIPLE;
               END;
               /* CASE 1 -- SQR() */
               DO;
                  IF COMPTYPES(#TP, REALPTR) THEN
                     CALL EMIT_TRIPLE(SQRFLT, TABLE_PTR, NULL, 3);
                  ELSE
                     DO;
                        CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                        CALL EMIT_TRIPLE(SQR, OPERAND#STK(#OP), NULL, 3);
                        #TP = INTPTR;
                     END;
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = LAST_TRIPLE;
               END;
               /* CASE 2 -- ODD() */
               DO;
                  CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                  CALL EMIT_TRIPLE(ODD, OPERAND#STK(#OP), NULL, 3);
                  #TP = BOOLPTR;
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = LAST_TRIPLE;
               END;
               /* CASE 3 -- SUCC() */
            PREDSUCC:
               DO;
                  IF ID_PTR = SUCCPTR THEN I = ADD;
                  ELSE  /* PRED() */ I = SUBTRACT;
                  CALL EMIT_TRIPLE(I, TABLE_PTR, 1 | MASK_IMMEDIATE, 3);
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = LAST_TRIPLE;
                  IF (STRUCTYPE(#TP) = SCALAR) |
                     (STRUCTYPE(#TP) = SUBRANGE) THEN
                     CALL RANGE_CHECK(#TP, (ID_PTR ~= SUCCPTR),
                        (ID_PTR = SUCCPTR));
                  ELSE IF ~COMPTYPES(#TP, INTPTR) THEN
                     CALL ERROR(PARAM_ERROR, 1);
               END;
               /* CASE 4 -- PRED() */
               GOTO PREDSUCC;
               /* CASE 5 -- ORD() */
               DO;
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = TABLE_PTR;
                  IF ((SHL(1, STRUCTYPE(#TP)) & "(1)00000 00000 01110") = 0)
                     /* ~(#TP IN (.POINTER, SUBRANGE, SCALAR.)) */
                     & ~COMPTYPES(#TP, INTPTR) THEN
                     CALL ERROR(PARAM_ERROR, 1);
                  #TP = INTPTR;
               END;
               /* CASE 6 -- CHR() */
               DO;
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = TABLE_PTR;
                  CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                  CALL RANGE_CHECK(CHARPTR, TRUE, TRUE);
                  #TP = CHARPTR;
               END;
               /* CASE 7 -- TRUNC() */
            TRUNCROUND:
               DO;
                  CALL COERCE_ASSIGNMENT(REALPTR, #TP);
                  IF ID_PTR = TRUNCPTR THEN I = TRUNCATE;
                  ELSE  /* ROUND() */ I = ROUND;
                  CALL EMIT_TRIPLE(I, OPERAND#STK(#OP), NULL, 3);
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = LAST_TRIPLE;
                  #TP = INTPTR;
               END;
               /* CASE 8 -- EOF() */
               DO;
                  #OP = #OP - 1;
                  CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                  CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE, NULL,
                     MONITOR_CODE(ID_PTR));
                  OPERAND#STK(#OP) = LAST_TRIPLE;
                  IF (STRUCTYPE(#TP) ~= FILE) &
                     (STRUCTYPE(#TP) ~= PACKED_FILE) THEN
                     CALL ERROR(PARAM_ERROR, 1);
                  #TP = BOOLPTR;
               END;
               /* CASE 9 -- SIN() */
            SINCOSEXPLNSQRTARCTAN:
               DO;
                  CALL COERCE_ASSIGNMENT(REALPTR, #TP);
                  CALL EMIT_TRIPLE(MONITOR, OPERAND#STK(#OP), NULL,
                     MONITOR_CODE(ID_PTR));
                  #OP = #OP - 1;
                  OPERAND#STK(#OP) = LAST_TRIPLE;
                  #TP = REALPTR;
               END;
               /* CASE 10 -- COS() */
               GOTO SINCOSEXPLNSQRTARCTAN;
               /* CASE 11 -- EXP() */
               GOTO SINCOSEXPLNSQRTARCTAN;
               /* CASE 12 -- LN() */
               GOTO SINCOSEXPLNSQRTARCTAN;
               /* CASE 13 -- SQRT() */
               GOTO SINCOSEXPLNSQRTARCTAN;
               /* CASE 14 -- ARCTAN() */
               GOTO SINCOSEXPLNSQRTARCTAN;
               /* CASE 15 -- ROUND() */
               GOTO TRUNCROUND;
               /* CASE 16 -- EOLN() */
               DO;
                  #OP = #OP - 1;
                  CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                  CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE, NULL,
                     MONITOR_CODE(ID_PTR));
                  OPERAND#STK(#OP) = LAST_TRIPLE;
                  IF ~COMPTYPES(TEXTPTR, #TP) THEN
                     CALL ERROR(PARAM_ERROR, 1);
                  #TP = BOOLPTR;
               END;
               /* CASE 17 -- GET() */
            GETPUTRESETREWRITEPAGE:
               DO;
                  #OP = #OP - 2;
                  CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                  CALL EMIT_TRIPLE(MONITOR, LAST_TRIPLE,
                     NULL, MONITOR_CODE(ID_PTR));
                  IF (STRUCTYPE(#TP) ~= FILE) &
                     (STRUCTYPE(#TP) ~= PACKED_FILE) THEN
                     CALL ERROR(PARAM_ERROR, 1);
                  IF ((TABLE_PTR = INPUTPTR) & (ID_PTR ~= GETPTR)) |
                     ((TABLE_PTR = OUTPUTPTR) & (ID_PTR ~= PUTPTR)
                     & (ID_PTR ~= PAGEPTR)) THEN
                     CALL ERROR(STD_FILE_ERR, 1);
                  IF FATHERS_MULTIPLICITY > 2 THEN
                     DO;
                        CALL ERROR(#_PARAMS, 1);
                        #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                     END;
               END;
               /* CASE 18 -- PUT() */
               GOTO GETPUTRESETREWRITEPAGE;
               /* CASE 19 -- RESET() */
               GOTO GETPUTRESETREWRITEPAGE;
               /* CASE 20 -- REWRITE() */
               GOTO GETPUTRESETREWRITEPAGE;
               /* CASE 21 -- NEW() */
               IF #MP = 2 THEN
                  DO;
                     IF STRUCTYPE(#TP) ~= POINTER THEN
                        CALL ERROR(PARAM_ERROR, 1);
                     IF (STRUCTYPE(DATATYPE(#TP)) = SCALAR) |
                        (STRUCTYPE(DATATYPE(#TP)) = SUBRANGE) THEN
                        RECORD_LENGTH = 2;
                     ELSE RECORD_LENGTH = STORAGE_LNGTH(DATATYPE(#TP));
                     CALL EMIT_TRIPLE(MONITOR, FINDCONST(RECORD_LENGTH),
                        NULL, MONITOR_CODE(ID_PTR));
                     CALL EMIT_TRIPLE(STORE, TABLE_PTR, LAST_TRIPLE, 0);
                     IF FATHERS_MULTIPLICITY = 2 THEN
                        DO;
                           #OP = #OP - 2;
                           RETURN;
                        END;
                     /* FLAG THE 'MONITOR' TRIPLE AS REUSABLE */
                     TRIPLES(N_TRIPLES - 1) = (N_TRIPLES - 6) | MASK_TEMP;
                     ERROR_FLAG = FALSE;
                     I = STRUCTYPE(DATATYPE(#TP));
                     IF (I ~= RECORD) & (I ~= PACKED_RECORD) THEN
                        ERROR_FLAG = TRUE;
                     ELSE
                        DO;
                           TAG_PTR = S_LIST(DATATYPE(#TP));
                           DO WHILE (STRUCTYPE(TAG_PTR) ~= TAG) &
                                 (TAG_PTR ~= NULL);
                              TAG_PTR = S_LIST(TAG_PTR);
                           END;
                           ERROR_FLAG = (TAG_PTR = NULL);
                        END;
                     IF ERROR_FLAG THEN
                        DO;
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                           #OP = #OP - 2;
                           CALL ERROR(
                              'MISSING CORRESPONDING TAGFIELD DECLARATION', 1);
                           RETURN;
                        END;
                     /* SAVE POINTER TO THE "MONITOR" TRIPLE */
                     FIX_LIST(NP) = (N_TRIPLES - 6) | MASK_TRIPLE;
                     #OP = #OP - 1;
                  END;   /* #MP = 2 */
               ELSE
                  DO;
                     I = FIX_LIST(NP);   /* POINTS TO "MONITOR" TRIPLE */
                     IF #MP < FATHERS_MULTIPLICITY THEN
                        I = I | MASK_TEMP;   /* FLAGS TRIPLE AS REUSABLE */
                     CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE, I,
                        RECORD_LENGTH - 1);
                     CALL EMIT_TRIPLE(INDEX, LAST_TRIPLE,
                        FINDCONST(DISPLACEMENT(TAG_PTR)), 1);
                     IF (TABLE_PTR & "C000") = MASK_SYMBOL THEN
                        ERROR_FLAG = (VAR_TYPE(TABLE_PTR) ~= CONSTANT);
                     ELSE ERROR_FLAG =
                           ((TABLE_PTR & "C000") ~= MASK_IMMEDIATE);
                     IF ERROR_FLAG THEN
                        DO;
                           CALL ERROR(
                             'CONSTANT REQUIRED IN TAGFIELD INITIALIZATION', 1);
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                           #OP = #OP - 2;
                           RETURN;
                        END;
                     I = LAST_TRIPLE;
                     CALL COERCE_ASSIGNMENT(DATATYPE(TAG_PTR), #TP);
                     CALL EMIT_TRIPLE(STORE, I, OPERAND#STK(#OP), 0);
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           #OP = #OP - 2;
                           RETURN;
                        END;
                     /* PREPARE FOR NEXT VISIT BY UPDATING TAG_PTR.
                        FIRST, FIND THE <VARIANT INSTANCE> WHICH
                        CORRESPONDS TO TABLE_PTR. */
                     IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                        I = TABLE_PTR & "3FFF";
                     ELSE I = VALUE(TABLE_PTR);
                     TABLE_PTR = OWNER(TAG_PTR);
                     VARIANT_NOT_FOUND = TRUE;
                     TAG_PTR = S_LIST(TAG_PTR);
                     DO WHILE VARIANT_NOT_FOUND & (TAG_PTR ~= NULL);
                        IF VALUE(TAG_PTR) = I THEN
                           DO;
                              VARIANT_NOT_FOUND = FALSE;
                              DO WHILE (VAR_TYPE(TAG_PTR) = CASELABEL) &
                                    (TAG_PTR ~= NULL);
                                 TAG_PTR = S_LIST(TAG_PTR);
                              END;
                           END;
                        ELSE
                           DO;   /* LOCATE NEXT CASELABEL */
                              TAG_PTR = S_LIST(TAG_PTR);
                              DO WHILE (OWNER(TAG_PTR) ~= TABLE_PTR) &
                                    (TAG_PTR ~= NULL);
                                 TAG_PTR = S_LIST(TAG_PTR);
                              END;
                           END;
                     END;
                     /* NOW FIND THE TAGFIELD */
                     TABLE_PTR = TAG_PTR;
                     IF TAG_PTR ~= NULL THEN TAG_PTR = S_LIST(TAG_PTR);
                     DO WHILE (TAG_PTR ~= NULL) & (OWNER(TAG_PTR) = TABLE_PTR)
                           & (STRUCTYPE(TAG_PTR) ~= TAG);
                        TAG_PTR = S_LIST(TAG_PTR);
                     END;
                     IF (TAG_PTR = NULL) | (OWNER(TAG_PTR) ~= TABLE_PTR) THEN
                        DO;
                           CALL ERROR(
                              'MISSING CORRESPONDING TAGFIELD DECLARATION', 1);
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                           #OP = #OP - 2;
                        END;
                     ELSE #OP = #OP - 1;
                  END;   /* #MP > 2 */
               /* CASE 22 -- READ() */
            READREADLN:
               DO;
                  IF #MP = 2 THEN
                     IF (STRUCTYPE(#TP) = FILE) |
                        (STRUCTYPE(#TP) = PACKED_FILE) THEN
                        DO;
                           IF TABLE_PTR = OUTPUTPTR THEN
                              DO;
                                 CALL ERROR(STD_FILE_ERR, 1);
                                 #OP = #OP - 2;
                                 #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                 RETURN;
                              END;
                           IF ID_PTR = READLNPTR THEN
                              IF ~COMPTYPES(#TP, TEXTPTR) THEN
                                 DO;
                                    CALL ERROR(PARAM_ERROR, 1);
                                    #OP = #OP - 2;
                                    #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                    RETURN;
                                 END;
                           FILE_PTR = TABLE_PTR;
                           CALL EMIT_TRIPLE(LOAD_ADDR, FILE_PTR, NULL, 3);
                           FIX_LIST(NP) = LAST_TRIPLE;
                           IF FATHERS_MULTIPLICITY = 2 THEN
                              DO;
                                 #OP = #OP - 2;
                                 IF ID_PTR = READPTR THEN
                                    CALL ERROR(#_PARAMS, 1);
                                 ELSE  /* READLN() */
                                    CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),
                                       NULL, MONITOR_CODE(ID_PTR));
                              END;
                           ELSE #OP = #OP - 1;
                           RETURN;
                        END;
                     ELSE  /* DEFAULT FILE IS INPUT */
                        DO;
                           FILE_PTR = INPUTPTR;
                           CALL EMIT_TRIPLE(LOAD_ADDR, INPUTPTR, NULL, 3);
                           FIX_LIST(NP) = LAST_TRIPLE;
                        END;
                  I = FIX_LIST(NP);  /* ADDR OF FILE */
                  IF (#MP < FATHERS_MULTIPLICITY) | (ID_PTR = READLNPTR) THEN
                     I = I | MASK_TEMP;
                  IF ~COMPTYPES(DATATYPE(FILE_PTR), TEXTPTR) THEN
                     DO;
                        CALL EMIT_TRIPLE(MONITOR, I, NULL,
                           MONITOR_CODE(GETPTR));
                        OPERAND#STK(#OP) = FILE_PTR;
                        CALL COERCE_ASSIGNMENT(DATATYPE(DATATYPE(FILE_PTR)),
                           #TP);
                        CALL EMIT_TRIPLE(STORE, TABLE_PTR, OPERAND#STK(#OP),
                           0);
                     END;
                  ELSE
                     DO;
                        IF STRUCTYPE(#TP) = SUBRANGE THEN
                           #TP1 = DATATYPE(#TP);
                        ELSE #TP1 = #TP;
                        IF COMPTYPES(#TP1, INTPTR) THEN
                           J = READ_INT;
                        ELSE IF COMPTYPES(#TP1, REALPTR) THEN
                           J = READ_REAL;
                        ELSE IF COMPTYPES(#TP1, CHARPTR) THEN
                           J = READ_CHAR;
                        ELSE CALL ERROR(PARAM_ERROR, 1);
                        CALL EMIT_TRIPLE(MONITOR, I, NULL, J);
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        IF #TP ~= #TP1 THEN CALL COERCE_ASSIGNMENT(#TP, #TP1);
                        CALL EMIT_TRIPLE(STORE, TABLE_PTR,
                           OPERAND#STK(#OP), 0);
                     END;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        #OP = #OP - 2;
                        IF ID_PTR = READLNPTR THEN
                           CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP), NULL,
                              MONITOR_CODE(ID_PTR));
                     END;
                  ELSE #OP = #OP - 1;
               END;
               /* CASE 23 -- WRITE() */
            WRITEWRITELN:
               DO;
                  IF #MP = 2 THEN
                     IF (STRUCTYPE(#TP) = FILE) |
                        (STRUCTYPE(#TP) = PACKED_FILE) THEN
                        DO;
                           IF TABLE_PTR = INPUTPTR THEN
                              DO;
                                 CALL ERROR(STD_FILE_ERR, 1);
                                 #OP = #OP - 2;
                                 #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                 RETURN;
                              END;
                           IF ID_PTR = WRITELNPTR THEN
                              IF ~COMPTYPES(#TP, TEXTPTR) THEN
                                 DO;
                                    CALL ERROR(PARAM_ERROR, 1);
                                    #OP = #OP - 2;
                                    #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                                    RETURN;
                                 END;
                           FILE_PTR = TABLE_PTR;
                           CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                           FIX_LIST(NP) = LAST_TRIPLE;
                           IF FATHERS_MULTIPLICITY = 2 THEN
                              DO;
                                 #OP = #OP - 2;
                                 IF ID_PTR = WRITEPTR THEN
                                    CALL ERROR(#_PARAMS, 1);
                                 ELSE  /* WRITELN() */
                                    CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),
                                       NULL, MONITOR_CODE(ID_PTR));
                              END;
                           ELSE #OP = #OP - 1;
                           RETURN;
                        END;
                     ELSE   /* DEFAULT FILE IS OUTPUT */
                        DO;
                           FILE_PTR = OUTPUTPTR;
                           CALL EMIT_TRIPLE(LOAD_ADDR, OUTPUTPTR, NULL, 3);
                           FIX_LIST(NP) = LAST_TRIPLE;
                        END;
                  I = FIX_LIST(NP);   /* ADDR OF FILE */
                  IF (#MP < FATHERS_MULTIPLICITY)
                     | (ID_PTR = WRITELNPTR) THEN
                     I = I | MASK_TEMP;
                  IF ~COMPTYPES(DATATYPE(FILE_PTR), TEXTPTR) THEN
                     DO;
                        CALL COERCE_ASSIGNMENT(DATATYPE(FILE_PTR), #TP);
                        CALL EMIT_TRIPLE(STORE, FILE_PTR, OPERAND#STK(#OP), 0);
                        CALL EMIT_TRIPLE(MONITOR, I, NULL,
                           MONITOR_CODE(PUTPTR));
                     END;
                  ELSE
                     DO;
                        IF STRUCTYPE(#TP) = SUBRANGE THEN
                           DO;
                              CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);
                              #TP = DATATYPE(#TP);
                              TABLE_PTR = OPERAND#STK(#OP);
                           END;
                        IF COMPTYPES(#TP, INTPTR) THEN
                           J = WRITE_INT;
                        ELSE IF COMPTYPES(#TP, REALPTR) THEN
                           J = WRITE_REAL;
                        ELSE IF COMPTYPES(#TP, BOOLPTR) THEN
                           J = WRITE_BOOL;
                        ELSE IF COMPTYPES(#TP, CHARPTR) THEN
                           J = WRITE_CHAR;
                        ELSE IF ((STRUCTYPE(#TP) = ARRAY) |
                              (STRUCTYPE(#TP) = PACKED_ARRAY)) &
                              COMPTYPES(DATATYPE(#TP), CHARPTR) THEN
                           DO;   /* FORM A STRING DESCRIPTOR */
                              CALL EMIT_TRIPLE(LOAD_ADDR, TABLE_PTR, NULL, 3);
                              CALL EMIT_TRIPLE(ADD, LAST_TRIPLE,
                                 FINDCONST(SHL(STORAGE_LNGTH(#TP) - 1, 24)), 3);
                              TABLE_PTR = LAST_TRIPLE;
                              J = WRITE_STRING;
                           END;
                        ELSE CALL ERROR(PARAM_ERROR, 1);
                        CALL EMIT_TRIPLE(MONITOR, I, TABLE_PTR, J);
                     END;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        #OP = #OP - 2;
                        IF ID_PTR = WRITELNPTR THEN
                           CALL EMIT_TRIPLE(MONITOR, FIX_LIST(NP),
                              NULL, MONITOR_CODE(ID_PTR));
                     END;
                  ELSE #OP = #OP - 1;
               END;
               /* CASE 24 -- PACK() */
            PACKUNPACK:
               IF #MP = 2 THEN
                  DO;
                     IF FATHERS_MULTIPLICITY ~= 4 THEN
                        DO;
                           #OP = #OP - 2;
                           CALL ERROR(#_PARAMS, 1);
                           #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                           RETURN;
                        END;
                     IF ID_PTR = PACKPTR THEN
                        DO;
                           ARRAY1 = TABLE_PTR;
                           ARRAY1_TYPE = #TP;
                        END;
                     ELSE  /* UNPACK() */
                        DO;
                           ARRAY2 = TABLE_PTR;
                           ARRAY2_TYPE = #TP;
                        END;
                     #OP = #OP - 1;
                  END;
               ELSE IF #MP = 3 THEN
                  DO;
                     IF ID_PTR = PACKPTR THEN
                        DO;
                           FIX_LIST(NP) = TABLE_PTR;
                           #TP1 = #TP;
                        END;
                     ELSE  /* UNPACK() */
                        DO;
                           ARRAY1 = TABLE_PTR;
                           ARRAY1_TYPE = #TP;
                        END;
                     #OP = #OP - 1;
                  END;
               ELSE  /* #MP = 4 */
                  DO;
                     IF ID_PTR = PACKPTR THEN
                        DO;
                           ARRAY2 = TABLE_PTR;
                           ARRAY2_TYPE = #TP;
                        END;
                     ELSE  /* UNPACK() */
                        DO;
                           FIX_LIST(NP) = TABLE_PTR;
                           #TP1 = #TP;
                        END;
                     ERROR_FLAG = (STRUCTYPE(ARRAY1_TYPE) ~= ARRAY)
                        | (STRUCTYPE(ARRAY2_TYPE) ~= ARRAY);
                     IF ~ERROR_FLAG THEN
                        ERROR_FLAG =
                           (STORAGE_LNGTH(ARRAY1_TYPE)
                           < STORAGE_LNGTH(ARRAY2_TYPE))
                           | ~COMPTYPES(DATATYPE(ARRAY1_TYPE),
                           DATATYPE(ARRAY2_TYPE));
                     IF ERROR_FLAG | (VAR_TYPE(ARRAY1_TYPE) = LITERAL) THEN
                        DO;
                           CALL ERROR(PARAM_ERROR, 1);
                           #OP = #OP - 2;
                           RETURN;
                        END;
                     OPERAND#STK(#OP) = FIX_LIST(NP);
                     CALL COERCE_ASSIGNMENT(S_LIST(ARRAY1_TYPE), #TP1);
                     I = STORAGE_LNGTH(ARRAY2_TYPE);
                     /* I EQUALS NUMBER OF BYTES TO BE MOVED */
                     J = STORAGE_LNGTH(ARRAY1_TYPE) / STORAGE_LNGTH(
                        S_LIST(ARRAY1_TYPE));
                     /* J IS ARRAY ELEMENT SIZE */
                     TABLE_PTR = OPERAND#STK(#OP);
                     IF (TABLE_PTR & "C000") = (MASK_TRIPLE & "C000") THEN
                        TABLE_PTR = TABLE_PTR | MASK_TEMP;
                     /* FLAG TABLE_PTR AS REUSABLE */
                     CALL EMIT_TRIPLE(GREATER, TABLE_PTR,
                        FINDCONST((STORAGE_LNGTH(ARRAY1_TYPE) - I) / J), 0);
                     CALL EMIT_TRIPLE(BZ, (N_TRIPLES + 6) | MASK_TRIPLE,
                        LAST_TRIPLE, 0);
                     /* VALUE OUT OF RANGE */
                     CALL EMIT_TRIPLE(MONITOR, NULL, NULL, 32);
                     CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
                     IF J ~= 1 THEN
                        DO;
                           CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP),
                              FINDCONST(J), 3);
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                        END;
                     CALL EMIT_TRIPLE(INDEX, ARRAY1, OPERAND#STK(#OP), I - 1);
                     OPERAND#STK(#OP) = LAST_TRIPLE;
                     IF I > 256 THEN
                        CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);
                     IF ID_PTR = PACKPTR THEN
                        CALL EMIT_TRIPLE(STORE, ARRAY2, OPERAND#STK(#OP), 0);
                     ELSE  /* UNPACK() */
                        CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP), ARRAY2, 0);
                     #OP = #OP - 2;
                  END;
               /* CASE 25 -- UNPACK() */
               GOTO PACKUNPACK;
               /* CASE 26 -- (NOT USED) */
               ;
               /* CASE 27 -- DISPOSE() */
               DO;
                  IF #MP = 2 THEN
                     DO;
                        IF STRUCTYPE(#TP) ~= POINTER THEN
                           CALL ERROR(PARAM_ERROR, 1);
                        IF (STRUCTYPE(DATATYPE(#TP)) = SCALAR) |
                           (STRUCTYPE(DATATYPE(#TP)) = SUBRANGE) THEN
                           RECORD_LENGTH = 2;
                        ELSE RECORD_LENGTH = STORAGE_LNGTH(DATATYPE(#TP));
                        CALL EMIT_TRIPLE(MONITOR, TABLE_PTR,
                           FINDCONST(RECORD_LENGTH), MONITOR_CODE(ID_PTR));
                     END;
                  IF #MP = FATHERS_MULTIPLICITY THEN #OP = #OP - 2;
                  ELSE #OP = #OP - 1;
               END;
               /* CASE 28 -- PAGE() */
               GOTO GETPUTRESETREWRITEPAGE;
               /* CASE 29 -- READLN() */
               GOTO READREADLN;
               /* CASE 30 -- WRITELN() */
               GOTO WRITEWRITELN;
               /* CASE 31 -- CLOCK */
               DO;
                  CALL ERROR('STANDARD FUNCTION CLOCK HAS NO PARAMETERS', 1);
                  #OP = #OP - 1;
                  #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                  #TP = INTPTR;
               END;
            END;   /* CASE */
         END;   /* #MP > 1 */
   END PROCFUNC;

IS_RECOVERY_PRODUCTION:
   PROCEDURE(PROD#) BIT(1);
      DECLARE PROD# BIT(16);
      IF (PROD# < 0) | (PROD# > 11) THEN RETURN FALSE;
      RETURN (SHL(1, PROD#) & "(1)1 11100 01111 0") ~= 0;
   END IS_RECOVERY_PRODUCTION;

   /*         $P ----- ENABLES XREF PROGRAM         */
   FIRST_VISIT = TRUE;
   NP, #OP = 0;
   NODE = ROOT_OF_SUBTREE;
   IF ~IS_VALID_ROOT_PRODUCTION(PARSE_TREE(NODE + 1)) THEN RETURN;
   DO WHILE FIRST_VISIT | NP > 0;
      IF FIRST_VISIT THEN
         DO;
            IF NODE = NULL THEN
               DO;
                  FIRST_VISIT = FALSE;
                  TABLE_PTR = NULL;
               END;
            ELSE IF IS_LEAF THEN
               DO;
                  TABLE_PTR = PARSE_TREE(NODE + 1);
                  FIRST_VISIT = FALSE;
                  IF IS_DECLARATION THEN CALL REPLACE(TABLE_PTR);
                  ELSE
                     DO;  /* PUSH SYMBOL TABLE POINTER ONTO OPERAND STACK */
                        IF #OP < #OPMAX THEN #OP = #OP + 1;
                        ELSE
                           DO;
                              CALL ERROR(OP#STACK#ERR, 1);
                              #OP = 10;
                           END;
                        OPERAND#STK(#OP) = TABLE_PTR;
                        /* OPERAND#STK IS POPPED WHEN TRIPLES ARE FORMED */
                        #TP = DATATYPE(TABLE_PTR);
                        CALL REPLACE(#TP);
                     END;
               END;
            ELSE
               DO;
                  /* CASE STATEMENT ON PRODUCTION NUMBER OF NODE */
                  I = PARSE_TREE(NODE + 1);
                  DO CASE PR_CASES(I);
                     /*  CASE 0 -- NO ACTION  */
                     ;
                     /* CASE 1 -- WHILE OR UNTIL STATEMENT  */
                     DO;
                        CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        IF NP < NPMAX THEN
                           FIX_LIST(NP + 1) = LAST_TRIPLE;
                        FX = FALSE;
                        LISTHEAD = NULL;
                     END;
                     /* CASE 2 -- PROD. 66 RECORD TYPE.  CREATE SY_TABLE
                                              ENTRY                    */
                     DO;
                        IF ALLOCATE_NEW_ROW THEN
                           ID_PTR = NEXT_FREE_ROW;
                        ELSE
                           DO;
                              ID_PTR = TP_ID_PTR;
                              ALLOCATE_NEW_ROW = TRUE;
                           END;
                        DATATYPE(ID_PTR) = ID_PTR;
                        VAR_TYPE(ID_PTR) = TYPE;
                        STRUCTYPE(ID_PTR) = RECORD;
                        OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        CURRENT_LEVEL = CURRENT_LEVEL + 1;
                        OWNER_STACK(CURRENT_LEVEL) = ID_PTR;
                        ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                        IF VAR_TYPE(OWNER_STACK(CURRENT_LEVEL - 1)) = PROC THEN
                           STACK_LIMIT(CURRENT_LEVEL),
                              HALFWORD_DISP(CURRENT_LEVEL) = 0;
                        ELSE
                           DO;
                              STACK_LIMIT(CURRENT_LEVEL) =
                                 STACK_LIMIT(CURRENT_LEVEL - 1);
                              HALFWORD_DISP(CURRENT_LEVEL) =
                                 HALFWORD_DISP(CURRENT_LEVEL - 1);
                           END;
                     END;
                     /* CASE 3 -- BLOCK HEADER  */
                     IS_DECLARATION = TRUE;
                     /* CASE 4 -- BLOCK BODY */
                     DO;
                        IS_DECLARATION = FALSE;
                        IF PARSE_TREE(NODE + 2) ~= NULL THEN
                           DO;
                              TRIPLES(0) = OWNER_STACK(CURRENT_LEVEL);
                              TRIPLES(1) = VALUE(TRIPLES(0));
                              TRIPLES(2), N_TRIPLES = 6;
                              IF CURRENT_LEVEL > 1 THEN
                                 IF MONITOR_LINK(2) > 0 THEN
                                   DO;  /* DEBUG LEVEL > 0; INITIALIZE STORAGE*/
                                       I = S_LIST(OWNER_STACK(CURRENT_LEVEL));
                                       MAX = DISPLAY_BYTES + 4 *
                                          (CURRENT_LEVEL - 1);
                                       DO WHILE I ~= NULL;
                                          J = DISPLACEMENT(I) +
                                             STORAGE_LNGTH(I);
                                          IF J > MAX THEN MAX = J;
                                          I = S_LIST(I);
                                       END;
                                       I = STACK_LIMIT(CURRENT_LEVEL) - MAX;
                                       IF I > 0 THEN
                                          DO;  /* THERE ARE LOCALS */
                                             J = NEXT_FREE_ROW;
                                             STORAGE_LNGTH(J) = I;
                                             PSEUDO_REG(J) = CURRENT_LEVEL - 1;
                                             DISPLACEMENT(J) = MAX;
                                             CALL EMIT_TRIPLE( XOR, J, J, 0);
                                          END;
                                       /* INITIALIZE FUNCTION RETURN VALUE */
                                       IF DATATYPE(OWNER_STACK(CURRENT_LEVEL))
                                          ~= NULL THEN
                                          CALL EMIT_TRIPLE(STORE,
                                             OWNER_STACK(CURRENT_LEVEL),
                                             0 | MASK_IMMEDIATE, 0);
                                    END;
                           END;
                     END;
                     /* CASE 5 -- ARRAY TYPES  */
                     DO;
                        ALLOCATE_ARRAY_ENTRY = ALLOCATE_NEW_ROW;
                        ALLOCATE_NEW_ROW = TRUE;
                     END;
                     /* CASE 6 -- ASSIGNMENT  */
                     DO;
                        LHS = TRUE;
                        FX = FALSE;
                        LISTHEAD = NULL;
                     END;
                     /* CASE 7 -- FOR STATEMENT, PROC/FUNC CALL,
                           SUBSCRIPT LIST, SET ELEMENT */
                     DO;
                        CALL REPLACE(FX);
                        FX = FALSE;
                        LISTHEAD = NULL;
                     END;
                     /* CASE 8 -- UNARY NOT */
                     FX = ~FX;
                     /* CASE 9 -- AND, OR */
                     DO;
                        CALL REPLACE(FX);
                        FX = (I = 41);  /* TRUE IF OR, FALSE IF AND */
                        LISTHEAD = NULL;
                     END;
                     /* CASE 10 -- STATEMENT LIST */
                     DO;
                        IS_DECLARATION = FALSE;
                        CALL DGNS#_PUSH;
                        CALL EMIT_ADD_DECIMAL;
                     END;
                     /* CASE 11 -- SET ELEMENT LIST */
                     DO;
                        IF NP < NPMAX THEN
                           FIX_LIST(NP + 1) = NEXT_FREE_ROW;
                        VAR_TYPE(N_DECL_SYMB - 1) = TYPE;
                        STRUCTYPE(N_DECL_SYMB - 1) = SET;
                     END;
                     /* CASE 12 -- DUMMY PROC_PARAM */
                     DO;
                        TABLE_PTR = NEXT_FREE_ROW;
                        DATATYPE(TABLE_PTR), S_LIST(TABLE_PTR) = NULL;
                        OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        STORAGE_LNGTH(TABLE_PTR) = 12;
                        VAR_TYPE(TABLE_PTR) = PROC_PARAM;
                        STRUCTYPE(TABLE_PTR) = STATEMENT;
                        PSEUDO_REG(TABLE_PTR) = NULL;
                        DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                        STACK_LIMIT(CURRENT_LEVEL) =
                           STACK_LIMIT(CURRENT_LEVEL) + 12;
                        CURRENT_LEVEL = CURRENT_LEVEL + 1;
                        OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;
                        ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                        STACK_LIMIT(CURRENT_LEVEL) = 0;
                        HALFWORD_DISP(CURRENT_LEVEL) = 0;
                        CALL REPLACE(TABLE_PTR);
                     END;
                     /* CASE 13 -- ERROR PRODUCTION */
                     DO;
                        DO WHILE ~IS_RECOVERY_PRODUCTION(FATHERS_PROD_NO);
                           CALL FATHER;
                        END;
                        CALL RIGHT_BRO;
                        GOTO ERROR_EXIT;
                     END;
                  END;  /* OF CASE ON PR_CASES  */
                  CALL LEFTSON;
               ERROR_EXIT: END;
         END;
      ELSE  /*  LATER VISITS  */
         DO;
            #MP = #POS_STACK(NP);
            FATHERS_MULTIPLICITY = PARSE_TREE(NODE#STACK(NP));
            DO CASE FATHERS_PROD_NO;
               /* FOR PRODUCTION NUMBERS WHOSE MULTIPLICITY CAN EXCEED ONE,
                  THE CODE WILL INCLUDE A SEGMENT TO VISIT THE NEXT SUBTREE.
                  IN ADDITION, FOR MANY OF THE PRODUCTION NUMBERS, IT WILL
                  BE NECESSARY TO DETERMINE WHICH OF THE SIBLING NODES IS
                  BEING VISITED.  FOR THIS PURPOSE, ONE CAN INTERROGATE #MP,
                  WHOSE VALUE IS THE INDEX OF 'NODE' AMONG ITS FATHER'S SONS. */
               /* CASE 0 IS A DUMMY BECAUSE WE NUMBER PRODUCTIONS FROM 1 */
               ;
               /* 1  <PROGRAM> ::= <ID> (<ID>)+ <BLOCK> */
               IF #MP = 1 THEN
                  DO;
                     DATATYPE(TABLE_PTR) = NULL;
                     VAR_TYPE(TABLE_PTR) = PROC;
                     STRUCTYPE(TABLE_PTR) = STATEMENT;
                     OWNER(TABLE_PTR) = NULL;
                     VALUE(TABLE_PTR) = 0;
                     PSEUDO_REG(TABLE_PTR) = 0;
                     OWNER_STACK(1) = TABLE_PTR;
                     STACK_LIMIT(1) = CONST_POOL_SIZE + DISPLAY_BYTES;
                     ARRAYS_ALLOCATED(1) = NULL;
                     CURRENT_LEVEL = 1;
                     DISPLACEMENT(TABLE_PTR), PROC_SEQUENCE_NUMBER = 0;
                     /* THE STORAGE_LNGTH FIELD IS TO BE FILLED IN LATER
                        WITH THE LENGTH OF THE ACTIVATION RECORD FOR THE
                        <PROGRAM> BLOCK.                                 */
                  END;
               ELSE
                  DO;  /* <ID> IS A FILE NAME */
                     IF VAR_TYPE(TABLE_PTR) = UNDEFINED THEN
                        DO;
                           VAR_TYPE(TABLE_PTR) = VARIABLE;
                           STRUCTYPE(TABLE_PTR) = FILE;
                           DATATYPE(TABLE_PTR) = NULL;
                        END;
                     S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                     /* DATATYPE, STORAGE_LNGTH ARE TO BE FILLED IN WHEN
                        THE FILE DECLARATION IS ENCOUNTERED              */
                  END;
               /* 2  <BLOCK> ::= (<LABEL DECL>) (<CONST DECL>) (<TYPE DEFN>)
                  (<VAR DECL LIST>) (<PROC DECL LIST>) <STATEMENT LIST> */
               ;
               /* 3  <STATEMENT LIST> ::= (<STATEMENT>)+ */
               IF #MP = FATHERS_MULTIPLICITY THEN CALL DGNS#_POP;
               ELSE IF DGNS#_GOTO THEN
                  DO;
                     DGNS#_GOTO = FALSE;
                     CALL EMIT_ADD_DECIMAL;
                  END;
               /* 4  <LABEL DECL> ::= (<UNSIGNED INTEGER>)+ */
               DO;
                  DATATYPE(TABLE_PTR) = NULL;
                  VAR_TYPE(TABLE_PTR) = LABLE;
                  STRUCTYPE(TABLE_PTR) = STATEMENT;
                  STORAGE_LNGTH(TABLE_PTR), OWNER(TABLE_PTR) =
                     OWNER_STACK(CURRENT_LEVEL);
               END;
               /* 5  <CONST DECL> ::= (<ID> <CONSTANT>)+ */
               IF #MP & 1 THEN
                  DO;   /* <ID> */
                     VAR_TYPE(TABLE_PTR) = CONSTANT;
                     OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     PSEUDO_REG(TABLE_PTR) = 0;
                  END;
               ELSE
                  DO;   /* <CONSTANT> */
                     ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                     DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                     IF VAR_TYPE(TABLE_PTR) = LITERAL THEN
                        DO;   /* <CONSTANT> IS A STRING */
                           STRUCTYPE(ID_PTR) = ARRAY;
                           STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);
                        END;
                     ELSE
                        DO;
                           IF VAR_TYPE(TABLE_PTR) ~= CONSTANT THEN
                              CALL ERROR(
                 'ILLEGAL IDENTIFIER ON RIGHT SIDE OF CONSTANT DECLARATION', 1);
                           STRUCTYPE(ID_PTR) = STRUCTYPE(I);
                           VALUE(ID_PTR) = VALUE(TABLE_PTR);
                        END;
                     DISPLACEMENT(ID_PTR) = DISPLACEMENT(TABLE_PTR);
                     S_LIST(ID_PTR) = TABLE_PTR;
                  END;
               /* 6  <TYPE DEFN> ::= (<ID> <TYPE>)+ */
               IF #MP & 1 THEN
                  DO;  /* <IDENTIFIER> */
                     VAR_TYPE(TABLE_PTR) = TYPE;
                     OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     TP_ID_PTR = TABLE_PTR;
                     ALLOCATE_NEW_ROW = FALSE;
                  END;
               ELSE
                  DO;  /* <TYPE> */
                     ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                     DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                     STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                     STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);
                  END;
               /* 7  <PROC DECL LIST> ::= <PROC DECL> (<PROC DECL LIST>) */
               ;
               /* 8  <PROC DECL> ::= <ID> (<FORMAL PARAM>)* <BODY> */
               /* PROPER PROCEDURE */
            PROC_DECL:
               IF #MP = 1 THEN
                  DO;
                     IF VAR_TYPE(TABLE_PTR) = MULTDECL THEN
                        DO;
                           VAR_TYPE(TABLE_PTR) = PROC;
                           CURRENT_LEVEL = CURRENT_LEVEL + 1;
                           OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;
                           STACK_LIMIT(CURRENT_LEVEL) =
                              STORAGE_LNGTH(TABLE_PTR);
                           ARRAYS_ALLOCATED(CURRENT_LEVEL),
                              HALFWORD_DISP(CURRENT_LEVEL) = 0;
                        END;
                     ELSE
                        DO;
                           IF VAR_TYPE(TABLE_PTR) = FORWARD THEN
                              VAR_TYPE(TABLE_PTR) = MULTDECL;
                           ELSE VAR_TYPE(TABLE_PTR) = PROC;
                           DATATYPE(TABLE_PTR) = NULL;
                           STRUCTYPE(TABLE_PTR) = STATEMENT;
                           OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                           PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL;
                           DISPLACEMENT(TABLE_PTR) = 0;
                           VALUE(TABLE_PTR), PROC_SEQUENCE_NUMBER =
                              PROC_SEQUENCE_NUMBER + 1;
                           /* STORAGE_LNGTH IS TO BE FILLED IN WHEN
                              PRODUCTION NUMBER 10 IS PROCESSED, AFTER
                              ALL DECLARATIONS OF VARIABLES LOCAL TO
                              THE PROCEDURE HAVE HAD STORAGE ALLOCATED. */
                           CURRENT_LEVEL = CURRENT_LEVEL + 1;
                           OWNER_STACK(CURRENT_LEVEL) = TABLE_PTR;
                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                           STACK_LIMIT(CURRENT_LEVEL) =
                              (CURRENT_LEVEL - 1) * 4 + DISPLAY_BYTES;
                           HALFWORD_DISP(CURRENT_LEVEL) = 0;
                           STORAGE_LNGTH(TABLE_PTR) =
                              STACK_LIMIT(CURRENT_LEVEL);
                        END;
                  END;  /* #MP = 1 */
               ELSE
                  DO;  /* LINK FORMAL PARAMETER LISTS TOGETHER. */
                     LINK = PARSE_TREE(NODE#STACK(NP) + #MP);
                     DO WHILE S_LIST(LINK) ~= NULL;
                        LINK = S_LIST(LINK);
                     END;
                     S_LIST(LINK) = TABLE_PTR;
                     CALL REPLACE(TABLE_PTR);
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;  /* ASSUMES NO ENTRY FOR <BODY> EXISTS IN FATHER
                                */
                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                           IF FATHERS_PROD_NO = 9 THEN
                              DO;
                                 S_LIST(LINK) = NULL;
                                 ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                                 DATATYPE(ID_PTR) = TABLE_PTR;
                                 I, STRUCTYPE(ID_PTR) =
                                    STRUCTYPE(TABLE_PTR);
                                 IF (VAR_TYPE(TABLE_PTR) ~= TYPE) |
                                    /* ~(I IN (.SCALAR, SUBRANGE, POINTER,
                                                   ARITHMETIC.))             */
                                    ((SHL(1, I) & "(1)10000 00000 01110")
                                    = 0) THEN
                                    CALL ERROR(
                    'FUNCTION CANNOT BE DECLARED TO HAVE A STRUCTURED TYPE', 1);
                              END;
                           STORAGE_LNGTH(OWNER_STACK(CURRENT_LEVEL)) =
                              STACK_LIMIT(CURRENT_LEVEL);
                        END;
                  END;  /* PROC_DECL */
               /* 9  <PROC DECL> ::= <ID> (<FORMAL PARAM>)* <ID> <BODY> */
               /* FUNCTION PROCEDURE */
               GOTO PROC_DECL;
               /* 10  <BODY> ::= (<STATEMENT LIST>) */
               DO;
                  IF CURRENT_LEVEL < 1 THEN RETURN;
                  CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                  STORAGE_LNGTH(OWNER_STACK(CURRENT_LEVEL)) =
                     STACK_LIMIT(CURRENT_LEVEL);
                  CURRENT_LEVEL = CURRENT_LEVEL - 1;
                  IF NODE ~= NULL THEN
                     DO;
                        CALL EMIT_TRIPLE(PRETURN, NULL, NULL, 0);
                        CALL EMIT_TRIPLE(PEND, NULL, NULL, 0);
                        TRIPLES(3) = N_TRIPLES;
                        IF SEVERE_ERRORS + MONITOR_LINK(3) = 0 THEN
                           CALL WRITE_TRIPLES;
                     END;
               END;
               /* 11  <VAR DECL LIST> ::= <VAR DECL> (<VAR DECL LIST>) */
               ;
               /* 12  <VAR DECL> ::= (<ID>)+ <TYPE> */
               IF #MP < FATHERS_MULTIPLICITY THEN
                  DO;
                     VAR_TYPE(TABLE_PTR) = VARIABLE;
                     OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;
                  END;
               ELSE
                  DO;
                     CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                     DO #TP = 2 TO FATHERS_MULTIPLICITY;
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #TP);
                        I, STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                        DATATYPE(ID_PTR) = TABLE_PTR;
                        CALL ALLOCATE_STORAGE(ID_PTR);
                     END;
                  END;
               /* 13  <STATEMENT> ::= <UNSIGNED INTEGER> <STATEMENT> */
               /* WHEN #MP = 1, NODE POINTS TO LABEL. */
               IF #MP = 1 THEN
                  DO;
                     IF (TRIPLES(N_TRIPLES - 3) & "7F") = ADD_DECIMAL THEN
                        DO;   /* BACK UP THE BLOCK-COUNTER EMITTER */
                           IC = IC - 1;
                           BASIC_BLOCKS = BASIC_BLOCKS - 1;
                           N_TRIPLES = N_TRIPLES - 3;
                        END;
                     /* SEE IF LABEL HAS ALREADY BEEN DEFINED. */
                     IF VALUE(TABLE_PTR) > 0 THEN
                        CALL ERROR('THE SAME LABEL IS DEFINED TWICE', 1);
                     /* NOW, DEFINE LABEL. */
                     CALL EMIT_TRIPLE(BCH_TARGET, TABLE_PTR, NULL, 0);
                     VALUE(TABLE_PTR) = IC;
                     DISPLACEMENT(TABLE_PTR) = N_TRIPLES - 3;
                     CALL EMIT_ADD_DECIMAL;
                     /* POP THE LABEL FROM THE OPERAND STACK */
                     #OP = #OP - 1;
                  END;
               /* 14  <STATEMENT> ::= <VARIABLE> <EXPRESSION> */
               /* ASSIGNMENT */
               DO;
                  CALL REPLACE(#TP);
                  IF #MP = 1 THEN LHS = FALSE;
                  ELSE
                     DO;
                        IF #TP = BOOLPTR THEN
                           IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                              CALL COND_TO_REGISTER;
                        CALL COERCE_ASSIGNMENT(
                           PARSE_TREE(NODE#STACK(NP) + #MP), #TP);
                        I = STRUCTYPE(#TP);
                        /* IF STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, POINTER,
                              ARRAY, PACKED_ARRAY, RECORD, PACKED_RECORD,
                              ARITHMETIC.) THEN   */
                        IF (SHL(1, I) & "(1)10000 11001 11110") ~= 0 THEN
                           CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 0);
                        ELSE IF (I = SET) | (I = PACKED_SET) THEN
                           DO;
                              IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                                 DO;
                                    J = OPERAND#STK(#OP - 1);
                                    CALL EMIT_TRIPLE( XOR, J, J, 0);
                                 END;
                              ELSE CALL EMIT_TRIPLE(MOVE, OPERAND#STK(#OP - 1),
                                    OPERAND#STK(#OP), 0);
                           END;
                        ELSE CALL ERROR('ILLEGAL ASSIGNMENT', 1);
                        #OP = #OP - 2;
                     END;
               END;
               /* 15  <STATEMENT> ::= <ID> (<EXPRESSION>)* */
               /* PROCEDURE STATEMENT */
               DO;
                  CALL PROCFUNC(TRUE);
                  DGNS#_TOP, DGNS#_GOTO, DGNS#_STACK(DGNS#_DEPTH) = TRUE;
               END;
               /* 16  <STATEMENT> ::= <STATEMENT LIST> */
               /* COMPOUND GROUP */
               ;
               /* 17  <STATEMENT> ::= <EXPRESSION> <STATEMENT> (<STATEMENT>) */
               /* CONDITIONAL STATEMENT */
               IF #MP = 1 THEN
                  DO;
                     IF ~COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE, 1);
                     IF ~IS_CONDITION(OPERAND#STK(#OP)) THEN
                        DO;
                           CALL EMIT_CONDITIONAL_BRANCH(FX);
                           LISTHEAD = LAST_TRIPLE;
                        END;
                     IF FX THEN
                        DO;  /* EMIT AN UNCONDITIONAL BRANCH AROUND
                                  THE 'THEN' CLAUSE. */
                           CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                           CALL FIXUP(LISTHEAD, N_TRIPLES);
                           CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        END;
                     ELSE OPERAND#STK(#OP) = LISTHEAD;
                     LISTHEAD = NULL;
                     CALL DGNS#_PUSH;
                     CALL EMIT_ADD_DECIMAL;
                  END;
               ELSE
                  DO;
                     LISTHEAD = OPERAND#STK(#OP);
                     IF #MP < FATHERS_MULTIPLICITY THEN
                        DO;  /* BRANCH AROUND 'ELSE' CLAUSE */
                           CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                        END;
                     ELSE #OP = #OP - 1;
                     CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                     CALL FIXUP(LISTHEAD, LAST_TRIPLE);
                     LISTHEAD = NULL;
                     IF #MP < FATHERS_MULTIPLICITY THEN
                        CALL EMIT_ADD_DECIMAL;
                     ELSE CALL DGNS#_POP;
                  END;
               /* 18  <STATEMENT> ::= <EXPRESSION> (<CASE INSTANCE>)+ */
               /* CASE STATEMENT */
               IF #MP = 1 THEN
                  DO;
                     FIX_LIST(NP) = NULL;
                     CALL DGNS#_PUSH;
                     MIN = MAXINT;
                     MAX = -MIN - 1;
                     IF #TP = BOOLPTR THEN
                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                           CALL COND_TO_REGISTER;
                     CALL REPLACE(#TP);
                     DO I = 3 TO FATHERS_MULTIPLICITY + 1;
                        CASE_INSTANCE_PTR = PARSE_TREE(NODE#STACK(NP) + I);
                        DO J = 2 TO MULTIPLICITY(CASE_INSTANCE_PTR);
                           CASE_LABEL_PTR = PARSE_TREE(CASE_INSTANCE_PTR + J);
                           IF MULTIPLICITY(CASE_LABEL_PTR) ~= 0 THEN
                              /* UNARY MINUS */
                              CASE_LABEL_VALUE = -VALUE(PARSE_TREE(
                                 PARSE_TREE(CASE_LABEL_PTR + 2) + 1));
                           ELSE CASE_LABEL_VALUE =
                                 VALUE(PARSE_TREE(CASE_LABEL_PTR + 1));
                           IF CASE_LABEL_VALUE < MIN THEN
                              MIN = CASE_LABEL_VALUE;
                           IF CASE_LABEL_VALUE > MAX THEN
                              MAX = CASE_LABEL_VALUE;
                        END;
                     END;
                     IF (OPERAND#STK(#OP) & MASK_TRIPLE) = 0 THEN
                        DO;   /* LOAD THE CASE SELECTOR */
                           CALL EMIT_TRIPLE(LOAD, OPERAND#STK(#OP), NULL, 3);
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                        END;
                     IF FATHERS_MULTIPLICITY = 1 THEN
                        DO;   /* EMPTY CASE LIST */
                           CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP), NULL, 0);
                           #OP = #OP - 1;
                        END;
                     ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN
                        DO;
                           IF VALUE(S_LIST(#TP)) ~= MIN THEN
                              DO;
                                 CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP),
                                    FINDCONST(VALUE(S_LIST(#TP)) - MIN), 3);
                                 OPERAND#STK(#OP) = LAST_TRIPLE;
                              END;
                           IF VALUE(S_LIST(#TP)) < MIN THEN
                              DO;
                                 CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP) |
                                    MASK_TEMP, 0 | MASK_IMMEDIATE, 0);
                                 CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                    LAST_TRIPLE, 0);
                                 FIX_LIST(NP) = LAST_TRIPLE;
                              END;
                           IF VALUE(#TP) > MAX THEN
                              DO;
                                 CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP) |
                                    MASK_TEMP, FINDCONST(MAX - MIN), 0);
                                 CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                    LAST_TRIPLE, 0);
                                 FIX_LIST(NP) = LAST_TRIPLE;
                              END;
                        END;
                     ELSE IF (STRUCTYPE(#TP) = SCALAR)
                           | COMPTYPES(#TP, INTPTR) THEN
                        DO;
                           IF MIN ~= 0 THEN
                              DO;
                                 CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP),
                                    FINDCONST(-MIN), 3);
                                 OPERAND#STK(#OP) = LAST_TRIPLE;
                                 CALL EMIT_TRIPLE(LESS, OPERAND#STK(#OP) |
                                    MASK_TEMP, 0 | MASK_IMMEDIATE, 0);
                                 CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                    LAST_TRIPLE, 0);
                                 FIX_LIST(NP) = LAST_TRIPLE;
                              END;
                           IF (STORAGE_LNGTH(#TP) - 1 > MAX)
                              | COMPTYPES(#TP, INTPTR) THEN
                              DO;
                                 CALL EMIT_TRIPLE(GREATER, OPERAND#STK(#OP)
                                    | MASK_TEMP, FINDCONST(MAX - MIN), 0);
                                 CALL EMIT_TRIPLE(BNZ, FIX_LIST(NP),
                                    LAST_TRIPLE, 0);
                                 FIX_LIST(NP) = LAST_TRIPLE;
                              END;
                        END;
                     ELSE CALL ERROR('ILLEGAL TYPE OF CASE SELECTOR', 1);
                     IF FATHERS_MULTIPLICITY > 1 THEN
                        DO;
                           TABLE_PTR = NEXT_FREE_ROW;
                           DATATYPE(TABLE_PTR) = DATATYPE(#TP);
                           STRUCTYPE(TABLE_PTR) = SUBRANGE;
                           VAR_TYPE(TABLE_PTR) = TYPE;
                           VALUE(TABLE_PTR) = MAX;
                           STORAGE_LNGTH(TABLE_PTR) = MAX - MIN + 1;
                           CALL EMIT_TRIPLE(CASE_JUMP, OPERAND#STK(#OP),
                              TABLE_PTR, 0);
                           OPERAND#STK(#OP) = (N_TRIPLES - 3);
                           DO I = MIN TO MAX;
                              CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                           END;
                        END;
                  END;   /* #MP = 1 */
               ELSE IF #MP < FATHERS_MULTIPLICITY THEN
                  DO;
                     CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);
                     FIX_LIST(NP) = LAST_TRIPLE;
                  END;
               ELSE  /* #MP = FATHERS_MULTIPLICITY */
                  DO;
                     LISTHEAD = NULL;
                     I = OPERAND#STK(#OP);
                     TABLE_PTR = TRIPLES(I + 2);
                     TRIPLES(I + 2) = FINDCONST(STORAGE_LNGTH(TABLE_PTR));
                     J = I + 3 * STORAGE_LNGTH(TABLE_PTR);
                     DO WHILE I < J;
                        I = I + 3;
                        IF TRIPLES(I + 1) = NULL THEN  /* EMPTY CASE */
                           DO;
                              TRIPLES(I + 1) = LISTHEAD;
                              LISTHEAD = I;
                           END;
                     END;
                     IF LISTHEAD ~= NULL THEN
                        DO;
                           CALL EMIT_TRIPLE(CASE_TARGET, NULL, NULL, 0);
                           CALL FIXUP(LISTHEAD, LAST_TRIPLE);
                           LISTHEAD = NULL;
                        END;
                     CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                     CALL FIXUP(FIX_LIST(NP), LAST_TRIPLE);
                     IF TABLE_PTR + 1 = N_DECL_SYMB THEN
                        /* RELEASE THE SYMBOL TABLE ENTRY */
                        N_DECL_SYMB = N_DECL_SYMB - 1;
                     #OP = #OP - 1;
                     CALL DGNS#_POP;
                  END;
               /* 19  <STATEMENT> ::= <EXPRESSION> <STATEMENT> */
               /* WHILE STATEMENT */
               IF #MP = 1 THEN
                  DO;
                     CALL DGNS#_PUSH;
                     IF ~COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE, 1);
                     IF ~IS_CONDITION(OPERAND#STK(#OP)) THEN
                        DO;
                           CALL EMIT_CONDITIONAL_BRANCH(FX);
                           LISTHEAD = LAST_TRIPLE;
                        END;
                     IF FX THEN
                        DO;  /* EMIT AN UNCONDITIONAL BRANCH
                                  AROUND THE WHILE STATEMENT */
                           CALL EMIT_TRIPLE(BCH, NULL, NULL, 0);
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                           CALL FIXUP(LISTHEAD, N_TRIPLES);
                           CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        END;
                     ELSE OPERAND#STK(#OP) = LISTHEAD;
                     LISTHEAD = NULL;
                     CALL EMIT_ADD_DECIMAL;
                  END;
               ELSE
                  DO;
                     CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);
                     CALL FIXUP(OPERAND#STK(#OP), N_TRIPLES);
                     CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                     #OP = #OP - 1;
                     CALL DGNS#_POP;
                  END;
               /* 20  <STATEMENT> ::= <STATEMENT LIST> <EXPRESSION> */
               /* UNTIL STATEMENT */
               IF #MP = 1 THEN FX = FALSE;
               ELSE
                  DO;
                     IF ~COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE, 1);
                     IF ~IS_CONDITION(OPERAND#STK(#OP)) THEN
                        DO;
                           CALL EMIT_CONDITIONAL_BRANCH(FX);
                           LISTHEAD = LAST_TRIPLE;
                        END;
                     IF FX THEN
                        DO;
                           CALL EMIT_TRIPLE(BCH, FIX_LIST(NP), NULL, 0);
                           CALL FIXUP(LISTHEAD, N_TRIPLES);
                           CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                        END;
                     ELSE CALL FIXUP(LISTHEAD, FIX_LIST(NP));
                     LISTHEAD = NULL;
                     #OP = #OP - 1;
                  END;
               /* 21  <STATEMENT> ::= <ID> <EXPRESSION> <EXPRESSION> <STATEMENT>
               */
               /* FOR STATEMENT -- UPTO */
            FORSTAT:
               IF #MP = 1 THEN
                  DO;
                     CALL REPLACE(#TP);
                     IF VAR_TYPE(TABLE_PTR) = VAR_PARAM THEN
                        CALL ERROR('CONTROL VARIABLE MUST NOT BE FORMAL', 1);
                     ELSE IF VAR_TYPE(TABLE_PTR) ~= VARIABLE THEN
                        CALL ERROR(
                           'ILLEGAL OR UNDECLARED LOOP CONTROL VARIABLE', 1);
                     I = STRUCTYPE(#TP);
                     IF ((SHL(1, I) & "(1)10000 00000 00110") = 0)
                        /* ~(I IN (.SCALAR, SUBRANGE, ARITHMETIC.)) */
                        | COMPTYPES(#TP, REALPTR) THEN
                        CALL ERROR('ILLEGAL TYPE OF LOOP CONTROL VARIABLE', 1);
                  END;
               ELSE IF #MP < 4 THEN
                  DO;
                     CALL REPLACE(#TP);
                     IF COMPTYPES(#TP, BOOLPTR) THEN
                        IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                           CALL COND_TO_REGISTER;
                     CALL COERCE_ASSIGNMENT(PARSE_TREE(NODE#STACK(NP) + 2),
                        #TP);
                     TABLE_PTR = OPERAND#STK(#OP);
                     IF (TABLE_PTR & "C000") = MASK_SYMBOL THEN
                        DO;
                           IF VAR_TYPE(TABLE_PTR) = CONSTANT THEN
                              DO;
                                 IF #MP = 2 THEN
                                    DO;
                                       BOUND1_IS_CONST = TRUE;
                                       BOUND1_VALUE = VALUE(TABLE_PTR);
                                    END;
                                 ELSE   /* #MP = 3 */
                                    DO;
                                       BOUND2_IS_CONST = TRUE;
                                       BOUND2_VALUE = VALUE(TABLE_PTR);
                                    END;
                              END;
                           ELSE IF #MP = 2 THEN BOUND1_IS_CONST = FALSE;
                           ELSE  /* #MP = 3 */ BOUND2_IS_CONST = FALSE;
                        END;
                     ELSE IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                        DO;
                           IF #MP = 2 THEN
                              DO;
                                 BOUND1_IS_CONST = TRUE;
                                 BOUND1_VALUE = TABLE_PTR & "3FFF";
                              END;
                           ELSE   /* #MP = 3 */
                              DO;
                                 BOUND2_IS_CONST = TRUE;
                                 BOUND2_VALUE = TABLE_PTR & "3FFF";
                              END;
                        END;
                     ELSE IF #MP = 2 THEN BOUND1_IS_CONST = FALSE;
                     ELSE  /* #MP = 3 */ BOUND2_IS_CONST = FALSE;
                     IF #MP = 3 THEN
                        DO;
                           CALL EMIT_TRIPLE(TEMP, OPERAND#STK(#OP), NULL, 3);
                           OPERAND#STK(#OP) = LAST_TRIPLE | MASK_TEMP;
                           IF FATHERS_PROD_NO = 21 THEN  /* UPTO */
                              DO;
                                 IF BOUND1_IS_CONST THEN
                                    DO;
                                       IF BOUND2_IS_CONST THEN
                                          CALL EMIT_TRIPLE(TEMP,
                                             FINDCONST(BOUND2_VALUE + 1
                                             - BOUND1_VALUE), NULL, 3);
                                       ELSE IF BOUND1_VALUE = 1 THEN
                                          CALL EMIT_TRIPLE(TEMP,
                                             OPERAND#STK(#OP), NULL, 3);
                                       ELSE
                                          DO;
                                             CALL EMIT_TRIPLE(SUBTRACT,
                                                OPERAND#STK(#OP),
                                                FINDCONST(BOUND1_VALUE - 1), 3);
                                             CALL EMIT_TRIPLE(TEMP,
                                                LAST_TRIPLE, NULL, 3);
                                          END;
                                    END;
                                 ELSE   /* ~BOUND1_IS_CONST */
                                    DO;
                                       IF BOUND2_IS_CONST THEN
                                          CALL EMIT_TRIPLE(SUBTRACT,
                                             FINDCONST(BOUND2_VALUE + 1),
                                             OPERAND#STK(#OP - 1), 3);
                                       ELSE
                                          DO;   /* WORST CASE */
                                             CALL EMIT_TRIPLE(SUBTRACT,
                                                OPERAND#STK(#OP),
                                                OPERAND#STK(#OP - 1), 3);
                                             CALL EMIT_TRIPLE(ADD,
                                                LAST_TRIPLE,
                                                1 | MASK_IMMEDIATE, 3);
                                          END;
                                       CALL EMIT_TRIPLE(TEMP,
                                          LAST_TRIPLE, NULL, 3);
                                    END;
                              END;
                           ELSE   /* DOWNTO */
                              DO;
                                 IF BOUND1_IS_CONST THEN
                                    DO;
                                       IF BOUND2_IS_CONST THEN
                                          CALL EMIT_TRIPLE(TEMP,
                                             FINDCONST(BOUND1_VALUE + 1
                                             - BOUND2_VALUE), NULL, 3);
                                       ELSE
                                          DO;
                                             CALL EMIT_TRIPLE(SUBTRACT,
                                                FINDCONST(BOUND1_VALUE + 1),
                                                OPERAND#STK(#OP), 3);
                                             CALL EMIT_TRIPLE(TEMP,
                                                LAST_TRIPLE, NULL, 3);
                                          END;
                                    END;
                                 ELSE   /* ~BOUND1_IS_CONST */
                                    DO;
                                       IF ~BOUND2_IS_CONST THEN
                                          DO;   /* WORST CASE */
                                             CALL EMIT_TRIPLE(SUBTRACT,
                                                OPERAND#STK(#OP - 1),
                                                OPERAND#STK(#OP), 3);
                                             CALL EMIT_TRIPLE(ADD,
                                                LAST_TRIPLE,
                                                1 | MASK_IMMEDIATE, 3);
                                             CALL EMIT_TRIPLE(TEMP,
                                                LAST_TRIPLE, NULL, 3);
                                          END;
                                       ELSE IF BOUND2_VALUE = 1 THEN
                                          CALL EMIT_TRIPLE(TEMP,
                                             OPERAND#STK(#OP - 1), NULL, 3);
                                       ELSE
                                          DO;
                                             CALL EMIT_TRIPLE(SUBTRACT,
                                                OPERAND#STK(#OP - 1),
                                                FINDCONST(BOUND2_VALUE - 1), 3);
                                             CALL EMIT_TRIPLE(TEMP,
                                                LAST_TRIPLE, NULL, 3);
                                          END;
                                    END;
                              END;
                           OPERAND#STK(#OP - 1) = LAST_TRIPLE | MASK_TEMP;
                           CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                           FIX_LIST(NP) = N_TRIPLES;
                           CALL EMIT_TRIPLE(BCT, NULL, OPERAND#STK(#OP - 1), 0);
                           IF FATHERS_PROD_NO = 21 THEN I = SUBTRACT;
                           ELSE I = ADD;
                           CALL EMIT_TRIPLE(I, OPERAND#STK(#OP),
                              OPERAND#STK(#OP - 1), 3);
                           CALL EMIT_TRIPLE(STORE, OPERAND#STK(#OP - 2),
                              LAST_TRIPLE, 0);
                           CALL DGNS#_PUSH;
                           CALL EMIT_ADD_DECIMAL;
                        END;
                  END;
               ELSE  /* #MP = 4 */
                  DO;
                     CALL EMIT_TRIPLE(BCH, (FIX_LIST(NP) - 3) | MASK_TRIPLE,
                        NULL, 0);
                     CALL FIXUP(FIX_LIST(NP), N_TRIPLES);
                     CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                     CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP - 1) & "BFFF",
                        NULL, 0);
                     CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP) & "BFFF",
                        NULL, 0);
                     #OP = #OP - 3;
                     CALL DGNS#_POP;
                  END;
               /* 22  <STATEMENT> ::= <ID> <EXPRESSION> <EXPRESSION> <STATEMENT>
               */
               /* FOR STATEMENT - DOWNTO */
               GOTO FORSTAT;
               /* 23  <STATEMENT> ::= (<VARIABLE>)+ <STATEMENT> */
               /* WITH STATEMENT */
               IF #MP < FATHERS_MULTIPLICITY THEN
                  DO;
                     CALL REPLACE(#TP);
                     WITH_PTR = WITH_PTR + 1;
                     IF WITH_PTR > WITH_LENGTH THEN
                        DO;
                           CALL ERROR('WITH VARIABLES NESTED TOO DEEPLY', 1);
                           WITH_PTR = WITH_PTR - 1;
                           #OP = #OP - 1;
                        END;
                     ELSE
                        DO;
                           IF (OPERAND#STK(#OP) & "C000") = MASK_SYMBOL THEN
                              DO;
                                 ID_PTR = OPERAND#STK(#OP);
                                 IF VAR_TYPE(ID_PTR) ~= VARIABLE THEN
                                    CALL ERROR('ILLEGAL "WITH" VARIABLE: '
                                       || IDENTITY(ID_PTR), 1);
                              END;
                           CALL EMIT_TRIPLE(LOAD_ADDR, OPERAND#STK(#OP),
                              NULL, 3);
                           WITH_VARIABLE(WITH_PTR) =
                              LAST_TRIPLE | MASK_TEMP;
                           WITH_DATATYPE(WITH_PTR) = #TP;
                           #OP = #OP - 1;
                        END;
                     IF #MP = FATHERS_MULTIPLICITY - 1 THEN
                        DO;
                           CALL DGNS#_PUSH;
                           CALL EMIT_ADD_DECIMAL;
                        END;
                  END;
               ELSE
                  DO I = 1 TO FATHERS_MULTIPLICITY - 1;
                     CALL EMIT_TRIPLE(TPOP, WITH_VARIABLE(WITH_PTR) & "BFFF",
                        NULL, 0);
                     WITH_PTR = WITH_PTR - 1;
                     IF I = FATHERS_MULTIPLICITY - 1 THEN
                        CALL DGNS#_POP;
                  END;
               /* 24  <STATEMENT> ::= <UNSIGNED INTEGER> */
               /* GOTO STATEMENT */
               DO;
                  CALL EMIT_TRIPLE(BCH, TABLE_PTR,
                     FINDCONST(VALUE(OWNER(TABLE_PTR))), 0);
                  #OP = #OP - 1;
                  DGNS#_TOP, DGNS#_GOTO, DGNS#_STACK(DGNS#_DEPTH) = TRUE;
               END;
               /* 25  <FORMAL PARAM> ::= (<ID>)+ <ID> */
               /* FORMAL VAR PARAMETER */
            FORMAL:
               IF #MP < FATHERS_MULTIPLICITY THEN DO;
                     OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;
                     IF #MP > 1 THEN
                        S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                     IF FATHERS_PROD_NO = 25 THEN
                        DO;   /* VAR PARAMETER */
                           VAR_TYPE(TABLE_PTR) = VAR_PARAM;
                           STORAGE_LNGTH(TABLE_PTR) = 4;
                           DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                           STACK_LIMIT(CURRENT_LEVEL) =
                              STACK_LIMIT(CURRENT_LEVEL) + 4;
                        END;
                     ELSE  /* VALUE PARAM */ VAR_TYPE(TABLE_PTR) = VARIABLE;
                  END;
               ELSE DO;   /* TYPE IDENTIFIER  */
                     IF VAR_TYPE(TABLE_PTR) ~= TYPE THEN
                        CALL ERROR(IDENTITY(TABLE_PTR) || IS_NOT_A_TYPE, 1);
                     I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                     DO WHILE ID_PTR ~= NULL;
                        DATATYPE(ID_PTR) = TABLE_PTR;
                        STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                        IF FATHERS_PROD_NO = 26 THEN DO;
                              CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                              CALL ALLOCATE_STORAGE(ID_PTR);
                           END;
                        ID_PTR = S_LIST(ID_PTR);
                     END;
                     TABLE_PTR = I;
                  END;
               /* 26  <FORMAL PARAM> ::= (<ID>)+ <ID> */
               /* FORMAL VALUE PARAMETER */
               GOTO FORMAL;
               /* 27  <FORMAL PARAM> ::= (<ID>)+ (<PARAM TYPES>)+ (<ID>) */
               /* FORMAL PROCEDURE PARAMETER */
               IF IS_LEAF & (#MP < FATHERS_MULTIPLICITY) THEN
                  DO;
                     DATATYPE(TABLE_PTR), S_LIST(TABLE_PTR) = NULL;
                     VAR_TYPE(TABLE_PTR) = PROC_PARAM;
                     STRUCTYPE(TABLE_PTR) = STATEMENT;
                     OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     STORAGE_LNGTH(TABLE_PTR) = 12;
                     PSEUDO_REG(TABLE_PTR) = CURRENT_LEVEL - 1;
                     DISPLACEMENT(TABLE_PTR) = STACK_LIMIT(CURRENT_LEVEL);
                     STACK_LIMIT(CURRENT_LEVEL) =
                        STACK_LIMIT(CURRENT_LEVEL) + 12;
                     IF #MP > 1 THEN
                        S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                     CALL REPLACE(TABLE_PTR);
                     FIRST_PARAM_TYPES =
                       (MULTIPLICITY(PARSE_TREE(NODE#STACK(NP) + #MP + 2)) > 0);
                     IF FIRST_PARAM_TYPES THEN
                        DO;  /* INCREMENT CURRENT_LEVEL */
                           CURRENT_LEVEL = CURRENT_LEVEL + 1;
                           OWNER_STACK(CURRENT_LEVEL) =
                              PARSE_TREE(NODE#STACK(NP) + 2);
                           ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                           STACK_LIMIT(CURRENT_LEVEL) = 0;
                           HALFWORD_DISP(CURRENT_LEVEL) = 0;
                        END;
                  END;
               ELSE
                  DO;
                     CALL REPLACE(TABLE_PTR);
                     ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                     IF FIRST_PARAM_TYPES THEN
                        DO;
                           FIRST_PARAM_TYPES = FALSE;
                           LINK = ID_PTR;
                           DO WHILE LINK ~= NULL;
                              VALUE(LINK) = TABLE_PTR;
                              LINK = S_LIST(LINK);
                           END;
                        END;
                     ELSE
                        DO;
                           LINK = PARSE_TREE(NODE#STACK(NP) + #MP);
                           IF LINK ~= NULL THEN
                              DO;
                                 DO WHILE S_LIST(LINK) ~= NULL;
                                    LINK = S_LIST(LINK);
                                 END;
                                 S_LIST(LINK) = TABLE_PTR;
                              END;
                        END;
                     IF #MP = FATHERS_MULTIPLICITY THEN
                        DO;
                           IF IS_LEAF THEN
                              DO;  /* FUNCTION-TYPE PARAMETERS */
                                 IF LINK ~= NULL THEN S_LIST(LINK) = NULL;
                                 LINK = ID_PTR;
                                 DO WHILE LINK ~= NULL;
                                    DATATYPE(LINK) = TABLE_PTR;
                                    STRUCTYPE(LINK) = STRUCTYPE(TABLE_PTR);
                                    LINK = S_LIST(LINK);
                                 END;
                                 IF VAR_TYPE(TABLE_PTR) ~= TYPE THEN
                                    CALL ERROR(IDENTITY(TABLE_PTR)
                                       || IS_NOT_A_TYPE, 1);
                              END;
                           CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                           CURRENT_LEVEL = CURRENT_LEVEL - 1;
                           TABLE_PTR = ID_PTR;
                        END;
                  END;
               /* 28  <CASE INSTANCE> ::= (<CONSTANT>)+ <STATEMENT> */
               IF #MP < FATHERS_MULTIPLICITY THEN
                  DO;
                     IF #MP = 1 THEN
                        DO;
                           CALL EMIT_TRIPLE(CASE_TARGET, NULL, NULL, 0);
                           CASE_PTR = LAST_TRIPLE;
                           CALL EMIT_ADD_DECIMAL;
                        END;
                     #OP = #OP - 1;
                     ID_PTR = TRIPLES(OPERAND#STK(#OP) + 2);
                     IF ~COMPTYPES(#TP, DATATYPE(ID_PTR)) THEN
                        CALL ERROR(
                           'LABEL TYPE INCOMPATIBLE WITH SELECTING EXPRESSION'
                           , 1);
                     IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                        CASE_LABEL_VALUE = TABLE_PTR & "3FFF";
                     ELSE CASE_LABEL_VALUE = VALUE(TABLE_PTR);
                     I = OPERAND#STK(#OP) + 3 * (CASE_LABEL_VALUE +
                        STORAGE_LNGTH(ID_PTR) - VALUE(ID_PTR));
                     /* I POINTS TO THE "BCH" TRIPLE IN THE JUMP TABLE
                           WHICH CORRESPONDS TO CASE_LABEL_VALUE   */
                     IF TRIPLES(I + 1) = NULL THEN CALL FIXUP(I, CASE_PTR);
                     ELSE CALL ERROR('MULTIDEFINED CASE LABEL', 1);
                  END;
               /* 29  <EXPRESSION> ::= <EXPRESSION> */
               /* UNARY '+' OPERATOR */
               ;
               /* 30  <EXPRESSION> ::= <EXPRESSION> */
               /* UNARY '-' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  IF STRUCTYPE(#TP) = SUBRANGE THEN
                     DO;
                        CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);
                        #TP = DATATYPE(#TP);
                     END;
                  IF COMPTYPES(#TP, INTPTR) THEN
                     DO;
                        TABLE_PTR = OPERAND#STK(#OP);
                        IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                          OPERAND#STK(#OP) = FINDCONST( - (TABLE_PTR & "3FFF"));
                        ELSE IF ((TABLE_PTR & "C000") = MASK_SYMBOL)
                              & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                           OPERAND#STK(#OP) = FINDCONST(-VALUE(TABLE_PTR));
                        ELSE
                           DO;
                              CALL EMIT_TRIPLE(NEGATE, TABLE_PTR, NULL, 3);
                              OPERAND#STK(#OP) = LAST_TRIPLE;
                           END;
                     END;
                  ELSE IF COMPTYPES(#TP, REALPTR) THEN
                     DO;
                        TABLE_PTR = OPERAND#STK(#OP);
                        IF ((TABLE_PTR & "C000") = MASK_SYMBOL)
                           & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                           DO;
                              I = VALUE(TABLE_PTR);
                              IF I > 0 THEN
                                 OPERAND#STK(#OP) = FINDREAL(I | "80000000");
                              ELSE OPERAND#STK(#OP) =
                                    FINDREAL(I & "7FFFFFFF");
                           END;
                        ELSE
                           DO;
                              CALL EMIT_TRIPLE(NEGATEFLT, OPERAND#STK(#OP),
                                 NULL, 3);
                              OPERAND#STK(#OP) = LAST_TRIPLE;
                           END;
                     END;
                  ELSE CALL ERROR('ILLEGAL UNARY "-" OPERATOR', 1);
               END;
               /* 31  <EXPRESSION> ::= <EXPRESSION> */
               /* UNARY 'NOT' OPERATOR */
               DO;
                  IF ~COMPTYPES(#TP, BOOLPTR) THEN
                     DO;
                        CALL ERROR(BOOLTYPE, 1);
                        #TP = BOOLPTR;
                     END;
                  IF IS_NEGATION(OPERAND#STK(#OP)) THEN
                     DO;
                        OPERAND#STK(#OP) = TRIPLES(N_TRIPLES - 2);
                        N_TRIPLES = N_TRIPLES - 3;
                        LAST_TRIPLE = (N_TRIPLES - 3) | MASK_TRIPLE;
                        IC = IC - 1;
                     END;
                  ELSE IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                     DO;
                        IF LISTHEAD ~= NULL THEN
                           DO;  /* REVERSE THE PARITY OF LISTHEAD */
                              IF (LISTHEAD & "8000") ~= 0 THEN
                                 LISTHEAD = LISTHEAD & "7FFF";
                              ELSE LISTHEAD = LISTHEAD | "8000";
                           END;
                        ELSE
                           DO;
                              CALL EMIT_CONDITIONAL_BRANCH(FX);
                              LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
                              OPERAND#STK(#OP) = LAST_TRIPLE;
                           END;
                     END;
                  ELSE
                     DO;
                        CALL EMIT_TRIPLE(NOT, OPERAND#STK(#OP), NULL, 3);
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                     END;
                  FX = ~FX;
               END;
               /* 32  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '=' OPERATOR */
               CALL EMIT_COMPARE(EQUAL_TO);
               /* 33  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '<' OPERATOR */
               CALL EMIT_COMPARE(LESS_THAN);
               /* 34  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '>' OPERATOR */
               CALL EMIT_COMPARE(GREATER_THAN);
               /* 35  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '<>' OPERATOR */
               CALL EMIT_COMPARE(NOT_EQUAL_TO);
               /* 36  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '<=' OPERATOR */
               CALL EMIT_COMPARE(LESS_EQ);
               /* 37  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '>=' OPERATOR */
               CALL EMIT_COMPARE(GREATER_EQ);
               /* 38  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY 'IN' OPERATOR */
               IF #MP = 1 THEN
                  DO;
                     CALL REPLACE(#TP);
                     IF STRUCTYPE(#TP) = SUBRANGE THEN
                        CALL COERCE_ASSIGNMENT(DATATYPE(#TP), #TP);
                     ELSE IF (STRUCTYPE(#TP) ~= SCALAR)
                           & ~COMPTYPES(#TP, INTPTR) THEN
                        DO;
                           CALL ERROR(
                'FIRST OPERAND OF "IN" MUST BE SCALAR, SUBRANGE OR INTEGER', 1);
                           #TP = BOOLPTR;
                           #POS_STACK(NP) = 2;
                        END;
                  END;
               ELSE  /* #MP = 2 */ IF #TP = EMPTYSETPTR THEN
                  DO;
                     IF (OPERAND#STK(#OP - 1) & MASK_TRIPLE) ~= 0 THEN
                        CALL EMIT_TRIPLE(TPOP, OPERAND#STK(#OP - 1), NULL, 0);
                     OPERAND#STK(#OP - 1) = FALSE | MASK_IMMEDIATE;
                     #OP = #OP - 1;
                     #TP = BOOLPTR;
                  END;
               ELSE
                  DO;
                     ID_PTR = OPERAND#STK(#OP - 1);
                     TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                     /* ID_PTR IS LEFT OPERAND, TABLE_PTR IS ITS DATATYPE */
                     IF ~COMPTYPES(TABLE_PTR, DATATYPE(#TP)) THEN
                        CALL ERROR(
                       'FIRST OPERAND OF "IN" NOT COMPATIBLE WITH SET TYPE', 1);
                     MIN = SHL(VALUE(#TP), 3);
                     MAX = SHL(VALUE(#TP) + STORAGE_LNGTH(#TP), 3) - 1;
                     IF STRUCTYPE(TABLE_PTR) = SCALAR THEN
                        DO;
                           MUST_CHECK_LOWBOUND = (MIN > 0);
                           MUST_CHECK_HIGHBOUND =
                              (MAX < STORAGE_LNGTH(TABLE_PTR) - 1);
                        END;
                     ELSE MUST_CHECK_LOWBOUND, MUST_CHECK_HIGHBOUND = TRUE;
                     IF (ID_PTR & MASK_TRIPLE) ~= 0 THEN
                        J = ID_PTR | MASK_TEMP;
                     ELSE J = ID_PTR;
                     IF FX THEN
                        DO;
                           LINK = LISTHEAD;
                           LISTHEAD = NULL;
                        END;
                     IF MUST_CHECK_LOWBOUND THEN
                        CALL EMIT_BOUND_CHECK(J, MIN, GREATER_EQ);
                     IF MUST_CHECK_HIGHBOUND THEN
                        CALL EMIT_BOUND_CHECK(J, MAX, LESS_EQ);
                     IF VALUE(#TP) ~= 0 THEN
                        DO;
                           CALL EMIT_TRIPLE(SUBTRACT, ID_PTR,
                              FINDCONST(MIN), 3);
                           ID_PTR = LAST_TRIPLE;
                        END;
                     CALL EMIT_TRIPLE(IN, ID_PTR, OPERAND#STK(#OP), 0);
                     #TP = BOOLPTR;
                     #OP = #OP - 1;
                     OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                     IF FX THEN
                        DO;
                           CALL EMIT_TRIPLE(BNZ, LINK, LAST_TRIPLE, 0);
                           IF LISTHEAD ~= NULL THEN
                              DO;
                                 CALL FIXUP(LISTHEAD, N_TRIPLES);
                                 CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 1);
                              END;
                           LISTHEAD = OPERAND#STK(#OP);
                        END;
                     ELSE
                        DO;
                           CALL EMIT_TRIPLE(BZ, LISTHEAD, LAST_TRIPLE, 0);
                           LISTHEAD = N_TRIPLES - 3;
                        END;
                  END;
               /* 39  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '+' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  IF #MP = 2 THEN
                     DO;
                        CALL COERCE_OP;
                        #TP = PARSE_TREE(NODE#STACK(NP) + 2);
                        IF COMPTYPES(#TP, INTPTR) THEN
                           CALL EMIT_TRIPLE(ADD, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 3);
                        ELSE IF COMPTYPES(#TP, REALPTR) THEN
                           CALL EMIT_TRIPLE(ADDFLT, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 3);
                        ELSE IF (STRUCTYPE(#TP) = SET) |
                              (STRUCTYPE(#TP) = PACKED_SET) THEN
                           DO;
                              IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                                 /* DO NOTHING */;
                              ELSE IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN
                                 OPERAND#STK(#OP - 1) = OPERAND#STK(#OP);
                              ELSE
                                 DO;
                                    CALL EMIT_TRIPLE(TEMP,
                                       OPERAND#STK(#OP - 1), 0,
                                       STORAGE_LNGTH(#TP) - 1);
                                    OPERAND#STK(#OP - 1) = LAST_TRIPLE;
                                    CALL EMIT_TRIPLE(OR,
                                       LAST_TRIPLE | MASK_TEMP,
                                       OPERAND#STK(#OP), 0);
                                 END;
                           END;
                        ELSE CALL ERROR('ILLEGAL "+" OPERATOR', 1);
                        #OP = #OP - 1;
                        IF (STRUCTYPE(#TP) ~= SET)
                           & (STRUCTYPE(#TP) ~= PACKED_SET) THEN
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                     END;
               END;
               /* 40  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '-' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  IF #MP = 2 THEN
                     DO;
                        CALL COERCE_OP;
                        #TP = PARSE_TREE(NODE#STACK(NP) + 2);
                        IF COMPTYPES(#TP, INTPTR) THEN
                           CALL EMIT_TRIPLE(SUBTRACT, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 3);
                        ELSE IF COMPTYPES(#TP, REALPTR) THEN
                           CALL EMIT_TRIPLE(SUBFLT, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 3);
                        ELSE IF (STRUCTYPE(#TP) = SET) |
                              (STRUCTYPE(#TP) = PACKED_SET) THEN
                           DO;
                              IF (OPERAND#STK(#OP) ~= EMPTYSETPTR)
                                 & (OPERAND#STK(#OP - 1) ~= EMPTYSETPTR) THEN
                                 DO;
                                    J = OPERAND#STK(#OP - 1);
                                    IF (J & MASK_TRIPLE) ~= 0 THEN
                                       J = J | MASK_TEMP;
                                    CALL EMIT_TRIPLE(TEMP, J, 0,
                                       STORAGE_LNGTH(#TP) - 1);
                                    CALL EMIT_TRIPLE( XOR,
                                       LAST_TRIPLE | MASK_TEMP,
                                       OPERAND#STK(#OP), 0);
                                    CALL EMIT_TRIPLE(AND,
                                       (N_TRIPLES - 6) | MASK_TEMP,
                                       OPERAND#STK(#OP - 1), 0);
                                    OPERAND#STK(#OP - 1) =
                                       (N_TRIPLES - 9) | MASK_TRIPLE;
                                 END;
                           END;
                        ELSE CALL ERROR('ILLEGAL "-" OPERATOR', 1);
                        #OP = #OP - 1;
                        IF (STRUCTYPE(#TP) ~= SET)
                           & (STRUCTYPE(#TP) ~= PACKED_SET) THEN
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                     END;
               END;
               /* 41  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY 'OR' OPERATOR */
            ANDOR:
               IF #MP = 1 THEN
                  DO;
                     IF ~COMPTYPES(#TP, BOOLPTR) THEN CALL ERROR(BOOLTYPE, 1);
                     IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                        FIX_LIST(NP) = LISTHEAD;
                     ELSE
                        DO;
                           CALL EMIT_CONDITIONAL_BRANCH(FATHERS_PROD_NO = 41);
                           FIX_LIST(NP) =
                              SHL(FATHERS_PROD_NO = 41, 15) | (N_TRIPLES - 3);
                        END;
                   FX = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1) + 1);
                     LISTHEAD = NULL;
                     #OP = #OP - 1;
                  END;
               ELSE
                  DO;
                     IF ~COMPTYPES(#TP, BOOLPTR) THEN
                        DO;
                           CALL ERROR(BOOLTYPE, 1);
                           #TP = BOOLPTR;
                        END;
                   FX = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1) + 1);
                     IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                        DO;  /* FIX UP RIGHT OPERAND LIST */
                           IF LISTHEAD ~= NULL THEN
                              IF (LISTHEAD & "8000") ~= (SHL(FX, 15) & "8000")
                                 THEN
                                 DO;
                                    CALL EMIT_TRIPLE(BCH_TARGET, NULL,
                                       NULL, 0);
                                    CALL FIXUP(LISTHEAD, LAST_TRIPLE);
                                    LISTHEAD = NULL;
                                 END;
                        END;
                     ELSE
                        DO;
                           CALL EMIT_CONDITIONAL_BRANCH(FX);
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                           LISTHEAD = (N_TRIPLES - 3) | SHL(FX, 15);
                        END;
                     /* CHECK LEFT OPERAND LIST FOR FIXUP */
                     I = FIX_LIST(NP);
                     IF I ~= NULL THEN
                        DO;
                           IF (I & "8000") ~= (SHL(FX, 15) & "8000") THEN
                              DO;
                                 CALL EMIT_TRIPLE(BCH_TARGET, NULL, NULL, 0);
                                 CALL FIXUP(I, LAST_TRIPLE);
                              END;
                           ELSE IF LISTHEAD = NULL THEN LISTHEAD = I;
                           ELSE
                              DO;  /* LINK LEFT AND RIGHT FIXUP LISTS */
                                 I = I & "3FFF";
                                 DO WHILE TRIPLES(I + 1) ~= NULL;
                                    I = TRIPLES(I + 1) & "3FFF";
                                 END;
                                 TRIPLES(I + 1) = LISTHEAD;
                                 LISTHEAD = FIX_LIST(NP);
                              END;
                        END;
                  END;
               /* 42  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '*' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  IF #MP = 2 THEN
                     DO;
                        CALL COERCE_OP;
                        #TP = PARSE_TREE(NODE#STACK(NP) + 2);
                        IF COMPTYPES(#TP, INTPTR) THEN
                           CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 3);
                        ELSE IF COMPTYPES(#TP, REALPTR) THEN
                           CALL EMIT_TRIPLE(MPYFLT, OPERAND#STK(#OP - 1),
                              OPERAND#STK(#OP), 3);
                        ELSE IF (STRUCTYPE(#TP) = SET) |
                              (STRUCTYPE(#TP) = PACKED_SET) THEN
                           DO;
                              IF OPERAND#STK(#OP - 1) = EMPTYSETPTR THEN
                                 /* DO NOTHING */;
                              ELSE IF OPERAND#STK(#OP) = EMPTYSETPTR THEN
                                 DO;
                                    IF (OPERAND#STK(#OP - 1) & MASK_TRIPLE)
                                       ~= 0 THEN
                                       CALL EMIT_TRIPLE(TPOP,
                                          OPERAND#STK(#OP - 1), NULL, 0);
                                    OPERAND#STK(#OP - 1) = EMPTYSETPTR;
                                 END;
                              ELSE
                                 DO;
                                    CALL EMIT_TRIPLE(TEMP,
                                       OPERAND#STK(#OP - 1), 0,
                                       STORAGE_LNGTH(#TP) - 1);
                                    OPERAND#STK(#OP - 1) = LAST_TRIPLE;
                                    CALL EMIT_TRIPLE(AND,
                                       LAST_TRIPLE | MASK_TEMP,
                                       OPERAND#STK(#OP), 0);
                                 END;
                           END;
                        ELSE CALL ERROR('ILLEGAL "*" OPERATOR', 1);
                        #OP = #OP - 1;
                        IF (STRUCTYPE(#TP) ~= SET)
                           & (STRUCTYPE(#TP) ~= PACKED_SET) THEN
                           OPERAND#STK(#OP) = LAST_TRIPLE;
                     END;
               END;
               /* 43  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY '/' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  CALL COERCE_ASSIGNMENT(REALPTR, #TP);
                  IF #MP = 2 THEN
                     DO;
                        CALL EMIT_TRIPLE(DIVFLT, OPERAND#STK(#OP - 1),
                           OPERAND#STK(#OP), 3);
                        #OP = #OP - 1;
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        #TP = REALPTR;
                     END;
               END;
               /* 44  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY 'DIV' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                  IF #MP = 2 THEN
                     DO;
                        CALL EMIT_TRIPLE(DIVIDE, OPERAND#STK(#OP - 1),
                           OPERAND#STK(#OP), 3);
                        #OP = #OP - 1;
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        #TP = INTPTR;
                     END;
               END;
               /* 45  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY 'MOD' OPERATOR */
               DO;
                  CALL REPLACE(#TP);
                  CALL COERCE_ASSIGNMENT(INTPTR, #TP);
                  IF #MP = 2 THEN
                     DO;
                        CALL EMIT_TRIPLE(REM, OPERAND#STK(#OP - 1),
                           OPERAND#STK(#OP), 3);
                        #OP = #OP - 1;
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        #TP = INTPTR;
                     END;
               END;
               /* 46  <EXPRESSION> ::= <EXPRESSION> <EXPRESSION> */
               /* BINARY 'AND' OPERATOR */
               GOTO ANDOR;
               /* 47  <EXPRESSION> ::= <IDENTIFIER> (<EXPRESSION>)* */
               /* FUNCTION PROCEDURE */
               DO;
                  IF ~((FATHERS_MULTIPLICITY = 1) & PARAMLIST) THEN
                     CALL PROCFUNC(FALSE);
                  IF #MP = FATHERS_MULTIPLICITY THEN
                   FX = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1) + 1);
               END;
               /* 48  <EXPRESSION> ::= (<ELEMENT>)+ */
               /* SET EXPRESSION */
            SET_ELEMENT:
               DO;
                  CALL REPLACE(#TP);
                  IF #TP = BOOLPTR THEN
                     IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                        CALL COND_TO_REGISTER;
                  TABLE_PTR = OPERAND#STK(#OP);
                  ID_PTR = FIX_LIST(NP);
                  ERROR_FLAG = FALSE;
                  I = PARSE_TREE(NODE + 1);
                  J = FATHERS_PROD_NO;
                  IF #MP = 1 THEN
                     IF ((J = 76) & (#POS_STACK(NP - 1) = 1)) | (I = 75) THEN
                        DO;   /* FORM AN INITIAL TYPING OF THE SET */
                           DATATYPE(ID_PTR) = DATATYPE(#TP);
                           IF COMPTYPES(DATATYPE(#TP), REALPTR) THEN
                              DO;
                                 CALL ERROR('SET ELEMENT OF TYPE REAL', 1);
                                 ERROR_FLAG = TRUE;
                              END;
                           IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) = 1;
                                 VALUE(ID_PTR) = SHR(TABLE_PTR & "3FFF", 3);
                              END;
                           ELSE IF ((TABLE_PTR & "C000") = MASK_SYMBOL)
                                 & (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) = 1;
                                 I = VALUE(TABLE_PTR) / 8;
                                 VALUE(ID_PTR) = I;
                              END;
                           ELSE IF STRUCTYPE(#TP) = SCALAR THEN
                              DO;
                                 STORAGE_LNGTH(ID_PTR) =
                                    SHR(STORAGE_LNGTH(DATATYPE(#TP)), 3) + 1;
                                 VALUE(ID_PTR) = 0;
                              END;
                           ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN
                              DO;
                                 I = VALUE(S_LIST(#TP)) / 8;
                                 VALUE(ID_PTR) = I;
                                 SL = VALUE(#TP) & "FFFFFFF8";
                                 SL = (SL / 8) - I + 1;
                                 STORAGE_LNGTH(ID_PTR) = SL;
                              END;
                           ELSE
                              DO;
                                 CALL ERROR(
                           'UNABLE TO DETERMINE DATATYPE OF SET EXPRESSION', 1);
                                 ERROR_FLAG = TRUE;
                              END;
                        END;
                  IF (SHL(1, STRUCTYPE(#TP)) & "(1)10000 00000 00110") = 0
                     /* ~(STRUCTYPE(#TP) IN (.SCALAR, SUBRANGE, ARITHMETIC.))
                        */ THEN
                     DO;
                        CALL ERROR('ILLEGAL SET ELEMENT', 1);
                        ERROR_FLAG = TRUE;
                     END;
                  IF ~ERROR_FLAG THEN
                     IF ~COMPTYPES(DATATYPE(ID_PTR), DATATYPE(#TP)) THEN
                        DO;
                           CALL ERROR('INCOMPATIBLE SET ELEMENTS', 1);
                           ERROR_FLAG = TRUE;
                        END;
                  /* UPDATE SET TYPE ESTIMATE */
                  MIN = SHL(VALUE(ID_PTR), 3);
                  MAX = MIN + SHL(STORAGE_LNGTH(ID_PTR), 3) - 1;
                  IF (TABLE_PTR & "C000") = MASK_IMMEDIATE THEN
                     DO;
                        J = TABLE_PTR & "3FFF";
                        IF J < MIN THEN MIN = J & "FFF8";
                        IF J > MAX THEN MAX = (J & "FFF8") + 7;
                     END;
                  ELSE IF ((TABLE_PTR & "C000") = MASK_SYMBOL) &
                        (VAR_TYPE(TABLE_PTR) = CONSTANT) THEN
                     DO;
                        J = VALUE(TABLE_PTR);
                        IF J < MIN THEN MIN = J & "FFFFFFF8";
                        IF J > MAX THEN MAX = (J & "FFFFFFF8") + 7;
                     END;
                  ELSE IF STRUCTYPE(#TP) = SCALAR THEN
                     DO;
                        MIN = 0;
                        MAX = (STORAGE_LNGTH(DATATYPE(#TP)) & "FFFFFFF8") + 7;
                     END;
                  ELSE IF STRUCTYPE(#TP) = SUBRANGE THEN
                     DO;
                        J = VALUE(S_LIST(#TP));
                        IF J < MIN THEN MIN = J & "FFFFFFF8";
                        IF VALUE(#TP) > MAX THEN
                           MAX = (VALUE(#TP) & "FFFFFFF8") + 7;
                     END;
                  ELSE IF ~ERROR_FLAG THEN
                     DO;
                        CALL ERROR(
                           'UNABLE TO DETERMINE DATATYPE OF SET EXPRESSION', 1);
                        ERROR_FLAG = TRUE;
                     END;
                  I = MIN / 8;
                  VALUE(ID_PTR) = I;
                  STORAGE_LNGTH(ID_PTR) = SHR(MAX - MIN, 3) + 1;
                  IF STORAGE_LNGTH(ID_PTR) > 256 THEN
                     DO;
                        CALL ERROR(SUBRANGE_SIZE, 1);
                        ERROR_FLAG = TRUE;
                     END;
                  IF PARSE_TREE(NODE + 1) = 76 THEN
                     DO;
                        CALL REPLACE(NODE);
                        IF #OP < #OPMAX THEN #OP = #OP + 1;
                        ELSE
                           DO;
                              CALL ERROR(OP#STACK#ERR, 1);
                              RETURN;
                           END;
                        OPERAND#STK(#OP) = NULL;
                     END;
                  IF ERROR_FLAG THEN
                     DO;
                        IF FATHERS_PROD_NO = 76 THEN
                           DO;
                              CALL FATHER;
                              #MP = #POS_STACK(NP);
                           END;
                        DO I = 1 TO #MP;
                           IF OPERAND#STK(#OP) = NULL THEN #OP = #OP - 3;
                           ELSE #OP = #OP - 1;
                        END;
                        #OP = #OP + 1;
                        #TP, OPERAND#STK(#OP) = EMPTYSETPTR;
                        #POS_STACK(NP) = FATHERS_MULTIPLICITY;
                     END;
                  ELSE IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        CALL EMIT_TRIPLE(TEMP, NULL, 0,
                           STORAGE_LNGTH(ID_PTR) - 1);
                        FIX_LIST(NP) = LAST_TRIPLE;
                        J = FIX_LIST(NP) | MASK_TEMP;
                        CALL EMIT_TRIPLE( XOR, J, J, 0);
                        DO I = 1 TO #MP;
                           IF OPERAND#STK(#OP) = NULL THEN
                              DO;  /* A RANGE-TYPE SET ELEMENT */
                                 #OP = #OP - 1;
                                 J = PARSE_TREE(NODE#STACK(NP) + #MP - I + 2);
                                 /* J POINTS TO 76-NODE */
                                 CALL COERCE_SET_ELEMENT(PARSE_TREE(J + 3),
                                    MIN);
                                 #OP = #OP - 1;
                                 CALL COERCE_SET_ELEMENT(PARSE_TREE(J + 2),
                                    MIN);
                                 CALL EMIT_TRIPLE(RANGE, OPERAND#STK(#OP),
                                    OPERAND#STK(#OP + 1),
                                    STORAGE_LNGTH(ID_PTR) - 1);
                                 OPERAND#STK(#OP) = LAST_TRIPLE;
                              END;
                           ELSE
                              CALL COERCE_SET_ELEMENT(
                                 PARSE_TREE(NODE#STACK(NP) + #MP - I + 2), MIN);
                           J = FIX_LIST(NP) | MASK_TEMP;
                           CALL EMIT_TRIPLE(INTO, OPERAND#STK(#OP), J, 0);
                           IF I < #MP THEN #OP = #OP - 1;
                           ELSE OPERAND#STK(#OP) = FIX_LIST(NP);
                        END;
                        #TP = ID_PTR;
                     END;
               END;
               /* 49  <EXPRESSION> ::= <VARIABLE> */
               CALL REPLACE(#TP);
               /* 50  <EXPRESSION> ::= <UNSIGNED CONSTANT> */
               DO;
                  PARAMLIST = FALSE;
                  IF VAR_TYPE(TABLE_PTR) = LITERAL THEN
                     DO;   /* A STRING CONSTANT */
                        #TP = TABLE_PTR;
                        CALL REPLACE(#TP);
                     END;
                  ELSE IF (#TP = INTPTR) | (#TP = CHARPTR) THEN
                     OPERAND#STK(#OP) = FINDCONST(VALUE(TABLE_PTR));
               END;
               /* 51  <VARIABLE> ::= <ID> (<QUALIFIER>)* */
               IF #MP = 1 THEN
                  DO;
                     I = VAR_TYPE(TABLE_PTR);
                     IF I = VAR_PARAM THEN
                        DO;
                           IF ~PARAMLIST | (FATHERS_MULTIPLICITY > 1) THEN
                              DO;
                                 IF (STRUCTYPE(TABLE_PTR) = SCALAR) |
                                    (STRUCTYPE(TABLE_PTR) = SUBRANGE) THEN
                                    I = 1;
                                 ELSE I = STORAGE_LNGTH(DATATYPE(TABLE_PTR))
                                       - 1;
                                 CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,
                                    OPERAND#STK(#OP), I);
                                 OPERAND#STK(#OP) = LAST_TRIPLE;
                                 I = I + 1;
                                 IF I > 256 THEN
                                    IF FATHERS_MULTIPLICITY = 1 THEN
                                       CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),
                                          I, 0);
                              END;
                        END;
                     ELSE IF (I = FIELD_ID) | (I = VARIANT) THEN
                        DO;
                           ID_PTR = OWNER(TABLE_PTR);
                           DO WHILE VAR_TYPE(S_LIST(ID_PTR)) = VARIANT;
                              ID_PTR = OWNER(ID_PTR);
                           END;
                           I = WITH_PTR;
                           DO WHILE (I ~= NULL) & (WITH_DATATYPE(I) ~= ID_PTR);
                              I = I - 1;
                           END;
                           IF I ~= NULL THEN
                              DO;
                                 CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,
                                    WITH_VARIABLE(I), 0);
                                 I = STORAGE_LNGTH(TABLE_PTR);
                                 OPERAND#STK(#OP) = N_TRIPLES | MASK_TRIPLE;
                                 CALL EMIT_TRIPLE(INDEX, LAST_TRIPLE,
                                    FINDCONST(DISPLACEMENT(TABLE_PTR)), I - 1);
                                 IF I > 256 THEN
                                    IF FATHERS_MULTIPLICITY = 1 THEN
                                       CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),
                                          I, 0);
                              END;
                           ELSE CALL ERROR('FIELD IDENTIFIER '
                                 || IDENTITY(TABLE_PTR)
                                 || ' MUST BE PRECEDED BY A RECORD NAME', 1);
                        END;
                     ELSE IF (I = PROC) | (I = MULTDECL) |
                           (I = PROC_PARAM) THEN
                        DO;
                           IF LHS THEN
                              DO;
                                 IF (DATATYPE(TABLE_PTR) = NULL) |
                                    (TABLE_PTR ~= OWNER_STACK(CURRENT_LEVEL))
                                    THEN CALL ERROR(
                                     'ILLEGAL ASSIGNMENT TO PROCEDURE/FUNCTION '
                                       || IDENTITY(TABLE_PTR), 1);
                              END;
                           ELSE IF ~PARAMLIST THEN
                              CALL PROCFUNC(FALSE);
                        END;
                     ELSE IF I = CONSTANT THEN
                        DO;
                           IF LHS THEN CALL ERROR('CONSTANT IDENTIFIER '
                                 || IDENTITY(TABLE_PTR)
                                 || ' MAY NOT BE ASSIGNED TO', 1);
                           ELSE IF STRUCTYPE(TABLE_PTR) = ARRAY THEN
                              DO;   /* A STRING CONSTANT */
                                 #TP = TABLE_PTR;
                                 CALL REPLACE(#TP);
                              END;
                           ELSE IF ~COMPTYPES(#TP, REALPTR) THEN
                              OPERAND#STK(#OP) = FINDCONST(VALUE(TABLE_PTR));
                        END;
                     ELSE IF I ~= VARIABLE THEN
                        CALL ERROR('ILLEGAL VARIABLE: '
                           || IDENTITY(TABLE_PTR), 1);
                     LHS, PARAMLIST = FALSE;
                  END;  /* #MP = 1 */
               ELSE
                  CALL REPLACE(#TP);
               /* 52  (NOT USED) */
               ;
               /* 53  <QUALIFIER> ::= (<EXPRESSION>)+ */
               /* SUBSCRIPT LIST */
               DO;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     FX = PARSE_TREE(NODE#STACK(NP - 1) +
                        #POS_STACK(NP - 1) + 1);
                  IF #MP = 1 THEN ID_PTR =
                        PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));
                  ELSE ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                  IF STRUCTYPE(ID_PTR) ~= ARRAY THEN
                     CALL ERROR('ILLEGAL SUBSCRIPT', 1);
                  ELSE
                     DO;
                        IF #TP = BOOLPTR THEN
                           IF IS_CONDITION(OPERAND#STK(#OP)) THEN
                              CALL COND_TO_REGISTER;
                        CALL COERCE_ASSIGNMENT(S_LIST(ID_PTR), #TP);
                        I = STORAGE_LNGTH(ID_PTR)
                           / STORAGE_LNGTH(S_LIST(ID_PTR));
                        /* I IS ARRAY ELEMENT SIZE */
                        IF (OPERAND#STK(#OP) & "C000") = MASK_IMMEDIATE THEN
                           OPERAND#STK(#OP) =
                              FINDCONST(I * (OPERAND#STK(#OP) & "3FFF"));
                        ELSE IF ((OPERAND#STK(#OP) & "C000") = MASK_SYMBOL) &
                              (VAR_TYPE(OPERAND#STK(#OP)) = CONSTANT) THEN
                           OPERAND#STK(#OP) =
                              FINDCONST(VALUE(OPERAND#STK(#OP)) * I);
                        ELSE IF I ~= 1 THEN
                           DO;
                              CALL EMIT_TRIPLE(MULTIPLY, OPERAND#STK(#OP),
                                 FINDCONST(I), 3);
                              OPERAND#STK(#OP) = LAST_TRIPLE;
                           END;
                        CALL EMIT_TRIPLE(INDEX, OPERAND#STK(#OP - 1),
                           OPERAND#STK(#OP), I - 1);
                        #OP = #OP - 1;
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        IF I > 256 THEN
                           IF (#MP = FATHERS_MULTIPLICITY) &
                              (#POS_STACK(NP - 1) =
                              MULTIPLICITY(NODE#STACK(NP - 1))) THEN
                              CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);
                        #TP = DATATYPE(ID_PTR);
                        CALL REPLACE(#TP);
                     END;
               END;
               /* 54  <QUALIFIER> ::= <EMPTY> */
               /* ARROW (@) */
               DO;
                  #TP = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));
                  IF (STRUCTYPE(#TP) = FILE) | (STRUCTYPE(#TP) = PACKED_FILE)
                     THEN #TP = DATATYPE(#TP);
                  ELSE IF STRUCTYPE(#TP) = POINTER THEN
                     DO;
                        ID_PTR = DATATYPE(#TP);
                        IF (STRUCTYPE(ID_PTR) = SCALAR) |
                           (STRUCTYPE(ID_PTR) = SUBRANGE) THEN
                           I = 1;
                        ELSE I = STORAGE_LNGTH(ID_PTR) - 1;
                        CALL EMIT_TRIPLE(INDEX, 0 | MASK_IMMEDIATE,
                           OPERAND#STK(#OP), I);
                        OPERAND#STK(#OP) = LAST_TRIPLE;
                        I = I + 1;
                        IF I > 256 THEN
                           IF #POS_STACK(NP - 1) =
                              MULTIPLICITY(NODE#STACK(NP - 1)) THEN
                              CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16), I, 0);
                        #TP = DATATYPE(#TP);
                     END;
                  ELSE CALL ERROR(
                        'TYPE OF VARIABLE MUST BE FILE OR POINTER', 1);
               END;
               /* 55  <QUALIFIER> ::= <ID> */
               /* FIELD IDENTIFIER */
               IF (VAR_TYPE(TABLE_PTR) = FIELD_ID) |
                  (VAR_TYPE(TABLE_PTR) = VARIANT) THEN
                  DO;
                     #TP =
                        PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1));
                     #OP = #OP - 1;
                     IF (STRUCTYPE(#TP) = RECORD) |
                        (STRUCTYPE(#TP) = PACKED_RECORD) THEN
                        DO;
                           ID_PTR = OWNER(TABLE_PTR);
                           DO WHILE VAR_TYPE(S_LIST(ID_PTR)) = VARIANT;
                              ID_PTR = OWNER(ID_PTR);
                           END;
                           IF ID_PTR ~= #TP THEN
                              CALL ERROR(IDENTITY(TABLE_PTR)
                                 || ' IS NOT A FIELD IN THIS RECORD', 1);
                           ELSE
                              DO;
                                 CALL EMIT_TRIPLE(INDEX, OPERAND#STK(#OP),
                                    FINDCONST(DISPLACEMENT(TABLE_PTR)),
                                    STORAGE_LNGTH(TABLE_PTR) - 1);
                                 OPERAND#STK(#OP) = LAST_TRIPLE;
                                 I = STORAGE_LNGTH(TABLE_PTR);
                                 IF I > 256 THEN
                                    IF #POS_STACK(NP - 1) =
                                       MULTIPLICITY(NODE#STACK(NP - 1))
                                       THEN
                                       CALL EMIT_TRIPLE(S_LENGTH, SHR(I, 16),
                                          I, 0);
                                 #TP = DATATYPE(TABLE_PTR);
                                 CALL REPLACE(#TP);
                              END;
                        END;
                     ELSE CALL ERROR('TYPE OF VARIABLE IS NOT RECORD', 1);
                  END;
               ELSE
                  DO;
                     CALL ERROR(IDENTITY(TABLE_PTR)
                        || ' IS NOT A FIELD IDENTIFIER', 1);
                     #OP = #OP - 1;
                  END;
               /* 56  (NOT USED) */
               ;
               /* 57  <CONSTANT> ::= <UNSIGNED CONSTANT> */
               /* + CONSTANT */
               ;
               /* 58  <CONSTANT> ::= <UNSIGNED CONSTANT> */
               /* - CONSTANT */
               IF (VAR_TYPE(TABLE_PTR) = CONSTANT) &
                  (STRUCTYPE(TABLE_PTR) = ARITHMETIC) THEN
                  DO;
                     I = VALUE(TABLE_PTR);
                     IF COMPTYPES(DATATYPE(TABLE_PTR), REALPTR) THEN
                        DO;
                           IF I < 0 THEN I = I & "7FFFFFFF";
                           ELSE I = I | "80000000";
                           TABLE_PTR = FINDREAL(I);
                        END;
                     ELSE TABLE_PTR = FINDCONST(-I);
                     IF IS_DECLARATION THEN
                        CALL REPLACE(TABLE_PTR);
                     ELSE
                        DO;
                           OPERAND#STK(#OP) = TABLE_PTR;
                           CALL REPLACE(#TP);
                        END;
                  END;
               ELSE CALL ERROR('ILLEGAL CONSTANT: -'
                     || IDENTITY(TABLE_PTR), 1);
               /* 59  <TYPE> ::= <IDENTIFIER> */
               /* SIMPLE TYPE IDENTIFIER */
               ALLOCATE_NEW_ROW = TRUE;
               /* 60  <TYPE> ::= (<ID>)+ */
               /* SCALAR TYPE */
               DO;
                  IF #MP = 1 THEN
                     DO;
                        IF ALLOCATE_NEW_ROW THEN
                           DO;
                              ID_PTR = NEXT_FREE_ROW;
                              VAR_TYPE(ID_PTR) = TYPE;
                              OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                           END;
                        ELSE
                           DO;
                              ID_PTR = TP_ID_PTR;
                              ALLOCATE_NEW_ROW = TRUE;
                           END;
                        STRUCTYPE(ID_PTR) = SCALAR;
                        DATATYPE(ID_PTR) = ID_PTR;
                        S_LIST(ID_PTR) = TABLE_PTR;
                        STORAGE_LNGTH(ID_PTR) = FATHERS_MULTIPLICITY;
                     END;
                  ELSE S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) = TABLE_PTR;
                  VAR_TYPE(TABLE_PTR) = CONSTANT;
                  STRUCTYPE(TABLE_PTR) = SCALAR;
                  OWNER(TABLE_PTR) = OWNER(ID_PTR);
                  VALUE(TABLE_PTR) = #MP - 1;
                  TABLE_PTR, DATATYPE(TABLE_PTR) = ID_PTR;
               END;
               /* 61  <TYPE> ::= <CONSTANT> <CONSTANT> */
               /* SUBRANGE TYPE */
               IF #MP = 1 THEN DO;
                     IF ALLOCATE_NEW_ROW THEN
                        ID_PTR = NEXT_FREE_ROW;
                     ELSE DO;
                           ID_PTR = TP_ID_PTR;
                           ALLOCATE_NEW_ROW = TRUE;
                        END;
                     CALL REPLACE(ID_PTR);
                     IF VAR_TYPE(TABLE_PTR) ~= CONSTANT THEN
                      CALL ERROR('LOWBOUND OF SUBRANGE TYPE MUST BE A CONSTANT',
                           1);
                     I, DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                     IF (I ~= INTPTR) THEN
                        IF STRUCTYPE(I) ~= SCALAR THEN CALL ERROR(
                           'A SUBRANGE MUST BE OF A SCALAR TYPE OR OF INTEGERS',
                              1);
                     VAR_TYPE(ID_PTR) = TYPE;
                     STRUCTYPE(ID_PTR) = SUBRANGE;
                     OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     S_LIST(ID_PTR) = TABLE_PTR;
                  END;
               ELSE DO;
                     IF VAR_TYPE(TABLE_PTR) ~= CONSTANT THEN
                     CALL ERROR('HIGHBOUND OF SUBRANGE TYPE MUST BE A CONSTANT',
                           1);
                     ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                     I = VALUE(S_LIST(ID_PTR));  /* GET VALUE(<CONSTANT1>) */
                     IF DATATYPE(ID_PTR) ~= DATATYPE(TABLE_PTR) THEN
                        CALL ERROR('TYPES OF SUBRANGE BOUNDS DISAGREE', 1);
                     ELSE IF I > VALUE(TABLE_PTR) THEN CALL ERROR(
                           'LOWER BOUND OF SUBRANGE EXCEEDS UPPER BOUND', 1);
                     VALUE(ID_PTR) = VALUE(TABLE_PTR);
                     IF I <= 0 THEN DO;
                           IF I + MAXINT > VALUE(TABLE_PTR) THEN
                              SL = VALUE(TABLE_PTR) - I + 1;
                           ELSE
                              DO;
                              CALL ERROR('CARDINALITY OF SUBRANGE > MAXINT', 0);
                                 SL = MAXINT;
                              END;
                        END;
                     ELSE SL = VALUE(TABLE_PTR) - I + 1;
                     STORAGE_LNGTH(ID_PTR) = SL;
                     TABLE_PTR = ID_PTR;
                  END;
               /* 62  <TYPE> ::= <ID> */
               /* POINTER TYPE */
               DO;
                  IF ALLOCATE_NEW_ROW THEN ID_PTR = NEXT_FREE_ROW;
                  ELSE
                     DO;
                        ID_PTR = TP_ID_PTR;
                        ALLOCATE_NEW_ROW = TRUE;
                     END;
                  DATATYPE(ID_PTR) = TABLE_PTR;
                  VAR_TYPE(ID_PTR) = TYPE;
                  STORAGE_LNGTH(ID_PTR) = 4;
                  STRUCTYPE(ID_PTR) = POINTER;
                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  TABLE_PTR = ID_PTR;
               END;
               /* 63  <TYPE> ::= (<TYPE>)+ <TYPE> */
               /* ARRAY TYPE */
            ARRAYTYP:
               IF #MP < FATHERS_MULTIPLICITY THEN DO;
                     IF ALLOCATE_ARRAY_ENTRY THEN
                        ID_PTR = NEXT_FREE_ROW;
                     ELSE DO;
                           ID_PTR = TP_ID_PTR;
                           ALLOCATE_ARRAY_ENTRY = TRUE;
                        END;
                     CALL REPLACE(ID_PTR);
                     VAR_TYPE(ID_PTR) = TYPE;
                     STRUCTYPE(ID_PTR) = ARRAY;
                     OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     S_LIST(ID_PTR) = TABLE_PTR;
                  END;
               ELSE DO;
                     CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                     #TP = FATHERS_MULTIPLICITY;
                     DO WHILE #TP >= 2;
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #TP);
                        DATATYPE(ID_PTR) = TABLE_PTR;
                        SL, STORAGE_LNGTH(ID_PTR) =
                           STORAGE_LNGTH(S_LIST(ID_PTR)) * SL;
                        TABLE_PTR = ID_PTR;
                        #TP = #TP - 1;
                     END;
                  END;
               /* 64  <TYPE> ::= <TYPE> */
               /* FILE TYPE */
            FILETYP:
               DO;
                  IF ALLOCATE_NEW_ROW THEN
                     ID_PTR = NEXT_FREE_ROW;
                  ELSE DO;
                        ID_PTR = TP_ID_PTR;
                        ALLOCATE_NEW_ROW = TRUE;
                     END;
                  DATATYPE(ID_PTR) = TABLE_PTR;
                  VAR_TYPE(ID_PTR) = TYPE;
                  STRUCTYPE(ID_PTR) = FILE;
                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                  STORAGE_LNGTH(ID_PTR) = SL;
                  TABLE_PTR = ID_PTR;
               END;
               /* 65  <TYPE> ::= <TYPE> */
               /* SET TYPE */
            SETTYP:
               DO;
                  IF ALLOCATE_ARRAY_ENTRY THEN
                     ID_PTR = NEXT_FREE_ROW;
                  ELSE DO;
                        ID_PTR = TP_ID_PTR;
                        ALLOCATE_ARRAY_ENTRY = TRUE;
                     END;
                  DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                  S_LIST(ID_PTR) = TABLE_PTR;
                  VAR_TYPE(ID_PTR) = TYPE;
                  STRUCTYPE(ID_PTR) = SET;
                  OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                  IF STRUCTYPE(TABLE_PTR) = SCALAR THEN
                     DO;
                        STORAGE_LNGTH(ID_PTR) =
                           SHR(STORAGE_LNGTH(TABLE_PTR) + 7, 3);
                        VALUE(ID_PTR) = 0;
                     END;
                  ELSE IF STRUCTYPE(TABLE_PTR) = SUBRANGE THEN
                     DO;
                        I = VALUE(S_LIST(TABLE_PTR)) & "FFFFFFF8";
                        I = I / 8;
                        VALUE(ID_PTR) = I;
                        SL = VALUE(TABLE_PTR) & "FFFFFFF8";
                        SL = (SL / 8) - VALUE(ID_PTR) + 1;
                        STORAGE_LNGTH(ID_PTR) = SL;
                     END;
                  ELSE CALL ERROR(
                    'A SET TYPE MUST BE BASED ON A SCALAR OR SUBRANGE TYPE', 1);
                  IF STORAGE_LNGTH(ID_PTR) > 256 THEN
                     CALL ERROR(SUBRANGE_SIZE, 1);
                  TABLE_PTR = ID_PTR;
               END;
               /* 66  <TYPE> ::= (<FIXED FIELD LIST>)* (<VARIANT FIELD>) */
               /* RECORD TYPE */
            RECORDTYP:
               DO;
                  IF #MP = 1 THEN
                     DO;
                        ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                        S_LIST(ID_PTR) = TABLE_PTR;
                        CALL REPLACE(TABLE_PTR);
                        STORAGE_LNGTH(ID_PTR) = STORAGE_LNGTH(TABLE_PTR);
                     END;
                  ELSE
                     DO;
                        I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                        DO WHILE S_LIST(I) ~= NULL;
                           I = S_LIST(I);
                        END;
                        S_LIST(I) = TABLE_PTR;
                        CALL REPLACE(TABLE_PTR);
                        ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                     END;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        TABLE_PTR = OWNER_STACK(CURRENT_LEVEL);
                        CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                        /* COMPUTE STORAGE_LNGTH FROM ALLOCATED DISPLACEMENT
                              INTO STACK.   */
                        IF VAR_TYPE(OWNER(TABLE_PTR)) = PROC THEN
                           STORAGE_LNGTH(TABLE_PTR) =
                              STACK_LIMIT(CURRENT_LEVEL);
                        ELSE STORAGE_LNGTH(TABLE_PTR) =
                              STACK_LIMIT(CURRENT_LEVEL)
                              - STACK_LIMIT(CURRENT_LEVEL - 1);
                        CURRENT_LEVEL = CURRENT_LEVEL - 1;
                     END;
               END;
               /* 67  <FIXED FIELD LIST> ::= (<ID>)+ <TYPE> */
               IF #MP < FATHERS_MULTIPLICITY THEN
                  DO;
                     I, OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                     IF GREAT_GRANDFATHERS_PROD_NO = 69 THEN
                        VAR_TYPE(TABLE_PTR) = VARIANT;
                     ELSE VAR_TYPE(TABLE_PTR) = FIELD_ID;
                     IF #MP > 1 THEN
                        DO;  /* LINK FIELD VARIABLES */
                           ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                           S_LIST(ID_PTR) = TABLE_PTR;
                        END;
                  END;
               ELSE
                  DO;
                     CALL COMPUTE_STORAGE_LENGTH(TABLE_PTR);
                     I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                     DO WHILE ID_PTR ~= NULL;
                        DATATYPE(ID_PTR) = TABLE_PTR;
                        STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                        CALL ALLOCATE_STORAGE(ID_PTR);
                        PSEUDO_REG(ID_PTR) = NULL;
                        ID_PTR = S_LIST(ID_PTR);
                     END;
                     TABLE_PTR = I;
                  END;
               /* 68  <VARIANT FIELD> ::= <ID> <ID> (<VARIANT INSTANCE>)+ */
               DO;
                  IF #MP = 1 THEN
                     DO;
                        I, OWNER(TABLE_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        IF GREAT_GRANDFATHERS_PROD_NO = 69 THEN
                           VAR_TYPE(TABLE_PTR) = VARIANT;
                        ELSE VAR_TYPE(TABLE_PTR) = FIELD_ID;
                        STRUCTYPE(TABLE_PTR) = TAG;
                        SL = 2;
                        CALL ALLOCATE_STORAGE(TABLE_PTR);
                        CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                        ARRAYS_ALLOCATED(CURRENT_LEVEL) = NULL;
                     END;
                  ELSE IF #MP = 2 THEN
                     DO;
                        IF (VAR_TYPE(TABLE_PTR) ~= TYPE) |
                           (STRUCTYPE(TABLE_PTR) < SCALAR) |
                           (STRUCTYPE(TABLE_PTR) > SUBRANGE)  THEN
                           CALL ERROR('INVALID TAG TYPE IN VARIANT RECORD'
                              , 1);
                        IF (STRUCTYPE(TABLE_PTR) = SUBRANGE)
                           & (STORAGE_LNGTH(TABLE_PTR) > 32768) THEN
                           CALL ERROR('CARDINALITY OF TAGFIELD TYPE > 32768',
                              1);
                        DATATYPE(PARSE_TREE(NODE#STACK(NP) + 2)) = TABLE_PTR;
                     END;
                  ELSE IF #MP = 3 THEN
                     DO;
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                        S_LIST(ID_PTR) = TABLE_PTR;
                        CALL REPLACE(TABLE_PTR);
                        IF TABLE_PTR ~= NULL THEN
                           STORAGE_LNGTH(ID_PTR) =
                              STACK_LIMIT(CURRENT_LEVEL + 1) -
                              STACK_LIMIT(CURRENT_LEVEL);
                     END;
                  ELSE IF TABLE_PTR ~= NULL THEN
                     DO;
                        I, ID_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                        DO WHILE S_LIST(ID_PTR) ~= NULL;
                           ID_PTR = S_LIST(ID_PTR);
                        END;
                        S_LIST(ID_PTR) = TABLE_PTR;
                        CALL REPLACE(TABLE_PTR);
                        ID_PTR = I;  /* POINTS TO TAGFIELD */
                        SL = STACK_LIMIT(CURRENT_LEVEL + 1)
                           - STACK_LIMIT(CURRENT_LEVEL);
                        IF STORAGE_LNGTH(ID_PTR) < SL THEN
                           STORAGE_LNGTH(ID_PTR) = SL;
                     END;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        TABLE_PTR = ID_PTR;  /* POINTS TO TAG */
                        STACK_LIMIT(CURRENT_LEVEL) =
                           STACK_LIMIT(CURRENT_LEVEL)
                           + STORAGE_LNGTH(ID_PTR);
                        STORAGE_LNGTH(ID_PTR) = 2;
                     END;
               END;
               /* 69  <VARIANT INSTANCE> ::= (<CONSTANT>)+ <TYPE>
                         IN WHICH <TYPE> IS ALWAYS A RECORD TYPE -- PROD. 66  */
               DO;
                  IF FATHERS_MULTIPLICITY - #MP > 1 THEN
                     DO;
                        /* CREATE A SYMBOL TABLE ENTRY FOR A CASELABEL */
                        ID_PTR = NEXT_FREE_ROW;
                        DATATYPE(ID_PTR) = DATATYPE(TABLE_PTR);
                        VAR_TYPE(ID_PTR) = CASELABEL;
                        STRUCTYPE(ID_PTR) = SCALAR;
                        OWNER(ID_PTR) = OWNER_STACK(CURRENT_LEVEL);
                        VALUE(ID_PTR) = VALUE(TABLE_PTR);
                        TABLE_PTR = ID_PTR;
                     END;
                  IF #MP < FATHERS_MULTIPLICITY THEN
                     DO;
                        CALL REPLACE(TABLE_PTR);
                        IF #MP > 1 THEN
                           S_LIST(PARSE_TREE(NODE#STACK(NP) + #MP)) =
                              TABLE_PTR;
                        I = DATATYPE(PARSE_TREE(NODE#STACK(NP - 1) + 2));
                        /* POINTER TO THE TAG TYPE */
                        IF DATATYPE(TABLE_PTR) ~= I THEN
                           DO;
                              IF STRUCTYPE(I) = SUBRANGE THEN
                                 DO;
                                    IF DATATYPE(I) ~= DATATYPE(TABLE_PTR)
                                       THEN CALL ERROR(TAG_TYPE, 1);
                                    ELSE
                                    IF (VALUE(TABLE_PTR) > VALUE(I)) |
                                          (VALUE(TABLE_PTR) < VALUE(S_LIST(I)))
                                       THEN CALL ERROR(
            'VALUE OF CASE LABEL IS OUTSIDE SUBRANGE SPECIFIED BY TAG TYPE', 1);
                                 END;
                              ELSE CALL ERROR(TAG_TYPE, 1);
                           END;
                     END;
                  ELSE IF TABLE_PTR ~= NULL THEN
                     DO;
                        ID_PTR = PARSE_TREE(NODE#STACK(NP) + #MP);
                        VALUE(TABLE_PTR) = VALUE(ID_PTR);
                        I = FATHERS_MULTIPLICITY - 1;
                        IF I > 1 THEN
                           DO;
                              S_LIST(PARSE_TREE(NODE#STACK(NP) + I)) =
                                 TABLE_PTR;
                              TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
                           END;
                     END;
               END;
               /* 70  <STATEMENT> ::= <EMPTY> */
               ;
               /* 71  <TYPE> ::= (<TYPE>)+ <TYPE> */
               /* PACKED ARRAY TYPE */
               GOTO ARRAYTYP;
               /* 72  <TYPE> ::= <TYPE> */
               /* PACKED FILE TYPE */
               GOTO FILETYP;
               /* 73  <TYPE> ::= <TYPE> */
               /* PACKED SET TYPE */
               GOTO SETTYP;
               /* 74  <TYPE> ::= (<FIXED FIELD LIST>)* (<VARIANT FIELD>) */
               /* PACKED RECORD TYPE */
               GOTO RECORDTYP;
               /* 75  <ELEMENT> ::= <EXPRESSION> */
               /* SIMPLE SET ELEMENT */
               FX = PARSE_TREE(NODE#STACK(NP - 1) + #POS_STACK(NP - 1) + 1);
               /* 76  <ELEMENT> ::= <EXPRESSION> <EXPRESSION> */
               /* RANGE */
               IF #MP = 1 THEN
                  DO;
                     FIX_LIST(NP) = FIX_LIST(NP - 1);
                     GOTO SET_ELEMENT;
                  END;
               ELSE
                  DO;
                     CALL REPLACE(#TP);
                     FX = PARSE_TREE(NODE#STACK(NP - 1) +
                        #POS_STACK(NP - 1) + 1);
                  END;
               /* 77  <PARAM TYPES> ::= (<TYPE ID>)+ */
               /* LIST OF TYPES OF VALUE PARAMETERS */
            TYPE_LIST:
               DO;
                  I = NEXT_FREE_ROW;
                  DATATYPE(I) = TABLE_PTR;
                  IF VAR_TYPE(TABLE_PTR) ~= TYPE THEN
                     CALL ERROR(IDENTITY(TABLE_PTR) || IS_NOT_A_TYPE, 1);
                  STRUCTYPE(I) = STRUCTYPE(TABLE_PTR);
                  OWNER(I) = OWNER_STACK(CURRENT_LEVEL);
                  PSEUDO_REG(I), S_LIST(I) = NULL;
                  IF FATHERS_PROD_NO = 77 THEN
                     DO;  /* FORMAL VALUE PARAMETERS */
                        VAR_TYPE(I) = VARIABLE;
                        CALL COMPUTE_STORAGE_LENGTH(I);
                        CALL ALLOCATE_STORAGE(I);
                     END;
                  ELSE   /* FORMAL VAR PARAMETER */
                     DO;
                        VAR_TYPE(I) = VAR_PARAM;
                        STORAGE_LNGTH(I) = 4;
                        DISPLACEMENT(I) = STACK_LIMIT(CURRENT_LEVEL);
                        STACK_LIMIT(CURRENT_LEVEL) =
                           STACK_LIMIT(CURRENT_LEVEL) + 4;
                     END;
                  IF #MP > 1 THEN
                     DO;  /* LINK FORMAL PARAMETER TYPES TOGETHER */
                        J = PARSE_TREE(NODE#STACK(NP) + #MP);
                        S_LIST(J) = I;
                     END;
                  CALL REPLACE(I);
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     TABLE_PTR = PARSE_TREE(NODE#STACK(NP) + 2);
               END;
               /* 78  <PARAM TYPES> ::= (<TYPE ID>)+ */
               /* LIST OF TYPES OF VAR PARAMETERS */
               GOTO TYPE_LIST;
               /* 79  <PARAM TYPES> ::= (<PARAM TYPES>)+ (<TYPE ID>) */
               /* PROCEDURE OR FUNCTION TYPES */
               DO;
                  CALL REPLACE(TABLE_PTR);
                  IF #MP > 1 THEN
                     DO;   /* LINK FORMAL PARAM LISTS TOGETHER */
                        LINK = PARSE_TREE(NODE#STACK(NP) + #MP);
                        IF LINK ~= NULL THEN
                           DO;
                              DO WHILE S_LIST(LINK) ~= NULL;
                                 LINK = S_LIST(LINK);
                              END;
                              S_LIST(LINK) = TABLE_PTR;
                           END;
                     END;
                  IF #MP = FATHERS_MULTIPLICITY THEN
                     DO;
                        ID_PTR = OWNER_STACK(CURRENT_LEVEL);
                        IF IS_LEAF THEN
                           DO;  /* A FUNCTION-TYPE PARAMETER */
                              IF LINK ~= NULL THEN S_LIST(LINK) = NULL;
                              DATATYPE(ID_PTR) = TABLE_PTR;
                              STRUCTYPE(ID_PTR) = STRUCTYPE(TABLE_PTR);
                              IF VAR_TYPE(TABLE_PTR) ~= TYPE THEN
                                 CALL ERROR(IDENTITY(TABLE_PTR)
                                    || IS_NOT_A_TYPE, 1);
                           END;
                        CALL ALLOCATE_ARRAY_STORAGE(CURRENT_LEVEL);
                        VALUE(ID_PTR) = PARSE_TREE(NODE#STACK(NP) + 2);
                        CURRENT_LEVEL = CURRENT_LEVEL - 1;
                        TABLE_PTR = ID_PTR;
                     END;
               END;
               /* 80  <PARAM TYPES> ::= <EMPTY> */
               TABLE_PTR = NULL;
               /* 81  <ERROR> ::= <EMPTY> */
               ;
            END;   /* CASE */
            IF #POS_STACK(NP) = MULTIPLICITY(NODE#STACK(NP)) THEN
               CALL FATHER;
            ELSE
               DO;
                  CALL RIGHT_BRO;
                  FIRST_VISIT = TRUE;
               END;
         END;
   END;
END VISIT_NODES;

   /*             PROCEDURES FOR RESTORING SYMBOL TABLE               */

NEXT_SYMBOL:
PROCEDURE CHARACTER;
   /*         $P ----- DISABLES XREF PROGRAM         */
   DECLARE (CP, S1, S2, TEXT_LIMIT) FIXED, (BCD, CHAR) CHARACTER;
   DECLARE FP FIXED;
   IF LENGTH(SY_TEXT) < 3 THEN
      DO;
         CHAR = INPUT(3);
         SY_TEXT = SY_TEXT || CHAR;
      END;
   BCD = '';
   S1 = BYTE(X1);
   S2 = BYTE(SY_TEXT, 1);
   CP, FP = 1;   /* CP POINTS TO CURRENT CHARACTER,
                    FP POINTS TO FIRST CHARACTER */
   TEXT_LIMIT = LENGTH(SY_TEXT) - 1;
   DO WHILE ~(S1 = BYTE('''') & S2 = BYTE(X1));
      IF (S1 = BYTE('''')) & (S2 = S1) THEN
         DO;
            BCD = BCD || SUBSTR(SY_TEXT, FP, CP - FP);
            S2 = BYTE(' ');
            FP = CP + 1;
         END;
      S1 = S2;
      CP = CP + 1;
      IF CP > TEXT_LIMIT THEN
         DO;
            IF CP > FP THEN BCD = BCD || SUBSTR(SY_TEXT, FP);
            SY_TEXT = INPUT(3);
            TEXT_LIMIT = LENGTH(SY_TEXT) - 1;
            CP, FP = 0;
         END;
      S2 = BYTE(SY_TEXT, CP);
   END;
   IF CP > FP THEN BCD = BCD || SUBSTR(SY_TEXT, FP, CP - FP);
   BCD = SUBSTR(BCD, 0, LENGTH(BCD) - 1);
   IF CP = TEXT_LIMIT THEN
      DO;
         CHAR = INPUT(3);
         SY_TEXT = SY_TEXT || CHAR;
      END;
   SY_TEXT = SUBSTR(SY_TEXT, CP + 1);
   RETURN BCD;
END NEXT_SYMBOL;

RESTORE_COLUMN:
PROCEDURE(ARRAY_ADDR, BYTES_PER_ITEM, LIMIT);
   DECLARE ARRAY_ADDR FIXED,
      (BYTES_PER_ITEM, LIMIT) BIT(16);
   DECLARE (INCREMENT, I, J, K) FIXED;
   DECLARE MVC(3) BIT(16) INITIAL("D200", "2000", "1000");
   INCREMENT = 80 / BYTES_PER_ITEM;
   J = ARRAY_ADDR + (N_PREDECLARED_SYMB + 1) * BYTES_PER_ITEM;
   I = N_PREDECLARED_SYMB + 1;
   DO WHILE I + INCREMENT < LIMIT;
      CALL INLINE("58", 1, 0, SY_TEXT);          /* L    1,SY_TEXT         */
      CALL INLINE("58", 2, 0, J);                /* L    2,J               */
      CALL INLINE("D2", "4", "F", 2, 0, 1, 0);   /* MVC  0(80,2),0(1)      */
      I = I + INCREMENT;
      J = J + 80;
      SY_TEXT = INPUT(3);
   END;
   K = (LIMIT - I) * BYTES_PER_ITEM - 1;
   CALL INLINE("58", 1, 0, SY_TEXT);             /* L    1,SY_TEXT         */
   CALL INLINE("58", 2, 0, J);                   /* L    2,J               */
   CALL INLINE("58", 3, 0, K);                   /* L    3,K               */
   CALL INLINE("44", 3, 0, MVC);                 /* EX   3,MVC             */
   SY_TEXT = INPUT(3);
END RESTORE_COLUMN;

RESTORE_SY_TABLE:
PROCEDURE;
   DECLARE I FIXED;
   DECLARE S CHARACTER;
   N_DECL_SYMB, N_ANONYMOUS_SYMB = 0;
   SY_TEXT = INPUT(3);
   IF SUBSTR(SY_TEXT, 0, 5) ~= '%SYMB' THEN
      DO;
         OUTPUT = '%SYMB CARD EXPECTED.';
         CALL EXIT;
      END;
   DO I = 5 TO 9;
      IF BYTE(SY_TEXT, I) ~= BYTE(' ') THEN
         N_DECL_SYMB = 10 * N_DECL_SYMB + BYTE(SY_TEXT, I) - BYTE('0');
   END;
   DO I = 10 TO 14;
      IF BYTE(SY_TEXT, I) ~= BYTE(' ') THEN
         N_ANONYMOUS_SYMB = 10 * N_ANONYMOUS_SYMB + BYTE(SY_TEXT, I)
            - BYTE('0');
   END;
   FIRST_LITERAL = 0;
   DO I = 15 TO 19;
      IF BYTE(SY_TEXT, I) ~= BYTE(' ') THEN
         FIRST_LITERAL = 10 * FIRST_LITERAL + BYTE(SY_TEXT, I) - BYTE('0');
   END;
   PRINT_STATISTICS = (BYTE(SY_TEXT, 20) = BYTE('D'));
   PRINT_SYMBOLS = (BYTE(SY_TEXT, 21) = BYTE('S'));
   IF FIRST_LITERAL < 0 THEN FIRST_LITERAL = NULL;
   GAP = TABLE_LENGTH - N_DECL_SYMB + 1;
   SY_TEXT = INPUT(3);
   DO I = N_PREDECLARED_SYMB + 1 TO N_ANONYMOUS_SYMB - 1;
      IDENTITY(I) = NEXT_SYMBOL;
   END;
   SY_TEXT = INPUT(3);
   CALL RESTORE_COLUMN(ADDR(VALUE), 4, N_DECL_SYMB);
   CALL RESTORE_COLUMN(ADDR(VAR_TYPE), 2, N_DECL_SYMB);
   CALL RESTORE_COLUMN(ADDR(DATATYPE), 2, N_DECL_SYMB);
   IDENTITY(N_PREDECLARED_SYMB + 1) =
      SUBSTR(IDENTITY(N_PREDECLARED_SYMB + 1), 1);
   CALL REWIND(FALSE, 3);   /* REWIND SYMBOL TABLE FILE */
END RESTORE_SY_TABLE;

INITIALIZE_SY_TABLE:
PROCEDURE;
   DECLARE I FIXED;
   DO I = 0 TO TABLE_LENGTH;
      VALUE(I) = 0;
      OWNER(I) = NULL;
      STORAGE_LNGTH(I), S_LIST(I) = NULL;
      PSEUDO_REG(I), DISPLACEMENT(I) = NULL;
   END;
   DO I = N_PREDECLARED_SYMB + 1 TO TABLE_LENGTH;
      DATATYPE(I) = NULL;
   END;
   VALUE(FALSEPTR) = FALSE;
   VALUE(TRUEPTR) = TRUE;
   VALUE(NILPTR) = "FBFBFBFB";
   VALUE(MAXINTPTR) = MAXINT;
   S_LIST(INTPTR) = MAXINTPTR;
   S_LIST(BOOLPTR) = FALSEPTR;
   S_LIST(FALSEPTR) = TRUEPTR;
   STORAGE_LNGTH(NILPTR) = 4;
   STORAGE_LNGTH(INTPTR), STORAGE_LNGTH(REALPTR) = 4;
   STORAGE_LNGTH(BOOLPTR) = 2;
   STORAGE_LNGTH(CHARPTR) = 256;
   STORAGE_LNGTH(MAXINTPTR) = 4;
   STORAGE_LNGTH(INPUTPTR), STORAGE_LNGTH(OUTPUTPTR) = 2;
   STORAGE_LNGTH(INTFIELDSIZEPTR), STORAGE_LNGTH(BOOLFIELDSIZEPTR) = 4;
   STORAGE_LNGTH(REALFIELDSIZEPTR), STORAGE_LNGTH(DECIMAL_PLACESPTR) = 4;
   PSEUDO_REG(MAXINTPTR) = 0;
   DISPLACEMENT(MAXINTPTR) = DISPLAY_BYTES;
   CALL EMIT_DATA_BYTES(MAXINTPTR);
   PSEUDO_REG(NILPTR) = 0;
   DISPLACEMENT(NILPTR) = DISPLAY_BYTES + 4;
   CALL EMIT_DATA_BYTES(NILPTR);
   PSEUDO_REG(INPUTPTR), PSEUDO_REG(OUTPUTPTR) = 0;
   DISPLACEMENT(INPUTPTR) = DISPLAY_BYTES + 8;
   DISPLACEMENT(OUTPUTPTR) = DISPLAY_BYTES + 10;
   DATA_BYTES(DISPLACEMENT(INPUTPTR) + 1) = BYTE('?');
   DATA_BYTES(DISPLACEMENT(OUTPUTPTR) + 1) = BYTE('?');
   PSEUDO_REG(INTFIELDSIZEPTR), PSEUDO_REG(BOOLFIELDSIZEPTR) = 0;
   PSEUDO_REG(REALFIELDSIZEPTR), PSEUDO_REG(DECIMAL_PLACESPTR) = 0;
   DISPLACEMENT(INTFIELDSIZEPTR) = DISPLAY_BYTES + 12;
   DISPLACEMENT(BOOLFIELDSIZEPTR) = DISPLAY_BYTES + 16;
   DISPLACEMENT(REALFIELDSIZEPTR) = DISPLAY_BYTES + 20;
   DISPLACEMENT(DECIMAL_PLACESPTR) = DISPLAY_BYTES + 24;
   DATA_BYTES(DISPLACEMENT(INTFIELDSIZEPTR) + 3) = 12;
   DATA_BYTES(DISPLACEMENT(BOOLFIELDSIZEPTR) + 3) = 6;
   DATA_BYTES(DISPLACEMENT(REALFIELDSIZEPTR) + 3) = 14;
   DATA_BYTES(DISPLACEMENT(DECIMAL_PLACESPTR) + 3) = 0;
   DO I = DISPLACEMENT(DECIMAL_PLACESPTR) + 4 TO 79;
      DATA_BYTES(I) = 0;
   END;
END INITIALIZE_SY_TABLE;

INITIALIZE_ARITHMETIC_FUNCTIONS:
PROCEDURE;
   /* INITIALIZE SYMBOL TABLE ENTRIES FOR SIN, COS, EXP, LN, SQRT
         AND ARCTAN. */
   DECLARE (FUNCTION, PARAM_PTR) BIT(16),
      MONITOR_CODE(5) BIT(8) INITIAL(0, 1, 3, 4, 5, 2);
   /* ALLOCATE SYMBOL TABLE ENTRY FOR FORMAL PARAMETER OF STANDARD
         ARITHMETIC FUNCTIONS */
   PARAM_PTR = NEXT_FREE_ROW;
   DATATYPE(PARAM_PTR) = REALPTR;
   STRUCTYPE(PARAM_PTR) = ARITHMETIC;
   VAR_TYPE(PARAM_PTR) = VARIABLE;
   S_LIST(PARAM_PTR) = NULL;
   DO FUNCTION = SINPTR TO ARCTANPTR;
      S_LIST(FUNCTION) = PARAM_PTR;
      VALUE(FUNCTION) = MONITOR_CODE(FUNCTION - SINPTR);
   END;
END INITIALIZE_ARITHMETIC_FUNCTIONS;

   /*                 PROCEDURE FOR READING IN A PARSE TREE           */

READ_TREE:
PROCEDURE FIXED;   /* RETURNS POINTER TO ROOT */
   DECLARE (ROOT, I, J) FIXED;
   ROOT, I = 0;
   SY_TEXT = INPUT(2);
   IF LENGTH(SY_TEXT) = 0 THEN RETURN NULL;
   IF SUBSTR(SY_TEXT, 0, 5) ~= '%TREE' THEN
      DO;
         OUTPUT = '%TREE CARD EXPECTED.';
         RETURN NULL;
      END;
   DO J = 5 TO 9;
      IF BYTE(SY_TEXT, J) ~= BYTE(' ') THEN
         ROOT = 10 * ROOT + BYTE(SY_TEXT, J) - BYTE('0');
   END;
   PRINT_TREES = (BYTE(SY_TEXT, 10) = BYTE('P'));
   PRINT_TRIPLES = (BYTE(SY_TEXT, 11) = BYTE('T'));
   PRINT_CODE = (BYTE(SY_TEXT, 12) = BYTE('E'));
   SY_TEXT = INPUT(2);
   DO WHILE SUBSTR(SY_TEXT, 0, 4) ~= '%END';
      J = ADDR(PARSE_TREE(I));
      CALL INLINE("58", 1, 0, SY_TEXT);          /* L    1,SY_TEXT         */
      CALL INLINE("58", 2, 0, J);                /* L    2,J               */
      CALL INLINE("D2", "4", "F", 2, 0, 1, 0);   /* MVC  0(80,2),0(1)      */
      I = I + 40;
      SY_TEXT = INPUT(2);
   END;
   LAST_LINE = NULL;
   CURRENT_LINE = PARSE_TREE(ROOT + MULTIPLICITY(ROOT) + 2);
   TREE_SIZE = ROOT + MULTIPLICITY(ROOT) + 3;
   IF GAP > 0 THEN
      DO;
         I = 1;
         DO WHILE I <= ROOT;
            IF MULTIPLICITY(I) = 0 THEN
               IF PARSE_TREE(I + 1) > N_ANONYMOUS_SYMB THEN
                  PARSE_TREE(I + 1) = PARSE_TREE(I + 1) - GAP;
            I = I + MULTIPLICITY(I) + 3;
         END;
      END;
   RETURN ROOT;
END READ_TREE;

EVALUATE_CONSTANTS:
PROCEDURE;
   DECLARE I BIT(16);
   HALFWORD_DISP(1) = 0;
   I = N_DECL_SYMB - 1;
   CONST_POOL_SIZE = DISPLACEMENT(DECIMAL_PLACESPTR) + 4 - DISPLAY_BYTES;
   DO WHILE I >= N_ANONYMOUS_SYMB;
      IF DATATYPE(I) = INTPTR THEN
         DO;
            STORAGE_LNGTH(I) = 4;
            STRUCTYPE(I) = ARITHMETIC;
            S_LIST(I) = S_LIST(INTPTR);
            S_LIST(INTPTR) = I;
            PSEUDO_REG(I) = 0;
            DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
            CONST_POOL_SIZE = CONST_POOL_SIZE + 4;
         END;
      ELSE IF DATATYPE(I) = CHARPTR THEN
         DO;
            STORAGE_LNGTH(I) = 2;
            STRUCTYPE(I) = SCALAR;
            S_LIST(I) = S_LIST(CHARPTR);
            S_LIST(CHARPTR) = I;
            PSEUDO_REG(I) = 0;
            IF HALFWORD_DISP(1) > 0 THEN
               DO;
                  DISPLACEMENT(I) = HALFWORD_DISP(1);
                  HALFWORD_DISP(1) = 0;
               END;
            ELSE
               DO;
                  DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
                  HALFWORD_DISP(1) = CONST_POOL_SIZE + DISPLAY_BYTES + 2;
                  CONST_POOL_SIZE = CONST_POOL_SIZE + 4;
               END;
         END;
      ELSE   /* DATATYPE(I) = REALPTR */
         DO;
            STORAGE_LNGTH(I) = 4;
            STRUCTYPE(I) = ARITHMETIC;
            S_LIST(I) = S_LIST(REALPTR);
            S_LIST(REALPTR) = I;
            PSEUDO_REG(I) = 0;
            DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
            CONST_POOL_SIZE = CONST_POOL_SIZE + 4;
         END;
      CALL EMIT_DATA_BYTES(I);
      I = I - 1;
   END;
   I = FIRST_LITERAL;
   DO WHILE I ~= NULL;
      STORAGE_LNGTH(I) = LENGTH(IDENTITY(I));
      STRUCTYPE(I) = ARRAY;
      PSEUDO_REG(I) = 0;
      DISPLACEMENT(I) = CONST_POOL_SIZE + DISPLAY_BYTES;
      CONST_POOL_SIZE = CONST_POOL_SIZE + STORAGE_LNGTH(I);
      CALL EMIT_DATA_BYTES(I);
      I = VALUE(I);
   END;
   CONST_POOL_SIZE = (CONST_POOL_SIZE + 3) & "FFFFFC";
END EVALUATE_CONSTANTS;

MAIN_PROCEDURE:
CALL INITIALIZE_SY_TABLE;
CALL RESTORE_SY_TABLE;
CALL EVALUATE_CONSTANTS;
CALL INITIALIZE_ARITHMETIC_FUNCTIONS;
ROOT_OF_SUBTREE = READ_TREE;
DO WHILE ROOT_OF_SUBTREE ~= NULL;
   CALL VISIT_NODES;
   ROOT_OF_SUBTREE = READ_TREE;
END;
IF PRINT_SYMBOLS THEN CALL SY_DUMP;
IF SEVERE_ERRORS + MONITOR_LINK(3) = 0 THEN
   DO;   /* NO SEVERE ERRORS WERE ENCOUNTERED */
      CALL WRITE_SYMBOLS;
      OUTPUT(5) = COREIM_DESCRIPT(ADDR(DATA_BYTES), 80);
      CALL REWIND(TRUE, 5);
      IF MONITOR_LINK(2) > 0 THEN   /* DEBUG LEVEL > 0 */
         CALL PREPARE_POST_MORTEM_TABLES;
   END;
ELSE   /* THERE WERE SEVERE ERRORS */
   DO;
      MONITOR_LINK(0) = NULL;   /* ABORT COMPILATION */
      CALL PRINT_COMPILE_TIME;
   END;
EOF EOF EOF
