   /********************************************************************
   *                                                                   *
   *                 STONY BROOK PASCAL 360 COMPILER                   *
   *             PASS 1 -- LEXICAL AND SYNTACTIC ANALYSIS              *
   *                                                                   *
   ********************************************************************/

   /*
   COPYRIGHT (C) 1976 DEPARTMENT OF COMPUTER SCIENCE, SUNY AT STONY BROOK.
                                                                      */

   DECLARE ENTRIES(96) BIT(16) INITIAL ( "0000", "0009", "000E", "0010", "0015",
      "001A", "001E", "0021", "0023", "0025", "002A", "0034", "0035", "0037",
      "0038", "0039", "003C", "003D", "003F", "0042", "004C", "0052", "0057",
      "005B", "0065", "0068", "006A", "006D", "0071", "0076", "007F", "0080",
      "0081", "0085", "008A", "008B", "008E", "0094", "0096", "0098", "009A",
      "009E", "00A3", "00A6", "00A7", "00AA", "00AB", "00AC", "00AD", "00B2",
      "00B7", "00BD", "00C2", "00C4", "00C9", "00D2", "00D8", "00DB", "00DD",
      "00E7", "00E9", "00EA", "00EE", "00EF", "00F2", "00F7", "00F9", "00FD",
      "00FE", "0101", "0102", "0103", "0104", "0106", "0107", "010C", "010D",
      "010E", "0111", "0113", "0115", "011F", "0120", "0123", "0128", "012A",
      "0130", "0139", "013A", "0140", "0149", "014A", "014B", "014C", "0150",
      "0153", "0155");
   DECLARE INIT (340) BIT(8) INITIAL ( "06", "09", "20", "2C", "32", "35", "3A",
      "3C", "3E", "1E", "26", "2D", "38", "3B", "09", "3C", "07", "13", "24",
      "3A", "3C", "1E", "26", "2D", "39", "3B", "02", "1D", "2B", "31", "04",
      "0B", "17", "09", "1B", "0D", "21", "07", "13", "24", "3A", "3C", "02",
      "08", "10", "14", "1D", "21", "27", "2B", "31", "34", "37", "02", "05",
      "3C", "08", "09", "3A", "3C", "3C", "03", "11", "03", "08", "14", "01",
      "06", "10", "13", "1D", "21", "27", "2B", "31", "34", "07", "09", "13",
      "24", "3A", "3C", "1E", "26", "2D", "39", "3B", "1E", "2D", "39", "3B",
      "02", "0F", "1D", "1F", "28", "2D", "30", "33", "3C", "3E", "02", "1D",
      "31", "39", "3B", "02", "05", "07", "02", "1D", "2B", "31", "02", "09",
      "1D", "3A", "3C", "01", "06", "10", "1D", "21", "27", "2B", "31", "34",
      "3C", "02", "1E", "2D", "39", "3B", "1E", "26", "2D", "39", "3B", "02",
      "02", "05", "07", "07", "09", "13", "24", "3A", "3C", "15", "34", "03",
      "05", "3C", "3E", "20", "2C", "32", "36", "02", "08", "1D", "28", "3C",
      "02", "08", "1D", "3C", "03", "14", "16", "07", "07", "02", "1E", "26",
      "2D", "39", "3B", "1E", "26", "2D", "39", "3B", "1E", "26", "2D", "2F",
      "39", "3B", "02", "08", "1E", "39", "3B", "02", "1D", "07", "09", "3A",
      "3C", "3E", "06", "09", "20", "2C", "32", "35", "3A", "3C", "3E", "01",
      "06", "12", "1D", "2B", "31", "1E", "39", "3B", "02", "08", "02", "08",
      "0B", "10", "14", "1D", "27", "2B", "31", "34", "03", "14", "1D", "1E",
      "2D", "39", "3B", "02", "2D", "39", "3B", "02", "08", "14", "16", "1D",
      "3A", "3C", "09", "3A", "3C", "3E", "1D", "2D", "39", "3B", "2D", "02",
      "02", "15", "34", "37", "1E", "26", "2D", "39", "3B", "02", "3C", "02",
      "05", "07", "02", "08", "02", "08", "04", "06", "09", "20", "2C", "32",
      "35", "3A", "3C", "3E", "04", "03", "08", "14", "02", "08", "1D", "3A",
      "3C", "02", "08", "07", "09", "13", "24", "3A", "3C", "02", "0F", "1D",
      "1F", "28", "2D", "30", "33", "3C", "07", "01", "06", "12", "1D", "2B",
      "31", "02", "08", "10", "14", "1D", "27", "2B", "31", "34", "05", "04",
      "07", "10", "15", "27", "34", "02", "08", "1D", "07", "13");
   DECLARE FIN (340) BIT(8) INITIAL ( "07", "0A", "20", "2C", "32", "36", "3A",
      "3C", "3E", "1E", "26", "2F", "39", "3B", "0A", "3E", "07", "13", "25",
      "3A", "3E", "1E", "26", "2F", "39", "3B", "02", "1D", "2B", "31", "04",
      "0C", "1A", "0A", "1B", "0E", "23", "07", "13", "25", "3A", "3E", "04",
      "0E", "11", "1B", "1D", "23", "27", "2B", "31", "34", "37", "02", "05",
      "3C", "08", "0A", "3A", "3E", "3C", "03", "11", "03", "08", "14", "04",
      "0E", "11", "1B", "1D", "23", "27", "2B", "31", "34", "07", "0A", "14",
      "25", "3A", "3E", "1E", "26", "2F", "39", "3B", "1E", "2D", "39", "3B",
      "02", "0F", "1D", "1F", "2B", "2D", "31", "33", "3C", "3E", "02", "1D",
      "31", "39", "3B", "03", "05", "08", "02", "1D", "2B", "31", "02", "0A",
      "1D", "3A", "3E", "04", "0E", "1B", "1D", "23", "27", "2B", "31", "34",
      "3C", "02", "1E", "2D", "39", "3B", "1E", "26", "2D", "39", "3B", "03",
      "02", "05", "07", "07", "0A", "13", "25", "3A", "3E", "15", "34", "03",
      "05", "3C", "3E", "20", "2C", "32", "36", "02", "08", "1D", "28", "3C",
      "02", "08", "1D", "3E", "03", "14", "16", "07", "07", "02", "1E", "26",
      "2F", "39", "3B", "1E", "26", "2F", "39", "3B", "1E", "26", "2D", "2F",
      "39", "3B", "02", "08", "1E", "39", "3C", "02", "1D", "07", "0A", "3A",
      "3C", "3E", "07", "0A", "20", "2C", "32", "36", "3A", "3C", "3E", "02",
      "07", "13", "1D", "2B", "31", "1E", "39", "3C", "02", "08", "04", "08",
      "0C", "11", "1A", "1D", "27", "2B", "31", "34", "03", "14", "1D", "1E",
      "2D", "39", "3C", "02", "2D", "39", "3C", "03", "08", "14", "16", "1D",
      "3A", "3C", "0A", "3A", "3C", "3E", "1D", "2D", "39", "3B", "2D", "02",
      "02", "15", "34", "37", "1E", "26", "2D", "39", "3C", "02", "3C", "02",
      "05", "08", "03", "08", "03", "08", "04", "07", "0A", "20", "2C", "32",
      "36", "3A", "3C", "3E", "04", "03", "08", "14", "02", "0A", "1D", "3A",
      "3E", "02", "08", "07", "0A", "13", "25", "3A", "3E", "02", "0F", "1D",
      "1F", "2B", "2D", "31", "33", "3C", "07", "02", "07", "13", "1D", "2B",
      "31", "04", "0C", "11", "1B", "1D", "27", "2B", "31", "34", "05", "04",
      "07", "11", "15", "27", "34", "02", "08", "1D", "07", "13");
   DECLARE PTR (340) BIT(16) INITIAL ( "0000", "0002", "0004", "0005", "0006",
      "0007", "0009", "000A", "000B", "000C", "000D", "000E", "0011", "0013",
      "0014", "0016", "0019", "001A", "001B", "001D", "001E", "0021", "0022",
      "0023", "0026", "0027", "0028", "0029", "002A", "002B", "002C", "002D",
      "002F", "0033", "0035", "0036", "0038", "003B", "003C", "003D", "003F",
      "0040", "0043", "0046", "004D", "004F", "0057", "0058", "005B", "005C",
      "005D", "005E", "005F", "0060", "0061", "0062", "0063", "0064", "0066",
      "0067", "006A", "006B", "006C", "006D", "006E", "006F", "0070", "0074",
      "007D", "007F", "0088", "0089", "008C", "008D", "008E", "008F", "0090",
      "0091", "0093", "0095", "0097", "0098", "009B", "009C", "009D", "00A0",
      "00A1", "00A2", "00A3", "00A4", "00A5", "00A6", "00A7", "00A8", "00A9",
      "00AA", "00AE", "00AF", "00B1", "00B2", "00B3", "00B4", "00B5", "00B6",
      "00B7", "00B8", "00B9", "00BB", "00BC", "00BE", "00BF", "00C0", "00C1",
      "00C2", "00C3", "00C5", "00C6", "00C7", "00CA", "00CE", "00D7", "00E3",
      "00E4", "00E7", "00E8", "00E9", "00EA", "00EB", "00EC", "00ED", "00EE",
      "00EF", "00F0", "00F1", "00F2", "00F3", "00F4", "00F5", "00F6", "00F8",
      "00F9", "00FA", "00FB", "00FC", "00FE", "00FF", "0101", "0102", "0105",
      "0106", "0107", "0108", "0109", "010A", "010B", "010C", "010D", "010E",
      "010F", "0110", "0111", "0112", "0113", "0114", "0115", "0116", "0117",
      "011A", "011B", "011C", "011D", "011E", "011F", "0120", "0121", "0122",
      "0125", "0126", "0127", "0128", "0129", "012C", "012D", "012E", "012F",
      "0130", "0131", "0132", "0133", "0134", "0135", "0136", "0137", "0138",
      "013A", "013B", "013C", "013D", "013F", "0140", "0141", "0142", "0144",
      "0146", "0147", "0148", "0149", "014B", "014C", "014D", "014E", "0150",
      "0152", "0154", "0155", "0156", "0157", "0158", "0159", "015B", "015C",
      "015D", "0160", "0161", "0163", "0165", "016C", "016D", "016E", "016F",
      "0170", "0171", "0172", "0173", "0174", "0175", "0176", "0177", "0179",
      "017A", "017B", "017C", "017E", "0180", "0181", "0182", "0183", "0184",
      "0185", "0186", "0188", "0189", "018A", "018B", "018C", "018D", "018E",
      "018F", "0190", "0191", "0192", "0193", "0194", "0195", "0196", "0197",
      "0198", "0199", "019B", "019C", "019D", "019E", "019F", "01A1", "01A3",
      "01A4", "01A6", "01A7", "01A8", "01AA", "01AC", "01AD", "01AE", "01AF",
      "01B1", "01B2", "01B3", "01B4", "01B5", "01B6", "01B7", "01B8", "01B9",
      "01BC", "01BD", "01BE", "01C1", "01C2", "01C3", "01C4", "01C6", "01C7",
      "01C9", "01CA", "01CD", "01CE", "01CF", "01D0", "01D1", "01D5", "01D6",
      "01D8", "01D9", "01DA", "01DB", "01DD", "01DF", "01E1", "01E2", "01E3",
      "01E4", "01E7", "01EC", "01EE", "01F6", "01F7", "01F8", "01F9", "01FA",
      "01FB", "01FC", "01FD", "01FE", "0200", "0201", "0202", "0203", "0204",
      "0205", "0206", "0207");
   DECLARE PROD_# (519) BIT(8) INITIAL ( "62", "61", "61", "61", "63", "63",
      "63", "64", "63", "61", "61", "61", "1C", "1C", "1C", "1C", "1C", "A6",
      "1C", "1C", "79", "7A", "7B", "7B", "7B", "8E", "8E", "8E", "8E", "8E",
      "8E", "8E", "8E", "02", "02", "02", "02", "02", "02", "02", "BE", "BE",
      "BE", "BE", "7F", "80", "81", "82", "83", "84", "85", "8B", "8C", "8D",
      "91", "92", "93", "94", "95", "97", "99", "98", "9D", "9C", "96", "9B",
      "9A", "90", "90", "90", "90", "90", "90", "90", "90", "8F", "8F", "90",
      "90", "90", "90", "90", "90", "90", "90", "90", "90", "90", "8F", "8F",
      "8F", "90", "90", "90", "90", "01", "A5", "A4", "22", "A2", "75", "75",
      "74", "75", "75", "75", "4E", "3D", "3E", "37", "38", "38", "9E", "9E",
      "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E",
      "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E", "9E",
      "9E", "9E", "9E", "9E", "9E", "9E", "A0", "A0", "A0", "A0", "A1", "A0",
      "A0", "A0", "A0", "A0", "A0", "03", "03", "03", "03", "03", "03", "03",
      "1D", "1E", "1E", "1E", "26", "26", "26", "26", "26", "26", "26", "26",
      "26", "26", "26", "26", "26", "25", "06", "07", "07", "1B", "1A", "24",
      "23", "24", "24", "24", "3A", "3A", "39", "3A", "A7", "49", "49", "A7",
      "49", "49", "49", "49", "50", "52", "52", "52", "51", "9F", "52", "52",
      "52", "52", "52", "52", "52", "52", "52", "52", "4F", "52", "52", "52",
      "52", "52", "52", "52", "52", "52", "52", "52", "52", "52", "52", "52",
      "52", "6F", "B6", "04", "04", "04", "04", "13", "12", "13", "13", "13",
      "0B", "0A", "40", "40", "3F", "7C", "7C", "7C", "7C", "7C", "7C", "7C",
      "7C", "7C", "7C", "3C", "3B", "4C", "4D", "5F", "60", "67", "66", "65",
      "68", "A8", "A8", "A8", "6C", "6B", "6D", "6E", "6E", "76", "78", "77",
      "AB", "AB", "AA", "B8", "BB", "C7", "C5", "C5", "C5", "C5", "C5", "C5",
      "C5", "09", "09", "09", "08", "09", "09", "09", "0D", "0D", "0D", "0C",
      "0D", "0D", "B2", "B2", "AF", "B0", "B1", "AE", "4A", "4B", "54", "55",
      "56", "58", "53", "57", "C8", "C8", "C8", "C8", "C8", "C8", "C8", "C8",
      "C8", "C8", "C8", "C8", "33", "36", "34", "35", "31", "32", "36", "36",
      "36", "42", "43", "44", "41", "45", "46", "7E", "7E", "7D", "7E", "7D",
      "7D", "7E", "7E", "7E", "7E", "7E", "7D", "7D", "7D", "7D", "7E", "7E",
      "7E", "7E", "7E", "AC", "AD", "C3", "15", "15", "15", "15", "14", "21",
      "20", "20", "20", "1F", "5A", "5A", "5A", "5A", "59", "5A", "5E", "5D",
      "5B", "5B", "5C", "5B", "5B", "C0", "19", "18", "18", "05", "17", "B7",
      "C1", "C1", "A3", "0F", "0F", "0F", "0F", "0F", "0E", "11", "BF", "48",
      "48", "47", "48", "BA", "B9", "BA", "BD", "BC", "BD", "CE", "CF", "CF",
      "CF", "CF", "CF", "CF", "CF", "CF", "CF", "CF", "CF", "CF", "10", "69",
      "6A", "6A", "A9", "A9", "72", "72", "A9", "72", "72", "72", "72", "B4",
      "B3", "88", "86", "87", "88", "88", "88", "88", "88", "88", "88", "30",
      "29", "30", "2D", "2A", "2E", "2F", "30", "28", "2B", "30", "2C", "27",
      "73", "D0", "D1", "D0", "D0", "D0", "D0", "D1", "D1", "D1", "8A", "8A",
      "8A", "8A", "89", "89", "8A", "8A", "8A", "8A", "8A", "8A", "8A", "8A",
      "8A", "8A", "8A", "89", "8A", "8A", "8A", "8A", "8A", "CD", "16", "B5",
      "C9", "CA", "CB", "D4", "CB", "70", "71", "71", "D3", "D2");
   DECLARE NONEMPTY (212) BIT(8) INITIAL (0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1,
      0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0,
      1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
      1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
      1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1,
      1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1,
      1);
   DECLARE PRODUCES_EMPTY (95) BIT(1) INITIAL ( 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
      0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
      0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1,
      1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
      1, 0, 1, 1, 0, 0, 0, 1, 1, 0);
   DECLARE TERMINAL_HEADS_INDEX (96) BIT(16) INITIAL ( 0, 12, 20, 22, 30, 37,
      37, 44, 47, 52, 60, 65, 66, 67, 68, 69, 75, 76, 77, 78, 82, 92, 95, 96,
      106, 107, 109, 110, 111, 118, 122, 123, 124, 128, 129, 130, 131, 141, 143,
      144, 146, 150, 153, 154, 157, 158, 159, 160, 161, 168, 169, 170, 175, 176,
      182, 194, 199, 203, 204, 211, 212, 213, 214, 215, 216, 217, 219, 224, 225,
      227, 228, 229, 230, 232, 233, 234, 235, 236, 237, 238, 239, 252, 253, 254,
      260, 261, 271, 280, 281, 286, 289, 290, 291, 292, 297, 298, 300);
   DECLARE TERMINAL_HEADS (300) BIT(8) INITIAL ( "06", "07", "09", "0A", "20",
      "2C", "32", "35", "36", "3A", "3C", "3E", "1E", "26", "2D", "2E", "2F",
      "38", "39", "3B", "09", "0A", "07", "13", "24", "25", "3A", "3C", "3D",
      "3E", "1E", "26", "2D", "2E", "2F", "39", "3B", "04", "0B", "0C", "17",
      "18", "19", "1A", "09", "0A", "1B", "0D", "0E", "21", "22", "23", "07",
      "13", "24", "25", "3A", "3C", "3D", "3E", "0D", "0E", "21", "22", "23",
      "37", "05", "3C", "08", "09", "0A", "3A", "3C", "3D", "3E", "3C", "03",
      "03", "01", "06", "07", "13", "07", "09", "0A", "13", "24", "25", "3A",
      "3C", "3D", "3E", "26", "2E", "2F", "1E", "0F", "1F", "28", "29", "2A",
      "2D", "30", "33", "3C", "3E", "02", "39", "3B", "03", "2B", "02", "09",
      "0A", "3A", "3C", "3D", "3E", "01", "06", "07", "13", "3C", "02", "1E",
      "2D", "39", "3B", "26", "03", "07", "07", "09", "0A", "13", "24", "25",
      "3A", "3C", "3D", "3E", "15", "34", "03", "3C", "3E", "20", "2C", "32",
      "36", "02", "28", "3C", "02", "3C", "3D", "3E", "16", "07", "07", "02",
      "1E", "26", "2D", "2E", "2F", "39", "3B", "2E", "2F", "02", "1E", "39",
      "3B", "3C", "02", "07", "09", "0A", "3A", "3C", "3E", "06", "07", "09",
      "0A", "20", "2C", "32", "35", "36", "3A", "3C", "3E", "01", "06", "07",
      "12", "13", "1E", "39", "3B", "3C", "02", "04", "0B", "0C", "17", "18",
      "19", "1A", "03", "1D", "3C", "02", "3C", "16", "3A", "3C", "09", "0A",
      "3A", "3C", "3E", "1D", "39", "3B", "2D", "02", "02", "15", "34", "37",
      "3C", "02", "3C", "07", "03", "03", "04", "06", "07", "09", "0A", "20",
      "2C", "32", "35", "36", "3A", "3C", "3E", "04", "03", "09", "0A", "3A",
      "3C", "3D", "3E", "02", "07", "09", "0A", "13", "24", "25", "3A", "3C",
      "3D", "3E", "0F", "1F", "28", "29", "2A", "2D", "30", "33", "3C", "07",
      "01", "06", "07", "12", "13", "09", "0A", "1B", "05", "04", "07", "10",
      "11", "15", "27", "34", "02", "07", "13", 0);
   DECLARE NSY LITERALLY '158', NT LITERALLY '62', NPR LITERALLY '212';
   DECLARE NNT LITERALLY '96';
   DECLARE V(NSY) CHARACTER INITIAL('<ERROR: TOKEN = 0>', '.', ';', ',', '=',
      ':', '@', '(', ')', '+', '-', '<', '>', '*', '/', 'IF', 'OF', 'DO', ':=',
      '(.', '.)', 'TO', '..', '<>', '<=', '>=', 'IN', 'OR', '_|_', 'END', 'VAR',
      'FOR', 'SET', 'DIV', 'MOD', 'AND', 'NOT', 'NIL', 'TYPE', 'THEN', 'CASE',
      'WITH', 'GOTO', 'ELSE', 'FILE', 'BEGIN', 'LABEL', 'CONST', 'WHILE',
      'UNTIL', 'ARRAY', 'REPEAT', 'DOWNTO', 'PACKED', 'RECORD', 'PROGRAM',
      'FORWARD', 'FUNCTION', '<STRING>', 'PROCEDURE', '<IDENTIFIER>',
      '<UNSIGNED REAL>', '<UNSIGNED INTEGER>', '<TYPE>', '<BODY>', '<SIGN>',
      '<TERM>', '<BLOCK>', '<CLOSE>', '<RELOP>', '<ADDOP>', '<MULOP>',
      '<FACTOR>', '<TERM 2>', '<PROGRAM>', '<RETURNS>', '<ID LIST>',
      '<RPARENT>', '<CONSTANT>', '<VARIABLE>', '<VAR LIST>', '<EXP LIST>',
      '<FACTOR 2>', '<ELEMENTS>', '<FIRSTPART>', '<VAR DECLS>', '<STATEMENT>',
      '<STAT LIST>', '<PROC DECL>', '<ID LIST 2>', '<ELSE PART>', '<CASE LIST>',
      '<QUALIFIER>', '<TAG IDENT>', '<SEMICOLON>', '<SECONDPART>',
      '<TYPE DEFNS>', '<LABEL LIST>', '<PARAM LIST>', '<EXPRESSION>',
      '<FOR STAT 2>', '<CONST LIST>', '<CONSTANT 1>', '<STRUC TYPE>',
      '<FIELD LIST>', '<NEXT FIELD>', '<CONSTANT 2>', '<ELEMENTS 2>',
      '<FUNC TYPES>', '<PROC TYPES>', '<SEMICOLON1>', '<DUMMYBLOCK>',
      '<LABEL DECLS>', '<CONST DECLS>', '<PARAM TYPES>', '<CASE LIST 2>',
      '<SIMPLE TYPE>', '<DUMMY FIELD>', '<ID STATEMENT>', '<PARAM LIST 1>',
      '<PARAM LIST 2>', '<EXPRESSION 2>', '<ELEMENT LIST>', '<DUMMY ENDING>',
      '<TYPE DEF LIST>', '<VAR DECL TAIL>', '<VAR DECL LIST>',
      '<SIMPLE TYPE 1>', '<SIMPLE TYPE 3>', '<SIMPLE TYPE 2>',
      '<RECORD ENDING>', '<PROC DECL LIST>', '<STATEMENT PART>',
      '<TYPE DEFN TAIL>', '<PROC DECL TAIL>', '<DUMMY FOR STAT>',
      '<PROGRAM HEADING>', '<CONST DECL LIST>', '<CONST DECL TAIL>',
      '<TYPE IDENTIFIER>', '<PARAM TYPE LIST>', '<FUNC TYPES TAIL>',
      '<PROC TYPES TAIL>', '<DUMMY TYPE BODY>', '<CONST VALUE PART>',
      '<SIMPLE TYPE LIST>', '<VARIANT INSTANCE>', '<PARAM TYPES TAIL>',
      '<SIMPLE EXPRESSION>', '<UNLABLED STATEMENT>', '<VARIANT INSTANCE 2>',
      '<ASSIGNMENT     PART>', '<SIMPLE EXPRESSION 2>', '<DUMMY VAR DECL BODY>',
      '<TYPE DESCRIPTOR PART>', '<PROGRAM HEADING TAIL>',
      '<DUMMY STATEMENT TAIL>', '<VARIANT INSTANCE LIST>',
      '<INDEX  AND  ELEMENTS  TYPE>');
   DECLARE V_INDEX(18) BIT(8) INITIAL ( 1, 15, 28, 38, 45, 51, 55, 57, 59, 60,
      60, 60, 61, 61, 61, 62, 62, 62, 63);
   DECLARE GOAL LITERALLY '74';
   DECLARE PR_LENGTH (212) BIT(8) INITIAL ( "00", "03", "02", "03", "03", "03",
      "02", "00", "03", "00", "02", "00", "02", "00", "01", "00", "02", "01",
      "02", "00", "01", "00", "02", "01", "02", "00", "04", "05", "01", "04",
      "00", "04", "00", "01", "01", "01", "00", "02", "01", "01", "03", "04",
      "04", "03", "04", "04", "05", "01", "00", "01", "06", "04", "03", "04",
      "00", "02", "00", "01", "00", "03", "03", "02", "00", "02", "00", "04",
      "04", "05", "03", "01", "00", "02", "00", "05", "01", "00", "02", "00",
      "01", "04", "02", "01", "00", "01", "02", "04", "04", "03", "02", "01",
      "00", "02", "00", "00", "00", "00", "00", "01", "01", "01", "01", "01",
      "02", "02", "02", "02", "00", "04", "06", "01", "00", "00", "02", "00",
      "04", "02", "00", "02", "00", "00", "00", "00", "00", "00", "02", "02",
      "00", "00", "00", "00", "00", "00", "00", "00", "02", "02", "02", "03",
      "00", "00", "00", "00", "02", "03", "00", "00", "00", "00", "00", "00",
      "01", "02", "01", "02", "00", "00", "00", "00", "01", "04", "03", "00",
      "00", "02", "01", "00", "00", "01", "01", "00", "01", "00", "03", "00",
      "02", "02", "02", "02", "01", "00", "01", "03", "00", "02", "05", "01",
      "00", "03", "01", "00", "00", "00", "00", "01", "00", "00", "00", "01",
      "00", "00", "02", "02", "01", "01", "00", "02", "01", "02", "03", "00",
      "05", "05", "02");
   DECLARE PR_PTR (212) BIT(16) INITIAL ( "0000", "0000", "0003", "0005",
      "0008", "000B", "000E", "0010", "0010", "0013", "0013", "0015", "0015",
      "0017", "0017", "0018", "0018", "001A", "001B", "001D", "001D", "001E",
      "001E", "0020", "0021", "0023", "0023", "0027", "002C", "002D", "0031",
      "0031", "0035", "0035", "0036", "0037", "0038", "0038", "003A", "003B",
      "003C", "003F", "0043", "0047", "004A", "004E", "0052", "0057", "0058",
      "0058", "0059", "005F", "0063", "0066", "006A", "006A", "006C", "006C",
      "006D", "006D", "0070", "0073", "0075", "0075", "0077", "0077", "007B",
      "007F", "0084", "0087", "0088", "0088", "008A", "008A", "008F", "0090",
      "0090", "0092", "0092", "0093", "0097", "0099", "009A", "009A", "009B",
      "009D", "00A1", "00A5", "00A8", "00AA", "00AB", "00AB", "00AD", "00AD",
      "00AD", "00AD", "00AD", "00AD", "00AE", "00AF", "00B0", "00B1", "00B2",
      "00B4", "00B6", "00B8", "00BA", "00BA", "00BE", "00C4", "00C5", "00C5",
      "00C5", "00C7", "00C7", "00CB", "00CD", "00CD", "00CF", "00CF", "00CF",
      "00CF", "00CF", "00CF", "00CF", "00D1", "00D3", "00D3", "00D3", "00D3",
      "00D3", "00D3", "00D3", "00D3", "00D3", "00D5", "00D7", "00D9", "00DC",
      "00DC", "00DC", "00DC", "00DC", "00DE", "00E1", "00E1", "00E1", "00E1",
      "00E1", "00E1", "00E1", "00E2", "00E4", "00E5", "00E7", "00E7", "00E7",
      "00E7", "00E7", "00E8", "00EC", "00EF", "00EF", "00EF", "00F1", "00F2",
      "00F2", "00F2", "00F3", "00F4", "00F4", "00F5", "00F5", "00F8", "00F8",
      "00FA", "00FC", "00FE", "0100", "0101", "0101", "0102", "0105", "0105",
      "0107", "010C", "010D", "010D", "0110", "0111", "0111", "0111", "0111",
      "0111", "0112", "0112", "0112", "0112", "0113", "0113", "0113", "0115",
      "0117", "0118", "0119", "0119", "011B", "011C", "011E", "0121", "0121",
      "0126", "012B");
   DECLARE RHS (300) BIT(8) INITIAL ( "88", "43", "01", "54", "5F", "70", "71",
      "60", "55", "83", "84", "56", "57", "1D", "56", "57", "3E", "61", "02",
      "3E", "61", "3C", "90", "90", "4E", "8A", "89", "3C", "9A", "9A", "3F",
      "85", "7C", "58", "86", "3C", "62", "02", "40", "3C", "62", "4B", "02",
      "40", "43", "4C", "05", "3F", "7D", "4C", "05", "3F", "7D", "7E", "59",
      "4C", "05", "95", "95", "76", "56", "57", "1D", "63", "27", "56", "5A",
      "63", "10", "5B", "1D", "63", "11", "56", "56", "57", "31", "63", "3C",
      "12", "63", "64", "4F", "50", "11", "56", "44", "3E", "63", "63", "51",
      "14", "5C", "12", "63", "3C", "5C", "12", "63", "5C", "12", "63", "63",
      "51", "08", "97", "63", "51", "56", "63", "11", "56", "63", "11", "56",
      "4F", "50", "77", "08", "4C", "05", "8B", "78", "4C", "05", "8B", "78",
      "4C", "8C", "05", "8B", "78", "4C", "8C", "78", "77", "72", "08", "4E",
      "65", "05", "56", "73", "5B", "4E", "65", "5C", "63", "51", "14", "5C",
      "3C", "5C", "5C", "7F", "4C", "08", "66", "16", "41", "66", "66", "16",
      "41", "66", "16", "41", "66", "16", "80", "81", "41", "66", "74", "8B",
      "67", "67", "9E", "10", "3F", "10", "74", "68", "82", "74", "91", "4C",
      "05", "3F", "69", "5D", "05", "3C", "10", "92", "9D", "68", "92", "9D",
      "4E", "65", "05", "96", "68", "08", "41", "6A", "94", "79", "45", "94",
      "42", "98", "42", "98", "42", "98", "46", "42", "98", "48", "49", "47",
      "48", "49", "52", "63", "4D", "48", "53", "14", "5C", "63", "51", "08",
      "5C", "63", "6B", "7A", "3C", "9B", "8B", "73", "69", "63", "63", "6B",
      "7A", "4C", "93", "4C", "93", "6C", "93", "6D", "93", "93", "72", "4C",
      "08", "5E", "6E", "83", "72", "08", "05", "3C", "8D", "6C", "72", "08",
      "8E", "6D", "64", "43", "3F", "69", "5B", "1D", "56", "64", "3F", "7D",
      "9A", "3F", "85", "5C", "12", "63", "74", "91", "14", "10", "3F", "74",
      "91", "08", "10", "3F", "56", "5A");
   DECLARE TERMINAL BIT(213) INITIAL ("(1) 0 00001 10101 01010 11101 01100 11010
      00111 01011 11111 11011 11101 01011 10100 11110 10010 10111 10111 11110
      01111 10101 11111 00110 11001 10111 11000 01111 11111 00011 10001 11111
      11111 11010 01110 10001 01001 11001 11011 01100 11001 00010 11001 00001
      11");
    DECLARE CATCH_ACTION(62) BIT(16) INITIAL( "0000", "0000", "0000", "00C2",
      "0130", "014A", "0000", "0000", "0000", "0000", "0000", "0000", "0000",
      "0000", "0000", "0032", "005F", "0088", "00B0", "0000", "0000", "0095",
      "0000", "0000", "0000", "0000", "0000", "0000", "0000", "00F9", "0015",
      "0032", "00A2", "0000", "0000", "0000", "0000", "0000", "000C", "00D9",
      "0043", "0032", "0032", "00E9", "00A2", "0021", "0001", "0006", "0032",
      "007B", "00A2", "0032", "0095", "00A2", "00A2", "0000", "0000", "0015",
      "0000", "0015", "0113", "0000", "0000");
   DECLARE  SP_BIT  BIT(354) INITIAL("(1) 0 10000 11100 01110 00010 10110 01100
      10111 01100 00001 10001 11101 00000 01100 00111 10001 10111 10000 00001
      10000 10110 10100 00111 00110 10000 00111 10100 01000 01110 00000 01011
      11100 00100 00011 10100 10100 00101 10000 01110 11010 01100 01110 10000
      00011 01110 01110 00001 10111 01001 00100 10000 11001 01011 01110 10010
      00001 01011 01001 01101 00100 00101 11000 11110 01100 11110 01100 00100
      10100 01111 01110 00110 110 ");
   DECLARE STOP_POP_SYMBOL(353) BIT(8) INITIAL (     "00",  "4A", "43", "40",
      "01", "00", "4A", "43", "40", "01", "5F", "00", "4A", "43", "40", "01",
      "5F", "60", "55", "54", "00", "4A", "01", "43", "40", "5F", "55", "62",
      "78", "77", "83", "8C", "00", "4A", "43", "40", "01", "5F", "84", "56",
      "57", "44", "1D", "5A", "31", "64", "5B", "73", "95", "00", "4A", "43",
      "40", "5F", "01", "84", "56", "57", "44", "1D", "5A", "31", "64", "5B",
      "73", "95", "00", "7D", "7E", "96", "69", "60", "55", "68", "9D", "92",
      "3F", "85", "4A", "43", "40", "5F", "01", "84", "56", "57", "44", "1D",
      "5A", "31", "64", "5B", "73", "95", "00", "9D", "96", "10", "69", "68",
      "3F", "60", "85", "9A", "83", "86", "84", "7D", "4A", "43", "40", "01",
      "5F", "84", "56", "57", "1D", "44", "5A", "31", "64", "73", "00", "4A",
      "43", "40", "01", "31", "56", "57", "5A", "1D", "5B", "73", "44", "00",
      "11", "4A", "43", "40", "01", "56", "57", "5A", "1D", "44", "31", "64",
      "00", "4A", "43", "40", "01", "56", "57", "5A", "1D", "44", "5B", "73",
      "31", "00", "3F", "85", "4A", "43", "40", "01", "96", "9D", "5F", "60",
      "69", "7E", "7D", "00", "12", "76", "97", "57", "56", "95", "5A", "31",
      "1D", "44", "63", "4A", "43", "40", "01", "5F", "84", "00", "55", "7D",
      "4C", "59", "76", "50", "65", "51", "53", "52", "4A", "61", "01", "57",
      "31", "1D", "44", "11", "10", "7A", "8D", "8E", "00", "4A", "43", "40",
      "6E", "01", "5F", "56", "95", "57", "73", "1D", "5A", "44", "64", "5B",
      "00", "4A", "43", "40", "01", "5F", "5A", "56", "95", "57", "44", "64",
      "31", "1D", "5B", "73", "00", "82", "1D", "3F", "60", "85", "55", "7D",
      "83", "86", "84", "7E", "7D", "5F", "4A", "43", "40", "01", "84", "56",
      "5A", "5B", "73", "57", "31", "44", "00", "71", "90", "54", "5F", "60",
      "85", "9A", "55", "3F", "9D", "69", "7D", "62", "78", "5B", "73", "72",
      "57", "93", "5A", "56", "31", "44", "84", "01", "43", "40", "4A", "00",
      "04", "90", "8A", "89", "71", "54", "86", "55", "5F", "7C", "85", "3F",
      "60", "9A", "43", "40", "01", "79", "63", "56", "57", "10", "11", "64",
      "4A", "00", "83", "5F", "7D", "68", "9D", "05", "3F", "92", "4A", "3F",
      "40", "01", "96", "69", "56", "57", "31", "5A", "A1", "5B", "73", "62",
      "77", "00");
   DECLARE REST_PTR(353) BIT(16) INITIAL("0000"  , "0001", "0000", "0000",
      "0004", "0000", "0006", "000B", "000B", "000B", "000F", "0000", "0012",
      "0016", "0016", "0016", "0019", "0000", "0019", "0019", "0000", "001B",
      "0020", "0020", "0020", "0000", "0000", "0024", "0027", "0000", "0029",
      "002B", "0000", "002E", "0031", "0031", "0031", "0031", "0033", "0000",
      "0037", "0037", "0039", "0039", "0039", "0037", "003C", "0037", "0000",
      "0000", "003F", "0033", "0033", "0033", "0033", "0033", "0000", "0037",
      "0037", "0039", "0039", "0039", "0037", "003C", "0037", "0000", "0000",
      "0044", "0047", "004B", "004E", "0050", "0050", "0000", "004B", "004B",
      "0044", "0044", "003F", "0033", "0033", "0033", "0033", "0000", "0000",
      "0037", "0037", "0039", "0039", "0039", "0037", "003C", "0037", "0000",
      "0000", "0054", "0057", "0000", "005C", "0060", "0064", "0066", "006A",
      "0066", "006D", "006D", "0071", "0076", "0079", "007F", "007F", "007F",
      "0066", "0084", "0089", "0089", "0089", "0089", "0089", "0084", "0089",
      "0089", "0000", "008D", "008D", "008D", "008D", "0000", "0093", "0093",
      "0093", "0093", "0096", "0093", "0093", "0000", "0000", "009A", "009A",
      "009A", "00A0", "00A5", "00A7", "00A7", "00A7", "00A7", "00A7", "00A7",
      "0000", "00AA", "00AA", "00AA", "00AA", "00AF", "00AF", "00AF", "00AF",
      "00AF", "00B1", "00AF", "00B4", "0000", "0000", "00B7", "00B9", "00B9",
      "00B9", "00BE", "00C2", "00C2", "00C6", "00C6", "00B7", "00C9", "00B7",
      "0000", "0000", "0000", "00CC", "00CF", "00CF", "00CF", "00CF", "00CF",
      "00CF", "00D3", "00D7", "00D9", "00E0", "00E0", "00E0", "00E0", "00E5",
      "0000", "00E9", "00EF", "00F4", "00F6", "00F9", "00FE", "0101", "0104",
      "0107", "00F9", "010C", "0113", "0116", "011C", "011C", "011C", "011C",
      "011C", "011C", "0120", "0124", "0127", "0000", "012A", "0131", "0131",
      "0131", "0131", "0131", "0137", "0137", "0137", "0137", "0137", "0137",
      "0137", "0137", "013B", "0000", "0140", "0145", "0145", "0145", "0145",
      "0000", "0149", "014B", "014B", "014B", "014B", "014E", "014E", "014B",
      "014B", "0000", "0000", "0000", "0152", "0154", "0152", "0154", "0157",
      "0157", "015B", "015B", "0157", "0160", "0154", "0164", "016B", "016B",
      "016B", "0152", "0152", "0152", "0171", "0152", "0152", "0152", "0152",
      "0000", "0174", "0177", "0179", "017E", "017E", "0181", "0177", "0183",
      "0185", "0188", "004E", "018A", "0024", "0027", "0000", "018E", "0000",
      "0037", "0190", "0037", "0000", "0037", "0037", "0033", "0033", "0192",
      "0192", "0195", "0000", "0000", "0000", "0199", "0199", "0199", "019D",
      "01A2", "01A7", "01A2", "01A7", "01AB", "01AE", "01A7", "01A7", "01A2",
      "01A2", "01A2", "0000", "01B0", "01B2", "01B2", "01B0", "01B0", "01B0",
      "01B5", "0000", "01BB", "01BF", "01C5", "01C8", "01CC", "0000", "01CF",
      "01CC", "01D1", "0000", "01D8", "01BF", "01E3", "01E7", "01EA", "01EA",
      "01EA", "01EA", "01ED", "01F1", "01F5", "01F8", "01FD", "0000");
   DECLARE  REST_SYMBOL(512)  BIT(8)   INITIAL(     "00", "02", "01", "43",
      "01", "43", "04", "01", "5F", "60", "71", "03", "5F", "60", "71", "02",
      "60", "71", "03", "01", "5F", "60", "02", "5F", "60", "01", "60", "04",
      "01", "84", "83", "55", "03", "84", "83", "55", "02", "08", "77", "01",
      "77", "01", "55", "02", "08", "72", "02", "01", "84", "01", "84", "03",
      "1D", "57", "56", "01", "56", "02", "57", "56", "02", "73", "56", "04",
      "01", "1D", "57", "56", "02", "82", "68", "03", "7D", "82", "68", "02",
      "08", "68", "01", "68", "03", "85", "82", "68", "02", "92", "10", "04",
      "08", "9D", "92", "10", "03", "9D", "92", "10", "03", "69", "3F", "10",
      "01", "10", "03", "85", "3F", "10", "02", "3F", "10", "03", "7D", "7F",
      "10", "04", "83", "7D", "7F", "10", "02", "7F", "10", "05", "01", "5F",
      "85", "3F", "10", "04", "5F", "85", "3F", "10", "04", "57", "1D", "5B",
      "10", "03", "1D", "5B", "10", "05", "01", "57", "5A", "63", "31", "02",
      "63", "31", "03", "73", "63", "31", "05", "01", "1D", "57", "56", "11",
      "04", "1D", "57", "56", "11", "01", "11", "02", "56", "11", "04", "01",
      "1D", "57", "64", "01", "64", "02", "73", "64", "02", "57", "64", "01",
      "3F", "04", "01", "5F", "85", "3F", "03", "5F", "85", "3F", "03", "08",
      "69", "3F", "02", "85", "3F", "02", "7D", "3F", "02", "63", "12", "03",
      "87", "63", "12", "03", "87", "9F", "12", "01", "12", "06", "01", "6F",
      "1D", "57", "63", "12", "04", "1D", "57", "63", "12", "03", "57", "63",
      "12", "05", "7D", "3F", "05", "4C", "03", "04", "3F", "05", "4C", "03",
      "01", "03", "02", "4C", "03", "04", "08", "51", "63", "03", "02", "4F",
      "03", "02", "4E", "03", "02", "63", "03", "04", "7A", "6B", "63", "03",
      "06", "01", "43", "5E", "08", "4C", "03", "02", "3E", "03", "05", "57",
      "56", "51", "63", "03", "03", "51", "63", "03", "03", "6B", "63", "03",
      "02", "6C", "03", "02", "6D", "03", "06", "01", "1D", "57", "5A", "56",
      "27", "05", "1D", "57", "5A", "56", "27", "03", "5A", "56", "27", "04",
      "73", "5A", "56", "27", "04", "01", "1D", "57", "5A", "03", "1D", "57",
      "5A", "01", "2B", "02", "56", "2B", "03", "57", "56", "2B", "01", "1D",
      "02", "85", "1D", "03", "55", "85", "1D", "04", "83", "55", "85", "1D",
      "03", "7E", "85", "1D", "06", "01", "6F", "7B", "57", "56", "1D", "05",
      "6F", "7B", "57", "56", "1D", "02", "73", "1D", "02", "90", "3C", "01",
      "3C", "04", "5F", "60", "90", "3C", "02", "9A", "3C", "01", "7C", "01",
      "7E", "02", "05", "4C", "01", "92", "03", "3F", "05", "4C", "01", "5B",
      "01", "72", "02", "5F", "7C", "03", "01", "5F", "7C", "03", "8A", "4E",
      "04", "04", "60", "8A", "4E", "04", "04", "5F", "85", "3F", "04", "03",
      "85", "3F", "04", "02", "3F", "04", "01", "04", "01", "79", "02", "9C",
      "79", "05", "01", "5F", "85", "3F", "04", "03", "7D", "3F", "05", "05",
      "84", "83", "7D", "3F", "05", "02", "3F", "05", "03", "69", "3F", "05",
      "02", "96", "05", "01", "05", "06", "01", "84", "83", "7D", "3F", "05",
      "0A", "84", "83", "7D", "43", "A0", "84", "83", "7D", "3F", "05", "03",
      "08", "75", "05", "02", "75", "05", "02", "95", "05", "03", "A2", "95",
      "05", "03", "73", "56", "05", "02", "56", "05", "04", "08", "78", "8B",
      "05", "03", "78", "8B", "05");
  DECLARE CATCH_SYMBOLS BIT(63) INITIAL("(1)0 00011 00000 00001
11100 10000 00011 11000 00111 11111 10111 11110 01010 00");
  DECLARE BLOCK_HEADS BIT(63) INITIAL(" (1)0 00000 00000 00000 00000
  00000 00001 00000 00100 00001 11000 00000 01010  00");
   DECLARE  IS_PROC_TYPE BIT(32) INITIAL("(1)0000 0000 0000 0000 0100 0000 1010
 0000");


   /* END OF DECLARATIONS PUNCHED BY LL(1) ANALYZER                   */
  DECLARE  NOT_VAR_NOR_CONST BIT(63) INITIAL("(1)0 00000 00000
  00000 00000 00000 00000 00000 00000 00000 00000 00000 00101 11");

  DECLARE NULL LITERALLY '"FFFFFFFF"';
  DECLARE RESERVED_WORDS  BIT(63) INITIAL("(1)0 00000 00000 00001 11000 10000
   11011 11111 11111 11111 11111 11111 11010 00");

   DECLARE EQUIVALENT(NT) FIXED INITIAL(0,0,5,0,18,2,0,19,20,0,0,0,0,0,0,0,0,0,
4,7,8, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
,0,0,0,0,0);
 DECLARE   CRASH_SCAN_SYMBOLS BIT(63)  INITIAL ("(1)0 01011 00000 00001 00000
 00000 00101 11000 00101 11011 11101 10111 01010 00");
  DECLARE RECOVERY_SYMBOLS BIT(97) INITIAL("(1)0 00000 00000 00000 00000
00000  00000 00000 00000 00000 00010  00000 00000 10000 00000 00100 00000 00000
  00000 00010 0");
  DECLARE DOT BIT(16) INITIAL("01");
  DECLARE  STAT_LIST BIT(16) INITIAL("57");
  DECLARE STATEMENT BIT(16) INITIAL("56");
  DECLARE PROC_DECL_LIST BIT(16) INITIAL("83");
  DECLARE CASE_LIST BIT(16) INITIAL(91);
  DECLARE CASE_LIST_2 BIT(16) INITIAL(115);
  DECLARE  ELSE_TOKEN BIT(16) INITIAL("2B");
  DECLARE DUMMY_VAR_DECL_BODY BIT(16) INITIAL("99");
  DECLARE  VAR_DECLS BIT(16) INITIAL("55");
  DECLARE  TYPE_DEFNS BIT(16) INITIAL("60");
  DECLARE DUMMY_TYPE_BODY  BIT(16) INITIAL("8F");
  DECLARE CONST_DECLS BIT(16) INITIAL("71");
  DECLARE  SEMI_COLON BIT(16) INITIAL("02");
  DECLARE RIGHT_PAREN BIT(16) INITIAL("08");
   /*  DECLARATIONS FOR THE SCANNER                                        */

   /* TOKEN IS THE INDEX INTO THE VOCABULARY V() OF THE LAST SYMBOL SCANNED,
      CP IS THE POINTER TO THE LAST CHARACTER SCANNED IN THE CARDIMAGE,
      BCD IS THE LAST SYMBOL SCANNED (LITERAL CHARACTER STRING). */
   DECLARE (TOKEN, CP) FIXED, BCD CHARACTER;

   /* SET UP SOME CONVENIENT ABBREVIATIONS FOR PRINTER CONTROL */
   DECLARE EJECT_PAGE LITERALLY 'OUTPUT(1) = PAGE',
      PAGE CHARACTER INITIAL ('1'), DOUBLE CHARACTER INITIAL ('0'),
      DOUBLE_SPACE LITERALLY 'OUTPUT(1) = DOUBLE',
      X70 CHARACTER INITIAL ('                                                  
                    ');

   /* LENGTH OF LONGEST SYMBOL IN V */
   DECLARE (RESERVED_LIMIT, MARGIN_CHOP) FIXED;

   /* CHARTYPE() IS USED TO DISTINGUISH CLASSES OF SYMBOLS IN THE SCANNER.
      TX() IS A TABLE USED FOR TRANSLATING FROM ONE CHARACTER SET TO ANOTHER.
      CONTROL() HOLDS THE VALUE OF THE COMPILER CONTROL TOGGLES SET IN $ CARDS.
      NOT_LETTER_OR_DIGIT() IS SIMILIAR TO CHARTYPE() BUT USED IN SCANNING
      IDENTIFIERS ONLY.

      ALL ARE USED BY THE SCANNER AND CONTROL() IS SET THERE.
   */
   DECLARE CHARSET_SIZE LITERALLY  '255';
   DECLARE (CHARTYPE,TX) (CHARSET_SIZE) BIT(8),
    (CONTROL, NOT_LETTER_OR_DIGIT) (CHARSET_SIZE) BIT(1);

   /* MINUS_FLAG IS SET IN SYNTHESIZE PRODUCTIONS 86 AND 122 TO TELL GET_TOKEN
      TO FOLD THE VALUE OF A NEGATIVE CONSTANT. */
   DECLARE MINUS_FLAG BIT(1);

   /* ALPHABET CONSISTS OF THE SYMBOLS CONSIDERED ALPHABETIC IN BUILDING
      IDENTIFIERS     */
   DECLARE ALPHABET CHARACTER INITIAL ('ABCDEFGHIJKLMNOPQRSTUVWXYZ');

   /* BUFFER HOLDS THE LATEST CARDIMAGE,
      TEXT HOLDS THE PRESENT STATE OF THE INPUT TEXT
      (NOT INCLUDING THE PORTIONS DELETED BY THE SCANNER),
      TEXT_LIMIT IS A CONVENIENT PLACE TO STORE THE POINTER TO THE END OF TEXT,
      CARD_COUNT IS INCREMENTED BY ONE FOR EVERY SOURCE CARD READ,
      ERROR_COUNT TABULATES THE ERRORS AS THEY ARE DETECTED,
      SEVERE_ERRORS TABULATES THOSE ERRORS OF FATAL SIGNIFICANCE.
   */
   DECLARE (BUFFER, TEXT) CHARACTER,
      (TEXT_LIMIT, CARD_COUNT, ERROR_COUNT, SEVERE_ERRORS, PREVIOUS_ERROR) FIXED
      ;

   /* NUMBER_VALUE CONTAINS THE NUMERIC VALUE OF THE LAST CONSTANT SCANNED,
      WHEN THE CONSTANT IS REAL, IT SPILLS OVER INTO A SECOND WORD,
      THEREFORE NUMBER_VALUE IS DECLARED AS A TWO-ELEMENT ARRAY       */
   DECLARE NUMBER_VALUE (1) FIXED;

   /* EACH OF THE FOLLOWING CONTAINS THE INDEX INTO V() OF THE CORRESPONDING
      SYMBOL.   WE ASK:    IF TOKEN = IDENT    ETC.    */
   DECLARE (IDENT, INTCONST, REALCONST, NEOP, DIVIDE, EOFILE, BLANK,
            ANDSY, ORSY, NOTSY, LTOP, LEOP, STRING, LPARENT, LBRACKET, COLON,
            RPARENT, EQUALSIGN, RBRACKET) BIT(16);
  DECLARE (COMPILING,BATCHING) BIT(1);
   DECLARE NODE_NUMBER BIT(16),
           ERROR_NODE BIT(16) INITIAL (81),
           ERROR_PROD LITERALLY '213';
 DECLARE   NODE#TRANSLATE (NPR) BIT(8) INITIAL (0, 1,2,0,0,10, 0,0,4,0,0,
   0,5,0,0,0, 0,0,6,0,0, 0,0,0,0,0, 8,9,0,11,0, 12,0,0,0,0, 0,13,0,14,16,
   17,18,19,20,21, 23,24,70,51,53, 55,54,53,0,0, 0,0,0,0,0, 0,0,0,0,26,
   25,27,27,0,0, 0,80,28,0,0, 0,0,51,53,55, 54,0,59,60,61, 61,61,61,0,0,
   0,0,0,0,0, 0,0,62,0,73, 63,64,65,66,0, 0,67,68,0,0, 0,0,0,69,66,
   0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,30, 0,0,0,0,0, 0,0,0,0,0,
0,0,0,0,49, 0,31,0,50,50, 50,50,0,53,48, 50,0,0,0,0, 10,0,0,0,0, 0,75,0,77,78,
   79,79,80,0,0, 0,0,0,0,79, 0,0,79,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0);
   DECLARE PR# (NNT) BIT(8) INITIAL (ERROR_PROD, 28, 0, 0, 2,
      190, 0, 0, 0, 154,   144, 1, 0, 0, 162,   0, 78, 62, 56, 0,
      161, 0, 0, 0, 7,   26, 36, 0, 73, 82,   111, 182, 0, 0, 0,
      64, 0, 0, 0, 0, 103, 107, 110, 0, 0, 0, 0, 0, 0, 0, 0, 174,
      75, 87, ERROR_PROD,0, ERROR_PROD, 70, 0, 173, 0, 21, 33, 32,
      0, 0, 0, 192, 25, 5, 23, 183, 0, 0, 15, 17, 16, 0, 0, 0, 0,
      16, 106, 114, 179, 0, 41, 115, 0, 138, 0, 22, 181, 0, 113, 0);




   /* TRANSLATION TABLES USED BY THE SCANNER */
   DECLARE F8 LITERALLY '"FFFFFFFF"';
   DECLARE ALPHATABLE(63) FIXED INITIAL(F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      "FF00FFFF", F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      F8, F8, F8, F8, F8, "FF000000", 0, "0000FFFF", F8, "FF000000", 0,
      "0000FFFF", F8, "FFFF0000", 0, "0000FFFF", F8, 0, 0, "0000FFFF", F8);
   DECLARE BLANKTABLE(63) FIXED INITIAL(F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      F8, F8, F8, F8, F8, F8,"00FFFFFF", F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8, F8,
      F8);
   DECLARE COMMENTTABLE(63) FIXED INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, "000000FF", "FF000000", 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0);
   DECLARE STRINGTABLE(63) FIXED INITIAL(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "00FF0000", 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0);


   DECLARE S CHARACTER;  /* A TEMPORARY USED VARIOUS PLACES */

   /*THE PROPER SUBSTRING OF POINTER IS USED TO PLACE A $ UNDER THE POINT
      OF DETECTION OF AN ERROR DURING CHECKING.  IT MARKS THE LAST CHARACTER
      SCANNED.  */
   DECLARE POINTER CHARACTER INITIAL ('                                         
                                           $');
   DECLARE CALLCOUNT(20) FIXED   /* COUNT THE CALLS OF IMPORTANT PROCEDURES */
      INITIAL(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

   /* RECORD THE TIMES OF IMPORTANT POINTS DURING CHECKING */
   DECLARE (CLOCK, CPU_CLOCK) (3) FIXED;
   DECLARE ELAPSED_CPU_TIME LITERALLY 'CLOCK_TRAP(1)';


   /* COMMONLY USED STRINGS */
   DECLARE X1 CHARACTER INITIAL(' '), X4 CHARACTER INITIAL('    ');
   DECLARE PERIOD CHARACTER INITIAL ('.');

   /* TEMPORARIES USED THROUGHOUT THE COMPILER */
   DECLARE (I, J) FIXED;

   DECLARE TRUE LITERALLY '1', FALSE LITERALLY '0', FOREVER LITERALLY 'WHILE 1';
   DECLARE REAL LITERALLY 'BIT(32)';
   DECLARE @REAL LITERALLY 'FIXED';
   DECLARE MAXINT LITERALLY'2147483647';   /* 2**31 - 1 */
   DECLARE NUL LITERALLY '"FFFF"';

   /* THE DEBUG SET SWITCH */
   DECLARE DEBUGGING LITERALLY '0';

   DECLARE LAST_LITERAL_SCANNED FIXED,
           (CURRENT_LEVEL, PROC_LEVEL) FIXED;
   DECLARE LOOKUP_TYPE(NT) BIT(8);

   /*  THE STACKS DECLARED BELOW ARE USED TO DRIVE THE SYNTACTIC
      ANALYSIS ALGORITHM AND STORE INFORMATION RELEVANT TO THE INTERPRETATION
      OF THE TEXT.  */

   DECLARE STACKSIZE LITERALLY '75',
           FORESTSIZE LITERALLY '200';
   DECLARE PARSE_STACK (STACKSIZE) BIT(8); /* TOKENS OF THE PARTIALLY PARSED
                                              TEXT */

   /* SP POINTS TO THE RIGHT END OF THE REDUCIBLE STRING IN THE PARSE STACK,
      NT1 IS NT + 1  */
   DECLARE (SP, NT1) FIXED;


   /* THE SEMANTIC STACKS */
   DECLARE NODE_STACK(STACKSIZE) BIT(16),
           SUBTREE_INDEX(STACKSIZE) BIT(16),
           SUBTREE_STACK(FORESTSIZE) BIT(16),
           (NODE_STACKSIZE, SUBTREE_STACKSIZE) BIT(16);
   /* THE PARSE TREE */
   DECLARE #_OF_TREES BIT(16);
   DECLARE PARSE_TREE(7200) BIT(16), TREE_SIZE FIXED;
   DECLARE MAX_TREE FIXED;   /* SIZE OF LARGEST PARSE_TREE */

   /* THE SYMBOL TABLE */
   DECLARE IDENTITY_LENGTH LITERALLY '500';
   DECLARE TABLE_LENGTH LITERALLY '725';
   DECLARE #_PREDECLARED FIXED INITIAL (46);
   DECLARE BLOCK_DEPTH LITERALLY '25';
   DECLARE NEW LITERALLY '1', OLD LITERALLY '0';
   DECLARE BLOCK_CLOSURE_CODE BIT(1) INITIAL (NEW);
   DECLARE NESTING_LEVEL FIXED;
   DECLARE DUMMY_NAME# FIXED;
   DECLARE #_MULTIPLE_DECLARATIONS BIT(16);
   DECLARE DOLLAR CHARACTER INITIAL ('$');
   DECLARE (IS_WITHBLOCK, IS_QUALIFIED_REFERENCE) (BLOCK_DEPTH) BIT(1),
           (BLOCK_STACK, WITHCOUNT, PROCMARK, SYMB_BLOCK_OWNER) (BLOCK_DEPTH)
                  BIT(16);
   DECLARE  IS_PROC_CALL  BIT(1),
            IS_FUNC_CALL(BLOCK_DEPTH) BIT(1);
   DECLARE BUCKET (255) BIT(16);
   DECLARE IDENTITY (IDENTITY_LENGTH) CHARACTER INITIAL (
      'FALSE', 'TRUE', 'NIL', '(..)', 'INTEGER', 'BOOLEAN', 'REAL', 'CHAR',
      'TEXT', 'INPUT', 'OUTPUT', 'ABS', 'SQR', 'ODD', 'SUCC', 'PRED', 'ORD',
      'CHR', 'TRUNC', 'EOF', 'SIN', 'COS', 'EXP', 'LN', 'SQRT', 'ARCTAN',
      'ROUND', 'EOLN', 'GET', 'PUT', 'RESET', 'REWRITE', 'NEW', 'READ', 'WRITE',
      'PACK', 'UNPACK', 'MAXINT', 'DISPOSE', 'PAGE', 'READLN', 'WRITELN',
      'CLOCK', 'INTFIELDSIZE', 'BOOLFIELDSIZE', 'REALFIELDSIZE',
      'DECIMAL_PLACES');
   DECLARE DATATYPE (TABLE_LENGTH) BIT(16) INITIAL (
      5, 5, 2, 3, 37, 5, NUL, NUL, 7, 8,
      8, NUL, NUL, 5, NUL, NUL, 4, 7, 4, 5,
      6, 6, 6, 6, 6, 6, 4, 5, NUL, NUL,
      NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL, NUL,
      NUL, NUL, 4, 4, 4, 4, 4);
   DECLARE VAR_TYPE (TABLE_LENGTH) BIT(16) INITIAL (
      2, 2, 2, 2, 4, 4, 4, 4, 4, 1,
      1, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 2, 5, 5,
      5, 5, 5, 1, 1, 1, 1);
   DECLARE INTCHAIN FIXED INITIAL (NULL), REALCHAIN FIXED INITIAL (NULL),
              CHARCHAIN FIXED INITIAL (NULL);
   DECLARE WHERE_DECL(IDENTITY_LENGTH) BIT(16);
   DECLARE N_LOOKUPS(IDENTITY_LENGTH) BIT(16);
   DECLARE VALUE(TABLE_LENGTH) BIT(32);
   DECLARE SYMB_LINK(IDENTITY_LENGTH) BIT(16);
   DECLARE N_DECL_SYMB FIXED;
   DECLARE N_ANONYMOUS_SYMB FIXED;
   DECLARE LABEL_DECL BIT(1);
   DECLARE LABEL_LOOKUP BIT(1);
   DECLARE OWN_MOD FIXED;
   DECLARE CURRENT_BLOCK FIXED;
   DECLARE FIRST_LITERAL FIXED;
   DECLARE SYMB_OVFLO CHARACTER INITIAL(
           'SYMBOL TABLE OVERFLOW, COMPILATION ABORTED');

   /* POINTERS INTO THE SYMBOL TABLE TO THE PREDECLARED TYPES */
   DECLARE INTPTR  BIT(16) INITIAL(4),
           BOOLPTR BIT(16) INITIAL(5),
           REALPTR BIT(16) INITIAL(6),
           CHARPTR BIT(16) INITIAL(7);

   /* STORAGE ALLOCATION COUNTERS */
      DECLARE (CONST_POOL_SIZE, LITERAL_POOL_SIZE) FIXED;

   /* TYPE_DECL_PART IS USED TO ALLOW FORWARD REFERENCES IN POINTER TYPE
      DEFINITIONS.  FORWARD_REF_HEAD IS THE INDEX IN THE SYMBOL TABLE OF
      THE MOST RECENT FORWARD REFERENCE POINTER TYPE.  THESE ARE CHAINED
      TOGETHER BY THEIR S_LIST'S   */
   DECLARE TYPE_DECL_PART BIT(1), FORWARD_REF_HEAD BIT(16);

   /* PARAMETERS PASSED TO CLOCK_TRAP */
   DECLARE TIMEST FIXED INITIAL (360000),
           TIMETRAP FIXED INITIAL(0);


   /* IS_DECLARATION IS A FLAG USED TO INDICATE WHEN A NEW IDENTIFIER IS TO BE
      ENTERED IN THE CURRENT BLOCK, IF NOT ALREADY PRESENT THERE.
      VARTYPECODE IS THE VALUE TO BE ENTERED IN THE VAR_TYPE COLUMN.  IT IS
      SET, ALONG WITH IS_DECLARATION, IN PROCEDURE SYNTHESIZE.         */
   DECLARE IS_DECLARATION BIT(1),  VARTYPECODE FIXED;
   DECLARE (IS_FORWARD_DECL, IS_SCALAR_TYPE_DEFN) BIT(1);

   /* TYPE VAR_TYPES =
        (TYPE_ID, VARIABLE, CONSTANT, LITERAL, TYPE, PROC, VAR_PARAM,
         PROC_PARAM, UNDEFINED, LABLE, TAG, CASELABEL, VARIANT, FIELD_ID,
         FORWARD, MULTDECL, VALUE_PARAM); */

   DECLARE VARIABLE    BIT(16) INITIAL(01),
           CONSTANT    BIT(16) INITIAL(02),
           LITERAL     BIT(16) INITIAL(03),
           TYPE        BIT(16) INITIAL(04),
           PROC        BIT(16) INITIAL(05),
           VAR_PARAM   BIT(16) INITIAL(06),
           PROC_PARAM  BIT(16) INITIAL(07),
           UNDEFINED   BIT(16) INITIAL(08),
           LABLE       BIT(16) INITIAL(09),
           DEFN_LABEL  BIT(16) INITIAL (11),
           VARIANT     BIT(16) INITIAL(12),
           FIELD_ID    BIT(16) INITIAL(13),
           FORWARD     BIT(16) INITIAL(14),
           MULTDECL    BIT(16) INITIAL(15),
           VALUE_PARAM BIT(16) INITIAL(16);
   DECLARE RECORD BIT(16) INITIAL (17);

   /*   FLOATING POINT POWERS OF TEN */
   DECLARE POWERS(307) REAL INITIAL("001DA48C", "E468E7C7", "011286D8",
      "0EC190DC", "01B94470", "938FA89C", "0273CAC6", "5C39C961", "03485EBB",
      "F9A41DDD", "042D3B35", "7C0692AA", "051C4501", "6D841BAA", "0611AB20",
      "E472914A", "06B0AF48", "EC79ACE8", "076E6D8D", "93CC0C11", "08450478",
      "7C5F878B", "092B22CB", "4DBBB4B7", "0A1AF5BF", "109550F2", "0B10D997",
      "6A5D5297", "0BA87FEA", "27A539EA", "0C694FF2", "58C74432", "0D41D1F7",
      "777C8A9F", "0E29233A", "AAADD6A4", "0F19B604", "AAACA626", "101011C2",
      "EAABE7D8", "10A0B19D", "2AB70E6F", "11646F02", "3AB26905", "123EC561",
      "64AF81A3", "13273B5C", "DEEDB106", "1418851A", "0B548EA4", "14F53304",
      "714D9266", "15993FE2", "C6D07B80", "165FC7ED", "BC424D30", "173BDCF4",
      "95A9703E", "18256A18", "DD89E627", "1917624F", "8A762FD8", "19E9D71B",
      "689DDE72", "1A922671", "2162AB07", "1B5B5806", "B4DDAAE4", "1C391704",
      "310A8ACF", "1D23AE62", "9EA696C1", "1E164CFD", "A3281E39", "1EDF01E8",
      "5F912E38", "1F8B6131", "3BBABCE3", "20571CBE", "C554B60E", "213671F7",
      "3B54F1C9", "2222073A", "8515171D", "23154484", "932D2E72", "23D4AD2D",
      "BFC3D078", "2484EC3C", "97DA624B", "255313A5", "DEE87D6F", "2633EC47",
      "AB514E65", "272073AC", "CB12D0FF", "2814484B", "FEEBC2A0", "28CAD2F7",
      "F5359A3B", "297EC3DA", "F9418065", "2A4F3A68", "DBC8F03F", "2B318481",
      "895D9627", "2C1EF2D0", "F5DA7DD9", "2D1357C2", "99A88EA7", "2DC16D9A",
      "0095928A", "2E78E480", "405D7B96", "2F4B8ED0", "283A6D3E", "302F3942",
      "19248447", "311D83C9", "4FB6D2AC", "3212725D", "D1D243AC", "32B877AA",
      "3236A4B4", "33734ACA", "5F6226F1", "34480EBE", "7B9D5856", "352D0937",
      "0D425736", "361C25C2", "68497682", "37119799", "812DEA11", "37AFEBFF",
      "0BCB24AB", "386DF37F", "675EF6EB", "3944B82F", "A09B5A53", "3A2AF31D",
      "C4611874", "3B1AD7F2", "9ABCAF48", "3C10C6F7", "A0B5ED8D", "3CA7C5AC",
      "471B4784", "3D68DB8B", "AC710CB3", "3E418937", "4BC6A7F0", "3F28F5C2",
      "8F5C28F6", "40199999", "9999999A", "41100000", "00000000", "41A00000",
      "00000000", "42640000", "00000000", "433E8000", "00000000", "44271000",
      "00000000", "45186A00", "00000000", "45F42400", "00000000", "46989680",
      "00000000", "475F5E10", "00000000", "483B9ACA", "00000000", "492540BE",
      "40000000", "4A174876", "E8000000", "4AE8D4A5", "10000000", "4B9184E7",
      "2A000000", "4C5AF310", "7A400000", "4D38D7EA", "4C680000", "4E2386F2",
      "6FC10000", "4F163457", "85D8A000", "4FDE0B6B", "3A764000", "508AC723",
      "0489E800", "5156BC75", "E2D63100", "523635C9", "ADC5DEA0", "5321E19E",
      "0C9BAB24", "54152D02", "C7E14AF7", "54D3C21B", "CECCEDA1", "55845951",
      "61401485", "5652B7D2", "DCC80CD3", "5733B2E3", "C9FD0804", "58204FCE",
      "5E3E2502", "591431E0", "FAE6D721", "59C9F2C9", "CD04674F", "5A7E37BE",
      "2022C091", "5B4EE2D6", "D415B85B", "5C314DC6", "448D9339", "5D1ED09B",
      "EAD87C03", "5E134261", "72C74D82", "5EC097CE", "7BC90716", "5F785EE1",
      "0D5DA46E", "604B3B4C", "A85A86C4", "612F050F", "E938943B", "621D6329",
      "F1C35CA5", "63125DFA", "371A19E7", "63B7ABC6", "27050306", "6472CB5B",
      "D86321E4", "6547BF19", "673DF52E", "662CD76F", "E086B93D", "671C06A5",
      "EC5433C6", "68118427", "B3B4A05C", "68AF298D", "050E4396", "696D79F8",
      "2328EA3E", "6A446C3B", "15F99267", "6B2AC3A4", "EDBBFB80", "6C1ABA47",
      "14957D30", "6D10B46C", "6CDD6E3E", "6DA70C3C", "40A64E6C", "6E6867A5",
      "A867F104", "6F4140C7", "8940F6A2", "7028C87C", "B5C89A25", "71197D4D",
      "F19D6057", "71FEE50B", "7025C36A", "729F4F27", "26179A22", "73639178",
      "77CEC055", "743E3AEB", "4AE13835", "7526E4D3", "0ECCC321", "76184F03",
      "E93FF9F5", "76F31627", "1C7FC391", "7797EDD8", "71CFDA3A", "785EF4A7",
      "4721E864", "793B58E8", "8C75313F", "7A251791", "57C93EC7", "7B172EBA",
      "D6DDC73D", "7BE7D34C", "64A9C85D", "7C90E40F", "BEEA1D3A", "7D5A8E89",
      "D7525244", "7E389916", "2693736B", "7F235FAD", "D81C2823");

   /* FLAGS TO SIGNAL EMPTY CASE INSTANCE OR EMPTY FIXED FIELD */
   DECLARE IS_EMPTY_CASE_INSTANCE BIT(1) INITIAL(FALSE),
           IS_EMPTY_FIELD_LIST BIT(1) INITIAL(FALSE);

   /* #_PRODS IS THE NUMBER OF PRODUCTIONS IN THE INTERNAL GRAMMAR */
   DECLARE #_PRODS LITERALLY '81';

   /* LEFT HAND SIDES IN INTERNAL FORM OF GRAMMAR */
   DECLARE LEFT_PART(#_PRODS) CHARACTER INITIAL('', '<PROGRAM>', '<BLOCK>',
      '<STATEMENT LIST>', '<LABEL DECL>', '<CONST DECL>', '<TYPE DEFN>',
      '<PROC DECL LIST>', '<PROC DECL>', '<PROC DECL>', '<BODY>',
      '<VAR DECL LIST>', '<VAR DECL>', '<STATEMENT>', '<STATEMENT>',
      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',
      '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>', '<STATEMENT>',
      '<FORMAL PARAM>', '<FORMAL PARAM>', '<FORMAL PARAM>', '<CASE INSTANCE>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>', '<EXPRESSION>',
      '<EXPRESSION>', '<EXPRESSION>', '<VARIABLE>', '<VARIABLE>', '<QUALIFIER>',
      '<QUALIFIER>', '<QUALIFIER>', '<QUALIFIER>', '<CONSTANT>', '<CONSTANT>',
      '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>',
      '<TYPE>', '<FIXED FIELD LIST>', '<VARIANT FIELD>', '<VARIANT INSTANCE>',
      '<STATEMENT>', '<TYPE>', '<TYPE>', '<TYPE>', '<TYPE>', '<ELEMENT>',
      '<ELEMENT>', '<PARAM TYPES>', '<PARAM TYPES>', '<PARAM TYPES>',
      '<PARAM TYPES>', '<ERROR>');





   /*               P R O C E D U R E S                                  */



I_FORMAT:
   PROCEDURE (NUMBER, WIDTH) CHARACTER;
      DECLARE (NUMBER, WIDTH, L) FIXED, STRING CHARACTER;

      STRING = NUMBER;
      L = LENGTH(STRING);
      IF L >= WIDTH THEN RETURN STRING;
      ELSE RETURN SUBSTR('0000000000', 0, WIDTH-L) || STRING;
   END I_FORMAT;

ERROR:
   PROCEDURE(MSG, SEVERITY);
      /* PRINTS AND ACCOUNTS FOR ALL ERROR MESSAGES */
      /* IF SEVERITY IS NOT SUPPLIED, 0 IS ASSUMED */
      DECLARE MSG CHARACTER, SEVERITY FIXED;
      DECLARE TP FIXED INITIAL (0);
      /* IF LISTING IS SUPPRESSED, FORCE PRINTING OF THIS LINE */
      IF ~ CONTROL(BYTE('L')) THEN
         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|';
      IF TEXT_LIMIT ~= TP | CARD_COUNT ~= PREVIOUS_ERROR THEN DO;
      OUTPUT = SUBSTR(POINTER, TEXT_LIMIT-CP+MARGIN_CHOP);
      OUTPUT = '*** ERROR, ' || MSG ||
            '.  LAST PREVIOUS ERROR WAS DETECTED ON LINE ' ||
            PREVIOUS_ERROR || '.  ***';
      ERROR_COUNT = ERROR_COUNT + 1;
      TP = TEXT_LIMIT;
      PREVIOUS_ERROR = CARD_COUNT;
      IF SEVERITY > 0 THEN
         IF SEVERE_ERRORS > 25 THEN
            DO;
               OUTPUT = '*** TOO MANY SEVERE ERRORS, CHECKING ABORTED ***';
               COMPILING = FALSE;
            END;
         ELSE
            DO;
               SEVERE_ERRORS = SEVERE_ERRORS + 1;
               MONITOR_LINK(2) = 0;   /* DEBUG LEVEL <--- 0 */
            END;
      END;
      ELSE DO;
         OUTPUT = '***        ' || MSG;
         IF SEVERITY = 1 & SEVERE_ERRORS = 0 THEN SEVERE_ERRORS = 1;
         END;
      SEVERITY = 0; /* IN CASE SEVERITY IS NOT SPECIFIED NEXT TIME */
   END ERROR;

IS_TERMINAL:  PROCEDURE (I) BIT(1);
   /* SIMULATES A BIT(1) ARRAY USING THE BIT STRING 'TERMINAL'.       */
   DECLARE I FIXED;
      RETURN(SHL(BYTE(TERMINAL, SHR(I, 3)), I & "07") &"80")~= 0;
   END IS_TERMINAL;


   IS_DECLARATION_NODE:
      PROCEDURE (SP) BIT(1);
         DECLARE (SP, NODE_NUMBER) BIT(16);
         DECLARE DECLARATION_NODES BIT(96) INITIAL ("(1) 0000 0010 0100 1000 000
0 0000 0111 0000 0000 0000 0000 0000 0000 0000 0000 0010 0001 0000 0000 0000
0000 0000 0000 0000");
         NODE_NUMBER = NODE_STACK(SP);
         SP = BYTE (DECLARATION_NODES, SHR(NODE_NUMBER, 3));
         RETURN SHR (SP, 7 - (NODE_NUMBER & 7)) & 1;
      END IS_DECLARATION_NODE;

   IS_ARRAY_OR_FILE_TYPE:
      PROCEDURE (SP) BIT(1);
         DECLARE (SP, NODE_NUMBER) BIT(16);
         DECLARE ARRAY_OR_FILETYPE BIT(96) INITIAL ("(1) 0000 0000 0000 0000 000
0 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0011 1000 0001 1100 0000
0000 0000 0000 0000");
         NODE_NUMBER = NODE_STACK(SP);
         SP = BYTE (ARRAY_OR_FILETYPE, SHR(NODE_NUMBER, 3));
         RETURN SHR (SP, 7 - (NODE_NUMBER & 7)) & 1;
      END IS_ARRAY_OR_FILE_TYPE;

UNDERLYING_TYPE:
   PROCEDURE (TP) BIT(16);
      DECLARE TP BIT(16);
      DO WHILE TP > #_PREDECLARED & DATATYPE(TP) ~= TP;
         TP = DATATYPE(TP);
         END;
      RETURN TP;
   END UNDERLYING_TYPE;

   ASSOCIATE_TYPE_WITH_ID:
      PROCEDURE;
         DECLARE (ID_PTR, SP) BIT(16);
      DECLARE NSP BIT(16);
      IS_NO_CYCLE:
         /* CHECKS FOR POSSIBLE CYCLIC DATATYPE CHAINS */
         PROCEDURE (T1, T2) BIT(1);
            DECLARE (T1, T2) BIT(16);
            DO WHILE T2 > #_PREDECLARED & DATATYPE(T2) ~= T2;
               T2 = DATATYPE(T2);
               IF T1 = T2 THEN RETURN FALSE;
               END;
            RETURN TRUE;
         END IS_NO_CYCLE;

         NSP = NODE_STACKSIZE;
         DO WHILE IS_ARRAY_OR_FILE_TYPE(NSP);
            NSP = NSP - 1;
            END;
         IF ~IS_DECLARATION_NODE(NSP) THEN RETURN;
         /* ELSE ALLOCATE TYPE WITH VARIABLE OR FIELD IDENTIFIERS */
         IF (LAST_LITERAL_SCANNED > #_PREDECLARED) &
                   (DATATYPE(LAST_LITERAL_SCANNED) = NULL) THEN
               DATATYPE(LAST_LITERAL_SCANNED) = LAST_LITERAL_SCANNED;
         IF TYPE_DECL_PART THEN DO;
               /* CHOOSE THE FIRST LEAF NODE ON THE SUBTREE STACK */
               SP = SUBTREE_STACKSIZE;
               DO WHILE PARSE_TREE(SUBTREE_STACK(SP)) > 0;
                  SP = SP - 1;
                  END;
               ID_PTR = PARSE_TREE(SUBTREE_STACK(SP) + 1);
              IF ID_PTR > #_PREDECLARED THEN
                  IF IS_NO_CYCLE (ID_PTR, LAST_LITERAL_SCANNED) THEN
                  DATATYPE(ID_PTR) = LAST_LITERAL_SCANNED;
                  ELSE CALL ERROR ('CYCLIC TYPE DECLARATION', 1);
               IF NODE_STACK(SP) = 6 THEN /* A TYPE RENAMING, PROPAGATE THE */
                  VALUE(ID_PTR) = VALUE(LAST_LITERAL_SCANNED);  /* BLOCK NO. */
               END;
         ELSE DO SP = SUBTREE_INDEX(NSP) TO SUBTREE_STACKSIZE;
            IF PARSE_TREE(SUBTREE_STACK(SP)) = 0 THEN DO;
               ID_PTR = PARSE_TREE(SUBTREE_STACK(SP) + 1);
               IF ID_PTR > #_PREDECLARED THEN
                  DATATYPE(ID_PTR) = LAST_LITERAL_SCANNED;
               END;
            END;
      END ASSOCIATE_TYPE_WITH_ID;

 /******************************************************************************
*                                                                              *
*                                                                              *
*        THE DGNS MODULE FOR PASCAL COMPILER                                   *
*        DESIGNED BY                                                           *
*             JOHN HENNESSY     GARY GOLDSTEIN     CHIA CHINSAW                *
*                                                                              *
*        MSC 522        DATE  10/29/74   VERSION 1                             *
*               VERSION UPDATE 3  INCLUDES ERROR MESSAGES AND DEBUGGING CODE   *
*                                                                              *
*                  P U R P O S E                                               *
*                       TO PREPARE THE PARGRAPHED VERSION OF THE SOURCE CODE   *
*                       AND SET BASIC BLOCK POINTERS  (SEE SPECS. AND DOCUMENT.*
*                                                                              *
*                                                                              *
*******************************************************************************/

 /******************************************************************************
*                                                                              *
*        THE FOLLOWING DECLARATION MUST APPEAR    THESE ARE GLOBAL INPUTS      *
*                                                                              *
*******************************************************************************/
     DECLARE DGNS#_FILE_NO FIXED INITIAL(3);
     DECLARE STRING_VALUE CHARACTER;

 /******************************************************************************
*                                                                              *
*                                                                              *
*        THE FOLLOWING ARE GLOBAL VARIABLE DECLARATIONS OF OUTSIDE INTEREST    *
*       THEY ARE EITHER DECLARATIONS OF OUTPUTED VARIABLES OR MACROS           *
*                                                                              *
*                                                                              *
*******************************************************************************/
DECLARE MAX_DEPTH LITERALLY '31',
        BB_FLAG BIT(1),   /* SIGNALS START OF BASIC BLOCK */
        (SUMMARY_BLOCKS, BASIC_BLOCKS) FIXED,
        SUMMARY(7199) BIT(8);

 /******************************************************************************
*                                                                              *
*                                                                              *
*        THE FOLLOWING DECLARATIONS ARE FOR GLOBAL VARIABLES WHICH ARE         *
*        REQUIRED FOR THE DGNS MODULE.(SEE SPECS. AND DOCUMENTATION.)          *
*        WHICH ARE NOT OF OUTSIDE INTEREST(I.E. THEY ARE OWN VARIABLES)        *
*                                                                              *
*                                                                              *
*******************************************************************************/
DECLARE DGNS#_STR CHARACTER,
        (DGNS#_INCR, DGNS#_DECR, DGNS#_PTR, DGNS#_GOTO,
        DGNS#_PROC, DGNS#_TOP2, IN_PROC_FLAG) BIT(1),
        DGNS#_TOP1 BIT(8),
        (DGNS#_LINE_NO, DGNS#_LAST_TOKEN, DGNS#_POS, DGNS#_INDEX,
        DGNS#_DEPTH) FIXED,
        DGNS#_IS_PROC_HEADING BIT(1), DGNS#_PAREN_COUNT FIXED,
        DGNS#_STACK1(MAX_DEPTH) BIT(8),
        DGNS#_STACK2(MAX_DEPTH) BIT(1);

DGNS#_INITIALIZE:
   PROCEDURE;
      SUMMARY_BLOCKS, BASIC_BLOCKS = 0;
      DGNS#_DEPTH = -1;
      DGNS#_INCR, DGNS#_DECR, DGNS#_PTR, IN_PROC_FLAG = FALSE;
      DGNS#_GOTO, DGNS#_PROC, DGNS#_TOP2 = FALSE;
      DGNS#_TOP1, DGNS#_LINE_NO, DGNS#_INDEX = 0;
      DGNS#_POS = 1;
   END DGNS#_INITIALIZE;

DGNS#_BLANK:
   PROCEDURE CHARACTER;

   IS_ALPHANUMERIC:
      PROCEDURE(M) BIT(1);
         DECLARE M FIXED;
         DECLARE ALPHANUMERIC BIT(63) INITIAL("(1) 0 00000 00000 00001 11000
            10000 11011 11111 11111 11111 11111 11111 11011 11");
         RETURN (SHL(BYTE(ALPHANUMERIC,SHR(M,3)),M & "07") & "80") ~= 0;
      END IS_ALPHANUMERIC;

   IS_OPERATOR:
      PROCEDURE(N) BIT(1);
         DECLARE N FIXED;
         DECLARE OPERATOR BIT(63) INITIAL("(1) 0 00011 00011 11001 11100 10111
            11000 00000 00011 00100 00100 01000 00000 00");
         RETURN (SHL(BYTE(OPERATOR,SHR(N,3)),N & "07") & "80") ~= 0;
      END IS_OPERATOR;

      IF IS_OPERATOR(DGNS#_LAST_TOKEN) | IS_OPERATOR(TOKEN) |
         (DGNS#_LAST_TOKEN = 2) /* SEMICOLON */ THEN RETURN X1;
      IF IS_ALPHANUMERIC(DGNS#_LAST_TOKEN) THEN IF IS_ALPHANUMERIC(TOKEN) THEN
         RETURN X1;
      RETURN '';
   END DGNS#_BLANK;

 /******************************************************************************
*                                                                              *
*         PROCEDURE DGNS#_CONVERT                                              *
*                  THIS PROCEDURE COMPLETES THE INTERFACE TO THE SCANNER TO    *
*                  HANDLE THE CASE OF STRINGS WHERE QUOTES MUST BE REINSERTED  *
*                                                                              *
*******************************************************************************/
DGNS#_CONVERT: PROCEDURE(STRING_VALUE) CHARACTER;
     DECLARE STRING_VALUE CHARACTER;
     DECLARE I FIXED,TEMP CHARACTER;
     TEMP='''';
     DO I=0 TO LENGTH(STRING_VALUE) - 1;
          IF SUBSTR(STRING_VALUE,I,1)='''' THEN TEMP=TEMP||'''''';
          ELSE TEMP=TEMP||SUBSTR(STRING_VALUE,I,1);
     END;
     RETURN(TEMP||'''');
END DGNS#_CONVERT;

 /******************************************************************************
*                                                                              *
*        PROCEDURE NEW_BLOCK                                                   *
*                       THIS PROCEDURE DUMPS THE CURRENT SUMMARY BLOCK         *
*                       TO THE FILE NUMBER DECLARED FILE_NO & RESETS DGNS#_POS *
*                                                                              *
*******************************************************************************/
DGNS#_NEW_BLOCK: PROCEDURE;
     /* SEE IF SUMMARY FULL IF NOT INSERT ZERO LENGTH FIELD    */
     IF DGNS#_POS<7199 THEN SUMMARY(DGNS#_POS+1)=0;
     FILE(DGNS#_FILE_NO, SUMMARY_BLOCKS) = SUMMARY;   /* OUTPUT THE BLOCK */
     SUMMARY_BLOCKS=SUMMARY_BLOCKS+1; /* INCREMENT SUMMARY BLOCK COUNT   */
     DGNS#_POS = 1;   /* RESET POSITION POINTER */
     SUMMARY(0) = 0;   /* ASSUME LAST SUMMARY BLOCK */
END DGNS#_NEW_BLOCK;

 /******************************************************************************
*                                                                              *
*        PROCEDURE SYM                                                         *
*                       PUT THE STRING DGNS#_STR INTO THE SUMMARY BLOCK AS     *
*                       ONE SUMMARY LINE OF OUTPUT                             *
*                                                                              *
*******************************************************************************/
DGNS#_SYM: PROCEDURE;
     DECLARE I FIXED;
     DECLARE STRING_LENGTH FIXED INITIAL (0);
     STRING_LENGTH=LENGTH(DGNS#_STR);
     IF STRING_LENGTH=0 THEN RETURN;
     IF SUBSTR(DGNS#_STR,0,1)= X1 THEN DO;
          DGNS#_STR=SUBSTR(DGNS#_STR,1);
          STRING_LENGTH=STRING_LENGTH-1;
     IF STRING_LENGTH=0 THEN RETURN;
     END;
     /* IF FULL THEN CALL NEW_BLOCK     */
     IF (DGNS#_POS + STRING_LENGTH + 6) > 7199 THEN
         DO;
            SUMMARY(0) = 1;   /* NOT LAST SUMMARY BLOCK */
            CALL DGNS#_NEW_BLOCK;
         END;
     SUMMARY(DGNS#_POS)=DGNS#_INDEX; /*   INSERT LINE INDENTING   */
     SUMMARY(DGNS#_POS+1)=STRING_LENGTH; /* INSERT THE LINELENGTH     */
     SUMMARY(DGNS#_POS+2) = SHR(DGNS#_LINE_NO,8);
     SUMMARY(DGNS#_POS+3) = DGNS#_LINE_NO;
     IF BB_FLAG THEN
         DO;
            SUMMARY(DGNS#_POS + 4) = SHR(BASIC_BLOCKS, 8);
            SUMMARY(DGNS#_POS + 5) = BASIC_BLOCKS;
            BASIC_BLOCKS = BASIC_BLOCKS + 1;
            BB_FLAG = FALSE;
         END;
     ELSE SUMMARY(DGNS#_POS + 4), SUMMARY(DGNS#_POS + 5) = NULL;
     DO I=0 TO STRING_LENGTH-1;
          SUMMARY(DGNS#_POS+I+6)=BYTE(DGNS#_STR,I);  /*  INSERT THE CHARACTERS*/
     END;
     /*    UPDATE THE POSITION POINTER AND RESET DGNS#_STR TO EMPTY    */
     DGNS#_POS=DGNS#_POS+STRING_LENGTH+6;
     DGNS#_STR='';
   END DGNS#_SYM;

 /******************************************************************************
*                                                                              *
*        PROCEDURE CHANGE                                                      *
*                       THIS PROCEDURE IMPLEMENTS THE INDENTING & DEDENTING    *
*                                                                              *
*******************************************************************************/
DGNS#_CHANGE:PROCEDURE(PARM);
     /*  PARM DENOTED INDENT OR DEDENT      */
     DECLARE PARM BIT(1);
     DECLARE INDEX_INC FIXED INITIAL(3);
     IF PARM THEN DO;
          DGNS#_INCR="0";
          DGNS#_INDEX = DGNS#_INDEX + INDEX_INC;
     END;
     ELSE DO;
          DGNS#_DECR="0";
          DGNS#_INDEX = DGNS#_INDEX - INDEX_INC;
     END;
END DGNS#_CHANGE;

 /******************************************************************************
*                                                                              *
*        PROCEDURE NEW_LINE                                                    *
*                       THIS PROCEDURE CHECKS WHEN THE PROGRAMMER STARTS A NEW *
*                       LINE(CARD) AND DOES THE SAME IN SUMMARY                *
*                                                                              *
*******************************************************************************/
DGNS#_NEW_LINE:PROCEDURE;
     DECLARE TEMP FIXED;
     DECLARE TEMP_STRING CHARACTER;
     IF LENGTH(BUFFER) = LENGTH(TEXT) - CP THEN TEMP = CARD_COUNT - 1;
          ELSE TEMP = CARD_COUNT;
     TEMP_STRING = DGNS#_BLANK;
     /* IF NOT A NEW LINE THEN CONCATENATE SYMBOL                          */
     IF DGNS#_LINE_NO = TEMP THEN
          DGNS#_STR = DGNS#_STR || TEMP_STRING || STRING_VALUE;
     ELSE DO;
          IF DGNS#_DECR THEN CALL DGNS#_CHANGE("0");
          /*   OTHERWISE START A NEW LINE      */
          IF DGNS#_STR ~= '' THEN CALL DGNS#_SYM;
          DGNS#_LINE_NO=CARD_COUNT;
          DGNS#_STR=STRING_VALUE;
     END;
END DGNS#_NEW_LINE;

 /******************************************************************************
*                                                                              *
*        PROCEDURE STACK                                                       *
*                       MANAGES A STACK OF 2 THINGS ONE BIT(8) THE OTHER       *
*                       BIT(1) HANDLES POP,PUSH,OVERFLOW,UNDERFLOW             *
*                                                                              *
*******************************************************************************/
 DGNS#_STACK:PROCEDURE (ELEMENT);
      DECLARE ELEMENT BIT(8) INITIAL(0);
     /*  CHECK FOR OVERFLOW THEN UNDERFLOW      */
     IF (DGNS#_DEPTH=MAX_DEPTH+1)&(ELEMENT~=0)THEN DO; /* STACK OVERFLOW   */
          CALL ERROR('COMPILER ERROR - DGNS STACK OVERFLOW', 0);
          RETURN;
     END;
     ELSE IF (DGNS#_DEPTH=-1)&(ELEMENT=0) THEN DO;
          DGNS#_DEPTH=-2;
          RETURN ;
     END;
               /*   PROCESS POP OPERATION      */
             IF ELEMENT=0 THEN DO;
             POP:DGNS#_DEPTH=DGNS#_DEPTH-1;
                 DGNS#_TOP1=DGNS#_STACK1(DGNS#_DEPTH);
                 DGNS#_TOP2 = DGNS#_TOP2 | DGNS#_STACK2(DGNS#_DEPTH);
                 DGNS#_STACK2(DGNS#_DEPTH)=DGNS#_TOP2;
                  END;
        ELSE DO;
               /*   PROCESS THE PUSH OPERATION      */
             PUSH:DGNS#_DEPTH=DGNS#_DEPTH+1;
             DGNS#_TOP1,DGNS#_STACK1(DGNS#_DEPTH)=ELEMENT;
             DGNS#_TOP2,DGNS#_STACK2(DGNS#_DEPTH)=0;
          DGNS#_GOTO = FALSE;
       END;
  END DGNS#_STACK;

 /******************************************************************************
*                                                                              *
*        PROCEDURE SET_PTR                                                     *
*                       THIS PROCEDURE SETS THE BASIC BLOCK POINTERS           *
*                       AND CALL SYM TO DUMP THE LINE FOR THE BASIC BLOCK      *
*                                                                              *
*******************************************************************************/
DGNS#_SET_PTR:PROCEDURE;
     DGNS#_PTR = FALSE;
     CALL DGNS#_SYM;
          /*  INCREMENT THE BASIC BLOCK COUNT AND SET THE BASIC BLOCK FLAG */
     BB_FLAG = TRUE;
END DGNS#_SET_PTR;

 /******************************************************************************
*                                                                              *
*        PROCEDURE PARAGRAPH                                                   *
*        MAIN PROCEDURE OF THE DGNS MODULE                                     *
*                       THIS PROCEDURE EXAMINES TOKENS, LOOKING FOR BASIC      *
*                       BLOCKS AND THEIR ENDINGS AND HANDLES THE INCR DECR     *
*                       AND POINTER SETTING FLAGS                              *
*                                                                              *
*******************************************************************************/
PARAGRAPH:PROCEDURE;
     /* THE FOLLOWING ARE THE DECLARATIONS FOR THE TOKEN VALUES WHICH SHOULD
        ADJUSTED TO ADHERE TO THOSE OF THE SCANNER BEING USED         */
DECLARE UNTIL$               FIXED INITIAL(49),
        REPEAT$              FIXED INITIAL(51),
        ID$                  FIXED INITIAL(60),
        BEGIN$               FIXED INITIAL(45),
        ELSE$                FIXED INITIAL(43),
        GOTO$                FIXED INITIAL(42),
        THEN$                FIXED INITIAL(39),
        END$                 FIXED INITIAL(29),
        EOP$                 FIXED INITIAL(28),
        COLON$               FIXED INITIAL(05),
        ASSIGN$              FIXED INITIAL(18),
        DO$                  FIXED INITIAL(17),
        OF$                  FIXED INITIAL(16),
        PROCEDURE$           FIXED INITIAL(59),
        FUNCTION$            FIXED INITIAL(57),
        SEMICOLON$           FIXED INITIAL(02);
     /*   LOCAL VARIABLE DECLARATIONS     */
     DECLARE INDEX_INC FIXED INITIAL(3);
     DECLARE TEMP_INDEX FIXED;
     DECLARE FLAG BIT(1);
     DECLARE STR_LENGTH FIXED;
     DECLARE TEMP CHARACTER;
     DECLARE CH BIT(8);

     POP$: PROCEDURE BIT(8);
          IF (DGNS#_TOP1=THEN$) | (DGNS#_TOP1=ELSE$) | (DGNS#_TOP1=DO$) THEN
               RETURN (DGNS#_TOP1);
          ELSE RETURN(0);
     END POP$;

     /* CHECK FOR FATAL ERROR PREVIOUSLY  */
     IF DGNS#_DEPTH<-1 THEN RETURN;
     IF TOKEN = STRING THEN STRING_VALUE = DGNS#_CONVERT(BCD);
     ELSE IF (TOKEN=IDENT) | (TOKEN=INTCONST) | (TOKEN = REALCONST) THEN
          STRING_VALUE = BCD;
     ELSE STRING_VALUE = V(TOKEN);
     /* TEST FOR END OF PROGRAM   IF SO THEN OUTPUT SUMMARY */
     IF TOKEN=EOP$ THEN DO;
          DGNS#_INDEX = 0;
          CALL DGNS#_SYM;
          CALL DGNS#_NEW_BLOCK;
          RETURN;
     END;
     IF (TOKEN=PROCEDURE$) | (TOKEN=FUNCTION$) THEN DO;
         IF ~DGNS#_IS_PROC_HEADING THEN
            DO;
               IF DGNS#_DECR THEN CALL DGNS#_CHANGE(FALSE);
               DGNS#_IS_PROC_HEADING = TRUE;
               DGNS#_PAREN_COUNT = 0;
               CALL DGNS#_SYM;
               IN_PROC_FLAG = TRUE;
               DGNS#_STR = '  ';
               CALL DGNS#_SYM;
            END;
     END;
     /* IF NOT IN STATEMENT BLOCK YET AND TOKEN IS NOT A BEGIN
       THEN RETURN  AND WAIT FOR BEGIN */
     IF (DGNS#_DEPTH=-1) & (TOKEN~=BEGIN$) THEN DO;
          IF DGNS#_IS_PROC_HEADING THEN
            DO;
               IF TOKEN = LPARENT THEN
                  DGNS#_PAREN_COUNT = DGNS#_PAREN_COUNT + 1;
               ELSE IF TOKEN = RPARENT THEN
                  DGNS#_PAREN_COUNT = DGNS#_PAREN_COUNT - 1;
               ELSE IF TOKEN = SEMICOLON$ THEN
                  DGNS#_IS_PROC_HEADING = (DGNS#_PAREN_COUNT > 0);
            END;
          CALL DGNS#_NEW_LINE;
          RETURN;
     END;
     /*   IF FLAG FOR POINTER SETTING IS ON THEN CALL ROUTINE   */
     IF DGNS#_PTR THEN CALL DGNS#_SET_PTR;
     /* TEST IF WE SHOULD INCREMENT OR DECREMENT AND CALL ROUTINE */
     IF DGNS#_DECR THEN CALL DGNS#_CHANGE("0");
     IF DGNS#_INCR THEN CALL DGNS#_CHANGE("1");
     IF DGNS#_LAST_TOKEN = ELSE$ THEN DGNS#_INDEX = DGNS#_INDEX + INDEX_INC;
     /* TEST FOR TOKEN BEING A BEGIN OR REPEAT  OR CASE  */
     IF (TOKEN=BEGIN$)|(TOKEN=REPEAT$)|(TOKEN=OF$) THEN DO;
          IF (DGNS#_DEPTH=-1)&(~IN_PROC_FLAG) THEN DO;
               CALL DGNS#_SYM;
               DGNS#_STR = '  ';
               CALL DGNS#_SYM;
          END;
          DGNS#_INCR="1";  /* SET INDEX FLAG */
          /*  IF THE STATEMENT IS NOT A CASE THEN SET BASIC BLOCK FLAG  */
          IF TOKEN~=OF$ THEN DGNS#_PTR="1";
          ELSE DO;
               DGNS#_STR=DGNS#_STR||X1||V(TOKEN);
               CALL DGNS#_SYM;
               STRING_VALUE='';
          END;
          DGNS#_PROC="1";     /*  POSSIBLE PROC CALL TO FOLLOW   */
          CALL DGNS#_STACK(TOKEN); /* STACK THE TOKEN TO POP LATER */
     END;
     /* PROCESS THE END OF A BLOCK IF NESTING IS MULTIPLE DEPTHS THEN  CONTINUE
       REMOVING LEVELS */
     ELSE IF (TOKEN=END$)|(TOKEN=UNTIL$) THEN DO; /* PROCESS END OF BLOCK  */
          TEMP_INDEX=DGNS#_INDEX;
          DO WHILE ((DGNS#_TOP1~=BEGIN$)&(DGNS#_TOP1~=REPEAT$)&(DGNS#_TOP1~=OF$)
            ); /*    POP THE STACK TILL WE FIND MATCHING  BEGINNING TOKEN */
               IF DGNS#_DEPTH<-1 THEN RETURN;   /* CHECK FOR UNDERFLOW   */
               CALL DGNS#_STACK(0);   /*    POP    */
               TEMP_INDEX=TEMP_INDEX-INDEX_INC;
          END;
          DGNS#_DECR="1";       /* SET UN INDENT FLAG   */
          /* IF A PROC CALL LOOKS LIKE A GOTO   */
          IF DGNS#_PROC=2 THEN DGNS#_GOTO="1";
          IF DGNS#_GOTO THEN DO;
               /*   A GOTO SET TOP OF STACK2, SET POINTER AND RESET FLAG  */
               DGNS#_TOP2="1";
               DGNS#_STACK2(DGNS#_DEPTH)="1";
          END;
          /*  NO PROC CALL   */
          DGNS#_PROC=0;
          CALL DGNS#_STACK(0);   /*   POP THE BEGINNING TOKEN   */
          IF DGNS#_DEPTH=-1 THEN IN_PROC_FLAG="0";
          CALL DGNS#_SYM;
          DGNS#_GOTO = DGNS#_STACK2(DGNS#_DEPTH+1) & (DGNS#_TOP1 ~= OF$);
          DGNS#_INDEX=TEMP_INDEX;
     END;
     ELSE IF (TOKEN=SEMICOLON$) THEN DO;
          IF DGNS#_PROC=2 THEN DO;      /*   CHECK FOR PROC CALL    */
               DGNS#_GOTO="1";       /* SET GOTO FLAG    */
          END;
          IF DGNS#_GOTO THEN DO;       /* PROCESS AN INTERIOR GOTO   */
                DGNS#_PTR="1";       /* SET POINTER   */
               DGNS#_TOP2="1";     /* SET INTERIOR GOTO FOR SURROUNDING BLOCK */
               DGNS#_STACK2(DGNS#_DEPTH)="1";
               DGNS#_GOTO="0";        /* RESET FLAG   */
               IF DGNS#_TOP2 THEN DGNS#_PTR="1"; /* INTERIOR GOTO */
          END;
          DGNS#_PROC=1;        /* POSSIBLE PROC CALL TO FOLLOW     */
          IF DGNS#_TOP1=POP$ THEN DO;      /*  CHECK IF POP */
               DGNS#_STR=DGNS#_STR||V(TOKEN);  /* PUT SEMICOLON ON LINE */
               CALL DGNS#_SYM;           /* DUMP LINE   */
               STRING_VALUE='';
               DGNS#_STR='';         /*   EMPTY STRING    */
               IF DGNS#_TOP2 THEN DGNS#_PTR="1"; /* INTERIOR GOTO */
          END;
          DO WHILE (DGNS#_TOP1=POP$);     /*  POP ALL NESTINGS WHICH END HERE */
               IF DGNS#_DEPTH<-1 THEN RETURN;     /* STACK UNDERFLOW   */
               CALL DGNS#_STACK(0);   /*    P O P       */
               IF DGNS#_DECR THEN  DGNS#_INDEX=DGNS#_INDEX-3;      /* UNINDENT*/
               ELSE DGNS#_DECR="1";
          END;
          IF DGNS#_TOP1 = OF$ THEN DGNS#_PTR = FALSE; /* SET BY NEXT CASELABEL*/
     END;
     /* THE TOKENS DO, THEN, ELSE START BASIC BLOCKS;  PROCESS THEM   */
     ELSE IF(TOKEN=DO$)|(TOKEN=THEN$)|(TOKEN=ELSE$) THEN DO;
          /*   INDENT FLAG,POINTER FLAG, PROC CALL START    */
          IF TOKEN~=ELSE$ THEN DO;
               DGNS#_INCR="1";
          /*   PUSH THE TOKEN TO POP SOON   */
               CALL DGNS#_STACK(TOKEN);
          END;
          ELSE DO;
               CALL DGNS#_SYM;
               IF DGNS#_PROC = 2 THEN DGNS#_TOP2, DGNS#_STACK2(DGNS#_DEPTH) = 1;
               DO WHILE DGNS#_TOP1 ~= THEN$;
                    IF DGNS#_DEPTH < -1 THEN RETURN;
                    DGNS#_INDEX = DGNS#_INDEX - INDEX_INC;
                    CALL DGNS#_STACK(0);
               END;
               DGNS#_INDEX = DGNS#_INDEX - INDEX_INC;
          END;
          DGNS#_PTR="1";
          DGNS#_PROC=1;
     END;
     /*   PROCESS THE COLON WHICH INDICATES A LABEL  */
     ELSE IF TOKEN=COLON$ THEN DO;
          DGNS#_PROC=1;
          TEMP='';
          IF LENGTH(DGNS#_STR)>=1 THEN DO;   /* POSSIBLE LABEL HERE    */
          /* NOT IN A CASE STATEMENT  */
          IF DGNS#_TOP1~=OF$ THEN DO;
          /*  ONLY ONE LABEL. BACKUP TO BLANK OR START OF STRING TO GET IT   */
               STR_LENGTH = LENGTH(DGNS#_STR) -1;
               CH = BYTE(DGNS#_STR, STR_LENGTH);
               DO WHILE ((CH < BYTE('0')) | (CH > BYTE('9'))) & (STR_LENGTH>0);
                    STR_LENGTH = STR_LENGTH - 1;
                    CH = BYTE(DGNS#_STR, STR_LENGTH);
               END;
               DO WHILE ((CH >= BYTE('0')) & (CH <= BYTE('9')))
                        & (STR_LENGTH > 0);
                    STR_LENGTH = STR_LENGTH - 1;
                    CH = BYTE(DGNS#_STR, STR_LENGTH);
               END;
          END;
          ELSE DO;  /* IN A CASE MUST BACKUP FOR PREVIOUS LABELS */
               STR_LENGTH=LENGTH(DGNS#_STR)-1;
               FLAG="1";
               /*   MULTIPLE LABELS MUST FIND TOKEN THAT CANNOT APPEAR OR END */
               DO WHILE  (FLAG);
                   /*   A SEMICOLON IS NOT IN LABEL STOP LOOKING  */
                    DO WHILE (BYTE(DGNS#_STR, STR_LENGTH) = BYTE(''''))
                             & (STR_LENGTH > 0);
                         STR_LENGTH = STR_LENGTH - 1;
                         DO WHILE (BYTE(DGNS#_STR,STR_LENGTH) ~= BYTE(''''))
                                  & (STR_LENGTH > 0);
                              STR_LENGTH = STR_LENGTH - 1;
                         END;
                         IF STR_LENGTH > 0 THEN STR_LENGTH = STR_LENGTH - 1;
                    END;
                    IF SUBSTR(DGNS#_STR,STR_LENGTH,1)=';' THEN DO;
                         FLAG="0";
                         STR_LENGTH=STR_LENGTH+1;
                    END;
                    /*  END OF STRING?..THEN STOP LOOKING   */
                    ELSE IF STR_LENGTH=0 THEN FLAG="0";
                    /*   PERHAPS A OF FROM CASE INDICATES END OF LABELS */
                    /*   IF MORE THEN KEEP BACKING UP   */
                       ELSE STR_LENGTH=STR_LENGTH-1;
               END;
          END;
          /* NOW SET TEMP TO THAT PART OF THE LINE STARTING WITH THE FIRST
             LABEL, AND DGNS#_STR TO THE PART PRECEDING THAT.   */
          IF STR_LENGTH = 0 THEN DO;
               TEMP = DGNS#_STR;
               DGNS#_STR = '';
          END;
          ELSE DO;
               TEMP = SUBSTR(DGNS#_STR, STR_LENGTH);
               DGNS#_STR = SUBSTR(DGNS#_STR, 0, STR_LENGTH);
          END;


          END;
               /*   SET THE POINTER AND RETURN THE STRING FROM TEMP   */
               CALL DGNS#_SET_PTR;
               DGNS#_STR = TEMP;
     END;
     ELSE IF TOKEN=GOTO$ THEN DGNS#_GOTO="1";
     ELSE IF TOKEN=ASSIGN$ THEN DGNS#_PROC=0;    /* CAN NOT BE PROC CALL */
     ELSE IF (TOKEN=ID$)&(DGNS#_PROC=1) THEN DGNS#_PROC=2;   /* MAY BE PROC CA*/
     CALL DGNS#_NEW_LINE;
END PARAGRAPH;




  /*                   CARD IMAGE HANDLING PROCEDURE                      */


GET_CARD:
   PROCEDURE;
      /* DOES ALL CARD READING AND LISTING                                 */
      DECLARE I FIXED, (TEMP, TEMP0, REST) CHARACTER, READING BIT(1);
            BUFFER = INPUT;
            IF LENGTH(BUFFER) = 0 THEN
               DO; /* SIGNAL FOR EOF */
                  TEXT = V(EOFILE) || '(*''(**)/**/' || V(EOFILE);
                  BATCHING = FALSE;
               END;
      ELSE DO;   CARD_COUNT = CARD_COUNT + 1;  /* USED TO PRINT ON LISTING */
      IF MARGIN_CHOP > 0 THEN
         DO; /* THE MARGIN CONTROL FROM DOLLAR | */
            I = LENGTH(BUFFER) - MARGIN_CHOP;
            REST = SUBSTR(BUFFER, I);
            BUFFER = SUBSTR(BUFFER, 0, I);
         END;
      ELSE REST = '';
      TEXT = BUFFER;
      IF CONTROL(BYTE('M')) THEN OUTPUT = BUFFER;
      ELSE IF CONTROL(BYTE('L')) THEN
         OUTPUT = I_FORMAT (CARD_COUNT, 4) || ' |' || BUFFER || '|' || REST;
      END;
      TEXT_LIMIT = LENGTH(TEXT) - 1;
      CP = 0;
   END GET_CARD;


   /*                THE SCANNER PROCEDURES              */


   /*              A FINITE MACHINE MOANED "OH, WHY
                   CAN I ADD BUT NOT MULTIPLY?"
                   "BECOME MORE COMPLEX,
                   OR DISCOVER SEX
                   AND DO IT," SAID THE RABBIT, "LIKE I."

                         -- PETER KUGEL             */


CHAR:
   PROCEDURE;
      /* USED FOR STRINGS TO AVOID CARD BOUNDARY PROBLEMS */
      CP = CP + 1;
      IF CP <= TEXT_LIMIT THEN RETURN;
      CALL GET_CARD;
   END CHAR;


TENINTO:
   PROCEDURE(N) FIXED;
      DECLARE(N,I) FIXED;
      I = 0;
      DO WHILE N > 0;
         N = N / 10;
         I = I + 1;
      END;
      RETURN(I);
   END TENINTO;

FLOAT:
   PROCEDURE (N, RETURN_LOC);
      DECLARE N FIXED, RETURN_LOC @REAL;
      DECLARE ZERO(4) REAL INITIAL(0,0,0,0,0), OFFSET FIXED, WORK(4) REAL;
      /* NOTE THAT IF ZERO IS DOUBLE-WORD ALLIGNED THEN SO IS WORK */
      WORK(0), WORK(3) = "4E000000";
      WORK(1), WORK(4) = N;
      IF (ADDR(WORK) & "FFFFFFF8") = ADDR(WORK) THEN
         OFFSET = 0;   /* DOUBLE-WORD ALLIGNED */
      ELSE OFFSET = 12;   /* ~DOUBLE-WORD ALLIGNED */
      CALL INLINE("58",1,0,RETURN_LOC);          /* L    1,RETURN_LOC      */
      CALL INLINE("58",2,0,OFFSET);              /* L    2,OFFSET          */
      CALL INLINE("41",3,2,WORK);                /* LA   3,WORK(2)         */
      CALL INLINE("68",0,2,WORK);                /* LD   0,WORK(2)         */
      CALL INLINE("6A",0,2,ZERO);                /* AD   0,ZERO(2)         */
      CALL INLINE("60",0,2,WORK);                /* STD  0,WORK(2)         */
      CALL INLINE("D2",0,7,1,0,3,0);             /* MVC  0(8,1),0(3)       */
   END FLOAT;


REAL_ADD:
   PROCEDURE (X, Y, RETURN_LOC);
      DECLARE (X, Y, RETURN_LOC) @REAL, WORK(4) REAL, (OFFSET, I) FIXED;
      IF (ADDR(WORK) & "FFFFFFF8") = ADDR(WORK) THEN
         OFFSET = 0;   /* DOUBLE-WORD ALLIGNED */
      ELSE OFFSET = 12;   /* ~DOUBLE-WORD ALLIGNED */
      I = COREWORD(SHR(X, 2));
      WORK(0), WORK(3) = I;
      I = COREWORD(SHR(X, 2) + 1);
      WORK(1), WORK(4) = I;
      CALL INLINE("58",2,0,OFFSET);              /* L    2,OFFSET          */
      CALL INLINE("68",0,2,WORK);                /* LD   0,WORK(2)         */
      I = COREWORD(SHR(Y, 2));
      WORK(0), WORK(3) = I;
      I = COREWORD(SHR(Y, 2) + 1);
      WORK(1), WORK(4) = I;
      CALL INLINE("58",1,0,RETURN_LOC);          /* L    1,RETURN_LOC      */
      CALL INLINE("58",2,0,OFFSET);              /* L    2,OFFSET          */
      CALL INLINE("41",3,2,WORK);                /* LA   3,WORK(2)         */
      CALL INLINE("6A",0,2,WORK);                /* AD   0,WORK(2)         */
      CALL INLINE("60",0,2,WORK);                /* STD  0,WORK(2)         */
      CALL INLINE("D2",0,7,1,0,3,0);             /* MVC  0(8,1),0(3)       */
   END REAL_ADD;


REAL_MULTIPLY:
   PROCEDURE (X, Y, RETURN_LOC);
      DECLARE (X, Y, RETURN_LOC) @REAL, WORK(4) REAL, (OFFSET, I) FIXED;
      IF (ADDR(WORK) & "FFFFFFF8") = ADDR(WORK) THEN
         OFFSET = 0;   /* DOUBLE-WORD ALLIGNED */
      ELSE OFFSET = 12;   /* ~DOUBLE-WORD ALLIGNED */
      I = COREWORD(SHR(X, 2));
      WORK(0), WORK(3) = I;
      I = COREWORD(SHR(X, 2) + 1);
      WORK(1), WORK(4) = I;
      CALL INLINE("58",2,0,OFFSET);              /* L    2,OFFSET          */
      CALL INLINE("68",0,2,WORK);                /* LD   0,WORK(2)         */
      I = COREWORD(SHR(Y, 2));
      WORK(0), WORK(3) = I;
      I = COREWORD(SHR(Y, 2) + 1);
      WORK(1), WORK(4) = I;
      CALL INLINE("58",1,0,RETURN_LOC);          /* L    1,RETURN_LOC      */
      CALL INLINE("58",2,0,OFFSET);              /* L    2,OFFSET          */
      CALL INLINE("41",3,2,WORK);                /* LA   3,WORK(2)         */
      CALL INLINE("6C",0,2,WORK);                /* MD   0,WORK(2)         */
      CALL INLINE("60",0,2,WORK);                /* STD  0,WORK(2)         */
      CALL INLINE("D2",0,7,1,0,3,0);             /* MVC  0(8,1),0(3)       */
   END REAL_MULTIPLY;


SCAN:
   PROCEDURE;
      DECLARE (S1, S2) FIXED;
      DECLARE MAX10 LITERALLY '214748364'; /* (2**31-1)/10 */
      DECLARE (SCALE,EXPONENT) FIXED, X(1) REAL,
         (ERROR_SW, SIGN) BIT(1),
         MAX_MANTISSA REAL INITIAL("40B9446F"),
         MIN_MANTISSA REAL INITIAL("408A2DC0");
      DECLARE ST CHARACTER;
      DECLARE LSTRNGM CHARACTER INITIAL('STRING TOO LONG');

   SCAN_FINDS_END_OF:
      PROCEDURE (TABLE) BIT(1);
         DECLARE TABLE FIXED;
         DECLARE TRT(2) BIT(16) INITIAL("DD00", "3000", "1000");

         /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */
         CALL INLINE("58",3,0,TEXT);             /* L    3,TEXT            */
         CALL INLINE("17",2,2);                  /* XR   2,2               */
         CALL INLINE("19",3,2);                  /* CR   3,2               */
         CALL INLINE("07",8,12);                 /* BER  12                */
         CALL INLINE("8D",2,0,0,8);              /* SLDL 2,8               */
         CALL INLINE("88",3,0,0,8);              /* SRL  3,8               */
         CALL INLINE("58",1,0,TABLE);            /* L    1,TABLE           */
         CALL INLINE("44",2,0,TRT);              /* EX   2,TRT             */
         CALL INLINE("05",12,0);                 /* BALR 12,0              */
         CALL INLINE("47",7,0,12,16);            /* BNZ  *+16              */
         CALL INLINE("18",1,2);                  /* LR   1,2               */
         CALL INLINE("41",1,0,1,1);              /* LA   1,1(,1)           */
         CALL INLINE("17",3,3);                  /* XR   3,3               */
         CALL INLINE("47",15,0,12,22);           /* B    *+10              */
         CALL INLINE("1B",1,3);                  /* SR   1,3               */
         CALL INLINE("41",3,0,0,1);              /* LA   3,1               */
         CALL INLINE("50",1,0,CP);               /* ST   1,CP              */
      END SCAN_FINDS_END_OF;

      SKIP_TO_END_OF_COMMENT: PROCEDURE(ENDC);
         DECLARE ENDC BIT(8);
            DO WHILE BYTE(TEXT, CP) ~= ENDC;
               TEXT = SUBSTR(TEXT, CP);
               TEXT_LIMIT = TEXT_LIMIT - CP;
               DO WHILE ~SCAN_FINDS_END_OF (ADDR(COMMENTTABLE));
                  CALL GET_CARD;
               END;
               IF BYTE(TEXT, CP) = BYTE('$') THEN
                  DO;  /* A CONTROL CHARACTER */
                     CALL CHAR;
                     S2 = BYTE(TEXT, CP);
                     CONTROL(S2) = ~ CONTROL(S2);
                     IF S2 = BYTE('|') THEN
                        DO;
                           IF CONTROL(S2) THEN
                              MARGIN_CHOP = TEXT_LIMIT - CP + 1;
                           ELSE
                              MARGIN_CHOP = 0;
                        END;
                  END;
               /* ELSE FOUND AN ASTERISK */
               CALL CHAR;
            END;
      END SKIP_TO_END_OF_COMMENT;

      CALLCOUNT(3) = CALLCOUNT(3) + 1;
      BCD = '';
      NUMBER_VALUE, SCALE = 0;
      DGNS#_LAST_TOKEN = TOKEN;
      DO FOREVER;
         IF CP > TEXT_LIMIT THEN CALL GET_CARD;
         ELSE
            DO; /* DISCARD LAST SCANNED VALUE */
               TEXT_LIMIT = TEXT_LIMIT - CP;
               TEXT = SUBSTR(TEXT, CP);
               CP = 0;
            END;
         /*  BRANCH ON NEXT CHARACTER IN TEXT                  */
         DO CASE CHARTYPE(BYTE(TEXT));

            /*  CASE 0  */

            /* ILLEGAL CHARACTERS FALL HERE  */
            CALL ERROR ('ILLEGAL CHARACTER: ' || SUBSTR(TEXT, 0, 1));

            /*  CASE 1  */

            /*  BLANK  */
            DO;
               CP = 1;
               IF CP > TEXT_LIMIT THEN CALL GET_CARD;
               IF BYTE(TEXT, CP) = BYTE(' ') THEN
                  DO WHILE ~ SCAN_FINDS_END_OF(ADDR(BLANKTABLE));
                     CALL GET_CARD;
                  END;
               CP = CP - 1;
            END;


            /*  CASE 2  */

            /*  STRING QUOTE ('):   CHARACTER STRING  */
            DO FOREVER;
               CALL CHAR;
               TOKEN = STRING;
               TEXT_LIMIT = TEXT_LIMIT - CP;
               TEXT = SUBSTR(TEXT, CP);
               DO WHILE ~ SCAN_FINDS_END_OF (ADDR(STRINGTABLE));
                  IF LENGTH(BCD) + LENGTH(TEXT) > 256 THEN
                     DO;
                        CALL ERROR(LSTRNGM, 1);
                        RETURN;
                     END;
                  BCD = BCD || TEXT;
                  CALL GET_CARD;
               END;
               IF LENGTH(BCD) + CP > 256 THEN
                  DO;
                     CALL ERROR(LSTRNGM, 1);
                     RETURN;
                  END;
               IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);
               CALL CHAR;
               IF BYTE(TEXT, CP) ~= BYTE('''') THEN
                  DO;
                     IF LENGTH(BCD) = 0 THEN
                        DO;
                           CALL ERROR(
                              'BLANK SUBSTITUTED FOR STRING OF LENGTH ZERO', 0);
                           BCD = X1;
                        END;
                     RETURN;
                  END;
               BCD = BCD || '''';
               /* PREPARE TO RESUME SCANNING STRING */
            END;

            /*  CASE 3  */

            DO;          /* A ( : MAY BE START OF "SQUARE BRACKET"
                                       OR COMMENT   */
               CALL CHAR;
               IF BYTE(TEXT,CP) = BYTE('.') THEN
                  DO;
                     TOKEN = LBRACKET;
                     CALL CHAR;
                     RETURN;
                  END;
               ELSE IF BYTE(TEXT,CP) ~= BYTE('*') THEN
                  DO;
                     TOKEN = LPARENT;
                     RETURN;
                  END;
               /* WE HAVE A COMMENT */
               CALL SKIP_TO_END_OF_COMMENT(BYTE(')'));
            END;

            /*  CASE 4  */

            DO FOREVER;  /* A LETTER:  IDENTIFIERS AND RESERVED WORDS */
               IF SCAN_FINDS_END_OF (ADDR(ALPHATABLE)) THEN
                  DO;  /* END OF IDENTIFIER  */
                     IF CP > 0 THEN BCD = BCD || SUBSTR(TEXT, 0, CP);
                     S1 = LENGTH(BCD);
                     IF S1 > 1 THEN IF S1 <= RESERVED_LIMIT THEN
                        /* CHECK FOR RESERVED WORDS */
                        DO I = V_INDEX(S1 - 1) TO V_INDEX(S1) - 1;
                           IF BCD = V(I) THEN
                              DO;
                                 TOKEN = I;
                                 RETURN;
                              END;
                        END;
                     /*  RESERVED WORDS EXIT HIGHER: THEREFORE <IDENTIFIER> */
                     TOKEN = IDENT;
                     RETURN;
                  END;
               /*  END OF CARD  */
               BCD = BCD || TEXT;
               CALL GET_CARD;
            END;

            /*  CASE 5  */

            DO;      /*  DIGIT:  A NUMBER  */
               TOKEN = INTCONST;     /* ASSUME AN INTEGER */
               ERROR_SW = FALSE;   /* ASSUME NO ERRORS */
               ST = '';
               DO WHILE BYTE(TEXT, CP) >= "F0";
                  ST = ST || SUBSTR(TEXT,CP,1);
                  IF NUMBER_VALUE < MAX10 THEN
                     NUMBER_VALUE = 10 * NUMBER_VALUE + BYTE(TEXT,CP) - "F0";
                  ELSE IF NUMBER_VALUE=MAX10 & BYTE(TEXT,CP)<="F7" THEN
                     NUMBER_VALUE = 10 * NUMBER_VALUE + BYTE(TEXT,CP) - "F0";
                  ELSE ERROR_SW = TRUE;
                  CALL CHAR;
               END;
               IF ERROR_SW THEN
                  DO;
                     CALL ERROR('INTEGER CONSTANT EXCEEDS RANGE',0);
                     NUMBER_VALUE = 0;
                  END;
               EXPONENT = 154;
               TEXT_LIMIT = TEXT_LIMIT - CP;
               TEXT = SUBSTR(TEXT,CP);
               CP = 0;
               IF LENGTH(TEXT) < 2 THEN
                  DO;
                     BCD = TEXT;
                     CALL GET_CARD;
                     TEXT = BCD || TEXT;
                  END;
               IF BYTE(TEXT) = BYTE('.') THEN
                  IF BYTE(TEXT,1) ~= BYTE(')')
                     & BYTE(TEXT,1) ~= BYTE('.') THEN
                     DO;     /* A REAL */
                        TOKEN = REALCONST;
                        ST = ST || '.';
                        CP = 1;
                        SCALE = TENINTO(NUMBER_VALUE);
                        EXPONENT = EXPONENT - 2*SCALE;
                        CALL FLOAT(NUMBER_VALUE, ADDR(NUMBER_VALUE));
                        CALL REAL_MULTIPLY(ADDR(NUMBER_VALUE),
                           ADDR(POWERS(2*(78-SCALE))),ADDR(NUMBER_VALUE));
                        IF BYTE(TEXT,1) < "F0" THEN
                           CALL ERROR('ERROR IN REAL CONSTANT: DIGIT EXPECTED');
                        ELSE
                           DO WHILE BYTE(TEXT,CP) >= "F0";
                                    CALL FLOAT(BYTE(TEXT,CP)-"F0",ADDR(X));
                              CALL REAL_MULTIPLY(ADDR(X),ADDR(POWERS(EXPONENT)),
                                 ADDR(X));
                              IF EXPONENT>0 THEN EXPONENT = EXPONENT - 2;
                              CALL REAL_ADD(ADDR(NUMBER_VALUE),ADDR(X),
                                 ADDR(NUMBER_VALUE));
                              ST = ST || SUBSTR(TEXT,CP,1);
                              CALL CHAR;
                           END;
                     END;
               IF BYTE(TEXT,CP) = BYTE('E') THEN
                  DO;
                     IF EXPONENT = 154 THEN /* WE THOUGHT IT WAS AN INTEGER */
                        DO;
                           TOKEN = REALCONST;
                           SCALE = TENINTO(NUMBER_VALUE);
                           CALL FLOAT(NUMBER_VALUE,ADDR(NUMBER_VALUE));
                           CALL REAL_MULTIPLY(ADDR(NUMBER_VALUE),
                              ADDR(POWERS(2*(78-SCALE))), ADDR(NUMBER_VALUE));
                        END;
                     SIGN = FALSE;
                     ST = ST || 'E';
                     CALL CHAR;
                     IF BYTE(TEXT,CP) < "F0" THEN ST = ST || SUBSTR(TEXT,CP,1);
                     IF BYTE(TEXT,CP)=BYTE('+') THEN CALL CHAR;
                     ELSE IF BYTE(TEXT,CP) = BYTE('-') THEN
                        DO;
                           SIGN = TRUE;
                           CALL CHAR;
                        END;
                     EXPONENT = 0;
                     IF BYTE(TEXT,CP) < "F0" THEN
                        CALL ERROR('ERROR IN REAL CONSTANT: DIGIT EXPECTED',0);
                     ELSE
                        DO WHILE BYTE(TEXT,CP) >= "F0";
                           ST = ST || SUBSTR(TEXT,CP,1);
                           EXPONENT = 10*EXPONENT + BYTE(TEXT,CP) - "F0";
                           CALL CHAR;
                        END;
                     IF SIGN THEN SCALE = SCALE - EXPONENT;
                     ELSE SCALE = SCALE + EXPONENT;
                  END;
               IF SCALE ~= 0 THEN
                  DO;
                     IF (SCALE < -78) | (SCALE > 75)
                        | (SCALE = -78 & NUMBER_VALUE < MIN_MANTISSA)
                        | (SCALE = 75 & NUMBER_VALUE > MAX_MANTISSA)
                        THEN CALL ERROR(
                           'ERROR IN REAL CONSTANT: VALUE OUT OF RANGE');
                        ELSE CALL REAL_MULTIPLY(ADDR(NUMBER_VALUE),
                           ADDR(POWERS(2*(78+SCALE))), ADDR(NUMBER_VALUE));
                  END;
               BCD = ST;
               RETURN;
            END;

            /*  CASE 6  */

            DO;      /*  A /:  MAY BE DIVIDE OR START OF COMMENT  */
               CALL CHAR;
               IF BYTE(TEXT, CP) ~= BYTE('*') THEN
                  DO;
                     TOKEN = DIVIDE;
                     RETURN;
                  END;
               /* WE HAVE A COMMENT  */
               CALL SKIP_TO_END_OF_COMMENT(BYTE('/'));
            END;

            /*  CASE 7  */
            DO;      /*  SPECIAL CHARACTERS  */
               IF LENGTH(TEXT) < 2 THEN DO;
                  BCD = TEXT;
                  CALL GET_CARD;
                  TEXT = BCD || TEXT;
                  TEXT_LIMIT = LENGTH(TEXT) - 1;
               END;
               IF BYTE(TEXT, 1) ~= BLANK & NOT_LETTER_OR_DIGIT(BYTE(TEXT,1))THEN
                  DO I = V_INDEX(1) TO V_INDEX(2) - 1;
                     IF SUBSTR(TEXT, 0, 2) = V(I) THEN DO;
                        TOKEN = I;
                        CP = 2;
                        RETURN;
                     END;
                  END;
               TOKEN = TX(BYTE(TEXT));
               CP = 1;
               RETURN;
            END;

            /*  CASE 8 - A '#' */

            DO;
               TOKEN = NEOP;
               CALL CHAR;
               RETURN;
            END;

            /* CASE 9 - THE 0-2-8 PUNCH */

            DO;
               TOKEN = EOFILE;
               COMPILING = FALSE;
               CALL CHAR;
               RETURN;
            END;

            /* CASE 10 -- AMPERSAND (&) */

            DO;
               TOKEN = ANDSY;
               CALL CHAR;
               RETURN;
            END;

            /* CASE 11 -- VERTICAL BAR (|) */

            DO;
               TOKEN = ORSY;
               CALL CHAR;
               RETURN;
            END;

            /* CASE 12 -- NEGATION (~) */
            DO;
               IF LENGTH(TEXT) < 2 THEN DO;
                  BCD = TEXT;
                  CALL GET_CARD;
                  TEXT = BCD || TEXT;
                  TEXT_LIMIT = LENGTH(TEXT) - 1;
               END;
               IF BYTE(TEXT,1) ~= BYTE('=') THEN DO;
                  TOKEN = NOTSY;
                  CP = 1;
                  RETURN;
               END;
               TOKEN = NEOP;
               CP = 2;
               RETURN;
            END;

            /* CASE 13 -- LEFT BRACKET */
            DO;
               TOKEN = LBRACKET;
               CP = CP + 1;
               RETURN;
            END;

            /* CASE 14 -- RIGHT BRACKET */
            DO;
               TOKEN = RBRACKET;
               CP = CP + 1;
               RETURN;
            END;

         END;     /* OF CASE ON CHARTYPE  */
         CP = CP + 1;  /* ADVANCE SCANNER AND RESUME SEARCH FOR TOKEN  */
      END;
   END SCAN;




  /*                       TIME AND DATE                                 */


PRINT_TIME:
   PROCEDURE (MESSAGE, T);
      DECLARE MESSAGE CHARACTER, T FIXED;
      MESSAGE = MESSAGE || T/360000 || ':' || T MOD 360000 / 6000 || ':'        
         || T MOD 6000 / 100 || '.';
      T = T MOD 100;  /* DECIMAL FRACTION  */
      IF T < 10 THEN MESSAGE = MESSAGE || '0';
      OUTPUT = MESSAGE || T || '.';
   END PRINT_TIME;

PRINT_TIMES:
   PROCEDURE (MESSAGE, T1, T2);
      /* T1 ASSUMED TO BE REAL TIME, T2 CPU TIME */
      DECLARE MESSAGE CHARACTER, (T1, T2) FIXED;
      MESSAGE = MESSAGE || 'ELAPSED = ' || T1/360000 || ':' ||
                T1 MOD 360000 / 6000 || ':' || T1 MOD 6000 / 100 || '.';
      T1 = T1 MOD 100;   /* DECIMAL FRACTION */
      IF T1 < 10 THEN MESSAGE = MESSAGE || '0';
      CALL PRINT_TIME(MESSAGE || T1 || ', CPU = ', T2);
   END PRINT_TIMES;

PRINT_DATE_AND_TIME:
   PROCEDURE (MESSAGE, D, T);
      DECLARE MESSAGE CHARACTER, (D, T, YEAR, DAY, M) FIXED;
      DECLARE MONTH(11) CHARACTER INITIAL ('JANUARY', 'FEBRUARY', 'MARCH',
         'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER',
         'NOVEMBER', 'DECEMBER'),
      DAYS(12) FIXED INITIAL (0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
         305, 335, 366);
      YEAR = D/1000 + 1900;
      DAY = D MOD 1000;
      IF (YEAR & "3") ~= 0 THEN IF DAY > 59 THEN DAY = DAY + 1; /* ~ LEAP YEAR*/
      M = 1;
      DO WHILE DAY > DAYS(M);  M = M + 1;  END;
      CALL PRINT_TIME(MESSAGE || MONTH(M-1) || X1 || DAY-DAYS(M-1) ||  ', '     
         || YEAR || '.  CLOCK TIME = ', T);
   END PRINT_DATE_AND_TIME;

  /*                       INITIALIZATION                                     */



INITIALIZATION:
   PROCEDURE;

   LOCATE_INDEX:  PROCEDURE (S) FIXED;
      DECLARE S CHARACTER;
      DECLARE I BIT(16);
      DO I = 1 TO NT;
         IF S = V(I) THEN RETURN I;
         END;
      END LOCATE_INDEX;

      ANDSY = LOCATE_INDEX ('AND');
      COLON = LOCATE_INDEX (':');
      DIVIDE = LOCATE_INDEX ('/');
      EOFILE = LOCATE_INDEX ('_|_');
      EQUALSIGN = LOCATE_INDEX ('=');
      IDENT = LOCATE_INDEX('<IDENTIFIER>');
      INTCONST = LOCATE_INDEX ('<UNSIGNED INTEGER>');
      LBRACKET = LOCATE_INDEX ('(.');
      RBRACKET = LOCATE_INDEX('.)');
      LEOP = LOCATE_INDEX ('<=');
      LPARENT = LOCATE_INDEX ('(');
      RPARENT = LOCATE_INDEX(')');
      LTOP = LOCATE_INDEX ('<');
      NEOP = LOCATE_INDEX ('<>');
      NOTSY = LOCATE_INDEX ('NOT');
      ORSY = LOCATE_INDEX ('OR');
      REALCONST = LOCATE_INDEX ('<UNSIGNED REAL>');
      STRING = LOCATE_INDEX ('<STRING>');
      RESERVED_LIMIT = 9;
      V(EOFILE) = '\';   /* THE 0-2-8 PUNCH */
      CHARTYPE(BYTE(' ')) = 1;
      BLANK = BYTE(X1);
      DO I = 0 TO 255;
         NOT_LETTER_OR_DIGIT(I) = TRUE;
      END;
      DO I = 0 TO LENGTH(ALPHABET) - 1;
         J = BYTE(ALPHABET, I);
         TX(J) = I;
         NOT_LETTER_OR_DIGIT(J) = FALSE;
         CHARTYPE(J) = 4;
      END;
      DO I = 0 TO 9;
         J = BYTE('0123456789', I);
         NOT_LETTER_OR_DIGIT(J) = FALSE;
         CHARTYPE(J) = 5;
      END;
      NOT_LETTER_OR_DIGIT(BYTE('_')) = FALSE;
      DO I = V_INDEX(0) TO V_INDEX(1) - 1;
         J = BYTE(V(I));
         IF NOT_LETTER_OR_DIGIT(J) THEN DO;
            TX(J) = I;
            CHARTYPE(J) = 7;
         END;
      END;
      DO I = V_INDEX(1) TO V_INDEX(2) - 1;
         J = BYTE(V(I));
         IF NOT_LETTER_OR_DIGIT(J) THEN CHARTYPE(J) = 7;
      END;
      CHARTYPE(BYTE('''')) = 2;
      CHARTYPE(BYTE('(')) = 3;
      CHARTYPE(BYTE('/')) = 6;
      CHARTYPE(BYTE('#')) = 8;
      CHARTYPE(BYTE('\')) = 9;    /* THE 0-2-8 PUNCH */
      CHARTYPE(BYTE('&')) = 10;
      CHARTYPE(BYTE('|')) = 11;
      CHARTYPE(BYTE('~')) = 12;
      CHARTYPE("AD") = 13;   /* LBRACKET */
      CHARTYPE("BD") = 14;   /* RBRACKET */
      NT1 = NT + 1;  /*  INDEX OF FIRST NONTERMINAL  */
      LOOKUP_TYPE(IDENT) = 1;
      LOOKUP_TYPE(STRING) = 2;
      LOOKUP_TYPE(INTCONST), LOOKUP_TYPE(REALCONST) = 2;
      BATCHING = TRUE;
   END INITIALIZATION;

 INIT_SY_TABLE:PROCEDURE;
 DECLARE I FIXED;
 DO I = #_PREDECLARED + 1 TO TABLE_LENGTH;
    VALUE(I) = 0 ;
    DATATYPE(I) = NULL;
    VAR_TYPE(I) = UNDEFINED;
 END;
 DO I = 0 TO IDENTITY_LENGTH;
    WHERE_DECL(I) = 0;
    N_LOOKUPS(I)=0;
    SYMB_LINK(I) = NULL;
 END;
DO I = 0 TO 255;
   BUCKET(I) = NULL;
   END;
DO N_DECL_SYMB = 0 TO #_PREDECLARED;
   /* ENTER PREDECLARED SYMBOLS ON THE HASH BUCKET CHAINS */
   I = LENGTH(IDENTITY(N_DECL_SYMB)) - 1;
   I =(BYTE(IDENTITY(N_DECL_SYMB)) + BYTE(IDENTITY(N_DECL_SYMB), I) + I) & "FF";
   IF BUCKET(I) = NULL THEN
         BUCKET(I) = N_DECL_SYMB;
   ELSE DO;
      I = BUCKET(I);
      DO WHILE SYMB_LINK(I) ~= NULL;
         I = SYMB_LINK(I);
         END;
      SYMB_LINK(I) = N_DECL_SYMB;
      END;
   END;
 VALUE(37) = MAXINT;
 N_ANONYMOUS_SYMB = TABLE_LENGTH;
 N_DECL_SYMB = #_PREDECLARED + 1;
 OWN_MOD = #_PREDECLARED;
 SYMB_BLOCK_OWNER(0) = NULL;
 PROCMARK(1) = N_DECL_SYMB;
 BLOCK_STACK(1), CURRENT_BLOCK = 1;
 FIRST_LITERAL = NULL;
 END INIT_SY_TABLE;

RE_INITIALIZE:  PROCEDURE;
      /* FIRST SET UP GLOBAL VARIABLES CONTROLLING SCAN, THEN GET THE FIRST CARD
                                                                      */
      CONTROL(BYTE('L')) = TRUE;
      CONTROL(BYTE('B')) = DEBUGGING;
      IF BATCHING THEN DO;
         CALL DGNS#_INITIALIZE;
         CALL INIT_SY_TABLE;
         /* INITIALIZE THE PARSE_STACK AND PARSE_TREE                 */
         PARSE_STACK(0) = EOFILE;
         SP = 1;  PARSE_STACK(SP) = GOAL;
         TREE_SIZE = 1;
         MAX_TREE, #_OF_TREES = 0;
         CURRENT_LEVEL = 1;
         TYPE_DECL_PART = FALSE;
         FORWARD_REF_HEAD = NULL;
         LITERAL_POOL_SIZE = 0;

         /* INITIALIZE  COMPILATION   FLAG AND CONSTANTS              */
          CARD_COUNT ,ERROR_COUNT,SEVERE_ERRORS,PREVIOUS_ERROR = 0 ;
         COMPILING = TRUE;

         /* INITIALIZE PROGRAM STATISTICS COUNTERS                    */
         CALLCOUNT(1), CALLCOUNT(3) = 0;

         /* PRINT PAGE HEADING                                        */
         EJECT_PAGE;
         CALL PRINT_DATE_AND_TIME(
            'PASS ONE -- STONY BROOK PASCAL -- COMPILER VERSION OF ',
               DATE_OF_GENERATION, TIME_OF_GENERATION);
         OUTPUT = SUBSTR(X70, 0, 34) || 'RELEASE 1, UPDATE 4';
         CALL PRINT_DATE_AND_TIME ('TODAY IS ', DATE, TIME);
         DOUBLE_SPACE;
         CALL GET_CARD;
      END;
END RE_INITIALIZE;




DUMPIT:
   PROCEDURE;    /* DUMP OUT THE STATISTICS COLLECTED DURING THIS RUN  */
      DOUBLE_SPACE;
      /*  PUT OUT THE ENTRY COUNT FOR IMPORTANT PROCEDURES */

      OUTPUT = 'SYMBOL TABLE SIZE = ' || N_DECL_SYMB;
      OUTPUT = 'NUMBER OF TREES   = ' || #_OF_TREES;
      OUTPUT = 'LARGEST TREE SIZE = ' || MAX_TREE;
   IF MONITOR_LINK(2) >= 2 THEN
      OUTPUT = 'BASIC BLOCKS      = ' || BASIC_BLOCKS;
      OUTPUT = 'SCAN              = ' || CALLCOUNT(3);
      OUTPUT = 'NUMBER OF PRODUCTIONS RECOGNIZED = ' || CALLCOUNT(1);
      OUTPUT = 'FREE STRING AREA  = ' || FREELIMIT - FREEBASE;
   END DUMPIT;


STACK_DUMP:
   PROCEDURE;
      DECLARE LINE CHARACTER;
      LINE = 'PARSE STACK AT THIS POINT PREDICTS: ';
      DO I = 1 TO SP;
         IF LENGTH(LINE) > 105 THEN
            DO;
               OUTPUT = LINE;
               LINE = X4;
            END;
         IF PARSE_STACK(I) = EOFILE THEN LINE = LINE || 'END OF FILE';
            ELSE LINE = LINE || X1 || V(PARSE_STACK(I));
      END;
      OUTPUT = LINE;
   END STACK_DUMP;

COREIM_DESCRIPT:
   PROCEDURE(ADDRESS,LENGTH) CHARACTER;
      DECLARE (ADDRESS,LENGTH,DESCRIPTOR) FIXED;

      IF LENGTH = 0 THEN DESCRIPTOR = 0;
         ELSE DESCRIPTOR = SHL(LENGTH-1,24) + ADDRESS;
   /* WE RETURN DESCRIPTOR IN REGISTER 3 */
      CALL INLINE("58",3,0,DESCRIPTOR);          /* L    3,DESCRIPTOR      */
   END COREIM_DESCRIPT;

PUNCH_PARSE_TREE:
   PROCEDURE(TREE);
      DECLARE (TREE,I) BIT(16);   /* TREE IS INDEX INTO PARSE TREE OF ROOT */
      DECLARE STRING CHARACTER;

      STRING = I_FORMAT(TREE,5);
      STRING = '%TREE' || STRING;
      /* TELL PASS 2 WHETHER OR NOT TO PRINT THE PARSE TREE */
      IF CONTROL(BYTE('P')) THEN STRING = STRING || 'P';
      ELSE STRING = STRING || X1;
      IF CONTROL(BYTE('T')) THEN STRING = STRING || 'T';
      ELSE STRING = STRING || X1;
      IF CONTROL(BYTE('E')) THEN STRING = STRING || 'E';
      OUTPUT(3) = STRING;
      I = 0;
      DO WHILE I < TREE_SIZE;
         STRING = COREIM_DESCRIPT(ADDR(PARSE_TREE(I)),80);
         OUTPUT(3) = STRING;
         I = I + 40;   /* 2 BYTES PER ARRAY ELEMENT */
      END;
      STRING = '%END';
      OUTPUT(3) = STRING;
   END PUNCH_PARSE_TREE;

COMPACTIFY_SYMBOL_TABLE:
   PROCEDURE;
      DECLARE (GAP, I) BIT(16);

   FIX_DATATYPE:
      PROCEDURE (TP_PTR, LISTHEAD);
      DECLARE LISTHEAD FIXED;
      DECLARE (ID_PTR, NEXT, TP_PTR) FIXED;
      ID_PTR = LISTHEAD;
      DO WHILE ID_PTR ~= NULL;
         NEXT = DATATYPE(ID_PTR);
         DATATYPE(ID_PTR) = TP_PTR;
         ID_PTR = NEXT;
         END;
   END FIX_DATATYPE;

      /* CHECK FOR UNDEFINED LABELS  */
      DO I = #_PREDECLARED + 1 TO N_DECL_SYMB;
         IF (VAR_TYPE(I) = LABLE) & (N_LOOKUPS(I) > 0) THEN
            CALL ERROR (IDENTITY(I) || ' DECLARED ON LINE ' ||
                        WHERE_DECL(I) || ' IS AN UNDEFINED LABEL', 1);
         END;

      GAP = N_ANONYMOUS_SYMB - N_DECL_SYMB + 1;
      IF GAP < 1 THEN
         DO;
            N_DECL_SYMB = TABLE_LENGTH;
            RETURN;
         END;
      DO I = 0 TO N_DECL_SYMB;
         IF DATATYPE(I) > N_ANONYMOUS_SYMB THEN
            DATATYPE(I) = DATATYPE(I) - GAP;
      END;
      DO I = N_ANONYMOUS_SYMB + 1 TO TABLE_LENGTH;
         IF DATATYPE(I) > N_ANONYMOUS_SYMB THEN
            DATATYPE(N_DECL_SYMB) = DATATYPE(I) - GAP;
         ELSE DATATYPE(N_DECL_SYMB) = DATATYPE(I);
         VAR_TYPE(N_DECL_SYMB) = VAR_TYPE(I);
         VALUE(N_DECL_SYMB) = VALUE(I);
         N_DECL_SYMB = N_DECL_SYMB + 1;
      END;
      IF INTCHAIN > NULL THEN INTCHAIN = INTCHAIN - GAP;
      IF REALCHAIN > NULL THEN REALCHAIN = REALCHAIN - GAP;
      IF CHARCHAIN > NULL THEN CHARCHAIN = CHARCHAIN - GAP;
      CALL FIX_DATATYPE(INTPTR, INTCHAIN);
      CALL FIX_DATATYPE(REALPTR, REALCHAIN);
      CALL FIX_DATATYPE(CHARPTR, CHARCHAIN);
      I = FIRST_LITERAL;
      DO WHILE I ~= NULL;
         I, VALUE(I) = SYMB_LINK(I);
      END;
      N_ANONYMOUS_SYMB = N_ANONYMOUS_SYMB - GAP + 1; /* OLD N_DECL_SYMB */
   END COMPACTIFY_SYMBOL_TABLE;

SY_TABLE_STAT:
   PROCEDURE (J);
      DECLARE X2 CHARACTER INITIAL ('  ');
      DECLARE J BIT(16);
      DECLARE LINE CHARACTER;
      DECLARE ID_FIELD FIXED INITIAL (12);
      DECLARE VAR_TYPES(17) CHARACTER INITIAL ('        ','VARIABLE','CONSTANT',
            'LITERAL ', 'TYPE    ', 'PROC    ', 'VAR PARM', 'PROCPARM',
            'UNDEFINE', 'UNDF LAB', '        ', 'LABEL   ', 'VARIANT ',
            'FIELD ID', 'FORWARD ', 'MULTDECL', 'VAL PARM', 'RECORD  ');

   LJUSTIFY:
      PROCEDURE (X, FIELDWIDTH);
         DECLARE (X, XTEMP) CHARACTER;
         DECLARE FIELDWIDTH FIXED;
         XTEMP = X;
         IF LENGTH(XTEMP) >= FIELDWIDTH THEN
            XTEMP = SUBSTR (XTEMP, 0, FIELDWIDTH);
         ELSE XTEMP = XTEMP || SUBSTR (X70, 0, FIELDWIDTH-LENGTH(XTEMP));
         LINE = LINE || XTEMP || X4;
      END LJUSTIFY;

   RJUSTIFY:
      PROCEDURE (X, FIELDWIDTH);
         DECLARE (X, FIELDWIDTH) FIXED;
         DECLARE XTEMP CHARACTER;
         XTEMP = X;
         IF LENGTH(XTEMP) > FIELDWIDTH THEN
            LINE = SUBSTR (LINE, 0, LENGTH(LINE) - LENGTH(XTEMP) + FIELDWIDTH);
         ELSE LINE = LINE || SUBSTR (X70, 0, FIELDWIDTH - LENGTH(XTEMP));
         LINE = LINE || XTEMP || X4;
      END RJUSTIFY;

      LINE = I_FORMAT (J, 4);
      LINE = LINE || X2;
      IF J >= N_ANONYMOUS_SYMB THEN LINE = LINE || SUBSTR (X70, 0, ID_FIELD +4);
      ELSE CALL LJUSTIFY (IDENTITY(J), ID_FIELD);
      CALL RJUSTIFY (DATATYPE(J), 4);
      CALL RJUSTIFY (SYMB_LINK(J), 8);
      LINE = LINE || VAR_TYPES(VAR_TYPE(J)) || X4;
      CALL RJUSTIFY (VALUE(J), 8);
      CALL RJUSTIFY (WHERE_DECL(J), 8);
      CALL RJUSTIFY (N_LOOKUPS(J), 8);
      OUTPUT = LINE;
   END SY_TABLE_STAT;

SY_DUMP: PROCEDURE;
      DECLARE I BIT(16);
      EJECT_PAGE;
      OUTPUT = '      IDENTITY      DATATYPE  SYMB LINK   VAR TYPE       VALUE' 
              || '     WHERE DECL   OCCURRENCES';
      OUTPUT = '';
      DO I = 0 TO N_DECL_SYMB - 1;
         CALL SY_TABLE_STAT(I);
      END;
   END SY_DUMP;

PARSE_TREE_DUMP:
   PROCEDURE (TREE);
      DECLARE A(127) BIT(16);   /* AUXILIARY STACK; CF KNUTH V.1 P.317 */
      DECLARE TREE BIT(16);   /* POINTER TO ROOT */
      DECLARE (TOP_OF_A,M,C,P) BIT(16);
      DECLARE LEAF LITERALLY 'PARSE_TREE(P+1)',
              MULTIPLICITY LITERALLY 'PARSE_TREE',
              PRODUCTION_NUMB LITERALLY 'PARSE_TREE(P+1)',
              LINE_NUMB LITERALLY 'PARSE_TREE(P+M+2)';
      DECLARE MARGIN CHARACTER;
      DECLARE INDENTATION BIT(16), (S1, S2) CHARACTER;
      DECLARE OVERFLOW_MESSAGE CHARACTER INITIAL(
         '*** AUXILIARY STACK OVERFLOW, PARSE TREE DUMP ABORTED');
      MARGIN = X70 || X70 || '|';
      INDENTATION = LENGTH(MARGIN) - 2;
      TOP_OF_A = 0;
      P = TREE;
      OUTPUT = 'PARSE_TREE AT THIS POINT IS:';
      DO FOREVER;
         IF P = NULL THEN
            DO;
               M = 0;
               S1 = '... EMPTY PRODUCTION ...';
            END;
         ELSE
            DO;
               M = MULTIPLICITY(P);
               IF M = 0 THEN
                  DO;
                     IF LEAF < N_ANONYMOUS_SYMB THEN
                        S1 = IDENTITY(LEAF);
                     ELSE IF (DATATYPE(LEAF)=INTPTR) | (DATATYPE(LEAF)=REALPTR)
                        THEN S1 = VALUE(LEAF);
                     ELSE
                        DO;
                           S1 = ' ';
                           BYTE(S1) = VALUE(LEAF) & "FF";
                        END;
                  END;
               ELSE S1 = PRODUCTION_NUMB || X1 || LEFT_PART(PRODUCTION_NUMB);
            END;
         S2 = SUBSTR(MARGIN,INDENTATION) || X1 || S1;
         IF LENGTH(S2) < 57 THEN S2 = S2 || X70;
         IF LENGTH(S2) < 127 THEN S2 = S2 || SUBSTR(X70,0,127 - LENGTH(S2));
         S1 = I_FORMAT(LINE_NUMB,4);
         IF P = NULL THEN S1 = '';
         OUTPUT = S2 || '|' || S1;
         IF M > 0 THEN
            DO;
               A(TOP_OF_A) = 0;
               TOP_OF_A = TOP_OF_A + 1;
               IF TOP_OF_A > 127 THEN
                  DO;
                     OUTPUT = OVERFLOW_MESSAGE;
                     RETURN;
                  END;
            END;
         DO C = - 1 TO M - 3;   /* STACK SUBTREES RIGHT TO LEFT */
            A(TOP_OF_A) = PARSE_TREE(P + M - C);
            TOP_OF_A = TOP_OF_A + 1;
            IF TOP_OF_A > 127 THEN
               DO;
                  OUTPUT = OVERFLOW_MESSAGE;
                  RETURN;
               END;
         END;
         IF M = 0 THEN
            DO;   /* UNSTACK SUBTREE */
               IF TOP_OF_A = 0 THEN RETURN;
               TOP_OF_A = TOP_OF_A - 1;
               P = A(TOP_OF_A);
               DO WHILE P = 0;
                  IF TOP_OF_A = 0 THEN RETURN;
                  INDENTATION = INDENTATION + 3;
                  TOP_OF_A = TOP_OF_A - 1;
                  P = A(TOP_OF_A);
               END;
            END;
         ELSE
            DO;    /* PREPARE TO DUMP LEFTMOST SUBTREE */
               P = PARSE_TREE(P + 2);
               INDENTATION = INDENTATION - 3;
            END;
      END;
   END PARSE_TREE_DUMP;

PUNCH_SYMBOLS:
   PROCEDURE;
      DECLARE (I,J) FIXED, (LINE,S1,S2) CHARACTER;
      DECLARE ID CHARACTER;

      LINE = '';
      S1 = I_FORMAT(N_DECL_SYMB,5);
      S2 = I_FORMAT(N_ANONYMOUS_SYMB,5);
      S1 = '%SYMB' || S1 || S2;
      S2 = I_FORMAT(FIRST_LITERAL,5);
      IF CONTROL(BYTE('D')) THEN S2 = S2 || 'D';
      ELSE S2 = S2 || X1;
      IF CONTROL(BYTE('S')) THEN S2 = S2 || 'S';
      OUTPUT(4) = S1 || S2;
      I = #_PREDECLARED + 1;
      DO WHILE I < N_ANONYMOUS_SYMB;
         ID = '''' || IDENTITY(I) || ''' ';
         DO J = 1 TO LENGTH(ID) - 3;
            IF BYTE(ID,J) = BYTE('''') THEN
               DO;
                  S1 = SUBSTR(ID,0,J);
                  S2 = SUBSTR(ID,J);
                  ID = S1 || '''' || S2;
                  J = J + 1;
               END;
         END;
         IF LENGTH(LINE) + LENGTH(ID) <= 80 THEN
               LINE = LINE || ID;
            ELSE DO;
               S1 = SUBSTR(ID,0,80 - LENGTH(LINE));
               OUTPUT(4) = LINE || S1;
               S2 = SUBSTR(ID,LENGTH(S1));
               DO WHILE LENGTH(S2) > 80;
                  OUTPUT(4) = SUBSTR(S2,0,80);
                  S2 = SUBSTR(S2,80);
               END;
               LINE = S2;
            END;
         IF LENGTH(LINE) = 80 THEN
            DO;
               OUTPUT(4) = LINE;
               LINE = '';
            END;
         I = I + 1;
      END;
      OUTPUT(4) = LINE;
      I = #_PREDECLARED + 1;
      DO WHILE I < N_DECL_SYMB;
         OUTPUT(4) = COREIM_DESCRIPT(ADDR(VALUE(I)),80);
         I = I + 20;
      END;
      I = #_PREDECLARED + 1;
      DO WHILE I < N_DECL_SYMB;
         OUTPUT(4) = COREIM_DESCRIPT(ADDR(VAR_TYPE(I)),80);
         I = I + 40;
      END;
      I = #_PREDECLARED + 1;
      DO WHILE I < N_DECL_SYMB;
         OUTPUT(4) = COREIM_DESCRIPT(ADDR(DATATYPE(I)),80);
         I = I + 40;
      END;
   END PUNCH_SYMBOLS;



  /*                      THE SYMBOL TABLE PROCEDURES                      */


OPEN_BLOCK:
   PROCEDURE (IS_NEW_BLOCK);
      DECLARE IS_NEW_BLOCK BIT(1),
              (SP, ID_PTR) BIT(16);
      CURRENT_LEVEL = CURRENT_LEVEL + 1;
      /***** FIND THE TOPMOST LEAF NODE ON THE SUBTREE STACK *****/
      SP = SUBTREE_STACKSIZE;
      DO WHILE PARSE_TREE(SUBTREE_STACK(SP)) > 0;
         SP = SP - 1;
         END;
      ID_PTR = PARSE_TREE(SUBTREE_STACK(SP) + 1);
      IF IS_NEW_BLOCK THEN DO;
         PROCMARK(CURRENT_LEVEL) = N_DECL_SYMB;
         VALUE(ID_PTR), BLOCK_STACK(CURRENT_LEVEL), CURRENT_BLOCK
            = CURRENT_BLOCK + 1;
         END;
       ELSE DO ;
         PROCMARK(CURRENT_LEVEL) = 0 ;
         IF VAR_TYPE(ID_PTR) = FORWARD THEN  DO;
             BLOCK_STACK(CURRENT_LEVEL) = VALUE(ID_PTR);
            PROCMARK(CURRENT_LEVEL) = N_DECL_SYMB;
            END;
         ELSE BLOCK_STACK(CURRENT_LEVEL) = VALUE(UNDERLYING_TYPE(ID_PTR));
       END;
      SYMB_BLOCK_OWNER(CURRENT_LEVEL), OWN_MOD = ID_PTR;
      DECLARE BLOCK_STRING CHARACTER;
      IF CONTROL(BYTE('Z')) THEN DO;
      BLOCK_STRING = '                                    *** BLOCK STACK DUMP';
      DO SP = 0 TO CURRENT_LEVEL;
         BLOCK_STRING = BLOCK_STRING || '  ' || BLOCK_STACK(SP);
         END;
      OUTPUT = BLOCK_STRING;
      END;
   END OPEN_BLOCK;

NULLOUT:
   PROCEDURE (MAXINDEX);
      DECLARE (I, MAXINDEX) BIT(16);
       IF MAXINDEX <= 0 THEN DO ;
        IF CONTROL(BYTE('Z')) THEN
         CALL ERROR('***COMPILER ATTEMPTED TO NULL A DECLARATION' ||
                     'BLOCK THAT IS NOT ASSOCIATED WITH A PROCEDURE',1);
         RETURN;
       END;
      DO I = 0 TO 255;
         IF BUCKET(I) > MAXINDEX THEN
            BUCKET(I) = NULL;
         END;
      DO I = #_PREDECLARED TO N_DECL_SYMB;
         IF SYMB_LINK(I) > MAXINDEX THEN
            IF VAR_TYPE(I) ~= LITERAL THEN
               SYMB_LINK(I) = NULL;
         END;
   END NULLOUT;

CLOSE_BLOCK:
   PROCEDURE (IS_PROC_BLOCK);
      DECLARE IS_PROC_BLOCK BIT(1);
       IF IS_PROC_BLOCK THEN
          IF BLOCK_STACK(CURRENT_LEVEL) > 1 THEN
             CALL NULLOUT(PROCMARK(CURRENT_LEVEL));
       IF CURRENT_LEVEL > 1 THEN CURRENT_LEVEL = CURRENT_LEVEL - 1 ;
      OWN_MOD = SYMB_BLOCK_OWNER(CURRENT_LEVEL);
   END CLOSE_BLOCK;

ENTER_SYMBOL:
   PROCEDURE (ID, LEVEL) FIXED;
      DECLARE ID CHARACTER,
              (LEVEL, INDEX, I, CHAIN_PTR) BIT(16);
         INDEX = N_DECL_SYMB;
         N_DECL_SYMB = N_DECL_SYMB + 1;
         IF (N_DECL_SYMB>IDENTITY_LENGTH) | (N_DECL_SYMB=N_ANONYMOUS_SYMB) THEN
              DO;
                   CALL ERROR(SYMB_OVFLO, 1);
                   COMPILING = FALSE;
              END;
         VAR_TYPE(INDEX) = UNDEFINED;
         IDENTITY(INDEX)= ID;
         WHERE_DECL(INDEX) = CARD_COUNT;
         I = LENGTH(ID) - 1;
         I = (BYTE(ID) + BYTE(ID, I) + I + BLOCK_STACK(LEVEL)) & "FF";
         IF BUCKET(I) = NULL THEN
            BUCKET(I) = INDEX;
         ELSE DO;
            CHAIN_PTR = BUCKET(I);
            DO WHILE SYMB_LINK(CHAIN_PTR) ~= NULL;
               CHAIN_PTR = SYMB_LINK(CHAIN_PTR);
               END;
            SYMB_LINK(CHAIN_PTR) = INDEX;
            END;
         RETURN (INDEX);
   END ENTER_SYMBOL;

   CONSTANT_INDEX: PROCEDURE(LISTHEAD) BIT(16);
      /* LISTHEAD IS PASSED BY REFERENCE! */
      DECLARE (LISTHEAD, INDEX) FIXED;
      INDEX = COREWORD (SHR(LISTHEAD, 2));
      DO WHILE INDEX > NULL;
         IF VALUE(INDEX) = NUMBER_VALUE THEN RETURN INDEX;
         INDEX = DATATYPE(INDEX);
      END;
      INDEX = N_ANONYMOUS_SYMB;
      N_ANONYMOUS_SYMB = N_ANONYMOUS_SYMB - 1;
      IF N_ANONYMOUS_SYMB = N_DECL_SYMB THEN
         DO;
            CALL ERROR(SYMB_OVFLO, 1);
            COMPILING = FALSE;
         END;
      DATATYPE(INDEX) = COREWORD(SHR(LISTHEAD, 2));
      COREWORD(SHR(LISTHEAD, 2)) = INDEX;
      VAR_TYPE(INDEX) = CONSTANT;
      VALUE(INDEX) = NUMBER_VALUE;
      RETURN INDEX;
   END CONSTANT_INDEX;

   LITERAL_INDEX: PROCEDURE BIT(16);
      DECLARE INDEX FIXED;
      INDEX = FIRST_LITERAL;
      DO WHILE INDEX ~= NULL;
         IF IDENTITY(INDEX) = BCD THEN RETURN INDEX;
         INDEX = SYMB_LINK(INDEX);
      END;
      INDEX = N_DECL_SYMB;
      N_DECL_SYMB = N_DECL_SYMB + 1;
      IF (N_DECL_SYMB>IDENTITY_LENGTH) | (N_DECL_SYMB=N_ANONYMOUS_SYMB) THEN
         DO;
            CALL ERROR(SYMB_OVFLO, 1);
            COMPILING = FALSE;
         END;
      SYMB_LINK(INDEX) = FIRST_LITERAL;
      FIRST_LITERAL = INDEX;
      DATATYPE(INDEX) = CHARPTR;
      VAR_TYPE(INDEX) = LITERAL;
      LITERAL_POOL_SIZE = LITERAL_POOL_SIZE + LENGTH(BCD);
      IDENTITY(INDEX) = BCD;
      RETURN INDEX;
   END LITERAL_INDEX;

LOOKUP:
   PROCEDURE (ID, DEPTH) BIT(16);
      DECLARE ID CHARACTER;
      DECLARE (DEPTH, INDEX, L, I) BIT(16);
      DECLARE ENTER_LEVEL BIT(16);
      ENTER_LEVEL = CURRENT_LEVEL;
      IF IS_DECLARATION THEN
         IF IS_SCALAR_TYPE_DEFN THEN
            DEPTH, ENTER_LEVEL = PROC_LEVEL;
         ELSE DEPTH = CURRENT_LEVEL;
      L = LENGTH(ID) - 1;
      I = BYTE(ID) + BYTE(ID, L) + L;
      IF IS_SCALAR_TYPE_DEFN THEN L = ENTER_LEVEL; ELSE L = CURRENT_LEVEL;
      DO WHILE L >= DEPTH;
         INDEX = BUCKET((I + BLOCK_STACK(L)) & "FF");
         DO WHILE INDEX ~= NULL;
            IF IDENTITY(INDEX) = ID THEN DO;
               N_LOOKUPS(INDEX) = N_LOOKUPS(INDEX) + 1;
               IF IS_DECLARATION THEN
                  IF VAR_TYPE(INDEX) = UNDEFINED THEN
                     VAR_TYPE(INDEX) = VARTYPECODE;
                  ELSE IF (VARTYPECODE = PROC) & (VAR_TYPE(INDEX) = FORWARD)
                     THEN BLOCK_CLOSURE_CODE = OLD;
                  ELSE DO;
                       CALL ERROR ('DUPLICATE DECLARATION FOR ' || ID, 0);
                       #_MULTIPLE_DECLARATIONS = #_MULTIPLE_DECLARATIONS + 1;
                       INDEX = ENTER_SYMBOL (DOLLAR || ID ||
                                    #_MULTIPLE_DECLARATIONS, CURRENT_LEVEL);
                     END;
               RETURN INDEX;
               END;
            INDEX = SYMB_LINK(INDEX);
            END;
         L = L - 1;
         END;
      INDEX = ENTER_SYMBOL (ID, ENTER_LEVEL);
      IF IS_DECLARATION THEN VAR_TYPE(INDEX) = VARTYPECODE;
      ELSE DO;
         VAR_TYPE(INDEX) = UNDEFINED;
         IF ~IS_FORWARD_DECL THEN
            CALL ERROR (ID || ' IS AN UNDECLARED IDENTIFIER', 0);
         END;
      RETURN INDEX;
   END LOOKUP;

   LOOKUP_LITERAL: PROCEDURE (ID) FIXED;
    DECLARE ID CHARACTER;
    DECLARE INDEX FIXED;
         IF LABEL_DECL THEN DO;
            INDEX = LOOKUP(ID,CURRENT_LEVEL);
            VAR_TYPE(INDEX)= LABLE;
            RETURN INDEX;
            END;
         IF LABEL_LOOKUP THEN DO;
            INDEX = LOOKUP(ID,1);
            LABEL_LOOKUP = FALSE;
            IF VAR_TYPE(INDEX) ~= LABLE & VAR_TYPE(INDEX) ~= DEFN_LABEL THEN DO;
               CALL ERROR ('UNDECLARED LABEL ' || ID, 0);
               VAR_TYPE(INDEX)= LABLE;
              END;
            RETURN(INDEX); END;
         IF TOKEN = INTCONST THEN RETURN CONSTANT_INDEX(ADDR(INTCHAIN));
         IF TOKEN = REALCONST THEN RETURN CONSTANT_INDEX(ADDR(REALCHAIN));
         /* TOKEN = STRING */
         IF LENGTH(BCD) > 1 THEN RETURN LITERAL_INDEX;
         NUMBER_VALUE = BYTE(BCD);
         RETURN CONSTANT_INDEX(ADDR(CHARCHAIN));
   END LOOKUP_LITERAL;


  /*               THE SYNTHESIS ALGORITHM FOR PASCAL 370                  */


GET_NODE:
   PROCEDURE(MULT) BIT(16);
      DECLARE (MULT, POINTER) BIT(16);
      IF (TREE_SIZE + MULT + 3) > 7200 THEN
         DO;
            CALL ERROR('PARSE TREE OVERFLOW',1);
            TREE_SIZE = 1;
            RETURN(1);
         END;
      POINTER = TREE_SIZE;
      PARSE_TREE(TREE_SIZE) = MULT;
      TREE_SIZE = TREE_SIZE + MULT + 3;
      RETURN (POINTER);
   END GET_NODE;

STACK_NODE:
   PROCEDURE(NODE_NUMBER);
      DECLARE NODE_NUMBER FIXED;
      NODE_STACKSIZE = NODE_STACKSIZE + 1;
      NODE_STACK(NODE_STACKSIZE) = NODE_NUMBER;
      SUBTREE_INDEX(NODE_STACKSIZE) = SUBTREE_STACKSIZE + 1;
   END STACK_NODE;

UNSTACK:
PROCEDURE;
   DECLARE (I, J, K) FIXED;
   IF NODE_STACKSIZE < 1 THEN RETURN;
   I = SUBTREE_STACKSIZE - SUBTREE_INDEX(NODE_STACKSIZE) + 1;
   IF I = 0 THEN J = NULL;
   ELSE
      DO;
         J = GET_NODE(I);
         PARSE_TREE(J + 1) = NODE_STACK(NODE_STACKSIZE);
      END;
   DO K = 1 TO I;
      PARSE_TREE(J+K+1) = SUBTREE_STACK(SUBTREE_INDEX(NODE_STACKSIZE) + K - 1);
   END;
   SUBTREE_STACKSIZE = SUBTREE_INDEX(NODE_STACKSIZE);
   SUBTREE_STACK(SUBTREE_STACKSIZE) = J;
   IF I > 0 THEN
      DO;
         K = PARSE_TREE(J+2);
         IF K ~= NULL THEN PARSE_TREE(I+J+2) = PARSE_TREE(K+PARSE_TREE(K)+2);
         ELSE PARSE_TREE(I+J+2) = CARD_COUNT;
      END;
   NODE_STACKSIZE = NODE_STACKSIZE - 1;
END UNSTACK;

BUILD_ERROR_TREE:
   PROCEDURE;
      /* FORCE AN ERROR SUBTREE ONTO THE SUBTREE STACK */
      CALL STACK_NODE(ERROR_NODE);
      SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
      SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
      CALL UNSTACK;
   END BUILD_ERROR_TREE;

UNSTACK_QUALIFIER:
   PROCEDURE;
      DECLARE NODE_NUMBER BIT(16);
      NODE_NUMBER = NODE_STACK(NODE_STACKSIZE);
      IF NODE_NUMBER = 53 THEN CALL UNSTACK; /* SUBSCRIPT QUALIFIER */
      ELSE IF NODE_NUMBER = 55 THEN DO;
            IF VAR_TYPE(UNDERLYING_TYPE(LAST_LITERAL_SCANNED)) = RECORD THEN
               DO;
               CURRENT_LEVEL = CURRENT_LEVEL - 1;
               CALL OPEN_BLOCK (OLD);
               END;
            CALL UNSTACK;
            END;
   END UNSTACK_QUALIFIER;

WRITEOUT:
   PROCEDURE;
   /* THIS PROCEDURE WILL SEND OUT TO DIRECT ACCESS STORAGE THE PARSE TREE
         FOR A PARSED PASCAL BLOCK.                                    */
      IF TREE_SIZE < 2 THEN
         DO;
            NODE_STACKSIZE, SUBTREE_STACKSIZE = 0;
            RETURN;
         END;
      DO WHILE NODE_STACKSIZE > 0;
         CALL UNSTACK;
      END;
      PARSE_TREE(0) = OWN_MOD;
      CALL PUNCH_PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE));
      IF TREE_SIZE > MAX_TREE THEN MAX_TREE = TREE_SIZE;
      TREE_SIZE = 1;
      #_OF_TREES = #_OF_TREES + 1;
      IF CONTROL(BYTE('P')) THEN
         CALL PARSE_TREE_DUMP(SUBTREE_STACK(SUBTREE_STACKSIZE));
   END WRITEOUT;

STACK_OP:
   PROCEDURE(OPERATOR);
      DECLARE OPERATOR FIXED;
      CALL STACK_NODE(OPERATOR);
   /* WE'VE ALREADY "UNSTACK"-ED ONE OF THE INFIX OPERATOR'S OPERANDS, SO */
      SUBTREE_INDEX(NODE_STACKSIZE) = SUBTREE_STACKSIZE;
   END STACK_OP;

SYNTHESIZE:
   PROCEDURE(PRODUCTION_NUMBER);
      DECLARE PRODUCTION_NUMBER FIXED;
      DECLARE LPARENT FIXED INITIAL(240);
      DECLARE FI FIXED INITIAL (241), IFF FIXED INITIAL (17);
      DECLARE I FIXED;
      DECLARE TYPE_ID_MARKER BIT(16);

      UNSTACK_DECLARATION:
         PROCEDURE;
            DO;
               CALL UNSTACK; /* <TYPE> */
               I = NODE_STACK(NODE_STACKSIZE);
               DO WHILE (63<=I & I<=66) | (71<=I & I<=74);
                  CALL UNSTACK;   /* ARRAY OF ARRAY OF ARRAY ...  (E.G.) */
                  I = NODE_STACK(NODE_STACKSIZE);
               END;
            END;
      END UNSTACK_DECLARATION;

   OPEN_BRACKET:
      PROCEDURE;
         NESTING_LEVEL = NESTING_LEVEL + 1;
         WITHCOUNT(NESTING_LEVEL) = 0;
      END OPEN_BRACKET;

      CALLCOUNT(1) = CALLCOUNT(1) + 1;
      IF CONTROL(BYTE('B')) THEN OUTPUT = 'PRODUCTION NUMBER ' ||
         PRODUCTION_NUMBER || ' APPLIES';

      DO CASE PRODUCTION_NUMBER;

            ; /* CASE 0 IS A DUMMY BECAUSE WE NUMBER PRODUCTIONS FROM 1 */

   /*   1   <PROGRAM>  ::=   <PROGRAM HEADING> <BLOCK> .   */
            DO;
               NODE_STACKSIZE, SUBTREE_STACKSIZE = 0;
               CALL STACK_NODE(NODE_NUMBER);
            END;

   /*   2   <BLOCK>  ::=   <FIRSTPART> <SECONDPART>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*   3   <FIRSTPART>  ::=   <LABEL DECLS> <CONST DECLS> <TYPE DEFNS>   */
            ;

   /*   4   <SECONDPART>  ::=   <VAR DECLS> <PROC DECL LIST> <STATEMENT PART>
        */
            ;

   /*   5   <STATEMENT PART>  ::=   BEGIN <STATEMENT> <STAT LIST> END   */
            DO;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL , TYPE_DECL_PART,IS_DECLARATION  = FALSE ;
               CALL STACK_NODE(NODE_NUMBER);
               CALL STACK_NODE(3);
            END;

   /*   6   <STAT LIST>  ::=   ; <STATEMENT> <STAT LIST>   */
            DO;
               CALL UNSTACK;
               I = NODE_STACK(NODE_STACKSIZE);
               DO WHILE (I=13) | (17<=I & I<=23);
                  CALL UNSTACK;   /* NESTED IF, FOR, WHILE, WITH STATEMENTS */
                  I = NODE_STACK(NODE_STACKSIZE);
               END;
            END;

   /*   7   <STAT LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               CALL UNSTACK;
               I = NODE_STACK(NODE_STACKSIZE);
               DO WHILE (I=13) | (17<=I & I<=23);
                  CALL UNSTACK;   /* NESTED IF, FOR, WHILE, WITH STATEMENTS */
                  I = NODE_STACK(NODE_STACKSIZE);
               END;
               CALL UNSTACK;   /* <STAT LIST> */
            END;

   /*   8   <LABEL DECLS>  ::=   LABEL <UNSIGNED INTEGER> <LABEL LIST> ;   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               LABEL_DECL, IS_DECLARATION = TRUE;
               VARTYPECODE = LABLE;
            END;

   /*   9   <LABEL DECLS>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /*  10   <LABEL LIST>  ::=   , <UNSIGNED INTEGER> <LABEL LIST>   */
            ;

   /*  11   <LABEL LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               LABEL_DECL, IS_DECLARATION = FALSE;
               CALL UNSTACK;
            END;

   /*  12   <CONST DECLS>  ::=   CONST <IDENTIFIER> <CONST VALUE PART>   */
            DO;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL = FALSE ;
               CALL STACK_NODE(NODE_NUMBER);
               IS_DECLARATION = TRUE;
               VARTYPECODE = CONSTANT;
            END;

   /*  13   <CONST DECLS>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /*  14   <CONST DECL LIST>  ::=   <IDENTIFIER> <CONST VALUE PART>   */
            ;

   /*  15   <CONST DECL LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IS_DECLARATION = FALSE;
               CALL UNSTACK;
            END;

   /*  16   <CONST VALUE PART>  ::=   = <CONSTANT> <CONST DECL TAIL>   */
            IS_DECLARATION = FALSE;

   /*  17   <CONST DECL TAIL>  ::=   ; <CONST DECL LIST>   */
            IS_DECLARATION = TRUE;

   /*  18   <TYPE DEFNS>  ::=   TYPE <IDENTIFIER> <TYPE DESCRIPTOR PART>   */
            DO;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL = FALSE ;
               CALL STACK_NODE(NODE_NUMBER);
               TYPE_DECL_PART = TRUE;
               IS_DECLARATION = TRUE;
               VARTYPECODE = TYPE;
               TYPE_ID_MARKER = N_DECL_SYMB;
            END;

   /*  19   <TYPE DEFNS>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /*  20   <TYPE DEF LIST>  ::=   <IDENTIFIER> <TYPE DESCRIPTOR PART>   */
            TYPE_DECL_PART = TRUE;

   /*  21   <TYPE DEF LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IS_DECLARATION = FALSE;
               TYPE_DECL_PART = FALSE;
               CALL UNSTACK;
               DO I = TYPE_ID_MARKER TO N_DECL_SYMB - 1;
                  IF VAR_TYPE(I) = UNDEFINED THEN
                     DO;
                        CALL ERROR(IDENTITY(I) || ' IS AN UNDECLARED TYPE', 0);
                        VAR_TYPE(I) = TYPE;
                     END;
               END;
            END;


   /*  22   <TYPE DESCRIPTOR PART>  ::=   = <TYPE> <TYPE DEFN TAIL>   */
            IS_DECLARATION = FALSE;

   /*  23   <TYPE DEFN TAIL>  ::=   ; <TYPE DEF LIST>   */
            DO;
               CALL UNSTACK_DECLARATION;
               IS_DECLARATION = TRUE;
               VARTYPECODE = TYPE;
            END;

   /*  24   <PROC DECL LIST>  ::=   <PROC DECL> <PROC DECL TAIL>   */
            CALL WRITEOUT;

   /*  25   <PROC DECL LIST>  ::=   ... EMPTY PRODUCTION ...   */
            CALL WRITEOUT;

   /*  26   <PROC DECL>  ::=   PROCEDURE <IDENTIFIER> <PARAM LIST> ; <BODY>   */
 PROC_DECL : DO ;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL , TYPE_DECL_PART = FALSE ;
               CALL STACK_NODE(NODE_NUMBER);
               IS_DECLARATION = TRUE;
               VARTYPECODE = PROC;
            END;

   /*  27   <PROC DECL>  ::=
      FUNCTION <IDENTIFIER> <PARAM LIST> <RETURNS> ; <BODY>   */
       GOTO PROC_DECL ;

   /*  28   <BODY>  ::=   <BLOCK>   */
            CALL WRITEOUT;

   /*  29   <VAR DECLS>  ::=   VAR <ID LIST> : <TYPE> <VAR DECL TAIL>   */
            DO;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL , TYPE_DECL_PART = FALSE ;
               CALL STACK_NODE(NODE_NUMBER);
               CALL STACK_NODE(12);
               IS_DECLARATION = TRUE;
               VARTYPECODE = VARIABLE;
            END;

   /*  30   <VAR DECLS>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /*  31   <VAR DECL LIST>  ::=   <ID LIST> : <TYPE> <VAR DECL TAIL>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  32   <VAR DECL LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IS_DECLARATION = FALSE;
               CALL UNSTACK;
            END;

   /*  33   <VAR DECL TAIL>  ::=   ; <VAR DECL LIST>   */
            DO;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL , TYPE_DECL_PART = FALSE ;
               CALL UNSTACK_DECLARATION;
               CALL UNSTACK;  /* <VAR DECL> */
               IS_DECLARATION = TRUE;
               VARTYPECODE = VARIABLE;
            END;
   /*  34   <ID LIST>  ::=   <IDENTIFIER> <ID LIST 2>   */
            ;

   /*  35   <ID LIST 2>  ::=   , <ID LIST>   */
            ;

   /*  36   <ID LIST 2>  ::=   ... EMPTY PRODUCTION ...   */
            IS_DECLARATION, IS_SCALAR_TYPE_DEFN = FALSE;

   /*  37   <STATEMENT>  ::=   <UNSIGNED INTEGER> : <UNLABLED STATEMENT>   */
            DO;
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL , TYPE_DECL_PART,IS_DECLARATION  = FALSE ;
               CALL STACK_NODE(NODE_NUMBER);
               I = CURRENT_LEVEL;
               J = VAR_TYPE(SYMB_BLOCK_OWNER(I));
               DO WHILE J ~= PROC;
                  I = I - 1;
                  J = VAR_TYPE(SYMB_BLOCK_OWNER(I));
                  END;
               VARTYPECODE = UNDEFINED;
               LAST_LITERAL_SCANNED = LOOKUP (BCD, I);
               IF VAR_TYPE(LAST_LITERAL_SCANNED) ~= LABLE THEN
                  IF VAR_TYPE(LAST_LITERAL_SCANNED) = UNDEFINED THEN
                     CALL ERROR ('UNDECLARED LABEL ' || BCD, 0);
                  ELSE CALL ERROR ('DUPLICATE DEFINITION OF ' || BCD, 1);
               VAR_TYPE(LAST_LITERAL_SCANNED) = DEFN_LABEL;
            END;

   /*  38   <STATEMENT>  ::=   <UNLABLED STATEMENT>   */
 /* REDUNDANT - CLEARS  FLAGS IN CASE OF ERROR  */
       LABEL_DECL , TYPE_DECL_PART,IS_DECLARATION  = FALSE ;

   /*  39   <UNLABLED STATEMENT>  ::=   <IDENTIFIER> <ID STATEMENT>   */
       DO; /* TEST IF IT IS A PROCEDURE CALL */
         IS_PROC_CALL = SHR(IS_PROC_TYPE,VAR_TYPE(LAST_LITERAL_SCANNED)) & 1 ;
         IF IS_PROC_CALL THEN  CALL STACK_NODE(15) ;
         ELSE DO;
           /* IT IS AN ASSIGNMENT STATEMENT */
           CALL STACK_NODE(NODE_NUMBER);
           CALL STACK_NODE(51) ; /* VARIABLE */
         END;
       END;

   /*  40   <UNLABLED STATEMENT>  ::=   BEGIN <STATEMENT> <STAT LIST> END   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               CALL STACK_NODE(3);
            END;

   /*  41   <UNLABLED STATEMENT>  ::=
      IF <EXPRESSION> THEN <STATEMENT> <ELSE PART>   */
            CALL STACK_NODE(FI);

   /*  42   <UNLABLED STATEMENT>  ::=   CASE <EXPRESSION> OF <CASE LIST> END
        */
               CALL STACK_NODE(NODE_NUMBER);

   /*  43   <UNLABLED STATEMENT>  ::=   WHILE <EXPRESSION> DO <STATEMENT>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  44   <UNLABLED STATEMENT>  ::=
      REPEAT <STATEMENT> <STAT LIST> UNTIL <EXPRESSION>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               CALL STACK_NODE(3);
            END;

   /*  45   <UNLABLED STATEMENT>  ::=
      FOR <IDENTIFIER> := <EXPRESSION> <FOR STAT 2>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  46   <UNLABLED STATEMENT>  ::=
      WITH <VARIABLE> <VAR LIST> DO <STATEMENT> <CLOSE>   */
            DO;
               IS_WITHBLOCK(NESTING_LEVEL) = TRUE;
               CALL STACK_NODE(NODE_NUMBER);
               END;

   /*  47   <UNLABLED STATEMENT>  ::=   GOTO <UNSIGNED INTEGER>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               LABEL_LOOKUP = TRUE;
            END;

   /*  48   <UNLABLED STATEMENT>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
            END;

   /*  49   <ID STATEMENT>  ::=   := <EXPRESSION>   */
            DO;
               IF IS_PROC_CALL THEN DO;  /* ASSIGNMENT TO FUNCTION NAME */
                  /* AN INSTANCE OF PREDICTIVE PARSING WITH HINDSIGHT */
                  NODE_STACK(NODE_STACKSIZE) = 14;
                  CALL STACK_NODE (NODE_NUMBER);
                  SUBTREE_INDEX(NODE_STACKSIZE) = SUBTREE_STACKSIZE;
                  IS_PROC_CALL = FALSE;
                  END;
               CALL UNSTACK;  /* FOUND A VARIABLE */
               END;

   /*  50   <ID STATEMENT>  ::=
      (. <EXPRESSION> <EXP LIST> .) <QUALIFIER> := <EXPRESSION>   */
 ASSIGNMENT : DO ;
               CALL OPEN_BRACKET;
               CALL STACK_NODE(NODE_NUMBER);
               END;

   /*  51   <ID STATEMENT>  ::=   . <IDENTIFIER> <QUALIFIER> := <EXPRESSION>
        */
            DO;
               IS_QUALIFIED_REFERENCE(NESTING_LEVEL) = TRUE;
               CALL OPEN_BLOCK (OLD);
               CALL STACK_NODE(NODE_NUMBER);
               END;

   /*  52   <ID STATEMENT>  ::=   @ <QUALIFIER> := <EXPRESSION>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
               CALL UNSTACK;
            END;

 /* <ID STATEMENT> ::= ( <EXPRESSION> <EXP LIST> ) <ASSIGNMENT PART> */
       DO;
         /* TEST IF IT IS A PROCEDURE CALL WITH PARAMETERS */
         IF IS_PROC_CALL THEN DO;
           IS_PROC_CALL = FALSE;
           CALL OPEN_BRACKET ;
         END;
         ELSE  /* ASSIGNMENT STATEMENT */
           GOTO ASSIGNMENT;
       END;

   /*  54   <ID STATEMENT>  ::=   ... EMPTY PRODUCTION ...   */
            /* A PARAMETERLESS PROPER PROCEDURE */
            IF IS_PROC_CALL THEN
               IS_PROC_CALL = FALSE;
            ELSE
               DO;   /* WE PREDICTED AN ASSIGNMENT */
                  NODE_STACKSIZE = NODE_STACKSIZE - 1;
                  NODE_STACK(NODE_STACKSIZE) = 15;   /* PROC CALL */
               END;

   /*  55   <EXP LIST>  ::=   , <EXPRESSION> <EXP LIST>   */
            ;

   /*  56   <EXP LIST>  ::=   ... EMPTY PRODUCTION ...   */
       IF NESTING_LEVEL > 0 THEN
            NESTING_LEVEL = NESTING_LEVEL - 1;

   /*  57   <ELSE PART>  ::=   ELSE <STATEMENT>   */
 ELSE_PART: DO;
               DO WHILE (NODE_STACK(NODE_STACKSIZE) ~= FI)
                        & (NODE_STACKSIZE > 0);
                     CALL UNSTACK;
                  END;
               NODE_STACK(NODE_STACKSIZE) = IFF;
            END;

   /*  58   <ELSE PART>  ::=   ... EMPTY PRODUCTION ...   */
            GOTO ELSE_PART;

   /*  59   <FOR STAT 2>  ::=   DOWNTO <EXPRESSION> DO <STATEMENT>   */
            NODE_STACK(NODE_STACKSIZE) = 22;

   /*  60   <FOR STAT 2>  ::=   TO <EXPRESSION> DO <STATEMENT>   */
            ;

   /*  61   <VAR LIST>  ::=   , <VARIABLE> <VAR LIST>   */
            IF IS_WITHBLOCK(NESTING_LEVEL) THEN
            WITHCOUNT(NESTING_LEVEL) = WITHCOUNT(NESTING_LEVEL) + 1;

   /*  62   <VAR LIST>  ::=   ... EMPTY PRODUCTION ...   */
            IF IS_WITHBLOCK(NESTING_LEVEL) THEN DO;
               WITHCOUNT(NESTING_LEVEL) = WITHCOUNT(NESTING_LEVEL) + 1;
               CALL OPEN_BRACKET;
               END;

   /*  63   <PARAM LIST>  ::=   ( <PARAM LIST 1> )   */
            DO;
               IF VAR_TYPE(LAST_LITERAL_SCANNED) = FORWARD THEN
                  CALL ERROR(IDENTITY(LAST_LITERAL_SCANNED) ||
' IS FORWARD DECLARED. REPETITION OF ITS PARAMETER LIST IS NOT ALLOWED', 1);
               VARTYPECODE = VARIABLE;
               CALL OPEN_BRACKET;
               CALL OPEN_BLOCK (NEW);
            END;

   /*  64   <PARAM LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IS_DECLARATION = FALSE;
               CALL OPEN_BLOCK(BLOCK_CLOSURE_CODE);
               BLOCK_CLOSURE_CODE = NEW;
            END;

   /*  65   <PARAM LIST 1>  ::=   <ID LIST> : <IDENTIFIER> <PARAM LIST 2>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  66   <PARAM LIST 1>  ::=   VAR <ID LIST> : <IDENTIFIER> <PARAM LIST 2>
        */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               VARTYPECODE =    VAR_PARAM;
            END;

   /*  67   <PARAM LIST 1>  ::=
      FUNCTION <ID LIST> <PARAM TYPE LIST> : <IDENTIFIER> <PARAM LIST 2>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               VARTYPECODE = PROC_PARAM;
            END;

   /*  68   <PARAM LIST 1>  ::=
      PROCEDURE <ID LIST> <PARAM TYPE LIST> <PARAM LIST 2>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               VARTYPECODE = PROC_PARAM;
            END;

   /*  69   <PARAM LIST 2>  ::=   ; <PARAM LIST 1>   */
            DO;
               CALL UNSTACK;
               IS_DECLARATION = TRUE;
               VARTYPECODE = VARIABLE;
            END;

   /*  70   <PARAM LIST 2>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               CALL UNSTACK;
               NESTING_LEVEL = NESTING_LEVEL - 1;
               END;

   /*  71   <PARAM TYPE LIST>  ::=   ( <PARAM TYPES> )   */
            ;

   /*  72   <PARAM TYPE LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
               CALL UNSTACK;
            END;

   /*  73   <CASE LIST>  ::=
      <CONSTANT> <CONST LIST> : <STATEMENT> <CASE LIST 2>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  74   <CASE LIST 2>  ::=   ; <CASE LIST>   */
            DO;
               IF IS_EMPTY_CASE_INSTANCE THEN
                  DO;
                     IS_EMPTY_CASE_INSTANCE = FALSE;
                     RETURN;
                  END;
               DO WHILE (NODE_STACK(NODE_STACKSIZE) ~= 28)
                        & (NODE_STACKSIZE > 0);
                  CALL UNSTACK;
               END;
               CALL UNSTACK;   /* CASE LIST */
            END;

   /*  75   <CASE LIST 2>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IF IS_EMPTY_CASE_INSTANCE THEN
                  DO;
                     IS_EMPTY_CASE_INSTANCE = FALSE;
                     RETURN;
                  END;
               DO WHILE (NODE_STACK(NODE_STACKSIZE) ~= 28)
                        & (NODE_STACKSIZE > 0);
                  CALL UNSTACK;
               END;
               CALL UNSTACK;   /* CASE LIST */
            END;

   /*  76   <CONST LIST>  ::=   , <CONSTANT> <CONST LIST>   */
            ;

   /*  77   <CONST LIST>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /*  78   <VARIABLE>  ::=   <IDENTIFIER> <QUALIFIER>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  79   <QUALIFIER>  ::=   (. <EXPRESSION> <EXP LIST> .) <QUALIFIER>   */
 SUBSCRIPT : DO;
               CALL UNSTACK_QUALIFIER;
               CALL OPEN_BRACKET;
               CALL STACK_NODE(NODE_NUMBER);
            END;

   /*  80   <QUALIFIER>  ::=   . <IDENTIFIER> <QUALIFIER>   */
            DO;
               CALL UNSTACK_QUALIFIER;
               IF ~IS_QUALIFIED_REFERENCE(NESTING_LEVEL) THEN DO;
                  CALL OPEN_BLOCK (OLD);
                  IS_QUALIFIED_REFERENCE(NESTING_LEVEL) = TRUE;
                  END;
               CALL STACK_NODE(NODE_NUMBER);
            END;

   /*  81   <QUALIFIER>  ::=   @ <QUALIFIER>   */
            DO;
               CALL UNSTACK_QUALIFIER;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
               CALL UNSTACK;
            END;

   /*  82   <QUALIFIER>  ::=   ... EMPTY PRODUCTION ...   */
            IF IS_FUNC_CALL(NESTING_LEVEL) THEN
               IS_FUNC_CALL(NESTING_LEVEL) = FALSE;
            ELSE
            DO;
               CALL UNSTACK_QUALIFIER;
               IF IS_QUALIFIED_REFERENCE(NESTING_LEVEL) THEN DO;
                  IF ~IS_WITHBLOCK(NESTING_LEVEL) THEN
                     CALL CLOSE_BLOCK (OLD);
                  IS_QUALIFIED_REFERENCE(NESTING_LEVEL) = FALSE;
                  END;
               ELSE IF IS_WITHBLOCK(NESTING_LEVEL) THEN
                  CALL OPEN_BLOCK (OLD);
               CALL UNSTACK;   /* FOUND A VARIABLE */
            END;

   /*  83   <SIMPLE TYPE>  ::=   <IDENTIFIER> <SIMPLE TYPE 1>   */
            DO;
               CALL ASSOCIATE_TYPE_WITH_ID;
               CALL STACK_NODE(NODE_NUMBER);
               END;

   /*  84   <SIMPLE TYPE>  ::=   ( <ID LIST> )   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               IS_DECLARATION = TRUE;
               VARTYPECODE = CONSTANT;
               PROC_LEVEL = CURRENT_LEVEL;
      RPT:     I = VAR_TYPE(SYMB_BLOCK_OWNER(PROC_LEVEL));
               IF (I ~= PROC) & (I ~= FORWARD) THEN DO;
                  IF PROC_LEVEL > 1 THEN PROC_LEVEL = PROC_LEVEL - 1;
                  IS_SCALAR_TYPE_DEFN = TRUE;
                  GOTO RPT;
                  END;
            END;

   /*  85   <SIMPLE TYPE>  ::=   + <CONSTANT 1> .. <SIGN> <CONSTANT 1>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  86   <SIMPLE TYPE>  ::=   - <CONSTANT 1> .. <SIGN> <CONSTANT 1>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               MINUS_FLAG = TRUE;
            END;

   /*  87   <SIMPLE TYPE>  ::=   <UNSIGNED INTEGER> .. <SIGN> <CONSTANT 1>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  88   <SIMPLE TYPE>  ::=   <STRING> .. <SIMPLE TYPE 3>   */
               CALL STACK_NODE(NODE_NUMBER);

   /*  89   <SIMPLE TYPE 1>  ::=   .. <SIMPLE TYPE 2>   */
            NODE_STACK(NODE_STACKSIZE) = 61;

   /*  90   <SIMPLE TYPE 1>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /*  91   <SIMPLE TYPE 2>  ::=   <SIGN> <CONSTANT 1>   */
            ;

   /*  92   <SIMPLE TYPE 2>  ::=   <STRING>   */
            ;

   /*  93   <SIMPLE TYPE 3>  ::=   <IDENTIFIER>   */
            ;

   /*  94   <SIMPLE TYPE 3>  ::=   <STRING>   */
            ;

   /*  95   <CONSTANT 1>  ::=   <IDENTIFIER>   */
            ;

   /*  96   <CONSTANT 1>  ::=   <UNSIGNED INTEGER>   */
            ;

   /*  97   <TYPE>  ::=   <SIMPLE TYPE>   */
            ;

   /*  98   <TYPE>  ::=   @ <TYPE IDENTIFIER>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               IS_FORWARD_DECL = TRUE;
               END;

   /*  99   <TYPE>  ::=   <STRUC TYPE>   */
            ;

   /* 100   <TYPE>  ::=   PACKED <STRUC TYPE>   */
               CALL STACK_NODE(NODE_NUMBER);

 /* 101 <STRUC TYPE> ::= ARRAY  <INDEX  AND  ELEMENTS  TYPE> */
            IF NODE_STACK(NODE_STACKSIZE) = 73 THEN
               NODE_STACK(NODE_STACKSIZE) = 71;
            ELSE
               CALL STACK_NODE(NODE_NUMBER);

   /* 102   <STRUC TYPE>  ::=   FILE OF <TYPE>   */
            IF NODE_STACK(NODE_STACKSIZE) = 73 THEN
               NODE_STACK(NODE_STACKSIZE) = 72;
            ELSE
               CALL STACK_NODE(NODE_NUMBER);

   /* 103   <STRUC TYPE>  ::=   SET OF <SIMPLE TYPE>   */
            IF NODE_STACK(NODE_STACKSIZE)~= 73 THEN
               CALL STACK_NODE(NODE_NUMBER);

   /* 104   <STRUC TYPE>  ::=   RECORD <FIELD LIST> <RECORD ENDINGS   */
            DO;
               IF ~TYPE_DECL_PART THEN DO;
                  /* CREATE A DUMMY TYPE IDENTIFIER IN THE SYMBOL TABLE */
                  DUMMY_NAME# = DUMMY_NAME# + 1;
                  LAST_LITERAL_SCANNED =  ENTER_SYMBOL ('$RECORD' ||
                                         DUMMY_NAME#, CURRENT_LEVEL);
                  END;
               VAR_TYPE(LAST_LITERAL_SCANNED) = RECORD;
               VALUE(LAST_LITERAL_SCANNED) = CURRENT_BLOCK + 1;
               CALL ASSOCIATE_TYPE_WITH_ID;
               TYPE_DECL_PART = FALSE;
               IS_DECLARATION = TRUE;
               VARTYPECODE = FIELD_ID;
            IF NODE_STACK(NODE_STACKSIZE) = 73 THEN
               NODE_STACK(NODE_STACKSIZE) = 74;
               ELSE CALL STACK_NODE(NODE_NUMBER);
               CALL OPEN_BLOCK (NEW);
            END;

   /* 105   <SIMPLE TYPE LIST>  ::=   , <SIMPLE TYPE> <SIMPLE TYPE LIST>   */
            DO;
               CALL UNSTACK;
               CALL STACK_NODE(NODE_STACK(NODE_STACKSIZE));
            END;

   /* 106   <SIMPLE TYPE LIST>  ::=   ... EMPTY PRODUCTION ...   */
            CALL UNSTACK;

   /* 107   <FIELD LIST>  ::=   <ID LIST> : <TYPE> <NEXT FIELD>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 108   <FIELD LIST>  ::=
      CASE <IDENTIFIER> : <IDENTIFIER> OF <VARIANT INSTANCE> <VARIANT INSTANCE L
        */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               VARTYPECODE = VARIANT;
            END;

   /* 109   <NEXT FIELD>  ::=   ; <FIELD LIST>   */
            DO;
               IF IS_EMPTY_FIELD_LIST THEN
                     DO;
                        IS_EMPTY_FIELD_LIST = FALSE;
                        RETURN;
                     END;
               CALL UNSTACK;   /* <TYPE> */
               IS_DECLARATION = TRUE;
               VARTYPECODE = FIELD_ID;
               I = NODE_STACK(NODE_STACKSIZE);
               DO WHILE (63<=I & I<=66) | (71<=I & I<=74);
                  CALL UNSTACK;   /* ARRAY OF ARRAY OF ARRAY ...  (E.G.) */
                  I = NODE_STACK(NODE_STACKSIZE);
               END;
               CALL UNSTACK;   /* <FIXED FIELD> */
            END;

   /* 110   <NEXT FIELD>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IF IS_EMPTY_FIELD_LIST THEN
                     DO;
                        IS_EMPTY_FIELD_LIST = FALSE;
                        RETURN;
                     END;
               CALL UNSTACK;   /* <TYPE> */
               I = NODE_STACK(NODE_STACKSIZE);
               DO WHILE (63<=I & I<=66) | (71<=I & I<=74);
                  CALL UNSTACK;   /* ARRAY OF ARRAY OF ARRAY ...  (E.G.) */
                  I = NODE_STACK(NODE_STACKSIZE);
               END;
               CALL UNSTACK;   /* <FIXED FIELD> */
            END;

   /* 111   <TAG IDENT>  ::=   <IDENTIFIER>   */
            IS_DECLARATION = FALSE;

   /* 112   <VARIANT INSTANCE LIST>  ::=
      ; <VARIANT INSTANCE> <VARIANT INSTANCE LIST>   */
            DO;
               IF IS_EMPTY_CASE_INSTANCE THEN
                  IS_EMPTY_CASE_INSTANCE = FALSE;
               ELSE
                  DO;
                     CALL UNSTACK;   /* 66 <TYPE> */
                     CALL UNSTACK;   /* LAST <VARIANT INSTANCE> */
                  END;
            END;

   /* 113   <VARIANT INSTANCE LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               IF IS_EMPTY_CASE_INSTANCE THEN
                  IS_EMPTY_CASE_INSTANCE = FALSE;
               ELSE
                  DO;
                     CALL UNSTACK;   /* 66 <TYPE> */
                     CALL UNSTACK;   /* LAST <VARIANT INSTANCE> */
                  END;
               CALL UNSTACK;   /* <VARIANT FIELD> */
            END;

   /* 114   <VARIANT INSTANCE>  ::=
      <CONSTANT> <CONST LIST> : <VARIANT INSTANCE 2>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 115   <VARIANT INSTANCE 2>  ::=   ( <FIELD LIST> )   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               IS_DECLARATION = TRUE;
               VARTYPECODE = FIELD_ID;
            END;

   /* 116   <CONSTANT>  ::=   <STRING>   */
            ;

   /* 117   <CONSTANT>  ::=   <SIGN> <CONSTANT 2>   */
            ;

   /* 118   <CONSTANT 2>  ::=   <IDENTIFIER>   */
            ;

   /* 119   <CONSTANT 2>  ::=   <UNSIGNED INTEGER>   */
            ;

   /* 120   <CONSTANT 2>  ::=   <UNSIGNED REAL>   */
            ;

   /* 121   <SIGN>  ::=   +   */
            ;

   /* 122   <SIGN>  ::=   -   */
            MINUS_FLAG = TRUE;

   /* 123   <SIGN>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /* 124   <EXPRESSION>  ::=   <SIMPLE EXPRESSION> <EXPRESSION 2>   */
            ;

   /* 125   <EXPRESSION 2>  ::=   <RELOP> <SIMPLE EXPRESSION>   */
            ;

   /* 126   <EXPRESSION 2>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /* 127   <RELOP>  ::=   =   */
            CALL STACK_OP(32);

   /* 128   <RELOP>  ::=   <   */
            CALL STACK_OP(33);

   /* 129   <RELOP>  ::=   >   */
            CALL STACK_OP(34);

   /* 130   <RELOP>  ::=   <>   */
            CALL STACK_OP(35);

   /* 131   <RELOP>  ::=   <=   */
            CALL STACK_OP(36);

   /* 132   <RELOP>  ::=   >=   */
            CALL STACK_OP(37);

   /* 133   <RELOP>  ::=   IN   */
            CALL STACK_OP(38);

   /* 134   <SIMPLE EXPRESSION>  ::=   + <TERM> <SIMPLE EXPRESSION 2>   */
            ;

   /* 135   <SIMPLE EXPRESSION>  ::=   - <TERM> <SIMPLE EXPRESSION 2>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 136   <SIMPLE EXPRESSION>  ::=   <TERM> <SIMPLE EXPRESSION 2>   */
            ;

   /* 137   <SIMPLE EXPRESSION 2>  ::=   <ADDOP> <TERM> <SIMPLE EXPRESSION 2>
        */
            DO WHILE (39 <= NODE_STACK(NODE_STACKSIZE)
                      & NODE_STACK(NODE_STACKSIZE) <= 41)
                  | NODE_STACK(NODE_STACKSIZE) = 30;
                  CALL UNSTACK;
            END;

   /* 138   <SIMPLE EXPRESSION 2>  ::=   ... EMPTY PRODUCTION ...   */
            DO WHILE (32 <= NODE_STACK(NODE_STACKSIZE)
                      & NODE_STACK(NODE_STACKSIZE) <= 41)
                  | NODE_STACK(NODE_STACKSIZE) = 30;
                  CALL UNSTACK;
            END;

   /* 139   <ADDOP>  ::=   +   */
            CALL STACK_OP(39);

   /* 140   <ADDOP>  ::=   -   */
            CALL STACK_OP(40);

   /* 141   <ADDOP>  ::=   OR   */
            CALL STACK_OP(41);

   /* 142   <TERM>  ::=   <FACTOR> <TERM 2>   */
            ;

   /* 143   <TERM 2>  ::=   <MULOP> <FACTOR> <TERM 2>   */
         TERM_2:
            DO;
               IF NODE_STACK(NODE_STACKSIZE) ~= LPARENT THEN
                  CALL UNSTACK;
               ELSE
                  NODE_STACKSIZE = NODE_STACKSIZE - 1;
               DO WHILE NODE_STACK(NODE_STACKSIZE) = 31;
                  CALL UNSTACK;   /* UNARY ~'S */
               END;
               DO WHILE 42 <= NODE_STACK(NODE_STACKSIZE)
                        & NODE_STACK(NODE_STACKSIZE) <= 46;
                  CALL UNSTACK;   /* <TERM> */
               END;
            END;

   /* 144   <TERM 2>  ::=   ... EMPTY PRODUCTION ...   */
            GOTO TERM_2;

   /* 145   <MULOP>  ::=   *   */
            CALL STACK_OP(42);

   /* 146   <MULOP>  ::=   /   */
            CALL STACK_OP(43);

   /* 147   <MULOP>  ::=   DIV   */
            CALL STACK_OP(44);

   /* 148   <MULOP>  ::=   MOD   */
            CALL STACK_OP(45);

   /* 149   <MULOP>  ::=   AND   */
            CALL STACK_OP(46);

   /* 150   <FACTOR>  ::=   <IDENTIFIER> <FACTOR 2>   */
       DO ; /* CHECK IF IT IS A FUNCTION CALL  */
               IS_FUNC_CALL(NESTING_LEVEL) =
                  SHR (IS_PROC_TYPE, VAR_TYPE(LAST_LITERAL_SCANNED)) & 1;
               IF IS_FUNC_CALL(NESTING_LEVEL) THEN CALL STACK_NODE(47);
         ELSE  DO ; /* IT IS A VARIABLE */
               CALL STACK_NODE(NODE_NUMBER);
               CALL STACK_NODE(51);
            END;
       END ;

   /* 151   <FACTOR>  ::=   ( <EXPRESSION> <RPARENT>   */
            DO;
               CALL STACK_NODE(LPARENT);
               CALL OPEN_BRACKET;
               END;

   /* 152   <FACTOR>  ::=   NOT <FACTOR>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 153   <FACTOR>  ::=   (. <ELEMENTS> .)   */
            CALL OPEN_BRACKET;

   /* 154   <FACTOR>  ::=   <UNSIGNED INTEGER>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 155   <FACTOR>  ::=   <UNSIGNED REAL>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 156   <FACTOR>  ::=   <STRING>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 157   <FACTOR>  ::=   NIL   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = GET_NODE(0);
               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE) + 1) = 2;
               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE) + 2) = CARD_COUNT;
            END;

   /* 158   <FACTOR 2>  ::=   <QUALIFIER>   */
            ;

 /* 159 <QUALIFIER>::= ( <EXPRESSION> <EXP LIST> ) <QUALIFIER> */
       DO;
         /* TEST IF IT IS A FUNCTION CALL */
               IF IS_FUNC_CALL(NESTING_LEVEL) THEN
           CALL OPEN_BRACKET ;
         ELSE /* IT IS A SUBSCRIPTED VARIABLE  */
           GOTO SUBSCRIPT ;
       END;

   /* 160   <ELEMENTS>  ::=   <EXPRESSION> <ELEMENTS 2> <ELEMENT LIST>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               CALL STACK_NODE(75);
            END;

   /* 161   <ELEMENTS>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = GET_NODE(0);
               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE)+1) = 3;
               PARSE_TREE(SUBTREE_STACK(SUBTREE_STACKSIZE)+2) = CARD_COUNT;
               NESTING_LEVEL = NESTING_LEVEL - 1;
            END;

   /* 162   <RPARENT>  ::=   )   */
            DO;
               DO WHILE NODE_STACKSIZE > 0 &
                        NODE_STACK(NODE_STACKSIZE) ~= LPARENT;
                  CALL UNSTACK;
               END;
               NESTING_LEVEL = NESTING_LEVEL - 1;
            END;

   /* 163   <PROGRAM HEADING>  ::=   PROGRAM <IDENTIFIER> <PROGRAM HEADING TAIL>
        */
            DO;
               IS_DECLARATION = TRUE;
               VARTYPECODE = PROC;
            END;

   /* 164   <RETURNS>  ::=   : <TYPE IDENTIFIER>   */
            ;

   /* 165   <RETURNS>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /* 166   <BODY>  ::=   FORWARD   */
            DO;
               CALL WRITEOUT;
               VALUE(OWN_MOD) = CURRENT_BLOCK;
               VAR_TYPE(OWN_MOD) = FORWARD;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
               CALL UNSTACK;
               CALL WRITEOUT;
               BLOCK_CLOSURE_CODE = OLD;
            END;

   /* 167   <CASE LIST>  ::=   <CASE LIST 2>   */
            IS_EMPTY_CASE_INSTANCE = TRUE;

   /* 168   <FIELD LIST>  ::=   <NEXT FIELD>   */
            DO;
               IS_DECLARATION = FALSE;
               IS_EMPTY_FIELD_LIST = TRUE;
            END;

   /* 169   <VARIANT INSTANCE>  ::=   ... EMPTY PRODUCTION ...   */
            IS_EMPTY_CASE_INSTANCE = TRUE;

   /* 170   <ELEMENTS 2>  ::=   .. <EXPRESSION>   */
            NODE_STACK(NODE_STACKSIZE) = 76;

   /* 171   <ELEMENTS 2>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /* 172   <ELEMENT LIST>  ::=   , <EXPRESSION> <ELEMENTS 2> <ELEMENT LIST>
        */
            DO;
               CALL UNSTACK;
               CALL STACK_NODE(NODE_NUMBER);
            END;

   /* 173   <ELEMENT LIST>  ::=   ... EMPTY PRODUCTION ...   */
            DO;
               CALL UNSTACK;
               NESTING_LEVEL = NESTING_LEVEL - 1;
               END;

   /* 174   <PARAM TYPES>  ::=   <ID LIST> <PARAM TYPES TAIL>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 175   <PARAM TYPES>  ::=   VAR <ID LIST> <PARAM TYPES TAIL>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 176   <PARAM TYPES>  ::=   FUNCTION <FUNC TYPES> <PARAM TYPES TAIL>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 177   <PARAM TYPES>  ::=   PROCEDURE <PROC TYPES> <PARAM TYPES TAIL>   */
               CALL STACK_NODE(NODE_NUMBER);

   /* 178   <PARAM TYPES>  ::=   <PARAM TYPES TAIL>   */
            DO;
               CALL STACK_NODE(NODE_NUMBER);
               SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
               SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
            END;

   /* 179   <PARAM TYPES TAIL>  ::=   ... EMPTY PRODUCTION ...   */
            CALL UNSTACK;

   /* 180   <PARAM TYPES TAIL>  ::=   ; <PARAM TYPES>   */
            CALL UNSTACK;

   /* 181   <PROGRAM HEADING TAIL>  ::=   ( <ID LIST> ) <SEMICOLON>   */
            DO;
               IS_DECLARATION = FALSE;
               /*  MAKE THE PROGRAM NAME UN-REFERENCEABLE AND
               **  RE-INITIALIZE THE BLOCK COUNT AND LEXICAL LEVEL */
               IDENTITY(LAST_LITERAL_SCANNED) = DOLLAR ||
                        IDENTITY(LAST_LITERAL_SCANNED);
               CURRENT_BLOCK, CURRENT_LEVEL = 0;
               CALL OPEN_BLOCK (NEW);
               IS_FORWARD_DECL = TRUE;
            END;

   /* 182   <SEMICOLON>  ::=   ;   */
            DO;
               IS_FORWARD_DECL = FALSE;
               CALL WRITEOUT;
               END;

   /* 183   <PROC DECL TAIL>  ::=   ; <PROC DECL LIST>   */
            DO;
               CALL CLOSE_BLOCK (BLOCK_CLOSURE_CODE);
               BLOCK_CLOSURE_CODE = NEW;
               END;

   /* 184   <FUNC TYPES>  ::=
      ( <PARAM TYPES> ) : <IDENTIFIER> <FUNC TYPES TAIL>   */
            ;

   /* 185   <FUNC TYPES TAIL>  ::=   , <FUNC TYPES>   */
            DO;
               CALL UNSTACK;
               CALL STACK_NODE(NODE_NUMBER);
            END;

   /* 186   <FUNC TYPES TAIL>  ::=   ... EMPTY PRODUCTION ...   */
            ;

   /* 187   <PROC TYPES>  ::=   ( <PARAM TYPES> ) <PROC TYPES TAIL>   */
            ;

   /* 188   <PROC TYPES TAIL>  ::=   , <PROC TYPES>   */
            DO;
               CALL UNSTACK;
               CALL STACK_NODE(NODE_NUMBER);
            END;

   /* 189   <PROC TYPES TAIL>  ::=   ... EMPTY PRODUCTION ...   */
            ;
   /* 190   <CLOSE>  ::=   ....EMPTY PRODUCTION ...   */
            DO;
               NESTING_LEVEL = NESTING_LEVEL - 1;
               DO I = 1 TO WITHCOUNT(NESTING_LEVEL);
                  CALL CLOSE_BLOCK (OLD);
                  END;
               IS_WITHBLOCK(NESTING_LEVEL) = FALSE;
               WITHCOUNT(NESTING_LEVEL) = 0;
               END;

   /* 191   <TYPE IDENTIFIER>  ::=   <IDENTIFIER>   */
            DO;
               IS_FORWARD_DECL = FALSE;
               CALL ASSOCIATE_TYPE_WITH_ID;
               END;

   /* 192   <RECORD ENDING>  ::=   END   */
            CALL CLOSE_BLOCK(OLD);

 /* 193 .. 212 ARE PRODUCTIONS FOR ERROR RECOVERY */
   /* 193   <DUMMY FOR STAT>  ::=   <FOR STAT 2>   */
      ;
   /* 194   <DUMMY FOR STAT>  ::=   ... EMPTY PRODUCTION ...   */
      ;
   /* 195   <DUMMY ENDING>  ::=   END   */
      ;
   /* 196   <DUMMY ENDING>  ::=   ... EMPTY PRODUCTION ...   */
      ;
   /* 197   <DUMMYBLOCK>  ::=   <BLOCK>   */
      ;
   /* 198   <DUMMYBLOCK>  ::=   ... EMPTY PRODUCTION ...   */
      ;
   /* 199   <SEMICOLON1>  ::=   ;   */
      ;
   /* 200   <DUMMY FIELD>  ::=   <TYPE> <NEXT FIELD>   */
      CALL BUILD_ERROR_TREE;
   /* 201   <DUMMY STATEMENT TAIL>  ::=   OF <CASE LIST> END   */
      CALL BUILD_ERROR_TREE;
   /* 202   <DUMMY STATEMENT TAIL>  ::=   DO <STATEMENT>   */
      CALL BUILD_ERROR_TREE;
   /* 203   <DUMMY STATEMENT TAIL>  ::=   <FOR STAT 2>   */
      CALL BUILD_ERROR_TREE;
   /* 204   <DUMMY STATEMENT TAIL>  ::=   ... EMPTY PRODUCTION ...   */
      ;
   /* 205   <DUMMY VAR DECL BODY>  ::=   : <TYPE> <VAR DECL TAIL>   */
      CALL BUILD_ERROR_TREE;
   /* 206   <DUMMY TYPE BODY>  ::=   <TYPE DESCRIPTOR PART>   */
      CALL BUILD_ERROR_TREE;
   /* 207   <DUMMY TYPE BODY>  ::=   <TYPE> <TYPE DEFN TAIL>   */
      CALL BUILD_ERROR_TREE;
   /* 208   <ASSIGNMENT     PART>  ::=   <QUALIFIER> := <EXPRESSION>   */
      ;
   /* 209   <ASSIGNMENT     PART>  ::=   ... EMPTY PRODUCTION ...   */
      ;
   /* 210   <INDEX  AND  ELEMENTS  TYPE>  ::=
      (. <SIMPLE TYPE> <SIMPLE TYPE LIST> .) OF <TYPE>   */
      ;
   /* 211   <INDEX  AND  ELEMENTS  TYPE>  ::=
      ( <SIMPLE TYPE> <SIMPLE TYPE LIST> ) OF <TYPE>   */
      ;
   /* 212   <DUMMY STATEMENT TAIL>  ::=   THEN <STATEMENT> <ELSE PART>   */
      DO;
         CALL STACK_NODE(FI);
         CALL BUILD_ERROR_TREE;
      END;
 /*  213  ERROR NODE  CASE  */
      CALL BUILD_ERROR_TREE;

      END;   /* OF DO CASE */

   END SYNTHESIZE;




 /*         STRONG LL(1) ANALYSIS ALGORITHM                   */



   /*              A PUSHDOWN STACK IN A PARSER
                   IS A LIFO QUEUE IN O.R., SIR.
                   YOU MAY CALL IT A 'TRAY STACK'                               
                   OR EVEN A HAYSTACK
                   BUT CALLING IT 'GEORGE' IS TOO FAR, SIR.

                         -- PETER KUGEL             */



COMPILATION_LOOP:  PROCEDURE;
   DECLARE (I, INDEX, STACKTOP, LGTH, RANGE) FIXED,
            PRODUCTION_NUMBER FIXED,
              TOKENS_OUT(NT) BIT(8),
            FOUND_PROD BIT(1);
  DECLARE  ( TOKEN_SUPPLIED,SUCCESSFUL_INSERTION) BIT(1),PREVIOUS_TOKEN FIXED;
   DECLARE  FOUND_SPELLING_ERROR BIT(1), TOKEN_MISSPELT FIXED;
  DECLARE BRACKET_COUNT BIT(1);
   DECLARE (TOKEN_EXPECTED, #_EXPECTED_TOKENS ) FIXED;
 DECLARE (SEMI_COLON_OK,RIGHT_PAREN_OK) BIT(1);






   GET_TOKEN:  PROCEDURE;  /* TO CALL THE LEXICAL ANALYZER  */
      DECLARE I FIXED;
      IF (TOKEN=IDENT) | (TOKEN=STRING) | (TOKEN=INTCONST) | (TOKEN=REALCONST)
         THEN DO;
            IF MINUS_FLAG THEN
               DO;
                    IF TOKEN=REALCONST THEN
                      NUMBER_VALUE =NUMBER_VALUE | "80000000";
                  ELSE IF TOKEN = INTCONST THEN NUMBER_VALUE = - NUMBER_VALUE;
                  IF TOKEN ~= IDENT THEN
                     DO;
                        MINUS_FLAG = FALSE;
                        LAST_LITERAL_SCANNED = LOOKUP_LITERAL(BCD);
                     END;
                  ELSE CALL STACK_NODE(58);
               END;
            SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
            IF SUBTREE_STACKSIZE >= FORESTSIZE THEN
               DO;
                  CALL ERROR('SEMANTIC STACK OVERFLOW',1);
                  COMPILING = FALSE;
                  RETURN;
               END;
            I = GET_NODE(0);
            SUBTREE_STACK(SUBTREE_STACKSIZE) = I;
            PARSE_TREE(I+1) = LAST_LITERAL_SCANNED;
            PARSE_TREE(I+2) = CARD_COUNT;
            IF NODE_STACK(NODE_STACKSIZE) = 58 THEN CALL UNSTACK;
            IF MINUS_FLAG THEN
               DO;
                  CALL UNSTACK;
                  MINUS_FLAG = FALSE;
               END;
         END;
      SUCCESSFUL_INSERTION=TRUE;
      IF TOKEN_SUPPLIED THEN DO;
        I=TOKEN;
        TOKEN=PREVIOUS_TOKEN;
        PREVIOUS_TOKEN=I;
        TOKEN_SUPPLIED=FALSE;
        SUCCESSFUL_INSERTION=FALSE;
        RETURN;
      END;
       PREVIOUS_TOKEN=TOKEN;
      CALL  SCAN;
        IF MONITOR_LINK(2)  >= 2 THEN
      CALL PARAGRAPH;
      DO CASE LOOKUP_TYPE(TOKEN);
         /*   CASE 0 -- NO LOOKUP  */
            ;
         /*   CASE 1 -- IDENTIFIER  */
            LAST_LITERAL_SCANNED = LOOKUP(BCD, 0);
         /*   CASE 2 -- STRING OR ARITHMETIC CONSTANT  */
            LAST_LITERAL_SCANNED = LOOKUP_LITERAL (BCD);
         END;  /* CASE ON LOOKUP_TYPE */
   END GET_TOKEN;


   /*                        ERROR RECOVERY PROCEDURES                */




 IS_RESERVED_WORD : PROCEDURE(I)  BIT(1);
   DECLARE I FIXED;
   RETURN (SHL(BYTE(RESERVED_WORDS,SHR(I,3)) ,I& "07" ) & "80" ) ~ = 0;
 END IS_RESERVED_WORD;


 CHECK_FOR_SPELLING_ERROR : PROCEDURE(I);
  DECLARE I FIXED;
   DECLARE (X,Y,Z,J) FIXED,MATCH BIT(1),(STRING1,STRING2) CHARACTER ;
   IF ~(IS_RESERVED_WORD(I) & (TOKEN=IDENT)) THEN RETURN;
   IF LENGTH(V(TOKEN)) > 1 THEN DO;
     STRING1 = V(I);
     X=LENGTH(BCD); Y= LENGTH(STRING1);
     IF ( (X-Y) >1 ) | ( (Y-X) > 1 )  THEN RETURN ;
     Z=Y; IF   X<Z THEN Z=X;
     J=0; MATCH=TRUE;
     DO WHILE  (J< Z) & MATCH ;
       IF SUBSTR(BCD,J,1) = SUBSTR(STRING1,J,1) THEN  J=J+1;
       ELSE  MATCH = FALSE;
       END;
     IF MATCH  THEN DO;
       FOUND_SPELLING_ERROR = TRUE;
       TOKEN_MISSPELT = I;
       RETURN;
       END;
     IF X=Y THEN DO;
       STRING2 = SUBSTR(STRING1,J+1);
       STRING1 = SUBSTR(BCD,J+1);
       J=J+1;
       END;
     ELSE IF  X>Y THEN DO;
              STRING2 = SUBSTR(STRING1,J);
              STRING1 = SUBSTR(BCD,J+1);
              END;
          ELSE DO;
              STRING2 = SUBSTR(STRING1,J+1);
              STRING1 = SUBSTR(BCD,J);
              END;
     Z = Z-J; J=0; MATCH = TRUE;
     DO WHILE (J< Z) & MATCH ;
       IF SUBSTR(STRING1,J,1) = SUBSTR(STRING2,J,1) THEN J=J+1;
       ELSE MATCH = FALSE;
       END;
     IF MATCH THEN DO;
       FOUND_SPELLING_ERROR = TRUE;
       TOKEN_MISSPELT = I;
       END;
     END;
 END CHECK_FOR_SPELLING_ERROR;


 DIAGNOSE_ERROR : PROCEDURE;
      DECLARE L FIXED;
      DECLARE (I, J, K, S, T) FIXED,
              (CHECK_NEXT, INCLUDE_TOKEN) BIT(1),
              LINE CHARACTER;

      J = -1;
      FOUND_SPELLING_ERROR, SEMI_COLON_OK, RIGHT_PAREN_OK = FALSE;
      CHECK_NEXT = TRUE;
      S = SP;
      DO WHILE CHECK_NEXT;
         T = PARSE_STACK(S);
         IF T <= NT THEN DO;
            J = J + 1;
            TOKENS_OUT(J) = T;
            IF T = RIGHT_PAREN THEN RIGHT_PAREN_OK = TRUE;
            IF ~FOUND_SPELLING_ERROR THEN CALL CHECK_FOR_SPELLING_ERROR (T);
            CHECK_NEXT = FALSE;
            END;
         ELSE DO;
            L = T - NT1 ;
            CHECK_NEXT = PRODUCES_EMPTY(L);
            DO I = TERMINAL_HEADS_INDEX(L) TO TERMINAL_HEADS_INDEX(L+1) - 1;
               INCLUDE_TOKEN = TRUE;
               T = TERMINAL_HEADS(I);
               DO K = 0 TO J;
                  IF T = TOKENS_OUT(K) THEN INCLUDE_TOKEN = FALSE;
                  END;
               IF INCLUDE_TOKEN THEN DO;
                  J = J + 1;
                  TOKENS_OUT(J) = T;
                  IF ~FOUND_SPELLING_ERROR THEN CALL CHECK_FOR_SPELLING_ERROR(T)
                     ;
                  IF T = SEMI_COLON THEN SEMI_COLON_OK = TRUE;
                  ELSE IF T = RIGHT_PAREN THEN RIGHT_PAREN_OK = TRUE;
                  END;
               END;
            END;
         S = S - 1;
         END;

      #_EXPECTED_TOKENS = J + 1;
      IF #_EXPECTED_TOKENS = 1 THEN TOKEN_EXPECTED = TOKENS_OUT;
      LINE = SUBSTR (X70, 0, 30);
      DO I = 0 TO J;
         LINE = LINE || V(TOKENS_OUT(I)) ||X1;
         END;
   OUTPUT = LINE;
 END DIAGNOSE_ERROR;





 IS_BLOCK_HEAD : PROCEDURE(I) BIT(1);
       DECLARE I FIXED;
       RETURN  (SHL( BYTE( BLOCK_HEADS,SHR(I,3)), I & "07" ) & "80" )~=0;
 END  IS_BLOCK_HEAD;



 IS_RECOVER_SYMBOL : PROCEDURE(I) BIT(1);
       DECLARE  I  FIXED;
       IF  I<=NT THEN  RETURN FALSE;
       I=I-NT;
       RETURN (SHL(BYTE(RECOVERY_SYMBOLS,SHR(I,3)),I & "07") & "80") ~= 0;
 END  IS_RECOVER_SYMBOL;





 IS_CRASH_SCAN_SYMBOL : PROCEDURE(I) BIT(1);
       DECLARE I FIXED;
       RETURN  ( SHL(BYTE( CRASH_SCAN_SYMBOLS,SHR(I,3)),I & "07") & "80")~=0;
 END IS_CRASH_SCAN_SYMBOL;







 IS_EXPECTED:  PROCEDURE (T, S) BIT(1);
      DECLARE (T, S, I, STACK_TOKEN) BIT(16);
      DO FOREVER;
         STACK_TOKEN = PARSE_STACK(S);
         IF STACK_TOKEN <= NT THEN RETURN (STACK_TOKEN = T);
         /* ELSE INSPECT THE TERMINAL HEADS OF STACK_TOKEN */
         DO I = TERMINAL_HEADS_INDEX(STACK_TOKEN - NT1)
                TO TERMINAL_HEADS_INDEX(STACK_TOKEN - NT1+ 1) - 1;
            IF TERMINAL_HEADS(I) = T THEN RETURN TRUE;
            END;
         IF PRODUCES_EMPTY(STACK_TOKEN - NT1) THEN S = S - 1;
         ELSE RETURN FALSE;
         END;
 END  IS_EXPECTED;

 IS_CATCH_SYMBOL  :  PROCEDURE(I) BIT(1);
       /*  PICKS OUT THE  I'TH BIT OF THE BIT STRING CATCH_SYMBOLS .  */
       DECLARE I FIXED;
       RETURN (SHL(BYTE(CATCH_SYMBOLS, SHR(I,3)), I & "07") & "80") ~= 0;
 END  IS_CATCH_SYMBOL;


 IS_TO_BE_REPLACED : PROCEDURE(I) BIT(1);
       /*  PICKS OUT THE I'TH BIT OF  SP_BIT  BIT STRING   */
       DECLARE I FIXED;
       RETURN ( SHL( BYTE(SP_BIT,SHR(I,3)), I&"07")& "80") ~= 0;
 END IS_TO_BE_REPLACED;


 SCAN_AHEAD  :   PROCEDURE ;
       /* SCANS AHEAD UNTIL THE TOKEN IS A HEAD SYMBOL FOR THE STACKTOP OR IS A
       CATCH SYMBOL  */

       DO WHILE COMPILING &
                ~(IS_CATCH_SYMBOL(TOKEN) | IS_EXPECTED(TOKEN, SP));
           CALL GET_TOKEN;
       END;
       IF ~IS_EXPECTED(SEMI_COLON, SP) THEN
       DO  WHILE  TOKEN=SEMI_COLON  ;
           CALL GET_TOKEN;
       END;
 END SCAN_AHEAD;

 CRASH_RESTORE : PROCEDURE;
       /* RESTORES THE STACK WHEN IT HAS CRASHED BECAUSE OF TOO MANY ERRORS. */
       PARSE_STACK(1)=DOT;
       PARSE_STACK(2)=STAT_LIST;
       PARSE_STACK(3)=STATEMENT;
       PARSE_STACK(4)=PROC_DECL_LIST;
       PARSE_STACK(5)=DUMMY_VAR_DECL_BODY;
       PARSE_STACK(6)=VAR_DECLS;
       PARSE_STACK(7)=DUMMY_TYPE_BODY;
       PARSE_STACK(8)=TYPE_DEFNS;
       PARSE_STACK(9)=CONST_DECLS;
       SP=9;
       /* NOW SCAN FOR A SYNBOL TO BEGIN A NEW BLOCK.  */
       DO  WHILE  ~ IS_CRASH_SCAN_SYMBOL(TOKEN);
           CALL GET_TOKEN;
       END;
      CALL SYNTHESIZE (1);  /* TO RE-INITIALIZE THE SEMANTIC STACKS */
 END  CRASH_RESTORE;





 IS_NOT_VAR_NOR_CONST:PROCEDURE(I) BIT(1);
       DECLARE I FIXED;
      RETURN (SHL(BYTE(NOT_VAR_NOR_CONST,SHR(I,3)), I&"07") & "80") ~= 0;
 END IS_NOT_VAR_NOR_CONST;





 HARD_RECOVER : PROCEDURE ;
       /****************************************************************
       *  POPS THE STACK  UNTIL ONE OF THE FOLLOWING CASES ARISES .    *
       *   (1)  THE CURRENT STACKTOP IS   EQUAL TO THE CATCH TOKEN.    *
       *   (2)  THE CURRENT STACKTOP HES THE CATCH TOKEN  AS  A        *
       *              HEAD  SYMBOL.                                    *
       *   (3)   THE CURRENT STACKTOP  IS A STOP POP SYMBOL FOR  THE   *
       *        CATCH TOKEN.  IN THIS CASE  THE STACK IS RESTORED.     *
       ****************************************************************/
       DECLARE  ( RECOVERY_INDEX,J,K) FIXED, STOPIT BIT(1);
       IF CONTROL(BYTE('B')) THEN
       OUTPUT=' *** HARD RECOVERY  ATTEMPTED  ***';
       RECOVERY_INDEX=CATCH_ACTION(TOKEN);
       IF  RECOVERY_INDEX=0 THEN RETURN;
       STOPIT=FALSE;
       DO WHILE  ~(SP=0 | STOPIT);
           STACKTOP=PARSE_STACK(SP);
           IF IS_EXPECTED (TOKEN, SP) THEN RETURN;
           J=RECOVERY_INDEX;
           DO  WHILE ~(STOP_POP_SYMBOL(J)=0 | STOPIT);
               IF  STOP_POP_SYMBOL(J)=STACKTOP THEN STOPIT=TRUE;
               ELSE  J=J+1;
           END;
           IF ~STOPIT THEN DO;
               NODE_NUMBER = ERROR_NODE;
               CALL SYNTHESIZE (PR#(PARSE_STACK(SP) - NT1));
               IF  CONTROL(BYTE('B')) THEN
               OUTPUT = '*** PRODUCTION #  ' || PR#(PARSE_STACK(SP)- NT1) ||
                        '  APPLIED  IN  HARD RECOVER. ***';
               SP = SP - 1;
               END;
       END;
       IF SP=0 THEN  CALL CRASH_RESTORE;
       ELSE  DO;
           IF IS_TO_BE_REPLACED(J) THEN DO;
               CALL SYNTHESIZE (ERROR_PROD);
               IF CONTROL(BYTE('B')) THEN
               OUTPUT='**  ERROR  PRODUCTION APPLIED    ';
               SP = SP - 1;
               END;
           K=REST_PTR(J);
           IF  K~=0 THEN DO;
             DO  J=K+1  TO  K+REST_SYMBOL(K);
               SP=SP+1;
               PARSE_STACK(SP)=REST_SYMBOL(J);
             END;
           END;
       END;
   IF CONTROL(BYTE('B')) THEN
   CALL  STACK_DUMP;
 END  HARD_RECOVER;


 SUPPLY_TOKEN : PROCEDURE (I);
       /* INSERTS  TOKEN  I  AND STORES THE PRESENT TOKEN IN PREVIOUS TOKEN */
       DECLARE  I  FIXED;
       PREVIOUS_TOKEN= TOKEN;
       TOKEN = I;
       TOKEN_SUPPLIED=TRUE;
       OUTPUT = '***        TOKEN SUPPLIED IS   ' || V(I) || '   ***';
       SEMI_COLON_OK=FALSE;
       RIGHT_PAREN_OK=FALSE;
 END  SUPPLY_TOKEN;





 SOFT_RECOVER : PROCEDURE;
       DECLARE I FIXED;
       /* FIRST  CHECK IF  EQUIVALENT TOKEN WILL DO */
       IF IS_EXPECTED (EQUIVALENT(TOKEN), SP) THEN DO;
           TOKEN=EQUIVALENT(TOKEN);
           OUTPUT='*** TOKEN ASSUMED TO BE ' || V(TOKEN) || '    ***';
           IF  STACKTOP<=NT THEN  DO;
               SP=SP-1;
               CALL GET_TOKEN;
           END;
           RETURN;
       END;

          IF FOUND_SPELLING_ERROR THEN DO;
             FOUND_SPELLING_ERROR=FALSE;
             TOKEN=TOKEN_MISSPELT;
             OUTPUT = '***        PROBABLE MISSPELLING OF A KEYWORD.  TOKEN ASSU
MED TO BE ' || V(TOKEN) || '   ***';
             IF  STACKTOP <= NT THEN DO;
                 SP=SP-1;
                 CALL GET_TOKEN;
                 END;
             RETURN;
             END;

       /*  TRY  MISSING TOKENS  */
       /*  NOW CHECK  IF IT IS AN ERROR OF OMISSION  */
       IF IS_EXPECTED (TOKEN, SP-1) THEN DO;
           IF  STACKTOP<=NT THEN
                OUTPUT=' ***  ' || V(STACKTOP)|| ' PROBABLY MISSING ***' ;
           ELSE CALL SYNTHESIZE (PR#(PARSE_STACK(SP) - NT1));
           SP=SP-1;
           RETURN;
       END;
       /*  CHECK FOR SPECIAL TYPES OF ERRORS  */
       /*  TOKEN  IS  'ELSE'  TOKEN   */
       IF TOKEN=ELSE_TOKEN  THEN DO;
           IF  PREVIOUS_TOKEN=SEMI_COLON  THEN  DO;
               OUTPUT = '***        A SEMICOLON CANNOT PRECEDE ''ELSE''   ***';
           END;
           IF STACKTOP = CASE_LIST THEN DO;
               CALL STACK_NODE(28);   /* CASE INSTANCE */
               CALL BUILD_ERROR_TREE;   /* FOR CASE LABEL */
               PARSE_STACK(SP) = CASE_LIST_2;
               SP = SP + 1;
               PARSE_STACK(SP) = STATEMENT;
           END;
           CALL GET_TOKEN;
           RETURN;
       END;
       /* INSERTION OF TOKENS */
       IF SUCCESSFUL_INSERTION THEN DO;
         IF (#_EXPECTED_TOKENS=1)& IS_NOT_VAR_NOR_CONST(TOKEN_EXPECTED)
            THEN DO;
            CALL SUPPLY_TOKEN(TOKEN_EXPECTED);
            RETURN;
         END;
         ELSE DO;
            IF SEMI_COLON_OK THEN DO;
              IF RIGHT_PAREN_OK  THEN
                IF  ~BRACKET_COUNT THEN DO;
                   BRACKET_COUNT=TRUE;
                   CALL SUPPLY_TOKEN(SEMI_COLON);
                   RETURN;
                END;
                ELSE DO;
                   BRACKET_COUNT=FALSE;
                   CALL SUPPLY_TOKEN(RIGHT_PAREN);
                   RETURN;
                END;
              CALL SUPPLY_TOKEN(SEMI_COLON);
              RETURN;
            END;
            IF RIGHT_PAREN_OK  THEN DO;
              BRACKET_COUNT=TRUE;
              CALL SUPPLY_TOKEN(RIGHT_PAREN);
              RETURN;
            END;
         END;
       END;
       /* IF SOFT_RECOVER FAILS ... */
       CALL STACK_NODE (ERROR_NODE);
       SUBTREE_STACKSIZE = SUBTREE_STACKSIZE + 1;
       SUBTREE_STACK(SUBTREE_STACKSIZE) = NULL;
       CALL SCAN_AHEAD;
       CALL UNSTACK;
       IF IS_EXPECTED (TOKEN, SP) THEN RETURN;
       ELSE  CALL  HARD_RECOVER;
 END  SOFT_RECOVER;




   /*                         THE ANALYSIS ALGORITHM                  */


   BRACKET_COUNT=FALSE;
   TOKEN_SUPPLIED=FALSE;
   CALL GET_TOKEN;
   DO WHILE COMPILING;
      IF SP = 0 THEN CALL CRASH_RESTORE;
      FOUND_PROD = FALSE;
      STACKTOP = PARSE_STACK(SP);
      IF CONTROL(BYTE('B')) THEN DO;
         IF TOKEN = IDENT THEN S = BCD;
         ELSE IF TOKEN=INTCONST THEN S=BCD;
         ELSE IF TOKEN=REALCONST THEN S=BCD;
         ELSE IF TOKEN=STRING THEN S=BCD;
         ELSE IF TOKEN=EOFILE THEN S='END OF FILE';
         ELSE S = V(TOKEN);
         OUTPUT = 'SCANNING ' || S;
         CALL STACK_DUMP;
      END;
      IF STACKTOP <= NT THEN DO;
         /*  MATCH TERMINAL SYMBOL SCANNED  */
         IF  TOKEN=STACKTOP  THEN  DO;
               SP=SP-1;  CALL GET_TOKEN;
               END;
         ELSE  DO;
               CALL ERROR ('ONE OF THE FOLLOWING SYMBOLS WAS EXPECTED:', 0);
               CALL DIAGNOSE_ERROR;
               CALL  SOFT_RECOVER;
               END;
      END; /* OF CASE TERMINAL */
      ELSE DO; /* STACKTOP IS NONTERMINAL */
   /*
         RANGE=ENTRIES(STACKTOP-NT1);
         DO WHILE TOKEN >= INIT(RANGE) & RANGE <= ENTRIES(STACKTOP-NT) - 1
                                                                & ~FOUND_PROD;
            IF TOKEN <= FIN(RANGE) THEN DO;
               INDEX = TOKEN - INIT(RANGE) + PTR(RANGE);
               PRODUCTION_NUMBER = PROD_#(INDEX);
               FOUND_PROD = TRUE;
            END;
            ELSE RANGE = RANGE + 1;
         END;  /* OF SEARCH FOR AN APPLICABLE PRODUCTION */
      CALL INLINE("58",2,0,STACKTOP);            /* L    2,STACKTOP        */
      CALL INLINE("5B",2,0,NT1);                 /* S    2,NT1             */
      CALL INLINE("41",3,0,2,1);                 /* LA   3,1(0,2)          */
      CALL INLINE("8D",2,0,0,1);                 /* SLDL 2,1               */
      CALL INLINE("48",1,2,ENTRIES);             /* LH   1,ENTRIES(2)      */
      CALL INLINE("48",2,3,ENTRIES);             /* LH   2,ENTRIES(3)      */
      CALL INLINE("06",2,0);                     /* BCTR 2,0               */
      CALL INLINE("58",0,0,TOKEN);               /* L    0,TOKEN           */
      CALL INLINE("1B",3,3);                     /* SR   3,3               */
      CALL INLINE("05",12,0);                    /* BALR 12,0              */
      CALL INLINE("19",1,2);                     /* CR   1,2               */
      CALL INLINE("47",2,0,12,66);               /* BH   66(0,12)          */
      CALL INLINE("43",3,1,INIT);                /* IC   3,INIT(1)         */
      CALL INLINE("19",0,3);                     /* CR   0,3               */
      CALL INLINE("47",4,0,12,66);               /* BL   66(0,12)          */
      CALL INLINE("43",3,1,FIN);                 /* IC   3,FIN(1)          */
      CALL INLINE("19",0,3);                     /* CR   0,3               */
      CALL INLINE("47",2,0,12,60);               /* BH   60(0,12)          */
      CALL INLINE("18",2,0);                     /* LR   2,0               */
      CALL INLINE("43",3,1,INIT);                /* IC   3,INIT(1)         */
      CALL INLINE("1B",2,3);                     /* SR   2,3               */
      CALL INLINE("1A",1,1);                     /* AR   1,1               */
      CALL INLINE("4A",2,1,PTR);                 /* AH   2,PTR(1)          */
      CALL INLINE("43",3,2,PROD_#);              /* IC   3,PROD_#(2)       */
      CALL INLINE("50",3,0,PRODUCTION_NUMBER);   /* ST   3,PRODUCTION_NUMBER */
      CALL INLINE("41",3,0,0,1);                 /* LA   3,1               */
      CALL INLINE("42",3,0,FOUND_PROD);          /* STC  3,FOUND_PROD      */
      CALL INLINE("47",15,0,12,66);              /* B    66(0,12)          */
      CALL INLINE("41",1,0,1,1);                 /* LA   1,1(0,1)          */
      CALL INLINE("07",15,12);                   /* BR   12                */
         IF  ~FOUND_PROD   THEN  DO;
            IF IS_RECOVER_SYMBOL(STACKTOP-NT) THEN  SP=SP-1;
            ELSE DO;
                  IF TOKEN ~= EOFILE THEN DO;
                     CALL ERROR('ONE OF THE FOLLOWING SYMBOLS WAS EXPECTED:',1);
                     CALL DIAGNOSE_ERROR;
                  END;
                  CALL   SOFT_RECOVER;
            END;
         END;


         IF FOUND_PROD THEN DO;
            NODE_NUMBER = NODE#TRANSLATE(PRODUCTION_NUMBER);
            CALL SYNTHESIZE(PRODUCTION_NUMBER);
            /* NOW UPDATE THE PARSE_STACK                             */
            SP = SP - 1;
            IF   NONEMPTY(PRODUCTION_NUMBER)~=0 THEN DO;
                 LGTH = PR_LENGTH(PRODUCTION_NUMBER);
                 IF LGTH > 0 THEN DO;
                    INDEX = PR_PTR(PRODUCTION_NUMBER);
                    DO I = 1 TO LGTH;
                       SP = SP + 1;
                       PARSE_STACK(SP) = RHS(INDEX + LGTH - I);
                    END;
                 END;
                 /* IF THE APPLICABLE PRODUCTION BEGINS WITH A TERMINAL SYMBOL,
                    THEN SCAN FOR NEXT TOKEN                               */
                 IF  IS_TERMINAL(PRODUCTION_NUMBER) THEN
                      CALL   GET_TOKEN;
            END;
         END;
      END;
   END;
   CALL WRITEOUT;
   CALL COMPACTIFY_SYMBOL_TABLE;
   CALL PUNCH_SYMBOLS;
      /* IF COMPILATION IS TERMINATED PREMATURELY, SCAN TO EOFILE     */
   IF TOKEN ~= EOFILE THEN DO;
      SP = 0;
      OUTPUT = '*****     NO FURTHER SYNTAX CHECKING WILL OCCUR     *****';
      COMPILING = TRUE;
      DO WHILE COMPILING;
         CALL GET_CARD;
         CALL SCAN;
      END;
   END;
   IF SP > 0 THEN DO;
      CALL ERROR(
         'COMPILING HALTED BY PREMATURE END OF FILE, POSSIBLY MISSING "END"',1);
      CALL STACK_DUMP;
      IF #_OF_TREES = 0 THEN MONITOR_LINK(0) = NULL;
  /* THE ABOVE INHIBITS FURTHER PROCESSING  */
   END;
   /* $P -- PRINT CROSS-REFERENCE LISTING FOR PROCEDURES  */
END COMPILATION_LOOP;

   /* $P */




PRINT_SUMMARY:
   PROCEDURE;
      DECLARE I FIXED;
      CALL PRINT_DATE_AND_TIME ('END OF PASS ONE ', DATE, TIME);
      OUTPUT = '';
      OUTPUT = CARD_COUNT || ' CARDS WERE PARSED.';
      IF ERROR_COUNT = 0 THEN OUTPUT = 'NO SYNTAX ERRORS WERE DETECTED.';
      ELSE IF ERROR_COUNT > 1 THEN
         OUTPUT = ERROR_COUNT || ' ERRORS (' || SEVERE_ERRORS
            || ' SEVERE) WERE DETECTED.';
      ELSE IF SEVERE_ERRORS = 1 THEN OUTPUT = 'ONE SEVERE ERROR WAS DETECTED.';
         ELSE OUTPUT = 'ONE ERROR WAS DETECTED.';
      IF PREVIOUS_ERROR > 0 THEN
         OUTPUT = 'THE LAST DETECTED ERROR WAS ON LINE ' || PREVIOUS_ERROR
            || PERIOD;
      IF ~CONTROL(BYTE('D')) THEN RETURN;
      CALL DUMPIT;
      DOUBLE_SPACE;
      CLOCK(3) = TIME;
      CPU_CLOCK(3) = ELAPSED_CPU_TIME;
      DO I = 1 TO 3;   /* WATCH OUT FOR MIDNIGHT */
         IF CLOCK(I) < CLOCK(I-1) THEN CLOCK(I) = CLOCK(I) +  8640000;
      END;
      CALL PRINT_TIMES('TOTAL TIME IN PASS ONE:  ',
         CLOCK(3) - CLOCK(0), CPU_CLOCK(3) - CPU_CLOCK(0));
      CALL PRINT_TIMES('SET UP TIME:             ',
         CLOCK(1) - CLOCK(0), CPU_CLOCK(1) - CPU_CLOCK(0));
      CALL PRINT_TIMES('ACTUAL PARSING TIME:     ',
         CLOCK(2) - CLOCK(1), CPU_CLOCK(2) - CPU_CLOCK(1));
      CALL PRINT_TIMES('CLEANUP TIME AT END:     ',
         CLOCK(3) - CLOCK(2), CPU_CLOCK(3) - CPU_CLOCK(2));
      IF CLOCK(2) > CLOCK(1) THEN   /* WATCH OUT FOR CLOCK BEING OFF */
      OUTPUT = 'PARSING RATE: ' || 6000*CARD_COUNT/(CLOCK(2)-CLOCK(1))
         || ' CARDS PER MINUTE.';
   END PRINT_SUMMARY;

MAIN_PROCEDURE:
      CLOCK(0) = TIME;  /* KEEP TRACK OF TIME IN EXECUTION */
      CPU_CLOCK(0) = 0;
      CALL CLOCK_TRAP(0,ADDR(TIMEST));
      CALL INITIALIZATION;
      CALL RE_INITIALIZE;

      CLOCK(1) = TIME;
      CPU_CLOCK(1) = ELAPSED_CPU_TIME;

      CALL COMPILATION_LOOP;

      CLOCK(2) = TIME;
      CPU_CLOCK(2) = ELAPSED_CPU_TIME;

      /* CLOCK(3) AND CPU_CLOCK(3) GET SET IN PRINT_SUMMARY */
      IF CONTROL(BYTE('Z')) THEN CALL SY_DUMP;
      CALL PRINT_SUMMARY;
      MONITOR_LINK(3) = SEVERE_ERRORS;

EOF EOF EOF
