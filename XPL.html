<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    
<title>Virtual AGC Document Library Page</title>


    
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


    
<meta name="Author" content="Ronald Burkey">


    
<link rel="icon" type="image/png" href="favicon.png">


    
<meta name="author" content="Ronald S. Burkey">


    
<script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    
<script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Space Shuttle").replace("@SUBTITLE@","XPL/I Compiler XCOM-I"))
</script><br>


    
<div align="center"><i>(This page is under construction.)</i><br>
    </div>


    
<h1>Table of Contents </h1>


    
<ul>


      <li><a moz-do-not-send="true" href="#Introduction">Introduction to XPL/I</a></li>
<li><a moz-do-not-send="true" href="#compiling">Processing a Program Written in XPL, Using <b>XCOM-I</b>
</a></li>
<ul>
  <li><a moz-do-not-send="true" href="#installation">Installation of <b>XCOM-I</b></a></li>
  <li><a moz-do-not-send="true" href="#xpl">Compiling and Running XPL Programs</a></li>
<li><a moz-do-not-send="true" href="halsfc">HAL/S-FC Through the Lens of <b>XCOM-I</b></a><br></li>
</ul>
<li><a moz-do-not-send="true" href="#xpli">A Primer for Standard XPL and Intermetrics XPL/I</a></li>
<li><a moz-do-not-send="true" href="#debugging">Debugging XPL Programs </a><br></li>

<ul>

  
</ul>

<li><a moz-do-not-send="true" href="#hooks">Patches for Insertion of Inline Code</a></li>
<li><a moz-do-not-send="true" href="inlines">IBM 360 Inline Code</a><br>
</li>

</ul>


    
<h1><a name="Introduction"></a>Introduction to XPL/I<br>
</h1>XPL used to be a computer language (<a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/XPL">see the Wikipedia article</a>) in the 1960's and 1970's that was defined by a book called <i>A Compiler Generator</i>,
 by William M. McKeeman, James J. Horning, and David B. Wortman.&nbsp; 
Today, the language is deader than ancient Sumerian.&nbsp; The 
internals of the language relied heavily on the fact that the compiled 
XPL 
programs would run on IBM System/360 mainframes.&nbsp; Indeed, the 
preface to the book explicitly states that they were creating a language
 specifically for the IBM 360.&nbsp; While you can 
write an XPL compiler that will run on a different type of computer 
system, or that would cross-compile program programs that will run on a 
different kind of 
computer system, doing so in a way that such programs, as-is, would 
produce the same results as they would have on an IBM 360 is 
problematic. Perhaps worse, the book <i>remains</i> the sole documentation for the standard
 XPL language, and is available neither for free, nor in digital form 
online.&nbsp; For brevity, I'll refer to that book from now on simply as
 <i>McKeeman</i>.<br>
<br>
Keep in mind that the Virtual AGC Project is devoted to onboard guidance
 
software used aboard space vehicles such as those of the Apollo and 
Space Shuttle projects, thus most of what I have to say on the topic of 
XPL is from that point of view.&nbsp; But that doesn't mean it isn't 
applicable more generally as well.&nbsp; For the purpose of thinking 
about XPL, 
what you need to know to follow the discussion herein is this:<br>
<ul>
  <li>Flight software for the Space Shuttle was primarily written in a computer language called <i>HAL/S</i>, created by Intermetrics, Inc.&nbsp; That flight software was called <i>PASS</i>, and that's what I'll refer to it as from now on.<br></li>
  <li>To compile PASS source code, you therefore need a compiler for 
HAL/S, and more-specifically for Intermetrics's specific variation of 
HAL/S.&nbsp; Intermetrics's HAL/S compiler, called <b>HAL/S-FC</b>, was primarily written in a language that the Intermetrics team <i>called</i> "XPL".</li>
  <li>Thus to compile the original compiler for PASS, you first need a compiler for what Intermetric referred to as XPL.<br></li>
</ul>
Well, that's certainly a mouthful of words!&nbsp; On takeaway is that 
having an XPL compiler is just one item — though an important one! —  in
 a 
chain of things that are helpful in the process of 
resurrecting PASS for modern audiences. <br>
<br>
Alas, it's even a bit more complicated than what I just said.&nbsp; For 
one thing, as you may have gathered from my wording above, Intermetrics did not write its HAL/S compiler in <i>standard</i>
 XPL as defined by McKeeman.&nbsp; Rather, they extended the language 
with new features, occasionally changing the existing features in an 
incompatible way.&nbsp; From now on, I'll
 refer to Intermetrics's variant of XPL as <i>XPL/I</i> to distinguish it from the standard.&nbsp; <br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
And in case you're wondering, there is no known surviving copy of 
Intermetrics's own XPL/I compiler.&nbsp; In fact, there is reason to 
believe that it was intentionally destroyed.&nbsp; (Prove me wrong, 
please!)&nbsp; If it had survived, however, it would presumably have 
been written in standard XPL and itself compiled by McKeeman's XPL 
compiler (which was called <b>XCOM</b>) or some later variant thereof.</font><br>
</blockquote>


Even if you actually had a perfect compiler for standard XPL that you 
could
 use on (say) a Windows, Mac OS, or Linux computer, it would most likely
 neither 
compile most XPL/I programs, nor would most of those compiled programs 
run correctly afterwards if you were able to do so.&nbsp; But frankly, 
even having such a hypothetical perfect compiler for standard XPL is 
somewhat of a trick, due to the dependence on the underlying IBM 360 
that's non-existent in Windows, Mac OS, and Linux.<br>
<br>
Consider the 
following brief example of a program:<br>
<blockquote>
  <pre><font color="#663333">declare x fixed, y fixed, z fixed;<br>x(0) = 1;<br>x(1) = 2;<br>x(2) = 3;<br>output = x(0) || ' ' || x(1) || ' ' || x(2);<br></font><font color="#663333">output = x || ' ' || y || ' ' || z;</font><br></pre>
</blockquote>
What is this little example supposed to do?&nbsp; First, it declares 3 variables of the <font color="#663333"><code>fixed</code></font> datatype; <font color="#663333"><code>fixed</code></font> means that <font color="#663333"><code>x</code></font>, <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font> are 32-bit signed integers.&nbsp; It then proceeds to use <font color="#663333"><code>x</code></font>
 <i>as if</i> it were a three-element array, though <font color="#663333"><code>x</code></font> wasn't declared that 
way, assigning values to each of its elements.&nbsp; The program simply assumes that <font color="#663333"><code>x(0)</code></font> corresponds to <font color="#663333"><code>x</code></font>, <font color="#663333"><code>x(1)</code></font> corresponds to <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>x(2)</code></font> corresponds to <font color="#663333"><code>z</code></font>.&nbsp; Finally, the program "prints out" both the elements of <font color="#663333"><code>x</code></font> (as an array) and the values of <font color="#663333"><code>x</code></font> (as a non-array), <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font>.&nbsp; Naturally, those two lines of printout are identical.&nbsp; In case you're wondering, we <i>could</i> have used <font color="#663300"><code>z(-1)</code></font> as an equivalent to <font color="#663300"><code>y</code></font>, or <font color="#663300"><code>z(-2)</code></font> as <font color="#663300"><code>x</code></font>.&nbsp; For that matter, we could have used this feature to read or write areas of memory in which no 
variables at all had been declared.&nbsp; Or to a certain extent, if we had declared 
variables of some other datatype than <font color="#663333"><code>FIXED</code></font>, we could have used this same trick to access them as if they were <font color="#663333"><code>FIXED</code></font>.<br>
<br>
I call this particular "feature" of XPL <i>subscripting sloppiness</i>.&nbsp;
 It's one of the many features of XPL that is simply undocumented and 
which you are left to deduce by examining actual XPL code or by trying 
to figure out why your apparently-perfectly-formed XPL code produces 
entirely unexpected results when executed.<br>

<blockquote>
  <font size="-1"><b>Aside:</b> I say that subcripting sloppiness is 
"undocumented", but you could find passing hints to it in McKeenan if 
you already knew in advance about this feature by other means.&nbsp; 
True, McKeeman does say that array bounds are respected, which is false,
 but it does also say on p. 137 of McKeeman:&nbsp; "Assignments to 
subscripted variables are not checked against the array bounds; thus 
every memory location is accessible through subscripting."&nbsp; And if 
you pore through every line of XPL source code in the book, you'll 
certainly come across examples of subscripting sloppiness.&nbsp; Is that
 "documentation" of such a major feature?&nbsp; You be the judge.</font><br>

</blockquote>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; <a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel 
Weaver has written an XPL-to-C translator</a>.&nbsp; 
The first thing anyone suggests to me when this topic is discussed is 
"Why don't you just use it?"&nbsp; The subscripting sloppiness inherent 
in 
actual usage of XPL is one good reason.&nbsp; As you might expect, 
since there's no reasonable way to deduce from the documentation that 
subscripting sloppiness exists, there's reason to doubt that an XPL 
compiler relying on the accuracy of McKeeman might not support it. 
Here's a fun printout of the very-sensible error messages you get by 
running the sample code above through Dan's translator :<br>
  </font>
  <blockquote>
    <pre><font size="-1">XPL to C language translator -- version 1.1<br>2    |x(0) = 1;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>3    |x(1) = 2;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 2. ***<br>4    |x(2) = 3;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 3. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                    |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 4. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                   |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                                 |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>6 cards containing 7 statements were compiled.<br>6 errors (0 severe) were detected.<br>The last detected error was on line 5.</font><br></pre>
  </blockquote>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Daniel has also pointed out that aside from his own compiler, <a moz-do-not-send="true" href="https://sourceforge.net/projects/intel-486-xpl-compiler/">Dave Bodenstab wrote an XPL compiler for FreeBSD, which Daniel himself has ported to Linux</a>.&nbsp; I have not tried it as of this writing.<br>
    <br>
    <b>Aside:</b>&nbsp; The other suggestion I receive with a fair 
degree of regularity is, "Why not just run all of this IBM 360 software 
in a simulator like <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>, and be done with it?&nbsp; Problem solved!"&nbsp; Well, for one thing, we don't have Intermetrics's XPL/I compiler, so we <i>can't</i>
 run it on an IBM 360 simulation.&nbsp; Lacking that, we can't build 
Intermetrics's HAL/S compiler in such a way that it could be run on an 
IBM 360 simulation.&nbsp; But if we had the HAL/S compiler and it could 
compile the PASS flight software to IBM 360 object code, why don't we 
just run <i>that</i> on an IBM 360 simulator?&nbsp; Well ... tell me how
 to integrate Hercules into a spacecraft simulator like Orbiter?&nbsp; 
And tell me how to motivate any of <i>you</i> to learn how to use 
Hercules in addition to the already very steep learning curve you face 
with the flight software?&nbsp; If you can answer those questions for 
me, I'll admit you've got a pretty good idea!&nbsp; With that said, 
there's definitely merit in emulating an IBM 360, if not necessarily 
emulating a full IBM 360 system.&nbsp;&nbsp; I'll come back to this 
point later<br>
  </font></blockquote>
From my whining above about the quality (from a user's point of view) of
 the documentation of the XPL language, you'll probably recognize that  
it's 
hard to make a full list of all the difficulties of XPL or all of the 
differences between XPL and XPL/I.&nbsp; And just as McKeeman is not a 
full and accurate description of XPL, neither is 
the surviving Intermetrics documentation a full description of 
XPL/I.&nbsp; And confusingly for the present discussion, Intermetrics 
did not use an explicit term (like "XPL/I") to refer to their 
language.&nbsp; Instead they continued to refer to it simply as "XPL", 
making it hard to be entirely sure what's supposed to be different 
between the two languages and what's not.&nbsp; <br>
<br>Taking all of this stuff into consideration, my conclusion is that if you want to compile
 Intermetrics's HAL/S compiler, you're not going to be able to rely on any <i>existing</i>
 XPL compiler.&nbsp; You're going to have to rely on a 
newly-written XPL compiler having support for the true (as opposed to 
documented) properties of XPL and XPL/I baked into it from the 
ground up.&nbsp; I call this new XPL+XPL/I compiler <b>XCOM-I</b>.&nbsp; (<b>XCOM</b>
 was the name of McKeeman's original XPL compiler, and I suspect of 
Intermetrics's compiler as well, while the "I" is for "Intermetrics".)<br>
<br>
Like Daniel Weaver's XPL translator, <b>XCOM-I</b> is actually an XPL/I-to-C translator, though it is entirely new and is 
not based on Daniel's work nor on any of the original XPL 
compilers. In most cases, <b>XCOM-I</b> should work for standard XPL programs too.<br>
<blockquote><font size="-1"><b>Aside:</b> In case you're wondering, <b>XCOM-I</b>
 does translate the sample XPL/I program given above to C without error;
 the C program it creates also compiles without errors; and if you run the compiled C 
program you get what you might expect:<br>
  </font>
  
<blockquote>
  <pre><font size="-1">PAGE 1<br><br><br>1 2 3<br>1 2 3</font><br></pre>
</blockquote>

</blockquote>
There's one final complication:&nbsp; In legacy XPL or XPL/I source 
code, it was typical to intersperse the XPL or XPL/I (thankfully, 
sparingly!) with code written in IBM 
System/360 Basic Assembly
 Language (BAL).&nbsp; Several sections below discuss this topic.<br>
<h1><a name="compiling"></a>Processing a Program Written in XPL, Using XCOM-I<br>
</h1>
<p>Despite the title of this section, there's actually little difference
 between how to build and run XPL/I programs versus XPL programs.&nbsp; 
Once you know how to build and run an XPL program, you'll automatically 
know how to build and run an XPL/I program ... mostly.  There's an extra
 command-line switch you can use to specify that you really, truly want 
XPL rather than XPL/I, namely <font color="#663300"><code>--xpl</code></font>, but it usually doesn't matter much if you leave it out.<br></p>
<p>With that said, the XPL/I source code available to us dwarfs the XPL 
source code we have for any standard XPL programs we have.&nbsp; 
Moreover, those XPL/I programs are much larger and more complex than the
 XPL programs.&nbsp; This means that there are differences in how the 
source code for the two is organized and maintained.&nbsp; In that sense
 we find differences in how to deal with the two.&nbsp; That's why I 
concentrate at first on compiling standard XPL programs, and defer some 
discussion of XPL/I compilation until later.
</p>

<h2><a name="installation"></a>Installation of XCOM-I</h2>
<p>Or more precisely, "installation of XCOM-I and other stuff needed to 
follow the instructions given below". <br>
</p>
<h3>Linux or Mac<br>
</h3>
<p>
</p>

<ul>
  <li>First, <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc">get the Virtual AGC source tree from our repository</a>.&nbsp; For the sake of discussion only, I'm going to assume that this ends up as a folder called <i>virtualagc</i>, but you need to substitute the actual name in the instructions below.<br>

  </li>
  <li>Add the folders <i>virtualagc</i>/XCOM-I and <i>virtualagc</i>/yaShuttle/ported/PASS1.PROCS to your PATH.&nbsp; I'm hoping you know how to do that on your system of choice.<br>
  </li>
  <li>Install extra Python3 modules:&nbsp; <font color="#663300"><code>pip3 install ebcdic</code></font>, or possibly <font color="#663300"><code>pip install ebcdic</code></font>.</li>
  <li>On Linux, install <b>clang-format</b> from your package repository.&nbsp; I believe it's already installed if you have <b>clang</b> on the Mac, which I think all current Macs do.<br>
  </li>
</ul>
Having done this, I find that everything described elsewhere on this 
page works identically on my up-to-date Linux Mint system as on my 
mid-2007 Mac OS 10.7.5 system, albeit much more slowly on the 
latter.&nbsp; Admittedly, I fire up the Mac only to check stuff like 
this — that is to say, <i>very seldom</i> — so experience on the Mac may vary on a day-to-day basis. <br>
<h3><a name="Windows"></a>Windows<br>
</h3>


The situation for Windows is less palatable.&nbsp; Everyone just wants 
to use Visual Studio, but that's not going to work without irritating 
modifications.&nbsp; There are potential easy solutions, such as WSL, 
which I'm unfortunately not in a position to try, and many candidates 
for more-native solutions, which I had no luck with.&nbsp; Of course, 
running a Linux virtual machine on your Windows system is free and easy,
 so there's that!&nbsp; Short of running a Linux virtual machine, 
though, a somewhat more light-weight solution I used on Windows 11 Pro 
is this:<br>
<ol>
  <li>Install <b><a moz-do-not-send="true" href="https://www.msys2.org/">Msys2</a></b>, which gives you a Linux/Mac-like command-line working environment for compiling stuff.&nbsp; <br>
  </li>
  <li>Start up <b>Msys2</b> from the Windows start menu and do all of 
the remaining installation steps, as well as the various other 
instructions I give you elsewhere on this page, within that <b>Msys2</b> command-line environment.</li>
  <li>Install various packages:&nbsp; <font color="#663300"><code>pacman -S git diffutils gcc make python3 python3-pip vim</code></font>.</li>
  <li>Install extra Python3 module(s):&nbsp; <font color="#663300"><code>pip3 install ebcdic</code></font>.</li>
  <li>Get the Virtual AGC source tree with this command:&nbsp; <font color="#663300"><code>git clone --depth=1 https://github.com/virtualagc/virtualagc.git</code></font>.</li>
  <li>To add folders to your PATH, you'll need to edit the file .bashrc (notice the leading dot) in your <b>Msys2</b> home directory.&nbsp; If you're familiar with <b>vim</b>, which you just now installed, you can do it with the command <font color="#663300"><code>vim ~/.bashrc</code></font>; if not, you can use another text editor that you're more familiar with, but outside of the <b>Msys2</b> environment you'll have to know where to find .bashrc to edit it.&nbsp; With the default options in the <b>Msys2</b> installation, I found it at c:\msys64\home\<i>username</i>\.bashrc and edited it with <b>notepad</b>.&nbsp; What you do is insert the line I've highlighted in <font color="#009900">green</font>:</li>
</ol>
<blockquote>
  <blockquote>
    <pre>.<br>.<br>.<br># User dependent .bashrc file<br><br># If not running interactively, don't do anything<br>[[ "$-" != *i* ]] &amp;&amp; return<br><br><font color="#009900">PATH=$PATH:~/<i>virtualagc</i>/XCOM-I:~/<i>virtualagc</i>/yaShuttle/ported/PASS1.PROCS</font><br><br># Shell Options<br>.<br>.<br>.<br></pre>
  </blockquote>
</blockquote>
<ol start="6">
  <li>After saving that file, close your <b>Msys2</b> command line, and then run <b>Msys2</b> again to put the new PATH into effect.<br>
  </li>
</ol>
This installation seems to function quite well, other than a very slight loss of functionality in Windows (vs Linux/Mac):<br>
<ul>
  <li>Optional backtraces are no longer available in the <b>XCOM-I</b> runtime library.</li>
  <li>The <b>XCOM-I</b> command-line option <font color="#663300"><code>--pp</code></font> for "pretty-printing" the C code output by <b>XCOM-I</b> no longer works.</li>
</ul>
<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; Actually, you <i>can</i> make <font color="#663300"><code>--pp</code></font> work, but I didn't suggest it above because it's such massive overkill.&nbsp; The <font color="#663300"><code>--pp</code></font> option relies on the program <b>clang-format</b>, which you can get by installing the entire <b>clang/llvm</b> compiler infrastructure.&nbsp; Even I wouldn't bother.&nbsp; On the other hand, if you do, you'd also have the <b>clang</b> compiler to choose from as an alternative to <b>gcc</b>.&nbsp;
 Note that you'll also have to add it to the PATH, as in step #6 
above.&nbsp; Instead of the line shown in step #6, insert this line into
 .bashrc:<br>
    </font></p>
  <blockquote>
    <pre><font color="#009900">PATH=$PATH:~/<i>virtualagc</i>/XCOM-I:~/<i>virtualagc</i>/yaShuttle/ported/PASS1.PROCS:/c/"Program Files"/LLVM/bin</font></pre>

  </blockquote>
</blockquote>
<h3>Testing the Installation</h3>
<p>Following the instructions on the remainder of this page essentially 
tests the installation.&nbsp; However, in brief, what I do to verify 
operation is:<br>
</p>
<blockquote>
  <pre><font color="#663300"><code>cd </code><code><i>virtualagc</i></code><code>/XCOM-I</code><code><br></code><code>make -f Makefile-regression &amp;&amp; make</code><code><br></code><code>cd ../yaShuttle/"Source Code"/PASS.REL32V0</code><code><br></code><code>make -s<br>make -s regression<br></code></font></pre>
</blockquote>
<p>Remember to use the path to where you installed the Virtual AGC source tree, in place of <i>virtualagc</i>. <br>
</p>
<p>Messages will be printed that give you a pretty clear idea as to success or failure.&nbsp; What's tested is:<br>
</p>
<ul>
  <li>The action of <b>XCOM-I</b>.<br>
  </li>
  <li>The action of some compilers originally written in XPL but now compiled by <b>XCOM-I</b>:&nbsp; in particular, XPL compilers <b>XCOM3</b> and <b>XCOM4</b>, and HAL/S compiler <b>HAL/S-FC</b>.<br>
  </li>
  <li>The action of <i>those</i> compilers, in compiling additional XPL or HAL/S programs.</li>
  <li>The action of the IBM 360 emulator, <b>sim360</b>.<br>
  </li>
</ul>
<h2><a name="xpl"></a>Compiling and Running XPL Programs<br>
</h2>
There are several standard XPL programs present in the folder 
XCOM-I/Tests/.&nbsp; It would be a mistake to think any of them are 
user-friendly.&nbsp; But they do illustrate the principles involved.<br>
<blockquote><font size="-1"><b>Aside:</b> You'd also be very mistaken to
 imagine that <b>XCOM-I</b> itself is user-friendly.&nbsp; I fear that there will be a
 lot of work involved — work which I may not even have the energy to perform —  before the error messages <b>XCOM-I</b> spits out upon 
occasion can be mistaken for anything <i>other</i> than mere spit.&nbsp; Until then, try not to make any errors in your XPL programming.</font><br>
</blockquote>

<blockquote><font size="-1"><b>Aside:</b>&nbsp; Throughout this 
discussion, I use the Linux/Mac convention that the symbol '/' is used 
to separate the components of a filename and the path to the folder 
containing it.&nbsp; Windows uses the separator '\' instead, so in some 
places you may find that you need to replace '/' by '\'.</font><br>

</blockquote>
<ul></ul>
<p>For the sake of discussion, suppose we wish to compile and run the 
sample program called Example-6.18.6.xpl.&nbsp; The first step is to use
 <b>XCOM-I</b> to translate Example-6.18.6.xpl into C source code:
</p>

<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py Tests/Example-6.18.6.xpl<br></font></pre><font color="#663300">
</font></blockquote><font color="#663300">
</font>This will create a sub-folder called Example-6.18.6/ of the current
 working folder, and put all of the files of the C translation into that
 folder.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; XCOM-I.py has various 
allowable command-line options, though none were needed in the 
invocation shown above.&nbsp; You can see a list of XCOM-I.py's 
command-line options with
 the command "</font><code><font size="-1" color="#663300">XCOM-I.py --help</font></code><font size="-1">".</font><br>

</blockquote>
<blockquote>
</blockquote>
I won't bore you with a lengthy description of the C files output by <b>XCOM-I</b>, 
but it might be mildly instructive to glance briefly at a couple of 
them.&nbsp; For this example, the principal outputs are the files 
RANDOM.c and main.c, and here you can see a comparison of the original 
XPL file (left) to the C translation of them (right):<br><br>
<table align="center" cellspacing="40" cellpadding="2" border="1">
  <caption><font size="+1"><b>XPL Source Code versus Generated C Code</b></font></caption>
  <tbody>
    <tr>
      <td valign="middle">
        <pre><font color="#663300">/* This is example XPL program 6.18.6 from McKeeman p. 157.<br>   The book only provides PROCEDURE RANDOM, which is transcribed as-is.<br>   The top-level code that exercises RANDOM is new. */<br>   <br>RANDOM:<br>  procedure(range) fixed;<br>    /*  Returns a random integer in the range 0 to range - 1  */<br>    <br>    declare range fixed, rbase fixed initial(1),<br>      rmult literally '671297325';<br>      <br>    rbase = rbase * rmult;<br>    <br>    return shr(shr(rbase, 16) * range, 16);<br>    <br>  end RANDOM;<br><br>declare i;<br><br>do i = 1 to 100;<br>  output = RANDOM(100000);<br>end;<br><br>eof</font><br></pre>
      </td>
      <td valign="top">
        <pre><font color="#663300">/*<br>  File RANDOM.c generated by XCOM-I, 2024-04-16 08:46:47.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>int32_t<br>RANDOM(void)<br>{<br><br>  // rbase = rbase * rmult; (2)<br>  {<br>    int32_t numberRHS = xmultiply(getFIXED(8), 671297325);<br>    putFIXED(8, numberRHS);<br>  }<br>  // return shr(shr(rbase, 16) * range, 16); (3)<br>  return SHR(xmultiply(SHR(getFIXED(8), 16), getFIXED(4)), 16);<br>}<br><br>/*<br>  File main.c generated by XCOM-I, 2024-04-16 08:46:47.<br>  XPL/I source-code file used: Example-6.18.6.xpl.<br>  To build the program from the command line, using defaults:<br>          cd Example-6.18.6/<br>          make<br>  View the Makefile to see different options for the `make`<br>  command above.  To run the program:<br>          Example-6.18.6 [OPTIONS]<br>  Use `Example-6.18.6 --help` to see the available OPTIONS.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>/*<br>  Memory Map:<br>           Address (Hex)        Data Type        Variable<br>           -------------        ---------        --------<br>              0 (000000)        FIXED            I<br>              4 (000004)        FIXED            RANDOMxRANGE<br>              8 (000008)        FIXED            RANDOMxRBASE<br>*/<br><br>int<br>main(int argc, char *argv[])<br>{<br><br>  if (parseCommandLine(argc, argv)) exit(0);<br><br>  // do i = 1 to 100; (0)<br>  {<br>    int32_t from0, to0, by0;<br>    from0 = 1;<br>    to0 = 100;<br>    by0 = 1;<br>    for (putFIXED(0, from0);<br>         getFIXED(0) &lt;= to0;<br>         putFIXED(0, getFIXED(0) + by0)) {<br>      // output = RANDOM(100000); (1)<br>      {<br>        int32_t numberRHS = ( putFIXED(4, 100000), RANDOM() );<br>        string_t stringRHS;<br>        strcpy(stringRHS, fixedToCharacter(numberRHS));<br>        OUTPUT(0, stringRHS);<br>      }<br>    }<br>  } // End of DO for-loop block<br><br>  if (LINE_COUNT)<br>    printf("\n"); // Flush buffer for OUTPUT(0) and OUTPUT(1).<br>  return 0; // Just in case ...<br>}<br></font><br></pre>
      </td>
    </tr>
  </tbody>
</table>
The comparison, I think, is both tantalizing and mysterious.&nbsp; Tantalizing, because you can <i>almost</i> see how it works.&nbsp; And mysterious, because you can't <i>quite</i> see it.&nbsp; But I digress!<br>
<br>
The next step, of course, is to compile the C programs.&nbsp; If you are
 on a relatively-normal Linux or Mac OS system, then compilation can be 
accomplished like this, assuming that you're still in the XCOM-I/ 
working directory:<font color="#663300"><code></code></font><br>
<font color="#663300"><code></code></font><blockquote><font color="#663300"><code>
make -C Example-6.18.6</code><br>


</font></blockquote><font color="#663300">
</font>This produces an executable program within the Example-6.18.6/ folder that's also called <b>Example-6.18.6</b>.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; On my system, which is a pretty-normal Linux system with <b>gcc</b> as the C compiler, the instructions I give you succeed basically without any compiler warnings.&nbsp; Whereas with <b>clang</b>
 as the C compiler there can be quite a few compiler warnings, and on a 
Mac OS system there may be an annoyingly-large number of compiler 
warnings ... all of which are nuisances without value, as far as I can 
tell, not to mention concerning things <i>you</i> can do nothing about.&nbsp; If that's what happens for you, I'd suggest turning off all compiler warnings by adding "<font color="#663300"><code>EXTRA=-w</code></font>" to all of the <code></code> <font color="#663300"><code>make</code></font> commands, as in:<br>
  </font>
  <blockquote><font size="-1" color="#663300"><code>make EXTRA=-w -C Example-6.18.6</code></font></blockquote>
</blockquote>
<blockquote><font size="-1"><b>Important note</b>:&nbsp; <font color="#663300"><code> make</code></font>
 will be fooled — badly, compiling multiple times with the wrong target 
names! — if the path to your current working directory contains any 
spaces.&nbsp; You can help </font><font size="-1"><font size="-1"><font color="#663300"><code>make</code></font></font> out in that case by explicitly specifying the target name:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">make -C Example-6.18.6 Example-6.18.6</font><br></pre>
  </blockquote>
</blockquote>
But the world being what it is, you most likely <i>don't</i> have a 
setup like mine, so some alterations in the instructions above may be 
needed in your situation.&nbsp; For one thing, your C compiler may not 
be <b>gcc</b>.&nbsp; 
Actually, the default assumption isn't that the compiler is <b>gcc</b>, but 
rather that the shell's environment variable <font color="#663300"><code>CC</code></font> holds the 
name of the compiler.&nbsp; But if that's not true, or if you're not using <b>gcc</b>, then the command for <font color="#663300"><code>make</code></font> will differ a little.&nbsp; For example, suppose you use <b>clang</b> instead of <b>gcc</b>.&nbsp; Just change the build commands to read:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 CC=clang</code></font><br>
</blockquote>


Or if you're on Windows — and other than myself who isn't, really? — then you'd want to 
add the filename extension ".exe" to your executable.&nbsp; That could be done 
like so:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 TARGET=Example-6.18.6.exe</code></font><br>
</blockquote>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; The Makefile itself lists other 
possible alterations, any or all of which can be used in combination 
with the others.&nbsp;&nbsp;</font></blockquote>

Finally, you can now run the now-fully-compiled program:<br>
<blockquote>
  <pre><font color="#663300">Example-6.18.6/Example-6.18.6</font></pre>
</blockquote>What this particular sample program does is just to print 
100 random numbers, so that's what should happen.&nbsp; (I say they're 
"random", but the seed for the random-number generator is hard-coded and
 always the same as 1, so you'll get the same 100 numbers every time you
 run the program.)<br>
<blockquote><font size="-1"><b>Aside:</b> Just like <b>XCOM-I</b>, the compiled
 application also has a variety of command-line options that may affect 
how it runs.&nbsp; None of them are really applicable to this particular
 sample program, but you could see them with the command "</font><code></code><code><font size="-1" color="#663300">Example-6.18.6/Example-6.18.6 --help</font></code><font size="-1">".</font><br>
</blockquote>If you want to see a meatier standard XPL example, you 
can look instead at McKeeman's <b>ANALYZER</b> program.&nbsp; If you happen to have a copy of <i>A Compiler Generator</i> (see Section 7.1, Chapter 10, and Appendix 
6), it provides reasonably-detailed operating instructions and theory of 
operation for <b>ANALYZER</b>.&nbsp; Basically, <b>ANALYZER</b> is used for 
analyzing a given BNF grammar and printing a report about it.&nbsp; Thus McKeeman recommends <b>ANALYZER</b>
 for 
developing BNF grammars and debugging them.&nbsp; There's an associated 
data file as well, SKELETON.bnf, which contains the BNF description for a
 very simple language (called "SKELETON", of course) that's the basis 
for some of the discussion in the book.&nbsp; The steps for compiling 
and running <b>ANALYZER</b> with SKELETON.bnf as input are just what you'd expect from the discussion earlier:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/ANALYZER.xpl
make -C ANALYZER
ANALYZER/ANALYZER &lt;Tests/SKELETON.bnf<br></font></pre></blockquote>
<blockquote>
</blockquote>
If you're interested, you can compare <a moz-do-not-send="true" href="SKELETON-XCOM-I.pdf">the report on the SKELETON grammar produced by the steps above,</a> versus <a moz-do-not-send="true" href="SKELETON-McKeeman.pdf">the report printed in Figure 7.1.6 of McKeeman</a><a moz-do-not-send="true" href="file:///home/rburkey/git/virtualagc-web/SKELETON-McKeeman.pdf"> in 1969</a>.&nbsp;
 You will notice slight differences between the two, but not (I think) 
anything substantive.&nbsp; Remember that the report printed in the book
 would have been <i>manually</i> typeset, always with the possibility of
 human error, and with editorial decisions having been made to affect 
the aesthetics and publishing cost, possibly to the detriment of literal
 100% accuracy.<br>
<blockquote><font size="-1"><b>Aside:</b> Reducing discussion of <b>ANALYZER</b> to just whether or not it works the same today as it did back in 1970 is doing it a injustice, because <b>ANALYZER</b>
 has interesting capabilities in its own right.&nbsp; If you look at the
 reports I mentioned above, you'll notice that one thing <b>ANALYZER</b> includes in these reports is a large section consisting of XPL <font color="#663300"><code>DECLARE</code></font> statements.&nbsp; These </font><font size="-1"><font size="-1"><font color="#663300"><code>DECLARE</code></font></font>
 statements, if plugged into the template XPL code provided elsewhere in
 McKeeman, are what's needed to create a compiler (written in XPL, of 
course) for the grammar being analyzed.&nbsp; In other words, the title 
of the book (<i>A Compiler Generator</i>) isn't a misnomer.&nbsp;&nbsp; 
This XPL code in the report isn't incredibly useful as-is, because it's 
formatted in a manner that's not immediately compilable.&nbsp; However, 
ANALYZER also allows you to "punch" separate punch-cards that do contain
 immediately-compilable XPL.&nbsp; More on that in a moment.&nbsp; </font><br>
</blockquote>
One of the legacy XPL programs provided for demonstration purposes is 
actually a compiler for the SKELETON language, though calling it a 
"compiler" is a bit of a stretch, since all it does is analyze 
statements in the SKELETON language for correctness, and doesn't produce
 any object code.&nbsp; The idea behind the <b>SKELETON</b> program was 
that since it's such a small program (~300 lines of XPL), it would be 
easy to experiment with.&nbsp; The SKELETON language itself is very 
bare-bones, in that it only has assignment statements in it, and those 
assignment statements have the form <code><font color="#663300">IDENTIFIER</font></code><font color="#663300"><code> = EXPRESSION;</code></font>.&nbsp;
 Identifiers follow the same rules as they do in XPL, except that lower-case 
letters aren't supported.&nbsp; There are no declarations, no arrays, no
 strings, and "expressions" are basically whatever normal arithmetical 
expressions you can form from just identifiers, literal decimal numbers,
 and the tokens <font color="#663300"><code>+</code></font> <font color="#663300"><code>-</code></font> <font color="#663300"><code>*</code></font> <font color="#663300"><code>/</code></font> <font color="#663300"><code>(</code></font> and <font color="#663300"><code>)</code></font>.&nbsp; Anyway, you can compile and run it like so:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/SKELETON.xpl
make -C SKELETON
</font><font color="#663300"><font color="#663300">SKELETON</font>/</font><font color="#663300"><font color="#663300">SKELETON</font></font></pre>
</blockquote>
SKELETON being relatively uninteresting, the Tests/ folder also contains
 a similar but more-complex BNF grammar for XPL itself.&nbsp; Analyzing 
the XPL grammar with <b>ANALYZER</b> is very slightly more complex than analyzing the SKELETON grammar was. That's because the XPL grammar file used as input for <b>ANALYZER</b> contains a directive which the SKELETON grammar did not.&nbsp; The culprit is <font color="#663300"><code>$PUNCH</code></font>, which directs <b>ANALYZER</b>
 to output the XPL code it generates to a "punch device".&nbsp; 
Technically, that means a file has to be "attached" to the punch device,
 or else the data has nowhere to go.&nbsp; But by default <b>ANALYZER</b>
 doesn't attach any file to the punch device.&nbsp; On an IBM 
System/360, this would have been handled by means of separately-provided
 Job Control Language (JCL), and in particular by <font color="#663300"><code>DD</code></font> statements in the JCL.&nbsp; Naturally, we have no JCL in our <b>XCOM-I</b> based system, but the equivalent to JCL would be <b>ANALYZER</b>'s command-line switches. The command-line switches for simulating <font color="#663300"><code>DD</code></font> statements are <font color="#663300"><code>--ddi</code></font> and <font color="#663300"><code>--ddo</code></font>.&nbsp;
 Putting that all together, we can analyze the XPL grammar, with the 
punch device attached to a file called PUNCH.txt, using the following 
command:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>
Or since ANALYZER accepts the input grammar it analyzes on "device 0" (attached by default to <font color="#663300"><code>stdin</code></font>, which is why we usually pipe in the input via <font color="#663300"><code>&lt;</code></font>), we could even run it instead as:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddi=0,Tests/XPL.bnf --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>

We'll come to <a moz-do-not-send="true" href="stillMeatier">a still meatier example</a> in a moment, but before doing that, the next section will be a necessary digression.<br>
<h2>
  <a name="sim360"></a>Emulating the IBM 360 CPU</h2>

<p>XPL or XPL/I programs compiled by <b>XCOM-I</b> are native to your own local computer system, and if <b>XCOM-I</b> has done its job properly, there should be no lingering dependencies on the IBM 360 in the compiled program.<br></p>
<p>Nevertheless ... XPL was <i>designed</i> to be a program for 
generating compilers, so a lot of legacy XPL or XPL/I code is actually 
the source code of a compiler for one or another computer language.  
Suppose for example that we had an XPL program called <b>X</b> that was a compiler for a programming language called "X".  It's true that if we compile the source code for <b>X</b> with <b>XCOM-I</b> that we'll get executable code for <b>X</b>
 that runs on our native Linux/Mac/Windows computer (rather than, say, 
an IBM 360).  But it's also true that if we use that native version of <b>X</b> to compile source-code in the X language, say for a program called <b>Y</b>, then the output of the compiler will still be an object file for the IBM 360.  So we still wouldn't be able to run <b>Y</b> on our native computer, and would still need an IBM 360 to run <b>Y</b>.<br></p>
<p>Which means that even with <b>XCOM-I</b> in hand, it's still very useful to have an IBM 360 emulator in which to run not the programs <i>produced</i> by <b>XCOM-I</b>, but the programs produced by the compilers produced by <b>XCOM-I</b>.<br></p>
<p>If you're already an IBM 360 expert or a wannabe IBM 360 user, then perhaps a full-scale IBM System/360 emulator such as <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>
 might work well for you.  As for myself, having tried to figure out&nbsp; without success how to use
Hercules, I have to concede that I'm neither a 360 expert nor 
wannabe, and have no desire to confront that learning curve.  I'd much 
prefer a <i>lightweight</i> IBM 360 emulator, with essentially no 
learning curve at all.  (And a lightweight emulator is far more in line 
with Virtual AGC's goal of integrating Space Shuttle computing support 
into spaceflight simulation programs than a full-blown mainframe 
emulator would be.)<br></p>

<p>As it happens, there is an available candidate for such lightweight IBM 360 emulator.  This emulator, called <b>sim360</b>,
 was written by the same Daniel Weaver who I've also mentioned earlier 
as the author of an XPL-to-C translator for standard XPL.  You can find 
the
 source code for <b>sim360</b> in <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/XCOM-I/sim360-source/simulate">the Virtual AGC software repository</a>, but <a moz-do-not-send="true" href="https://sourceforge.net/projects/suny-pascal/">the official place to get the most up-to-date version is Dan's own site</a>.
 That hyperlink is disguised as a Pascal compiler, which is also there, 
but don't be confused:  There's an IBM 360 emulator in there!<br>
</p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
There is a limit, of course, to how "lightweight" an IBM 360 emulator 
can be while still remaining useful.&nbsp; To run programs originally 
written in XPL or XPL/I, for example, just emulating the CPU's 
instruction set is not enough.&nbsp; Such XPL or XPL/I programs depend 
on there being an operating system in place to allow operations like 
inputting data (from a files or keyboards) or outputting data (to a 
displays, printers, or files) to occur.&nbsp; But an XPL program doesn't
 actually interact directly with the operating system.&nbsp; Instead, an
 XPL program expects that there's a separate program called the <i>submonitor</i>
 running along side of it, and the XPL program makes its low-level 
requests for input, output, allocation of memory, and so on, to this 
submonitor program.&nbsp; In fact, there will be <a moz-do-not-send="true" href="#builtin">a whole section later on</a> that describes XPL's built-in functions, some of which rely on the submonitor, as well as <a moz-do-not-send="true" href="#monitor">another section covering the <font color="#663300"><code>MONITOR</code></font> procedure</a>, <i>all</i> of whose functionality comes from the submonitor.&nbsp; But the point is that to be useful to us, a lightweight emulator like <b>sim360</b>
 must provide enough submonitor capability to respond correctly when the
 XPL program makes these requests of the submonitor even though the IBM 
360 operating system is entirely absent.</font><font size="-1">&nbsp; Fortunately, although at the present writing it's a work in progress, <b>sim360</b> does so.&nbsp; Thanks, Dan!<br>
    <br>
By the way, if in place of <b>sim360</b> you were to use a full-scale IBM 360 simulator such as <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>, an emulation of the XPL or XPL/I submonitor would <i>not</i>
 be built into it.&nbsp; Rather, you would have to assemble the IBM 360 
Basic Assembly Language (BAL) source code for the submonitor, and 
presumably contrive the JCL needed to run the submonitor program 
along-side your compiled XPL program on the emulator.&nbsp; Fortunately,
 although we don't need it if we are using <b>sim360</b>, we <i>do</i> have source code for the submonitor:&nbsp; <br>
  </font>
  <ul>
    <li><font size="-1">For McKeeman's <b>XCOM</b>, it's <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/XPL-TWS-1969-03/XMON.bal">XMON.bal</a>.</font></li>
    <li><font size="-1">For SUNY's <b>XCOM</b> 4.5, which we've not discussed yet but which we'll get to in the next section, it's the slightly-different <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLSM4.5.bal">XPLSM.bal</a>.</font></li>
    
    <li><font size="-1">For Intermetrics's unavailable <b>XCOM</b>, it's the collection of BAL source-code files known as <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM">MONITOR.ASM</a>.&nbsp; You may wonder why that matters, given that the source code for the Intermetrics version of <b>XCOM</b> has not survived, and thus we couldn't run it anyway?&nbsp; (After all, the whole point of <b>XCOM-I</b> in the first place is to fill in for the missing Intermetrics <b>XCOM</b>, and <b>XCOM-I</b> needs no submonitor!)&nbsp; Well presumably, if we compile HAL/S source code (like PFS or BFS) using <b>HAL/S-FC</b>, we'd expect PFS or BFS to need the same submonitor as the Intermetrics <b>XCOM</b> would have.&nbsp; Probably.&nbsp; Or at least, maybe!<br>
      </font></li>
  </ul>
  <p><font size="-1">What we <i>don't</i> have in this scenario is a BAL
 assembler, nor an IBM 360 linker program, so in spite of this wealth of
 source code for submonitors, in the end we still have no way to build 
the submonitor programs that I'm aware of.</font><br>
  </p>
</blockquote>


<p>Assuming you're working from Virtual AGC's archived copy, the first thing you have to do is to build <b>sim360</b> itself as follows: <br></p>

<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>make sim360</font><br></pre>
</blockquote>

<p>If you've added XCOM-I/ into your PATH as I recommended earlier, then <b>sim360</b> will now be in your PATH as well. <br></p>

<p>If you want to try out <b>sim360</b>, you'll need an IBM 360 <i>load file</i>
 for some actual program.&nbsp; In the next couple of sections, we'll 
produce a lot of just load files.&nbsp; For now, I'll just point out the
 IBM 360 load file for a simple Hello World program is available in our 
Tests folder, and you can run it like so:<br>
</p>


<blockquote>
  <pre><font color="#663300">sim360 -o0ET stdout -i0AT stdin Tests/HELLO.obj</font><br></pre>
</blockquote>
The command-line switches for <b>sim360</b> probably look mysterious, but they're not so bad.  You can see a full list of command-line options with the command "<font color="#663300"><code>sim360 --help</code></font>", but what the mysterious switches in the example above mean is this:<br>


<ul>
<li><font color="#663300"><code>-o0ET stdout</code></font>:  Causes <font color="#663300"><code>OUTPUT(0)</code></font> to send data to <font color="#663300"><code>stdout</code></font> and automatically translate it from EBCDIC to ASCII.<br></li><li><code><font color="#663300">-i0AT stdin</font></code>:  Causes <font color="#663300"><code>INPUT(0)</code></font> to receive data from <font color="#663300"><code>stdin</code></font> and automatically translate it from ASCII to EBCDIC.<br></li>
</ul>
<h2><a name="compilingXCOM"></a>Insane Bootstrapping!</h2>
And I do mean <i>insane</i>.<br>
<br>
Regarding the "still meatier example" that I promised (threatened?) earlier, here it is with a vengeance!&nbsp; We're going try <i>bootstrapping</i>
 some legacy standard-XPL compilers.&nbsp; By a "legacy" compiler, I 
mean an IBM 360 XPL compiler from the good-old 1960's or 1970's, against 
which we can hopefully accurately measure the authenticity of <b>XCOM-I</b>'s behavior, at least in so far as standard XPL is concerned.&nbsp; We happen to have XPL source code <i>and</i> IBM 360 builds of more than one such legacy compiler:<br>
<br>
<table cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Available Legacy IBM 360 XPL Compilers</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">Designation<br>
      </th>
      <th valign="bottom" align="center">Notes<br>
      </th>
      <th valign="bottom" align="center">Where I Got it From<br>
      </th>
      <th valign="bottom" align="center">Legacy XPL Source Code for XCOM Proper<br>
      </th>
      <th valign="bottom" align="center">Legacy XPL Source Code for Library<br>
      </th>
      <th valign="bottom" align="center">Legacy IBM 360 Executable<br>
      </th>
      <th valign="bottom" align="center">"Modern" Patch(es) for use with XCOM-I<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM3</b><br>
      </td>
      <td valign="middle">This is the version of XCOM listed in the book <i>A Compiler Generator</i>.&nbsp; Printouts from it identify it as "XCOM III".<br>
        <br>
In reality, there's no way to know if it's identical to the book without
 comparing it line by line, which I have not done.&nbsp;&nbsp; The notes
 in the download file state that the files were recovered from a legacy 
computer tape from the Stanford Computation Center, dated 1969-01-23. 
&nbsp; The contemporary notes on the tape itself hint that it is the 
source code from the book, but stop short of saying explicitly that it's
 the precise version that appears in the book.&nbsp;&nbsp; The 
contemporary notes further state that <br>
        <blockquote><font size="-1">"THE BINARY IMAGE OF THE XCOM COMPILER ... [is] THE RESULT OF USING XCOM TO COMPILE ITSELF FROM THE SOURCE CARDS"</font><br>
        </blockquote>
However, if you run the binary executable, its printout says that it was
 built on May 2, 2001, at 13:40:40.19.&nbsp; I'd suggest it's rare to 
find files created in 2001 on tapes made in 1969.&nbsp; I'll give 
pretty-convincing reasons later to believe that while this version of 
the source code was compiled to get this executable, a different version
 of the compiler itself was used to do so. Regardless, how this 2001 
executable made its way onto the 1969 tape, or at 
least into the download file, I cannot say.<br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/xpl.zip">University of Toronto XPL page</a><br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM.xpl">XCOM.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/XPL.LIBRARY.xpl">XPL.LIBRARY.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM3-20010502.obj">XCOM3-20010502.obj</a><br>
      </td>
      <td valign="middle" align="center">n/a<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM45</b><br>
      </td>
      <td valign="top">The accompanying notes indicate that this is from
 a computer tape from the State University of New York, 
Stonybrook.&nbsp; The notes from the tape itself date it 1977-05-22.<br>
        <br>
No information is given about how the binary executable of the compiler 
was created.&nbsp; Its printout identifies itself as "XCOM 4.5", compiled on
 July 19, 1976, at 21:05:40.16.&nbsp; Fortunately, unlike <b>XCOM3</b>, 
that's consistent with the date of the tape itself.&nbsp; But for 
reasons we'll come to later, I believe that while the provided 
executable is indeed compatible with the version of the XPL source code 
provided, it was nevertheless not used to compile itself.<br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://sourceforge.net/projects/suny-pascal/files/suny0005.tar.gz/download">Dan Weaver's XPL project</a><br>
      </td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/xcom4.xpl">XCOM4.5.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLIB4.5.xpl">XPLIB4.5.xpl</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/XCOM4-1976.obj">XCOM45-19760719.obj</a></td>
      <td valign="middle" align="center"><a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/patch0.c">patch0.c</a></td>
    </tr>
  </tbody>
</table>
<br>

To avoid confusion, from now on I'll refer to these specific compilers as <b>XCOM3</b> or <b>XCOM45</b>,
 rather than via vague references like "McKeeman XCOM" as I've been doing up to now.&nbsp; Also from 
now on, if I'm speaking generically about any of these old compilers, 
I'll simply refer to <b>XCOM<i>x</i></b>.&nbsp; (For the legacy executables, I'll generically call those <b>XCOM</b><b><i>x-YYYYMMDD</i></b>.)&nbsp; As for the "patches" in the rightmost column, <a moz-do-not-send="true" href="#hooks">XCOM-I
 has a framework for providing C-language patch files to replace the 
functionality the original XPL source code implemented by inline IBM 360
 machine code</a>.&nbsp; Fortunately, <b>XCOM3</b> has no such inlined code, and <b>XCOM45</b> has merely has a single block of 19 consecutive machine-code instructions.&nbsp; The patch file, of course, was <i>not</i> on the legacy computer tape; I wrote it myself.<br>
<br>
"Bootstrapping" is a process employed by folks who feel compelled to 
write computer-language compilers that can "self-compile"; in the case of XPL, that means that an <b>XCOM</b> executable can compile the XPL source code for <b>XCOM</b>, and get back an executable <i>identical</i>
 to itself when it does so.&nbsp; How could it have possibly worked the 
very first time back in the 1960's, when there was XPL source code but 
no <b>XCOM</b> executable yet to compile it with?&nbsp; Well, obviously the initial versions of <b>XCOM</b> must have been very cut-rate; and they must have been compiled with something <i>other</i> than <b>XCOM</b>, something presumably with very-constrained functionality itself and not written in XPL itself.&nbsp; But over time, as <b>XCOM</b> became more and more capable, <b>XCOM</b> was eventually able to compile 
itself.&nbsp; That process is called "bootstrapping", as in "hauling 
yourself up by your own bootstraps".&nbsp; We're now going to try doing 
that with <b>XCOM<i>x</i></b>.<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; To be clear, <b>XCOM-I</b> is not self-compiling.&nbsp; It's written in Python, not XPL.&nbsp; Rather, it's <b>XCOM3</b> and <b>XCOM45</b> that I expect to be self-compiling once they're bootstrapped.&nbsp; In the bootstrapping scenario, <b>XCOM-I</b> is that <i>other</i> compiler used to compile the initial version of <b>XCOMx</b> before an <b>XCOMx</b> executable exists.&nbsp; Except that unlike the normal bootstrapping scenario, <b>XCOM-I</b>, <b>XCOM3</b>, and <b>XCOM45</b> are full-blown compilers rather than being the initial weak-and-feeble versions thereof.</font><br>
</blockquote>


Also to be clear, the use case for <b>XCOM-I</b> I'm personally interested in is building <b>HAL/S-FC</b> and then forgetting that XPL and <b>XCOM-I</b> even exist.&nbsp;&nbsp;<img moz-do-not-send="true" src="smiley.png" alt="" width="16" height="16">&nbsp; And we don't need <i>a single one</i> of these <b>XCOM<i>x</i></b> programs to do that.&nbsp; But still, it's going to go much more smoothly if <b>XCOM-I</b> is believed to work properly in the first place.&nbsp; And if we can use <b>XCOM-I</b> for bootstrapping <b>XCOM<i>x</i></b>, that will give us a certain degree of confidence that <b>XCOM-I</b>
 does in fact work as intended. And if in that process <b>XCOM-I</b> can be made useful for 
somebody who (unlike myself) actually wants to play around with XPL, 
then why not?<br>
<br>
Here's the bootstrapping game-plan as it applies to any or all of the legacy <b>XCOM<i>x</i></b> compilers:<br>
<ol>
  <li>We'll use <b>XCOM-I</b> to compile the XPL source code for <b>XCOM<i>x</i></b>.  That will give us an executable which I'll call <b><b>XCOM<i>x</i></b>-native</b> that runs natively on our Linux, Windows, or Mac computers. <br>
</li>
  <li>We'll then use <b>XCOM<i>x</i></b><b>-native</b> to compile the XPL source code for <b>XCOM<i>x</i></b> <i>again</i>.  That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360</b> that's native to the IBM 360. I.e., it only runs on an IBM 360 or a simulation thereof.<br></li>
  <li>Finally, we'll run&nbsp;<b><b>XCOM<i>x</i></b>-360</b> under <b>sim360</b> to compile the source code for <b>XCOM<i>x</i></b> one last time.  That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360A</b>.&nbsp; If everything worked perfectly, <b><b>XCOM<i>x</i></b>-360A</b> should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b>.</li>
<li><i>Finally</i> finally, we'll run the legacy <b>XCOM<i>x</i></b><b>-<i>YYYYMMDD</i></b> executable under <b>sim360</b> to compile source code for <b>XCOM<i>x</i></b> one <i>really-truly</i> last time.&nbsp; That will give us an executable which I'll call <b>XCOM<i>x</i>-360C</b>.&nbsp; If everything worked perfectly, <b><b>XCOM<i>x</i></b>-360C</b> should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b>.
</li>

</ol>

That's a <i>lot</i> of XPL compilers floating around to keep straight.&nbsp; Here's a synopsis of the <b>XCOM</b> variants relevant to the discussion:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Summary of XPL Compilers in Bootstrapping Process</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">Compiler Variant<br>
      </th>
      <th valign="bottom" align="center">Compiler's Own<br>
Source-Code Files<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Compiled With<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Runs on IBM 360?<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Runs on Linux/Mac/Windows<br>
      </th>
      <th valign="bottom" align="center">Source-Code Language<br>
&nbsp;and Encoding Accepted<br>
By Compiler<br>
      </th>
      <th valign="bottom" align="center">Object Files Directly <br>
Output By Compiler<br>
      </th>
      <th valign="bottom" align="center">Encoding of <br>
Textual I/O When<br>
Running the <br>
Output<br>
Object Files <br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM-I</b><b>.py<br>
        </b></td>
      <td valign="middle" align="center">XCOM-I.py <i>et al.</i><br>
      </td>
      <td valign="middle" align="center">n/a<br>
      </td>
      <td valign="middle" align="center">No<br>
      </td>
      <td valign="middle" align="center">Yes<br>
      </td>
      <td valign="middle" align="center">XPL or XPL/I, ASCII coding<br>
      </td>
      <td valign="middle" align="center">C-language files<br>
      </td>
      <td valign="middle" align="center">ASCII<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM3-native</b><b><br>
          </b></font></td>
      <td valign="middle" align="center"><font color="#009900">XCOM.xpl, XPL.LIBRARY.xpl<br>
        </font></td>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM-I.py</b><b><br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">No</font><font color="#009900"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">Yes</font><font color="#009900"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">XPL, ASCII coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM45-native</b></font></td>
      <td valign="middle" align="center"><font color="#009900">XCOM4.5.xpl, XPLIB4.5.xpl<br>
        </font></td>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM-I</b><b>.py<br>
          </b></font></td>
    </tr>
    
    <tr>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-360</b><b>.obj<br>
          </b></font></td>
      <td valign="middle" align="center"><font color="#cc9933">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-native</b><b><br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">Yes</font><font color="#cc9933"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">Only under <b>sim360</b> or similar</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">XPL, EBCDIC coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-360.obj</b></font></td>
      <td valign="middle" align="center"><font color="#cc9933">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-native</b></font></td>
    </tr>
    
    <tr>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360A</b><b>.obj</b><br>
        </font></td>
      <td valign="middle" align="center"><font color="#000099">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360</b><b>.obj<br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">Yes<br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">Only under <b>sim360</b> or similar</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">XPL, EBCDIC coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360A.obj</b></font></td>
      <td valign="middle" align="center"><font color="#000099">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360.obj</b></font></td>
    </tr><tr>
  <td valign="middle" align="center"><b>XCOM3-20010502.obj</b><b><br>
</b>

  </td>
  <td valign="middle" align="center">XCOM.xpl, XPL.LIBRARY.xpl</td>
  <td valign="middle" align="center">n/a</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">Yes</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">Only under <b>sim360</b> or similar</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">XPL, EBCDIC coding</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">IBM 360 load file</td>
  <td rowspan="2" colspan="1" valign="middle" align="center">EBCDIC<br>
  </td>
</tr>
<tr>
  <td valign="middle" align="center"><b>XCOM45-19760719.obj</b><b><br>
</b>
  </td>
  <td valign="middle" align="center">XCOM4.5.xpl, XPLIB4.5.xpl</td>
  <td valign="middle" align="center">n/a<br>
  </td>
</tr><tr>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM3-360C.obj<br>
  </font></b>
  </td>
  <td valign="middle" align="center"><font color="#ff0000">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM3-20010502.obj</font></b></td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">Yes<br>
</font>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">Only under <b>sim360</b> or similar<br>
</font>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">XPL, EBCDIC coding<br>
</font>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">IBM 360 load file</font><br>
  </td>
  <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#ff0000">EBCDIC</font><br>
  </td>
</tr>
<tr>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM45-360C.obj<br>
  </font></b>
  </td>
  <td valign="middle" align="center"><font color="#ff0000">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
  <td valign="middle" align="center"><b><font color="#ff0000">XCOM45-19760719.obj</font></b></td>
</tr>


    
  </tbody>
</table>
<br>
There are other possibilities that the table doesn't cover, for 
compiling stuff with other stuff .&nbsp; Those are left as an exercise 
for the reader, though I don't think they have any relevance <i>vis à vis</i> bootstrapping.<br><br>
In the next four subsections, I'm going to make a 
detailed examination of the steps needed to actually carry out the 
bootstrapping manipulations and to show that the bootstrapping was 
successful.&nbsp; Or not!&nbsp; (But it was successful for me.)<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
If you're on Linux or Mac OS and you don't have the patience to read through all of the garbage just mentioned, <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Makefile">the Makefile provided with XCOM-I</a> can
also perform all 4 steps of the bootstrapping roadmap for you automatically.&nbsp; <a moz-do-not-send="true" href="#halsfc">You could then just skip past the next four subsections</a>.&nbsp; Unfortunately, I'm sure that the Makefile won't work in 
Windows as-is, but that it could be made to work.&nbsp; I'm not going to 
personally research the Windows situation, but you can look at the Makefile yourself to 
see what has to be done.&nbsp; If you figure it out, drop me a line and 
tell me about it.&nbsp; At any rate, the commands to bootstrap <b>XCOM3</b> and <b>XCOM45</b>
 using the makefile are as follows.&nbsp; It'll simply print messages at the end that it succeeded or failed:<br>
  </font>
  <blockquote>
    <pre><font size="-1"><font color="#663300">cd XCOM-I<br>make</font></font><font size="-1"><br></font></pre>
  </blockquote>
</blockquote>
<blockquote>
</blockquote>




<h3>Step 1:&nbsp; Compiling XCOM<i>x</i> source code with XCOM-I to produce XCOM<i>x</i>-native</h3>

<blockquote>
  </blockquote>For <b>XCOM3</b>:<br>
<blockquote><pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl --output=XCOM3-native Tests/XCOM.xpl
make -C XCOM3-native
</font></pre>

</blockquote>
For <b>XCOM45</b>:<br>

<blockquote>
  <pre><font color="#663300"><font color="#663300">cd XCOM-I<br></font>XCOM-I.py --xpl --lib-file=sim360-source/port/XPLIB4.5.xpl --output=XCOM45-native sim360-source/port/XCOM4.5.xpl
make -C XCOM45-native
</font></pre>

</blockquote><blockquote>

</blockquote>


This is very much as described earlier, so I won't duplicate that discussion here.<br>
<br>
Of course, the proof-of-the-pudding for a new compiler like <b>XCOM<i>x</i>-native</b> is whether or not the programs you compile with it produce the same 
results as the programs compiled by the contemporary <b>XCOM</b><i><b>x</b></i> did, back in the day. &nbsp; As it happens, McKeeman provides two sample XPL programs, <b>Example-6.18.1</b> and <b>Example-6.18.2</b>, with which we can test just that.&nbsp; The former demonstrates 
IBM 360 object-code production, while the latter demonstrates error 
handling.&nbsp; The complete <b>XCOM</b><b>3</b>
 reports for these programs are given in the book, so it's
 possible to compare the original reports from <b>XCOM3</b>, 
including the interspersed IBM System/360 assembly language produced by 
the compiler, versus the corresponding reports created now by <b>XCOM3-native</b>:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Today's XCOM Reports versus <i>A Compiler Generator</i></b></font></caption>


  <tbody>
    <tr>
      <th valign="bottom" align="center">XPL Source-Code File<br>
      </th>
      <th valign="bottom">Compiled by XCOM3 for the book <br>
        <i>A Compiler Generator</i> (1970)<br>
      </th>
      <th valign="bottom">Compiled by XCOM3-native for <br>
The Virtual AGC Project (2024)<br>
      </th>
    </tr>
    <tr>
      <td valign="top">Tests/Example-6.18.1.xpl<br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.1-McKeeman.pdf">Report</a><br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.1-XCOM-I.pdf">Report</a><br>
      </td>
    </tr>
    <tr>
      <td valign="top">Tests/Example-6.18.2.xpl<br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.2-McKeeman.pdf">Report</a><br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.2-XCOM-I.pdf">Report</a><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
As for a similar check of <b>XCOM45-native</b>, I'm not aware of any legacy reports that have survived from the olden days.<br>


<h3>Step 2:&nbsp; Compiling XCOM<i>x</i> source code with XCOM<i>x</i>-native to produce XCOM<i>x</i>-360</h3>
For <b>XCOM3</b>:<br>
<blockquote>
  <pre><font color="#663300"><font color="#663300">cd XCOM-I<br></font>XCOM3-native/XCOM3-native --ddi=0,Tests/XCOM.xpl</font><font color="#663300"> --ddi=2,XPL.LIBRARY.xpl --raf=B,3600</font><font color="#663300"><font color="#663300">,1</font>,XCOM3-360.obj --raf=B,3600</font><font color="#663300"><font color="#663300">,2</font>,</font><font color="#663300">XCOM3-360</font><font color="#663300">.dat --raf=B,3600</font><font color="#663300"><font color="#663300">,3</font>,</font><font color="#663300"><font color="#663300">XCOM3-360</font>.str &gt;XCOM3-360.rpt</font></pre>

</blockquote>


For <b>XCOM45</b>:<br>

<blockquote>
  <pre><font color="#663300"><font color="#663300">cd XCOM-I<br></font>XCOM45-native/XCOM45-native --ddi=0,sim360-source/port/XCOM4.5.xpl</font><font color="#663300"> --ddi=2,sim360-source/port/XPLIB4.5.xpl --raf=B,7200</font><font color="#663300"><font color="#663300">,1</font>,XCOM45-360.obj --raf=B,7200</font><font color="#663300"><font color="#663300">,2</font>,</font><font color="#663300">XCOM45-360</font><font color="#663300">.dat --raf=B,7200</font><font color="#663300"><font color="#663300">,3</font>,</font><font color="#663300"><font color="#663300">XCOM45-360</font>.str &gt;XCOM45-360.rpt</font></pre>

</blockquote>As you can see, this involves a bit of command-line complexity that step
 1 did not.&nbsp; The command-line options are all there to compensate 
for the lack of Job Control Language (JCL), and in particular to provide
 replacements for missing <font color="#663300"><code>DD</code></font> statements.&nbsp; For one thing, there's an extra file which 
needs to be attached as an input, because <b>XCOM</b><i><b>x</b></i> always needs to include the library file containing <a moz-do-not-send="true" href="#compactify"><font color="#663300"><code>COMPACTIFY</code></font></a>.&nbsp; Also, <b>XCOM</b><i><b>x</b></i> wants to use several "random-access
 files" for storing object code and what not, and we have to attach 
those files.&nbsp; (Refer to <a moz-do-not-send="true" href="#file">the <font color="#663300"><code>FILE</code></font> entry in the section on XPL's built-in library functions</a>.)&nbsp; Those random-access files are as follows:<br>
<ul>
  <li><font color="#663300"><code>FILE(1)</code></font> — The compiled IBM 360 object code.</li>
  <li><font color="#663300"><code>FILE(2)</code></font> — A scratch file (i.e., temporary working space) for data.</li>
  <li><font color="#663300"><code>FILE(3)</code></font> — A scratch file for strings.</li>
</ul>
As far as the numbers 3600 or 7200 appearing in the command line, <b>XCOM<i>x</i></b> uses a hard-coded constant to determine the record sizes for
 these random-access files, which happens to have the default value of <font color="#663300"><code>DISKBYTES=3600</code></font> for <b>XCOM3</b>, but <font color="#663300"><code>DISKBYTES=7200</code></font> for <b>XCOM45</b>.<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; Incidentally, <b>XCOM3</b>
 has plenty of quirks specific to it, quite aside from any quirks XPL 
more-generally may have as a computer language.&nbsp; <b>XCOM3-native</b> and <b>XCOM3-360</b> inherit these quirks.&nbsp; I mention this 
just in case you become excited about using <b>XCOM3-native</b> and start writing new XPL programs for it!&nbsp; Here are a few quirks I've noticed:</font><br>
  <font size="-1">
  </font>
  
  <ul><li><font size="-1">It only accepts upper-case for identifiers and keywords ... in spite of the fact that every speck of XPL source code in <i>A Compiler Generator</i> is printed in lower case! But I've provided a trick to work around that in <b>XCOM3-native</b>:  In <b>XCOM3-native</b>'s <font color="#663300"><code>--ddi</code></font> command-line switches that attach the XPL source-code files, you can optionally suffix them with "<font color="#663300"><code>,U</code></font>".  This tells <b>XCOM3-native</b> to automatically translate the associated files to upper case.  </font><font size="-1" color="#663300"><font color="#663300"><font color="#000000">It's
 not a perfect workaround, since it translates comments and quoted 
strings to upper case too, but that's life!  We didn't actually need to 
do that for these source-code files, though, because they're already 
completely upper-case.</font></font></font></li><li><font size="-1">It requires an <font color="#663300"><code>EOF</code></font>
 token at the end of the source code.&nbsp; Other than correcting some 
EBCDIC-to-ASCII translation bugs that were present before I got some of 
the files, addition of </font><font size="-1"><font size="-1"><font color="#663300"><code>EOF</code></font></font> at the ends was my sole code change.<br>
  </font></li><li><font size="-1">It won't allow you to have two division operations (including <font color="#663300"><code>MOD</code></font> as a division) in the same statement, instead emitting an error message saying that it requires a "busy register".</font></li><li><font size="-1">... and who knows what else?</font></li></ul></blockquote>
<p>The *.rpt files produced by these compilations are worth looking at, 
if only to verify that somewhere in each of them is a line reading "NO 
ERRORS WERE DETECTED".<br>
</p>
<p>I had <i>hoped</i> at this point to find that <b>XCOM<i>x</i>-360.obj</b> is byte-for-byte identical to the corresponding legacy executable <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b>.
 &nbsp; Unfortunately, my hopes have been dashed:&nbsp; They are 
interestingly-similar but not identical.&nbsp; But as I mentioned 
earlier, I expect to give convincing evidence that neither <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b> was <i>not</i> actually self-compiled, and instead was presumably compiled by a <i>different version</i> of <b>XCOM</b>.&nbsp; If so, it would fully explain the mismatch versus <b>XCOM<i>x</i>-360.obj</b>.&nbsp;
 But until I show you that evidence, it would certainly be reasonable to
 maintain the possibility that the mismatch is due to a bug in <b>XCOM-I</b>.<br>
</p>
<blockquote>
</blockquote>



<h3>Step 3:&nbsp; Compiling XCOM<i>x</i> source code with XCOM<i>x</i>-360 under sim360 to produce XCOM<i>x</i>-360A</h3>

For <b>XCOM3</b>:


<blockquote>
  <pre><font color="#663300">sim360 --size=3600</font><font color="#663300"><font color="#663300"> -o0ET stdout </font>-i0AT Tests/XCOM.xpl -i2AT XPL.LIBRARY.xpl -f1wb+ XCOM3-360A.obj -f2wb+ XCOM3-360A.dat -f3wb+ XCOM3-360A.str XCOM3-360.obj</font><br></pre>
</blockquote>For <b>XCOM45</b>:<br>
<blockquote>
  <pre><font color="#663300">sim360 --size=7200</font><font color="#663300"><font color="#663300"> -o0ET stdout </font>-i0AT sim360-source/port/XCOM4.5.xpl -i2AT </font><font color="#663300"><font color="#663300">sim360-source/port/</font>XPLIB4.5.xpl -f1wb+ XCOM45-360A.obj -f2wb+ XCOM45-360A.dat -f3wb+ XCOM45-360A.str XCOM45-360.obj</font></pre>
</blockquote>These command-line switches differ in detail from the ones we had to with <b>XCOM<i>x</i>-native</b>, but I think you can see that they're just the same old replacements for JCL <font color="#663300"><code>DD</code></font> commands, but employing a different syntax.<br>
<br>
For this denouement of the bootstrapping progress, what are the results?&nbsp; <b>XCOM3</b> and <b>XCOM45</b> are in the same boat in this regard, so I'll just explain what we see with <b>XCOM45</b>.&nbsp; You can check out <b>XCOM3</b> yourself if you like.<br>
<br>Firstly, the build of <b>XCOM45-360A.obj</b> succeeds with no errors.&nbsp; If <b>XCOM45</b>
 has successfully built itself, I claimed above that <b>XCOM45-360.obj</b> and 
<b>XCOM45-360A.obj</b> will be byte-for-byte identical.&nbsp; That was actually an oversimplification.&nbsp; Anybody who runs <b>XCOM<i>x</i></b>
 will immediately notice that the first thing reported by it is the date 
and time at which the compiler itself was compiled.&nbsp; To be able to 
do that, an <b>XCOM<i>x</i></b> executable must have such a timestamp embedded within it somewhere.&nbsp; Which further means that using identical <b>XCOM<i>x</i></b> executables to compile identical XPL source code for <b>XCOM<i>x</i></b>
 will nevertheless produce output files that embed different timestamps,
 and therefore will not be byte-for-byte identical.&nbsp; But there are 
tricks you can use to work around that.&nbsp; Here's one of them:&nbsp; I
 made hexadecimal dumps of 
the two object files, and then used a file-comparison utility to compare
 the hex dumps side-by-side.&nbsp; Here's a screenshot of the <i>only</i> difference found between the two files, with <b>XCOM45-360.obj</b> on the left and <b>XCOM45-360A.obj</b> on the right:<br>
<br>
<img moz-do-not-send="true" src="XCOM45-360-meld.png" alt="" width="1580" height="89"><br>
<br>
What are the 3 bytes that are different?&nbsp; Well, <b>XCOM45-360.obj</b> was 
built (according to the report it prints out) at time 19:53.37.27, while
<b> XCOM45-360A.obj</b> was built at 17:5:6.24.&nbsp; Now, <b>XCOM</b> gets the 
compile time using <a moz-do-not-send="true" href="#builtin">the built-in function <font color="#663300"><code>TIME_OF_GENERATION</code></font></a>,
 which returns the number of centiseconds since midnight.&nbsp; For 
<b>XCOM45-360.obj</b>, that computes to 
100*(19*3600+60*53+37.27)=7161727=0x6D477F.&nbsp; Similarly, for 
<b>XCOM45-360A.obj</b>, 100*(17*3600+5*60+6.24)=6150624=0x5DD9E0, which 
(surprise!) matches the screenshot above.&nbsp; (Recall that these IBM 
360 programs all store their integer data in <i>big-endian</i> form, so that the most-significant bytes come first in memory.)&nbsp; In short, <b>XCOM45</b><b>-360.obj</b> can indeed accurately build itself, and bootstrapping <b>XCOM45</b> has been 100% successful!<br>
<br>
In other words, it works!&nbsp; <b>XCOMx</b> can be bootstrapped and accurately builds itself.<br>
<h3>Step 4:&nbsp; Bonus Cross-Comparison of Files Built by XCOMx-360.obj Versus Files Built by Legacy XCOMx Executables</h3>
<p>In step 2 above, I noted that <b>XCOM<i>x</i>-360.obj</b>, disappointingly, 
is not byte-for-byte identical to the corresponding legacy IBM 360 executable load 
file <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b>.&nbsp; I had further speculated, but could not prove, that this was because 
those legacy executables had themselves been built using different 
versions of <b>XCOM</b><b><i>x</i></b>.&nbsp; For example, perhaps <b>XCOM45</b><b><i>-</i>19760719.obj</b> was built by XCOM 4.4, or the perhaps the legacy <b>XCOM3</b><b><i>-</i>20010502.obj</b> was built by XCOM 3.2.&nbsp; Now comes the evidence!<br>
</p>
<p>Suppose that my speculation is true.&nbsp; In that case, if we rebuild <b>XCOM</b><b><i>x</i></b> source code using <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b> we should find that:</p>
<ul>
  <li>The executable load file we get by doing that <i>also</i> should <i>not</i> match <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b> byte-for-byte, proving that <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b> had indeed not been self-built.<br>
  </li>
  <li>But it <i>should</i> match <b>XCOMx-360.obj</b> byte-for-byte, 
giving us a tremendously warm, fuzzy feeling of independent confirmation
 that the bootstrapping process was 100% successful.<br>
</li>
</ul>
<p>So let's try that.&nbsp; As usual, here are the instructions for doing the compilations:</p>
<p>For <b>XCOM3</b>:


</p>
<blockquote>
  <pre><font color="#663300">sim360 --size=3600</font><font color="#663300"><font color="#663300"> -o0ET stdout </font>-i0AT Tests/XCOM.xpl -i2AT XPL.LIBRARY.xpl -f1wb+ XCOM3-360C.obj -f2wb+ XCOM3-360C.dat -f3wb+ XCOM3-360C.str XCOM3-20010502.obj</font><br></pre>
</blockquote>
For <b>XCOM45</b>:<br>

<blockquote>
  <pre><font color="#663300">sim360 --size=7200</font><font color="#663300"><font color="#663300"> -o0ET stdout </font>-i0AT sim360-source/port/XCOM4.5.xpl -i2AT </font><font color="#663300"><font color="#663300">sim360-source/port/</font>XPLIB4.5.xpl -f1wb+ XCOM45-360C.obj -f2wb+ XCOM45-360C.dat -f3wb+ XCOM45-360C.str XCOM45-19760719.obj<br></font></pre></blockquote>We could use the same technique as in the preceding section to check that <b>XCOMx-360.obj</b> is identical to <b>XCOM</b><b><i>x-YYYYMMDD</i>.obj</b>,
 taking into account the embedded timestamp.&nbsp; I'll let that as an 
exercise for the reader.&nbsp; But there's also an automated way to do 
the check, and obviously that's somewhat easier.<br>
<br>
I mentioned earlier that if you're on Linux (or possibly Mac), then <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Makefile">the makefile </a>will
 do the entire bootstrapping process for you, including this 
byte-for-byte check.&nbsp; It actually uses a simplified check  (in the Makefile, see how the <font color="#663300"><code>cmp</code></font> 
command is used), in which it just counts the number of mismatched 
bytes, and concludes that if there were 3 or less mismatched bytes, then
 there's an overall match.&nbsp; It doesn't bother to check that the 
mismatched bytes are valid timestamps.<br>
<br>
QED.<br>
<blockquote>
</blockquote>


<blockquote>
</blockquote>
<h2><a name="halsfc"></a>HAL/S-FC Through the Lens of XCOM-I<br>
</h2>
<h3>Compiling HAL/S-FC Itself<br>
</h3>

The examples in the preceding section are all very well and good, but the Holy Grail is compilation via <b>XCOM-I</b> of <b>HAL/S-FC</b> itself, and subsequently being able to successfully run <b>HAL/S-FC</b>.&nbsp; Just as there was a big leap in complexity from being able to compile <b>ANALYZER</b> (~1500 lines of XPL) to being able to compile <b>XCOM<i>x</i></b> (~4200 lines of XPL), there's a much larger leap to being able to compile <b>HAL/S-FC</b> (&gt;30,000 lines of XPL, for some of <b>HAL/S-FC</b>'s
 passes).&nbsp; The steps for doing so are also somewhat more complex, 
so I've once again taken the pains to simplify them for you with a 
Makefile; and <i>this</i> time, I won't insist upon droning on in a sleep-inducing fashion about those details.<br>
<br>
To compile <b>HAL/S-FC</b> <i>itself</i>, switch over to the working directory where the <b>HAL/S-FC</b> source code actually is stored, and compile it there, as follows:<br>
<blockquote>
  <pre><font color="#663300">cd yaShuttle/"Source Code"/PASS.REL32V0<br>make<br></font></pre>
</blockquote><b>HAL/S-FC</b> actually consists of 7 passes, 
each with its own, standalone executable, and the instructions above (if
 they succeed), will thus create 7 new programs in the PASS.REL32V0/ folder:&nbsp; 
<b>PASS1</b>, <b>FLO</b>, <b>OPT</b>, <b>AUX</b>, <b>PASS2</b>, <b>PASS3</b>, and <b>PASS4</b>. You may or may not want 
to move these into your PATH.&nbsp; The reason you might not want to 
move them into your PATH is that a number of compilers written in XPL
 use this kind of naming pattern, and <i>also</i> have program names like <b>PASS1</b>, 
<b>PASS2</b>, and <b>PASS3</b>.&nbsp; <br>



<h3>Using PASS1 to Process Programs Written in HAL/S<br>
</h3>
Now that you've built <b>HAL/S-FC</b> itself, <i>using</i> <b>HAL/S-FC</b> to compile HAL/S source code is a bit trickier, because I haven't yet built a Makefile to simplify it for you.&nbsp; <b>HAL/S-FC</b>'s
 development, and of course the IBM System/360's development before 
that, greatly preceded the modern notion that the user experience must 
be simplified to the point where no knowledge at all is required to use 
the software.&nbsp; The 7 compiler passes, or at least some substantial 
number of them, are run in succession.&nbsp; Each pass receives data 
from the preceding pass, and sends data into the next pass either 
explicitly via files, or else via
 <font color="#663300"><code>COMMON</code></font> memory.&nbsp; It's 
thus necessary not merely to run the passes in the correct order, but to
 use all of the command-line settings properly to make sure that filenames match up from pass to pass.&nbsp; <br>
<br>
<i>At first</i>, though, let's not worry about all of that stuff.&nbsp; Let's just think about running <b>PASS1</b> by itself, and ignore all of the other passes.&nbsp;
 It's obviously the most important pass, since where would the other passes 
be without it?&nbsp; Nowheresville, baby, that's where! <br>
<br>
Besides, <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/ported">we also 
have my previous manually-created port (<b>HAL_S_FC.py</b>) of PASS1 from XPL/I to Python</a> with 
which to compare to <b>PASS1</b> as created by <b>XCOM-I</b>.&nbsp; Speaking of which here's how one might process a simple HAL/S program using <b>HAL_S_FC.py</b>:<br>
<blockquote>
  <pre><font color="#663300">HAL_S_FC.py SRN --hal=<i>SOURCECODE</i> &gt;<i>REPORT</i>.txt</font><br></pre>
</blockquote>
Pretty simple looking!&nbsp; Unfortunately, the simplicity of <font color="#663300"><code>HAL_S_FC.py</code></font>&nbsp;
 was aided somewhat by the fact that I never intended to port any of the
 other 6 compiler passes into Python, and hence didn't have to worry 
about the interconnections between the compiler passes.&nbsp; In 
contrast, here's a sample of how to run <b>PASS1</b> as created by <b>XCOM-I</b> to process that same HAL/S program:<br>
<blockquote>
  <pre><font color="#663300">./PASS1</font><font color="#663300"><font color="#663300"> </font></font><font color="#663300"><font color="#663300"><font color="#663300"><font color="#663300">--parm="SRN"</font></font></font> </font><font color="#663300"><font color="#663300">--pdsi=5,ERRORLIB</font> --pdsi=6,ACCESS --ddi=0,<i>SOURCECODE</i>.hal --raf=B,7200,1,<i>HALMAT</i>.bin </font><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font><font color="#663300"><font color="#663300"> --raf=B,3360,6,<i>VMEM</i>.bin</font> &gt;<i>REPORT</i>.txt</font><br></pre>
</blockquote>

There's obviously a bit of added complexity here, or at least the 
appearance of added complexity, so let me go through these things 
one-by-one:<br>
<ul>
  <li><code><font color="#663300">./PASS1</font></code> is, of course, the program <b>PASS1</b> of <b>HAL/S-FC</b>
 itself.&nbsp; The "./" prefixing is to help some versions of Linux that
 don't automatically look in your current working folder for program 
names.&nbsp; At the very least, it's harmless in Linux or Mac OS.&nbsp; 
Leave it off in Windows!&nbsp; <br>
  </li>
  <li><code><font color="#663300"><font color="#663300">--parm="SRN"</font></font></code>:&nbsp;
 The <font color="#663300"><code>--parm='...'</code></font> switch in general is used to pass options to the compiler, replacing the <font color="#663300"><code>PARM='...'</code></font> that originally appeared in Job Control Language (JCL) on the IBM 360.&nbsp; <a moz-do-not-send="true" href="#programOptions">The numerous possibilities for inclusion in <font color="#663300"><code>--parm='...'</code></font> are discussed later</a>.&nbsp;
 But specifically, SRN tells the compiler that there are serial numbers 
in columns 73-80 
of the "cards" containing your source code, or more-precisely, that 
there is no source code in columns 73-80.&nbsp; I typically put all my
 source code in columns 1-72, just because I think it's a good habit in 
HAL/S.&nbsp; But you can use the entirety of columns 1-80 if you leave 
off this command-line option.&nbsp; Of course, if you did not write the 
HAL source code yourself, you don't really have any choice, and have to 
stick with whatever's consistent with the actual source code.&nbsp; As 
for columns 81 and above, you cannot use them for HAL/S source code by 
any means whatever.&nbsp; Too bad!</li>
<li>The <font color="#663300"><code>--pdsi=...</code></font>, <font color="#663300"><code>--pdso=...</code></font>, <font color="#663300"><code>--ddi=...</code></font>, <font color="#663300"><code>--ddo=...</code></font>, and <font color="#663300"><code>--raf=... </code></font>switches, in general, all replace the <font color="#663300"><code>DD</code></font>
 commands that originally appeared in JCL on the IBM 360:&nbsp; i.e., 
they associate specific filenames and (to a certain extent) file types 
with the device numbers used in XPL source code <font color="#663300"><code>INPUT(n)</code></font>, <font color="#663300"><code>OUTPUT(n)</code></font>, and <font color="#663300"><code>FILE(n)</code></font> functions.</li>
</ul>
<p>Among themselves, the seven passes of <b>HAL/S-FC</b> use a 
somewhat-consistent scheme for associating filenames to file numbers, 
though not all of the passes necessarily use all of the files.&nbsp; I 
say "somewhat", because files output by one pass are sometimes input to 
another pass using a different file number.&nbsp; Here's a handy table 
that summarizes the file usage of each pass.&nbsp; When you see 
something italicized, such as <i><code>HALMAT</code></i> in <code><font color="#663300">--raf=B,7200,1,<i>HALMAT</i>.bin</font></code>,
 I mean to imply that you may or may not want to choose a different name
 than I have, or to use different names for different compiler passes; 
however, the names must be consistent between the passes outputting them
 and the passes using them as input.&nbsp; The cells that have been highlighted in color emphasize those places in which the <i>same</i>
 file must be used on successive passes; in the case of the 
virtual-memory file, I don't know if the same file is used on successive
 passes or not, so I haven't highlighted it, but I've been using the 
same file without any apparent difficulty.<br>
</p>
<table width="100%" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom">HAL/S-FC Usage<br>
      </th>
      <th valign="bottom">PASS1<br>
      </th>
      <th valign="bottom">FLO<br>
      </th>
      <th valign="bottom">OPT<br>
      </th>
      <th valign="bottom">AUX<br>
      </th>
      <th valign="bottom">PASS2<br>
      </th>
      <th valign="bottom">PASS3<br>
      </th>
      <th valign="bottom">PASS4<br>
      </th>
      <th valign="bottom">Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center">Input HAL source code<br>
      </td>
      <td valign="middle" align="center"><b><code><font color="#663300">--ddi=0,<i>SOURCECODE</i>.hal</font></code></b><b> or </b><b><code><font color="#663300">stdin<br>
          </font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Output report<br>
      </td>
      <td valign="top" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=0,<i>REPORT</i>.txt</code></font></b><b> or </b><b><font color="#663300"><code>stdout</code></font></b></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Output error messages<br>
      </td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b></td>
      <td valign="middle" align="center"><b><font color="#663300"><code>stderr</code></font></b></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Extra listing file, plus SPACELIB error messages<br>
      </td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font></b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font></b></td>
      <td valign="middle" align="center"><font color="#663300"><code></code></font><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font>
      </td>
      <td valign="middle" align="center"><font color="#663300"><code></code></font><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font>
      </td>
      <td valign="middle" align="center"><font color="#663300"><code></code></font><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font>
      </td>
      <td valign="middle" align="center"><font color="#663300"><code></code></font><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font>
      </td>
      <td valign="middle" align="center"><font color="#663300"><code>--ddo=2,<i>LISTING2</i>.txt</code></font>
      </td>
      <td valign="middle">This file is produced by <b>PASS1</b> if "LISTING2" is among the options in PARM='...', and I don't show it in the sample <b>PASS1</b>
 invocation above, because LISTING2 isn't among the chosen PARM 
options.&nbsp; However, SPACELIB directs certain error messages to it as
 well, so in some ways it's better to have it even if LISTING2 isn't 
specified.<br>
      </td>
    </tr>
    <tr>
  <td valign="middle" align="center">AP-101S object code<br>
  </td>
  <td valign="middle" align="center"><b>n/a</b><b><br>
    </b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><font color="#663300"><code>--ddo=3,<i>CARDFILE</i>.bin,U</code></font><br>
  </td>
  <td valign="middle" align="center"><b><br>
    </b></td>
  <td valign="middle" align="center"><b><br>
    </b></td>
  <td valign="top"><a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/OS/360_Object_File_Format">I think that object code output by <b>PASS2</b> is provided in a punch-card format similar to the way IBM 360 object code is</a>.&nbsp; Possibly device 3 is an actual card-punch (SYSPUNCH); I'm not sure.<br>
  </td>
</tr>
<tr>
  <td valign="middle" align="center">Object code "deck"<br>
  </td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><font color="#663300"><code>--ddo=4,<i>DECK</i>.bin,U</code></font></td>
  <td valign="top"><br>
  </td>
  <td valign="top"><br>
  </td>
  <td valign="middle" align="left">An optional copy of <font color="#663300"><code><i>CARDFILE</i></code></font>.&nbsp; (Which only makes sense if device 3 is a physical card-punch as speculated above.)<br>
  </td>
</tr>
<tr>
      <td valign="middle" align="center">Input error-message library<br>
      </td>
      <td valign="middle" align="center"><b><code><font color="#663300"><font color="#663300">--pdsi=5,ERRORLIB</font></font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><font color="#663300"><code>--pdsi=5,ERRORLIB</code></font><br>
</td>
      <td valign="middle" align="center"><br>
</td>
      <td valign="middle" align="center"><br>
</td>
      <td valign="middle">The 
compiler requires access to the library of HAL/S error messages, which 
is the folder PASS.REL32V0/ERRORLIB/.&nbsp; Note that "ERRORLIB" is 
literally its name, and it's all you need in the command-line option if 
you're running the compiler from the PASS.REL32V0/ directory.&nbsp; But 
if you're running the compiler from a different directory, you need an 
absolute or relative path to ERRORLIB.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Input access-rights library<br>
      </td>
      <td valign="middle" align="center"><b><code><font color="#663300">--pdsi=6,ACCESS</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b>
      </td>
      <td valign="middle">The compiler also requires access to the library of access rights, 
namely the folder PASS.REL32V0/ACCESS/.&nbsp; The folder is empty, yes, because <i>you</i>
 have full access and there are no restrictions.&nbsp; But it's still 
required!&nbsp; Note that "ACCESS" is literally its name.&nbsp; Like 
ERRORLIB (see above), just using ACCESS in the command-line option is 
fine only if you're running the compiler directly from the PASS.REL32V0/
 folder.<br>
      </td>
    </tr>
    <tr>
  <td valign="middle" align="center">Extra listing<br>
  </td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><b>n/a</b></td>
  <td valign="middle" align="center"><font color="#663300"><code>--ddo=7,<i>EXTRA</i>.txt</code></font></td>
  <td valign="top"><br>
  </td>
  <td valign="top"><br>
  </td>
  <td valign="top"><br>
  </td>
</tr>
<tr>
      <td valign="middle" align="center">Output or input HALMAT<br>
      </td>
      <td valign="middle" align="center" bgcolor="#ffcccc"><b><code><font color="#663300">--raf=B,7200,1,<i>HALMAT</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#ffcccc"><b><code><font color="#663300">--raf=B,7200,1,<i>HALMAT</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#ffcccc"><b><code><font color="#663300">--raf=B,7200,1,<i>HALMAT</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#999900"><b><code><font color="#663300">--raf=B,7200,1,<i>AUXMAT</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#999900"><code><font color="#663300">--raf=B,7200,1,<i>AUXMAT</i>.bin</font></code></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="top">This is a "random-access file" storing "HALMAT".&nbsp; For some passes (such as <b>PASS1</b>) this is output; for others (such as <b>FLO</b>) it is input.&nbsp; When output, it doesn't need
 to 
previously exist.&nbsp; Recall that HALMAT is the name of the 
"intermediate language" into which <b>PASS1</b> converts your HAL/S source code.&nbsp; This file is the principal output of <b>PASS1</b>, and is what is sent along to the optimizing passes, some of which modify the HALMAT, and eventually to <b>PASS2</b>
 to be converted to IBM 360 or AP-101S object code.&nbsp; Alas, due to 
the apparent non-survival of adequate documentation related to HALMAT, 
this file is presently incomprehensible even when translated from its 
binary format into a somewhat-human-readable form.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Literal file<br>
      </td>
      <td valign="middle" align="center" bgcolor="#cc33cc"><b><code><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#cc33cc"><b><code><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#cc33cc"><b><code><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center" bgcolor="#cc33cc"><b><code><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#cc33cc"><b><code><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle">This is a "random-access file" that the compiler uses to store the 
values of literals.</td>
    </tr>
    <tr>
      <td valign="middle" align="center">Varies(?)<br>
      </td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,1560,3,<i>ICFILE</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b><code></code></b><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,1600,3,<i>OBJFILE</i>.bin<br>
</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle">By <i><font color="#663300"><code>ICFILE</code></font></i>, I mean the INITIAL/CONSTANT queue.&nbsp; I <i>think</i> that the compiler can only hold
 a certain number of initializers in memory at once, and this file is 
used to swap any overflow of the initializers from memory.<br>
<br>
By <i><code>OBJFILE</code></i>, I mean a work-file that accepts data 
related to object-code generation when it overflows the provided memory 
buffer for it.&nbsp; It is not object code as such.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" align="center">Second HALMAT file<br>
      </td>
      <td valign="middle" align="center"><b><code></code></b><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center" bgcolor="#cc9933"><b><code><font color="#663300">--raf=B,7200,4,<i>OPTMAT</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#cc9933"><b><code><font color="#663300">--raf=B,7200,4,<i>OPTMAT</i>.bin</font></code></b></td>
      <td valign="middle" align="center" bgcolor="#cc9933"><code><font color="#663300">--raf=B,7200,4,<i>OPTMAT</i>.bin</font></code></td>
      <td valign="middle" align="center"><b><code></code></b><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="top">Secondary HALMAT file.&nbsp; As you can see, we somehow end up with three separate HALMAT files:&nbsp; <br>
        <ul>
          <li><font color="#663300"><code><i>HALMAT</i>.bin</code></font>, produced by <b>PASS1</b> and used by lots of other passes.<br>
          </li>
          <li><font color="#663300"><code><i>OPTMAT</i>.bin</code></font>, produced by <b>OPT</b> and <i>apparently</i> not used.<br>
          </li>
          <li><font color="#663300"><code><i>AUXMAT</i>.bin</code></font>, produced by <b>AUX</b> and used by <b>PASS2</b>.</li>
        </ul>
        <p>Is <font color="#663300"><code><i>OPTMAT</i>.bin</code></font>, perhaps, the same as <font color="#663300"><code><i>AUXMAT</i>.bin</code></font>?<br>
        </p>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">SDF<br>
      </td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,1680,5,<i>SDF</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="top"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Virtual-memory<br>
file<br>
      </td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,3360,6,<i>VMEM</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,3360,6,<i>VMEM</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,3360,6,<i>VMEM</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b><code><font color="#663300">--raf=B,3360,6,<i>VMEM</i>.bin</font></code></b></td>
      <td valign="middle" align="center"><b>n/a</b></td>
      <td valign="middle">This is a "random-access file" that the compiler uses to store blocks of virtual 
memory which have been temporarily unloaded from memory.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Input <font color="#663300"><code>COMMON</code></font> file<br>
      </td>
      <td valign="middle" align="center"><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle" align="center" bgcolor="#ffff99"><b><font color="#663300"><code>--commoni=</code><code><i>COMMON1</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#99ff99"><b><font color="#663300"><code>--commoni=</code><code><i>COMMONf</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#99ffff"><b><font color="#663300"><code>--commoni=</code><code><i>COMMONo</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#ff6666"><b><font color="#663300"><code>--commoni=</code><code><i>COMMON</i></code><code><i>a</i>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#ff99ff"><b><font color="#663300"><code>--commoni=</code><code><i>COMMON2</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#cccccc"><b><font color="#663300"><code>--commoni=</code><code><i>COMMON</i></code><code><i>3</i>.out</code></font></b></td>
      <td valign="middle">On the IBM 360, certain areas of memory, known as <font color="#663300"><code>COMMON</code></font>,
 were expected to retain their contents when one pass of the compiler 
was unloaded from memory, and the next pass loaded into it.&nbsp; Of 
course, this will not happen any any computer you'll be likely to use, 
and <b>XCOM-I</b> supports <font color="#663300"><code>COMMON</code></font> differently than that.&nbsp; Instead, each pass writes out <font color="#663300"><code>COMMON</code></font> as a file upon termination, and (optionally) inputs <font color="#663300"><code>COMMON</code></font>
 from a file upon startup.&nbsp; By default, output is to a file 
literally called "COMMON.out", while input is disabled.&nbsp; For <b>PASS1</b>, these defaults are reasonable.&nbsp; However, each subsequent pass wants to take <font color="#663300"><code>COMMON</code></font> from the preceding pass, so the default input is no longer good. <br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Output <font color="#663300"><code>COMMON</code></font> file<br>
      </td>
      <td valign="middle" align="center" bgcolor="#ffff99"><b><font color="#663300"><code>--commono=</code><code><i>COMMON1</i></code><code>.out</code></font></b><b><br>
</b>
      </td>
      <td valign="middle" align="center" bgcolor="#99ff99"><b><font color="#663300"><code>--commono=</code><code><i>COMMONf</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#99ffff"><b><font color="#663300"><code>--commono=</code><code><i>COMMONo</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#ff6666"><b><font color="#663300"><code>--commono=</code><code><i>COMMONa</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#ff99ff"><b><font color="#663300"><code>--commono=</code><code><i>COMMON2</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center" bgcolor="#cccccc"><b><font color="#663300"><code>--commono=</code><code><i>COMMON3</i></code><code>.out</code></font></b></td>
      <td valign="middle" align="center"><b>n/a</b><b><br>
</b>
      </td>
      <td valign="middle">See the comment above.&nbsp; It is, of course, possible to omit all of the <font color="#663300"><code>--commono</code></font> options entirely, and to use <font color="#663300"><code>--commoni=</code><code>COMMON</code><code>.out</code></font> everywhere.&nbsp; This is perfectly workable, and its only drawback is the lose of transparency of what happens between passes.<br>
      </td>
    </tr>
  </tbody>
</table>
<p><br>
</p>
<h3>Correctness of PASS1</h3>
<p>As discussed in the preceding section, our <i>goal</i> is to be able to compile HAL/S programs by means of <b>HAL/S-FC</b> (as compiled itself by <b>XCOM-I</b>), but we can be assisted somewhat in reaching that goal by taking advantage of work done prior to the effort of creating <b>XCOM-I</b>.&nbsp; Specifically, before writing <b>XCOM-I</b>, I had ported <b>PASS1</b> of <b>HAL/S-FC</b> from XPL to Python.&nbsp; This Python version of <b>PASS1</b> is called <b>HAL_S_FC.py</b>.&nbsp; In an <i>ideal</i> world, we'd expect <b>PASS1</b> and <b>HAL_S_FC.py</b>
 to produce results that were identical in all respects, except for 
things like (say) timestamps.&nbsp; Given that this isn't an <i>ideal</i>
 world, as far as we know, and in particular neither I nor my creations 
are perfect, we should instead expect some discrepancies.&nbsp; In fact,
 discrepancies are very useful, as they highlight bugs in one or another
 of the two versions, and correcting those bugs helps me to push both 
versions closer to validity.&nbsp; Nevertheless, some discrepancies are 
rooted in the very fact that theses two versions are implemented using 
very different underlying principles and tools, and cannot be removed by
 any reasonable means.<br>
</p>
<p>What kinds of discrepancies can we expect to find between <b>PASS1</b> and <b>HAL_S_FC.py</b>?&nbsp;
 I haven't done any systematic testing at this point, so I can only 
comment on discrepancies I've observed.&nbsp; We can categorize them 
somewhat by the output files produced by the programs:<br>
</p>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom">File Type<br>
      </th>
      <th valign="bottom">Output File in HAL_S_FC.py<br>
      </th>
      <th valign="bottom">Output File in PASS1<br>
      </th>
      <th valign="bottom" align="left">Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center">Compiler Report<br>
      </td>
      <td valign="middle" align="center">Printed to <font color="#663300"><code>stdout</code></font><br>
      </td>
      <td valign="middle" align="center">Printed to <font color="#663300"><code>stdout</code></font></td>
      <td valign="middle">
        <ul>
          <li>Differing timestamps and time usage reported, as expected and desired.<br>
          </li>
          <li><b>HAL_S_FC.py</b>:&nbsp; Does not report the "FREE STRING AREA".&nbsp; This is a design choice, since <b>HAL_S_FC.py</b> manages string data as Python strings.<br>
          </li>
          <li><b>HAL_S_FC.py</b>:&nbsp; Does not report the number of FILE 6 "locates", "reads", and "writes", because <b>HAL_S_FC.py</b> neither needs nor implements the <b>HAL/S-FC</b> virtual-memory module.&nbsp; This is a design choice.</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">HALMAT<br>
      </td>
      <td valign="middle" align="center">FILE1.bin<br>
      </td>
      <td valign="top" align="center">Set by <code><font color="#663300">--raf=B,7200,1,<i>HALMAT</i>.bin</font></code>.<br>
      </td>
      <td valign="middle">No discrepancies!<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Literals<br>
      </td>
      <td valign="middle" align="center">FILE2.bin<br>
      </td>
      <td valign="top" align="center">Set by <code><font color="#663300">--raf=B,1560,2,<i>LITFILE</i>.bin</font></code>.<br>
      </td>
      <td valign="middle"><font color="#663300"><code>FIXED</code></font> and <font color="#663300"><code>BIT(&lt;33)</code></font> literals in the file are identical for <b>PASS1</b> vs <b>HAL_S_FC.py</b>.&nbsp; However, string descriptors for <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT(&gt;32)</code></font> literals are different, because <b>HAL_S_FC.py</b> manages string data as Python strings, and thus string data is not stored in the identical memory locations used by <b>PASS1</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">Virtual Memory<br>
      </td>
      <td valign="middle" align="center">FILE6.bin<br>
      </td>
      <td valign="middle" align="center">Set by <code><font color="#663300">--raf=B,3360,6,<i>VMEM</i>.bin</font></code>.<br>
      </td>
      <td valign="middle">They differ, because <b>HAL_S_FC.py</b> does not implement <b>HAL/S-FC</b>'s virtual-memory module at all.&nbsp; The virtual-memory file produced by <b>HAL_S_FC.py</b> is in fact empty.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h3>Processing with FLOWGEN<br>
</h3>
After <b>PASS1</b>, the next pass of <b>HAL/S-FC</b> that's run is <b>FLO</b> (which is short for FLOWGEN).&nbsp; TBD<br>
<br>
<h1><a name="xpli"></a>A Primer for Standard XPL and Intermetrics XPL/I</h1>


<p>It is a truth universally acknowledged that there is no satisfactory 
introductory information available concerning programming in XPL.&nbsp; 
Or at least, it <i>would</i> be universally acknowledged if anybody had ever heard of XPL and wanted to use it for anything.&nbsp; <br></p>
<p>The best you can do, generally speaking, is to purchase a used copy of McKeeman (i.e., <i>A Compiler Generator</i>).&nbsp;
 If you do, you'll find a book that's densely packed with information, 
but that information is the source code for an XPL compiler (written in 
XPL), lots of BNF descriptions of the language, lots of theory on how to
 write a compiler-generator program, and very little of direct interest 
to a programmer who wants to come up to speed quickly on how to write or
 understand a program written in XPL.  Not to mention the fact — though I
 <i>am</i> mentioning it! — that some of the most-critical 
counter-intuitive information is buried in easy-to-miss, 
easy-to-misunderstand comments made in passing, rather than as big, 
bold-face warnings. &nbsp; And as a bonus, the book provides an index of
 almost no use at all to a newby XPL programmer.&nbsp; Besides which, 
most <i>online</i> information about XPL, in my experience, is a simple abridgement or other rehashing of <i>A Compiler Generator</i>,
 and adds little extra of value in a tutorial sense, since it's almost 
never written by anybody actually working with XPL.&nbsp; With that 
said, you may find some useful online information in a couple of places:<br></p>

<ul>
  <li>&nbsp;<a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel Weaver provides some documentation (in particular, his xpl.pdf) with his XPL-to-C translator program</a>.</li>
  <li>The <a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/ldindex.html">University of Toronto XPL website has a page</a> with a small but useful transcription of some material from <i>A Compiler Generator</i> — albeit with unfortunate HTML formatting that make some of it almost unreadable.</li>
</ul>
<p>And as for Intermetrics XPL/I ... well, from a tutorial perspective, 
it's orders of magnitude worse.  Perhaps later, non-surviving 
documentation did a better job.&nbsp; Enough said!
</p>

<p>Taking all of that into account, it might be reasonable to provide a 
full tutorial here how to write XPL or XPL/I programs.&nbsp; Perhaps 
I'll do that sometime.&nbsp; It turns out that that's easier said than 
done, since as you may have noticed, simplification for beginners is not
 really my personal strong suit.  Which is ironic, considering my strong
 criticism of <i>A Compiler Generator above</i>!  For now, I'll just 
cover some of the basics and quirks of the language(s).  Send in 
suggestions for improvement, if you like; I'm sure I can use them 
somehow to make the discussion even worse.
</p>
<h2><a name="basics"></a>The Basics</h2>
<h3>Character Set and Modern Character Substitutions<br>
</h3>
<p>The most basic characteristic of a language is the character set in 
which the language is expressed.&nbsp; Neither McKeeman nor Intermetrics
 specifies the character set.&nbsp; I've given it a lot of thought, and 
my conclusion is that the originally-supported character set was:
</p>
<p align="center">&lt;space&gt;<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>0 1 2 3 4 5 6 7 8 9<br>_ % + - * . / | &amp; = &lt; &gt; # @ $ , ; : ( ) ' " ! ?  [ ] { }<br>¢ ¬ &lt;eof&gt;<br>
</p>
<p>Here, by &lt;space&gt; I mean a space character, and by &lt;eof&gt; I mean an end-of-file character.<br>
</p>
<p>You'll notice that several characters common today were not originally supported, including:</p>

<p align="center">` ~ ^ \<br>
</p>

<p>Contrariwise, there are three characters (¢, ¬, and &lt;eof&gt;) that don't exist at 
all in the 7-bit ASCII character set that's the common core for the 
character sets typically used today when writing software source 
code.&nbsp; Therefore, when working with <b>XCOM-I</b>, we use the fortunately otherwise-unused ASCII characters in place of the unsupported characters:<br>
</p>
<ul>
  <li>The 
ASCII characters ~ and ^ are used interchangeably with ¬, but XCOM-I prefers ~.&nbsp; <br>
  </li>
  <li>Similarly, we use the ASCII character ` in preference to ¢.&nbsp; </li>
  <li>Finally, the ASCII \ character is now used in place of &lt;eof&gt;
 (EBCDIC code 0xFE), which was a character that could be punched on the 
punch cards, but had no printable representation.</li>
</ul>
<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; The &lt;eof&gt; <i>character</i> — not to be confused with the <font color="#663300"><code>EOF</code></font> <i>token</i> that appears at the end of the source code in an XPL or XPL/I program — 
 is an unusual case.&nbsp; It is not a special character in XPL 
programs.&nbsp; However, it is used as a bookkeeping device by HAL/S 
compilers, or at least by <b>HAL/S-FC</b>, in padding that the HAL/S 
compiler automatically appends to a stream of input HAL/S source 
code.&nbsp; Thus we have to have a way of representing it in the XCOM-I 
framework, even though it's not a character anyone would ever have 
occasion to use in either an XPL or HAL/S source-code file, unless that 
file was itself part of a HAL/S compiler!&nbsp; To the best of my 
knowledge, &lt;eof&gt; appears only within a single string variable, <font color="#663300"><code>INPUT_PAD</code></font>, that occurs in the <b>HAL/S-FC</b>
 source-code file STREAM.xpl.&nbsp; As far as I can tell, it is not even
 a standard EBCDIC character, but rather is something chosen for some 
reason unknown to me by HAL/S developers. See the comments for </font><font size="-1"><font size="-1"><font color="#663300"><code>INPUT_PAD</code></font></font> in STREAM.xpl.</font><br>
  </p>
</blockquote>
<p>These substitutions allow 
us to completely translate the original XPL or XPL/I source code 
back-and-forth between the original EBCDIC and ACII without any loss of 
information, and without insisting that you adopt any specific "locale" 
like ISO-8859-15 or UTF-8 for your computer that's not optimal for your 
other (non-XPL'ing) activities.&nbsp; With that said, I <i>hope</i> that you could use ¢ and ¬ in your XPL/I source code, if you insist on doing so, but I do not guarantee it. <br></p>

<blockquote>
  <p><font size="-1"><b>Aside:</b> All previously-existing XPL or XPL/I 
source code I've found, or HAL/S source code for that matter, has 
already substituted ~ or ^ for ¬ anyway.  And indeed, some early HAL/S 
documentation suggests this very substitution.  I suspect that's because
 some IBM printers at the time printed ~ in place of </font><font size="-1"><font size="-1">¬</font>.  But whatever the explanation, the substitutions I'm suggesting are not exactly daring in their originality.  As far as the </font><font size="-1">¢
 symbol is concerned, it's not actually used in active XPL or XPL/I 
code, as such, but can be used in program comments to toggle various 
compiler options on and off, or in principle could appear within quoted 
strings.</font></p>
</blockquote>

<h3>Case Sensitivity</h3>
<p>XPL programs are <i>not</i> case-sensitive, except in so far as the 
contents of quoted strings are concerned.&nbsp; E.g., lower-case or 
mixed-case symbols are treated as being identical to their upper-case 
correspondents, but quoted strings are case-sensitive.<br></p>
<h3>Source-Code Formatting<br>
</h3>
<p>Input to an XPL or XPL/I program (via the <font color="#663300"><code>INPUT</code></font>
 built-in function) is expected to conform to computer punch-card-like 
conventions.  I.e., input lines are always exactly 80 characters long, 
and <b>XCOM-I</b> enforces this by truncating or right-padding input 
lines as necessary.  If the input lines are longer than 80 columns 
physically — say, because they have punch-card sequence numbers in 
columns 81-88 — the extra columns are stripped off.<br></p>
<p>As for the source-code proper, other than being confined to columns 
1-80, it is entirely free-form.  I.e., line breaks are ignored; several 
statements may exist on the same input card, or conversely, a single 
statement may be split across multiple cards.  Even though XPL <font color="#663300"><code>CHARACTER</code></font> strings are limited to 256 characters, there is seemingly no limit to the length of an XPL statement.<br></p>
<p>There are hints in the error messages of McKeeman's <b>XCOM</b> (and I believe, in <i>A Compiler Generator</i> text) that <i>some</i>
 contemporary computer systems may have treated column 1 specially, 
perhaps accepting some kind of non-blank control characters there.  If 
so, it was a issue outside <b>XCOM</b> proper and is irrelevant to <b>XCOM-I</b>.
  However, you do find that legacy XPL source code does often begin in 
column 2 rather than column 1, and I suspect that this hypothetical 
column-sensitivity is the reason for it.<br></p>
<p>Regarding this column-1 ambiguity, however, there is the practical 
question of what to do when a long quoted string is split across 
multiple cards.  Does column 1 belong to the string or not?  In <b>XCOM-I</b>, I take my cue from McKeeman's source code for <b>XCOM</b> in this matter:  In spite of the fact that <b>XCOM</b>'s source code generally avoids column 1 in all other cases, column 1 <i>does</i> belong to any multi-line quoted strings.<br></p>

<h3>Identifiers</h3>
<p>Identifiers cannot begin with a digit, but otherwise consist of any sequence of upper- or lower-case alphanumeric characters, <i>or</i> any of the characters @ _ # $.&nbsp; For example, @_26$8ab# is a legal name for a variable.
</p>
<p>Identifiers cannot exceed 256 characters in length.
</p>
<h3><a name="datatypes"></a>Datatypes, Declarations, and Literals<br>
</h3>
<p></p>
<h4>The Basic XPL Datatypes</h4>
<p>There are only three basic datatypes:<br></p>

<ul>

  <li><font color="#663333"><code>FIXED</code></font> is a 32-bit signed
 integer.&nbsp; (Stored as 2's-complement, in big-endian byte order, vs 
the little-endian byte order used in most personal computers today.)<br></li><li><font color="#663333"><code>CHARACTER</code></font>
 is a variable-width character string, with a string-length limited to 
256 or less.&nbsp; Strings are stored as a 32-bit unsigned integer known
 as a <i>descriptor</i>, paired with a separate area from 1 to 256 bytes
 containing the individual characters of the string, encoded in 
EBCDIC.&nbsp; The descriptor has 8 bits specifying the string length 
(minus 1) and 24-bits providing the starting memory-address of the 
character data.</li><li><font color="#663333"><code>BIT(<i>n</i>)</code></font>, where <i><font color="#663333"><code>n</code></font></i> is from 1 to 2048, is an <font color="#663333"><code>n</code></font>-bit object.&nbsp; The amount of storage varies by the precision:</li><ul><li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>B(8)</code></font> are stored in memory as single bytes.</li><li><font color="#663333"><code>BIT(9)</code></font> through <font color="#663333"><code>BIT(16)</code></font> are stored as 2-byte "half-words".</li><li><font color="#663333"><code>BIT(17)</code></font> through <font color="#663333"><code>BIT(32)</code></font> are stored as 32-bit words.</li>
  <li><font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> are stored similarly to <font color="#663300"><code>CHARACTER</code></font>
 variables: There's a 32-bit "descriptor", of which 8 bits is the number
 of bytes needed to store all of the bits, minus 1, and 24 bits area 
pointer to elsewhere in memory, where the bytes themselves are stored.  
Thus, a long <font color="#663300"><code>BIT(n)</code></font> like this uses up 4 bytes for the descriptor, plus ⌊(n+7)/8⌋ bytes (5 for n=33 through 256 for n=2048) for the data. </li>
</ul>
</ul>

<blockquote>
  <p><font size="-1"><b>Aside:</b> The method for storing </font><font size="-1"><font color="#663333"><code>CHARACTER</code></font> data described above leaves no room for 0-length "empty" strings.  But the XPL and XPL/I languages <i>do</i>
 allow for empty strings: p. 207 of McKeeman tells us that an 
empty-string is represented by a string-descriptor with the value 
0x00000000, with no extra memory allocation for the non-existent "data" 
of the string.  This isn't ambiguous, by the way.  While 0x00000000 <i>technically</i>
 appears to be a descriptor for a 1-byte string whose data is located at
 address 0x000000, in fact address 0x000000 would always have been 
outside of the block of memory dedicated for storage of EBCDIC string 
data, rendering a descriptor of 0x00000000 unusable under the normal 
interpretation.</font><br></p>
</blockquote>
<ul>

</ul>

<p>Regarding the <font color="#663300"><code>BIT(<i>n</i>)</code></font> datatypes, you might suppose that since one has gone to all the trouble to define separate datatypes like <font color="#663300"><code>BIT(1)</code></font>, <font color="#663300"><code>BIT(2)</code></font>, ..., <font color="#663300"><code>BIT(8)</code></font>, that there is some distinction between them.&nbsp; That they behave differently in some way.&nbsp; That there's some <i>reason</i>
 for making such a distinction.&nbsp; You would be cruelly mistaken, as I
 was.&nbsp; There is literally no difference between these 8 
datatypes.&nbsp; Nor is there any distinction between the 8 datatypes <font color="#663300"><code>BIT(9)</code></font> through <font color="#663300"><code>BIT(16)</code></font>.&nbsp; Nor is there any distinction between the 16 datatypes <font color="#663300"><code>BIT(17)</code></font> through <font color="#663300"><code>BIT(32)</code></font>.&nbsp; The distinctions between the <font color="#663300"><code>BIT(<i>n</i>) </code></font>datatypes for <font color="#663300"><code><i>n</i>&gt;32</code></font> are left as a thought experiment for the reader.&nbsp; Thus we're left with seemingly ridiculous code, like the following from <b>PASS1</b> of <b>HAL/S-FC</b>:<br>
</p>
<blockquote>
  <pre><font color="#663300">DECLARE COMPILING BIT(1);
...<br>IF (COMPILING&amp;"80")^=0 THEN<br>    ...</font><br></pre>
</blockquote>
<p>Or in other words, first you declare <font color="#663300"><code>COMPILING</code></font>
 to have a single bit, and then later you check it to see what the value
 of its 8th bit is!&nbsp; This particular bit of hilarity caused me 
months worth of trouble.<br>
</p>
<p>The storage formats in memory duplicate those that would have been 
expected on an IBM System/360 computer, within the limits of my ability 
to infer what those formats were.&nbsp; While the storage formats are 
not significant in abstract terms, they'll be seen to be <i>quite</i> significant in dealing with certain aspects of <b>HAL/S-FC</b>'s source code, such as its so-called "virtual memory" system, and indeed I think it would be impossible to run <b>HAL/S-FC</b> unless these underlying IBM 360 storage formats were used.<br></p>
You'll notice that there is no floating-point datatype, a fact which will be discussed in some detail later. <br>
<br>

The three basic datatypes can also be incorporated into single-dimension arrays. 
Multi-dimensional arrays are not allowed.&nbsp; There is no maximum 
array length beyond the available memory.&nbsp; Array indices start at 
0.&nbsp; Indices (or "subscripts") are enclosed in parentheses, as in <font color="#663300"><code>A(3)</code></font> or <font color="#663300"><code>B(N)</code></font>.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> It's easy to become confused and to imagine (incorrectly!) that you can treat a <font color="#663333"><code>CHARACTER</code></font> variable (as opposed to an array of <font color="#663333"><code>CHARACTER</code></font>
 variables) as an array itself, in order to access its individual 
characters.&nbsp; You cannot!&nbsp; In fact, the XPL language does not 
provide <i>any</i> syntactical means to access individual characters of a
 string.&nbsp; For that, you must rely on built-in functions provided by
 the runtime library.&nbsp; The most-direct method is to use the <font color="#663300"><code>BYTE</code></font> function, which can either retrieve the EBCDIC numerical encoding of an individual character in a <font color="#663333"><code>CHARACTER</code></font> variable, or else to store a new EBCDIC numerical value at a given position in a <font color="#663333"><code>CHARACTER</code></font> variable.&nbsp; Thus if we had a <font color="#663333"><code>CHARACTER</code></font> variable <font color="#663300"><code>C</code></font> which held the value 'HELLO!', then <font color="#663300"><code>BYTE(C, 3)</code></font> would return 211 (the EBCDIC encoding for the letter 'L'), while the assignment statement "<font color="#663300"><code>BYTE(C, 3) = 198;</code></font>" would change the contents of <font color="#663300"><code>C</code></font>
 to 'HELFO' since 198 is the EBCDIC code for the letter 'F'.&nbsp; That 
sounds cumbersome, since very few of us have memorized the EBCDIC table,
 but it's really not.&nbsp; You generally don't have to look up the 
EBCDIC encoding for anything, because you would actually have programmed
 operations such as this as "<font color="#663300"><code>BYTE(C, 3) = BYTE('F');</code></font>".&nbsp; Another, less-generally-useful method would be to use the built-in <font color="#663300"><code>SUBSTR</code></font> function to retrieve a specific character position as a new <font color="#663300"><code>CHARACTER</code></font> object of length 1.<br></font></blockquote><font size="-1">
    </font>The <font color="#663333"><code>BIT(N)</code></font> datatype is actually quite problematic.&nbsp; It would be reasonable to assume that since <font color="#663333"><code>BIT(N)</code></font>
 seems to represent support for collections of bits, then XPL should 
provide some syntactical sugar for reading the values of these bits or 
modifying them.&nbsp; For <font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>, you'd be somewhat correct, in that XPL largely treats these as being interchangeable with integers (i.e., <font color="#663333"><code>FIXED</code></font>), and automatically converts them back and forth between <font color="#663333"><code>FIXED</code></font>.&nbsp; The runtime library's built-in logical-shift-left and logical-shift-right functions (<font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font>) work just as easily with them as with the <font color="#663333"><code>FIXED</code></font>, as do the logical operators <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> (<font color="#663300"><code>~</code></font>), and the relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>=</code></font>, <font color="#663300"><code>!=</code></font>, <font color="#663300"><code>&gt;=</code></font>, and <font color="#663300"><code>&lt;=</code></font>.&nbsp; Swell!<br>
<br>
But once you advance to <font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>, you are cruelly disappointed. &nbsp; XPL provides <i>no</i> built-in methods of working with this data, beyond the ability to initialize <font color="#663333"><code>BIT(N)</code></font>
 variables with data when they're declared.&nbsp; (More on that 
later.)&nbsp; As far as actually using this data for anything, there are
 no built-in means to do anything at all with that data.&nbsp; While you
 <i>can</i> manipulate the data by cobbling together various 
runtime-library memory-access functions, McKeeman gives none of the 
technical information about the storage format that would allow you to 
do so, in so far as I was able to discover.<b>&nbsp; </b>What do I mean about cobbling together memory-access functions?&nbsp; Well, suppose that you want to access bit 43 of a <font color="#663300"><code>BIT(86)</code></font> variable called <font color="#663300"><code>B</code></font>.&nbsp; First, you must know where the data for <font color="#663300"><code>B</code></font>
 is located in memory.&nbsp; There's a function that can tell you 
that.&nbsp; Then you must know which byte in that block contains bit 
43.&nbsp; There's no function that tells you that, but if you <i>do</i> 
know it somehow then there's a function that gives you the value of a 
byte at that address.&nbsp; Then you must know which bit in the byte 
corresponds to bit 43.&nbsp; Again, there's no function for that, but if
 you know it, then you can use library functions like <font color="#663300"><code>SHL</code></font> or <font color="#663300"><code>SHR</code></font>, probably in conjunction with a logical operator like <font color="#663300"><code>&amp;</code></font>,
 to isolate the value of that bit.&nbsp; If you wanted to change the 
value of that bit, different but similar awfulness is involved.<br>
<br>
But doing any of that requires that you have intimate knowledge of how such <font color="#663333"><code>BIT</code></font>
 data is packed into memory.&nbsp; It's hard to write unambiguously 
about these matters, but I'll try to do so using the following 
concepts:&nbsp; An <i>n</i>-bit value, when written out in human-readable form has a <i>leftmost</i> bit and a <i>rightmost</i> bit; meanwhile, a block of <i>m</i> bytes in memory has a byte that's at the <i>lowest</i> address, a byte at the <i>highest</i> address, and within each byte has a <i>most-significant</i> bit and a <i>least-significant</i> bit.&nbsp; With those ideas in mind, here's how XPL packs <font color="#663333"><code>BIT</code></font> data into memory:<br>
<ul>
  <li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>:  The rightmost bit corresponds to the least-significant bit in the byte at the highest address.</li>
  <li><font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>:  The leftmost bit corresponds to the most-significant bit in the byte at the lowest address.</li>
</ul>
Or to put it concisely if ambiguously, short bit strings are right justified, while long bit strings are left justified.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Since I say that the 
bit-packing is undocumented, what's my justification for claiming that 
what I said just above is true?&nbsp; The short answer is 
trial-and-error!&nbsp; The longer answer is that one of the intermediate
 milestones in trying to get <b>XCOM-I</b> to the point of being able to compile the original source code for <b>HAL/S-FC</b> was first to be able to compile McKeeman's original <b>XCOM</b>
 and run it with a verifiably correct result.&nbsp; But I couldn't get 
it to work!&nbsp; After messing with it for days on end, I eventually 
got the answer in a dream, and then experimented with a couple of 
different bit-packing schemes before finally getting <b>XCOM</b> to run properly.&nbsp; The packing scheme I describe above is the one that worked.</font><br>
</blockquote>
<font size="-1"></font>
<blockquote><font size="-1">
    <b>Aside:</b> If all that wasn't bad enough, there's also a trap waiting for you if you're already used to doing bit manipulations 
with logical operators and shifts in other computer languages.&nbsp; This trap is in the behavior of 
conditional tests in XPL's <font color="#663300"><code>IF</code></font> and <font color="#663300"><code>DO WHILE</code></font> statements.&nbsp; Conditional tests in these statements depend only on the <i>least significant</i> bit; i.e., it as if any conditional test involves an extra "<font color="#663300"><code>&amp; 1</code></font>" operation that you can't see.&nbsp; Thus if you wanted to detect (say) that bit 3 of the <font color="#663300"><code>BIT(5)</code></font> variable <font color="#663300"><code>A</code></font> was set, a statement like "<code><font color="#663300">IF A &amp; 8 THEN ...;</font></code>" wouldn't help you at all, since the implicit </font><font size="-1"> "<font color="#663300"><code>&amp; 1</code></font>" in the conditional would cause the test always to fail!&nbsp; You would instead need to use a shift-right operation, such as </font><font size="-1"><font size="-1">"<code><font color="#663300">IF SHR(A, 3) THEN ...;</font></code>". </font></font><font size="-1"><font size="-1"><br>
    </font></font></blockquote>


But enough of these measly <font color="#663333"><code>BIT</code></font>-based frustrations!<br>
<br>
Variables in general are <i>supposedly</i> strictly typed, and every variable used 
must have an associated declaration statement, though we've already seen
 examples of the casual way XPL/I treats XPL's strict typing with subscripting sloppiness.<br>
<br>
Here are a few examples of declarations of variables, both scalar and array:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED, C CHARACTER, B BIT(5);<br>DECLARE FS(10) FIXED, CS(10) CHARACTER, BS(10) BIT(5);</font><br></pre>
</blockquote>

These are pretty self-explanatory in most ways, so I won't dissect them 
for you in detail.&nbsp; What's perhaps most confusing is that the three
 arrays declared here (<font color="#663300"><code>FS</code></font>, <font color="#663300"><code>CS</code></font>, and <font color="#663300"><code>BS</code></font>) each have <i>eleven</i>
 elements in them, because the number 10 in their declarations is not 
the number of elements, but rather the highest legal index.&nbsp; As 
mentioned above, indices start at 0, so the total number of elements in 
each is 11. <br>
<blockquote><font size="-1"><b>Aside:</b> Standard XPL, <i>à la</i> 
McKeenan, doesn't allow expressions when expressing array sizes, whereas
 XPL/I does allow them.&nbsp; For example, the following is fine in 
XPL/I but is a no-no in XPL:<br>
  </font>
  <blockquote>
    <pre><font size="-1">DECLARE BUFFER(3600-1) BIT(8);<br></font></pre>
  </blockquote>
  <font size="-1">This example will be continued in the next section, 
where it will make a little more sense, but this is actually the kind of
 thing you might want to do.</font><br>
</blockquote>

<br>
There are additional attributes which can be applied to such declarations, of which the most important is probably <code><font color="#663300">INITIAL</font></code>.&nbsp; This attribute allows you to supply an initial value for the variable, such as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED INITIAL(22), F2 FIXED INITIAL("22"), F3 FIXED INITIAL("(8) 22");<br>DECLARE C CHARACTER INITIAL('Hello!');<br>DECLARE B BIT(5) INITIAL("(1) 10100");<br>DECLARE FS(10) FIXED INITIAL(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);</font><br></pre>
</blockquote>
It's important to understand that the initializer has its affect only at
 compile-time, and is not applied at run-time.&nbsp; That means that if 
you declare variables within <font color="#663300"><code>PROCEDURE</code></font>s, they're <i>not reinitialized</i> each time the <font color="#663300"><code>PROCEDURE</code></font> is executed.<br>
<br>
You may have been confused by the initializers shown above for the variables <font color="#663300"><code>F2</code></font>, <font color="#663300"><code>F3</code></font>, and <font color="#663300"><code>B</code></font>,
 since they naively appear to be strings instead of numbers; but the 
naive interpretation is wrong.&nbsp; Which brings up the nature of <i>literals</i> in XPL:<br>
<ul>
  <li><code><font color="#663300">CHARACTER</font></code> literals — 
i.e., text strings — are enclosed in single-quote (') characters.  If a 
single-quote itself must appear within the string, you use two 
single-quotes in succession.  For example: <font color="#663300"><code>'I am the ''king'' of the world!'</code></font>.</li>
  <li>Integer literals for <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(N)</code></font> have one of several forms:</li>
  <ul>
    <li>A sequence of decimal digits is interpreted as a non-negative 
number in base-10 in the usual way.  Note that a leading minus sign (-) 
or plus sign (+) is <i>not</i> part of a numeric literal!  In XPL, minus signs are only <i>operators</i>, and thus something like <font color="#663300"><code>-10</code></font>
 is not a literal for the number -10, but is instead the minus operator 
followed by the literal for the number 10.  In most cases this is a 
distinction without significance, because <b>XCOM-I</b> (or the original <b>XCOM</b>)
 automatically tries to perform all computations that are possible at 
compile time.  Nevertheless, this distinction does cause some 
arithmetically-satisfactory expressions to be syntactically illegal in 
XPL.  For example, the expression <font color="#663300"><code>5 + -5</code></font> isn't legal in XPL.</li>
    <li>A sequence of hexadecimal digits enclosed in double-quote (") 
characters represents a hexadecimal number.  Spaces are ignored within 
literals like this, and hence can be added at will for improved human 
readability.</li>
    <li>If a double-quoted string is preceded (within the quotes) by a 
parenthesized decimal number, then that number indicates the number of 
bits represented by each digit.  <b>XCOM-I</b> supports only the following cases:</li>
    <ul>
      <li>"(1) ..." (with digits 0-1 and spaces) is a binary number.</li>
      <li>"(2) ..." (with digits 0-3 and spaces) is a base-4 number.</li>
      <li>"(3) ..." (with digits 0-7 and spaces) is an octal number.</li>
    </ul>
  </ul>
</ul>

These numeric literals are the only syntactical reason that the double-quote character (") appears in XPL source code.<br>
<br>
Another important attribute is <font color="#663300"><code>LITERALLY</code></font>. It's not strictly related to declaration of variables, even though appearing in <font color="#663300"><code>DECLARE</code></font> statements and so it's discussed in the next section instead.<br>
<h4>
<a name="basedManagement"></a>XPL/I ARRAY and BASED Data ... and an Exception<br>
</h4>

XPL/I provides a separate kind of statement which can declare arrays, which syntactically differs only in that the keyword <font color="#663300"><code>ARRAY</code></font> is used in place of the keyword <font color="#663300"><code>DECLARE</code></font>, and in that it can only be used for arrays of <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT</code></font>, and not for <font color="#663300"><code>CHARACTER</code></font>.<br>
<blockquote><font size="-1"><b>Aside:</b> For the original XPL/I compiler, I believe there was a distinction in the way <font color="#663300"><code>ARRAY</code></font> variables were stored in memory vs <font color="#663300"><code>DECLARE</code></font> variables.&nbsp; At the present time, I don't see this distinction as being operationally significant, so <b>XCOM-I</b>
 treats the two keywords identically.&nbsp; This is subject to change, 
if I discover my thinking was in error.&nbsp; As, unfortunately, I often
 do. </font><br>
</blockquote>

More significantly, XPL/I adds an additional kind of datatype that it calls a <font color="#663300"><code>BASED</code></font> variable.&nbsp; These are basically <i>pointers</i> to arrays of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.&nbsp; Note that I said "pointers to arrays" rather than "arrays of pointers".&nbsp; By changing the address stored in the <font color="#663300"><code>BASED</code></font>
 variable's pointer, you can instantly interpret an entirely different 
chunk of memory as the array.&nbsp; Moreover, besides the basic types 
just mentioned, the <font color="#663300"><code>BASED</code></font> variable can point to an array of "records", where each "record" is a collection of the basic 
datatypes.&nbsp; I.e., a record can hold any combination of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font> fields, or arrays thereof.&nbsp; Using the <font color="#663300"><code>BASED</code></font>
 mechanism, XPL/I can thus mimic both pointers and primitive types of 
structures, neither of which is available in XPL proper.&nbsp; I say 
that the structures are "primitive", because <font color="#663300"><code>BASED</code></font> variables cannot themselves be fields of <font color="#663300"><code>BASED</code></font> variables, hence only structures that are a single-level deep are available.&nbsp; <br>
<br>
Here are a couple of examples of declarations of <font color="#663300"><code>BASED</code></font> variables:<br>
<blockquote>
  <pre><font color="#663300">BASED FB FIXED;<br>BASED RB RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(10) BIT(5),<br>END;</font><br></pre>
</blockquote>

Although <font color="#663300"><code>BASED</code></font> variables are always (or almost always) arrays, you'll note that the declarations of <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font>
 don't indicate any dimensional information.&nbsp; That's because no 
memory for them, other than for the pointer, is allocated at 
compile-time.&nbsp; Space is instead explicitly allocated at runtime by 
user code.&nbsp; Thus <b>XCOM-I</b> has knowledge of the <i>size</i> of each array entry, but not of the <i>number of elements</i> in the array.&nbsp; <br>
<blockquote>
<div align="center"><b>
    <font size="-1"><a name="DopeVectors"></a>"Dope Vectors"<br>
      <br>
    </font></b></div>
<font size="-1">When I said that a <font color="#663300"><code>BASED</code></font> is a "pointer to an array", I was glossing over the fact that to be useful a <font color="#663300"><code>BASED</code></font> must track a lot more information about the <font color="#663300"><code>BASED</code></font> than just its data's location in memory.&nbsp; In fact, a <font color="#663300"><code>BASED</code></font> is stored as a 28-byte structure <i>plus</i>
 the separately-positioned data for the array.&nbsp; The 28-byte 
structure is referred to as a "dope vector". &nbsp; In other words, if 
you had a <font color="#663300"><code>BASED</code></font> called (say) <font color="#663300"><code>MYBASED</code></font> and you executed the built-in function <font color="#663300"><code>ADDR(MYBASED)</code></font>, it would return the address of the dope vector for <font color="#663300"><code>MYBASED</code></font>.&nbsp; As usual, the <b>HAL/S-FC</b>
 documentation and source code do not actually provide any useful facts 
about this setup, but various factoids can be inferred from <b>HAL/S-FC</b>
 source code, to a greater or lesser degree of confidence, and here are 
my feeble inferences about the fields of dope vectors.&nbsp; The fields 
with <font color="#009900">green</font> highlighting are those of 
conceivable interest to an application programmer, though all of them 
are managed entirely transparently in most cases.<br>

  </font><ol>
    </ol>
<ul>

  <li><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 0:&nbsp; </font><code>FIXED</code></font> pointer giving the address of the actual data.</font></li>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 4:&nbsp; </font></font></font><code>BIT(16)</code></font> giving the size in bytes of each record.</font></li>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 6:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font size="-1"> <font color="#009900">gives the number of <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT(≥32)</code></font> fields in each <font color="#663300"><code>BASED RECORD</code></font>, or 1 if it's a <font color="#663300"><code>BASED CHARACTER</code></font> or <font color="#663300"><code>BASED </code><code>BIT(≥32)</code></font>, or 0 otherwise.  The point is that it's the number of "string descriptors" associated with each element of the <font color="#663300"><code>BASED</code></font> array.  This information is used by </font><font color="#663300"><code>COMPACTIFY</code></font>.  (<a moz-do-not-send="true" href="#compactify">See below</a>.)  While I don't fully understand the calculations being performed, I'd venture the opinion that for <font color="#663300"><code>COMPACTIFY</code></font> to use this information efficiently, it's necessary for the XPL/I compiler to rearrange the fields of <font color="#009900"><font color="#663300"><code>BASED RECORD</code></font></font> from their declared order in such a way that all of string-descriptor fields come first in the record. </font></li>
  <li><font size="-1" color="#009900"><font color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 8:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font> giving the total number of array entries for which space has been <i>allocated</i>.</font></li>
  <li><font size="-1" color="#009900"><font color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 12:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font> giving the total number of array entries actually <i>used</i> so far.</font></li>
  
  <li><font size="-1" color="#009900"><font color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 16:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font></font><font size="-1">.&nbsp; The dope vectors for all <font color="#663300"><code>BASED</code></font> variables for which memory has been allocated form a linked list.&nbsp; The global variable <font color="#663300"><code>FIRSTRECORD</code></font>
 gives the address of the first dope vector on the list, and this field 
at offset 16 in the dope vector points to the next dope vector, or 0 if 
there is no next one (or if space hasn't been allocated).&nbsp; The 
ordering is TBD, since I haven't traced through the code in all of its 
gory detail, but I believe they are ordered according to <i>decreasing</i> address fields (i.e., the field at offset 0), which at least initially is also the order in which the <font color="#663300"><code>RECORD_CONST</code></font> or <font color="#663300"><code>ALLOCATE_SPACE</code></font> macros (see below) were executed to allocate memory for them.<br>
    </font></li>

  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 20:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font><font size="-1">.  It appears to me that this field supplies some properties of the <font color="#663300"><code>BASED</code></font> in the form of bit fields. It is laid out as follows:</font></li>
  <ul>
    <li><font size="-1">Bit 24 indicates the <font color="#663300"><code>BASED</code></font> is "constant", which appears to mean that you cannot incrementally grow it.  (The macro <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font> is used to increase the size of the specified <font color="#663300"><code><i>based</i></code></font> by 1 record, an operation which fails if the <font color="#663300"><code><i>based</i></code></font> is "constant".)</font></li>

      
    <li><font size="-1">Bit 25 indicates the <font color="#663300"><code>BASED</code></font> is "unmoveable".  If a <font color="#663300"><code><i>based</i></code></font> is "unmovable", it means that an operation like <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font>
 (see above) will succeed only if there is enough free space immediately
 following the allocated memory that can be "stolen".  Whereas if it's 
not unmovable, then the <font color="#663300"><code><i>based</i></code></font> may migrate in its entirety to a newly-allocated block elsewhere and the space it originally occupied may thus be freed.</font></li>
  </ul>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 24:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font size="-1"> of purpose TBD.  It is referred to as "global factor".</font></li>
  <li><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font size="-1" color="#009900"><font color="#663300"><font color="#000000">Offset 26:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font size="-1"> is referred to as "group factor".  As far as I can see, all uses of this are commented out in <b>HAL/S-FC</b>, so perhaps it ended up being unused.<br>
</font></li>
</ul>

<ol>

  
</ol>
<font size="-1">

The <b>XCOM-I</b> implementation mimics this dope-vector structure, though only the fields I've highlighted in <font color="#009900">green</font> are significant in <b>XCOM-I</b> ... which is fortunate, since they're the only ones I imagine I understand somewhat.<br>

  <br>

With that discussion in mind, in understanding some of the things that need to happen with <font color="#663300"><code>BASED</code></font> variables in actual XPL/I source code (and in particular, in <b>HAL/S-FC</b>), let's consider various space-management macros and/or procedures used:<br>

  </font><ul>
    <li><font size="-1" color="#663300"><code>RECORD_ALLOC(<i>based</i>)</code></font><font size="-1">, used in expressions, returns the number of records allocated in <font color="#663300"><code>BASED</code></font> variable <font color="#663300"><code><i>based</i></code></font>.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_USED(<i>based</i>)</code></font><font size="-1">,
 normally used on the left-hand-side in assignments, sets the number of 
records used so far in based.  Its most-common usage is <font color="#663300"><code>RECORD_USED(<i>based</i>)=RECORD_ALLOC(<i>based</i>)</code></font>,
 but it can also be used with something other than that on the 
right-hand side to truncate the array or to skip past the lowest 
indexes.  And it can be used in expressions or conditionals, though that
 happens relatively seldom.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_TOP(<i>based</i>)</code></font><font size="-1">, as you might expect, simply returns <font color="#663300"><code>RECORD_USED(<i>based</i>)-1</code></font>.</font></li>
    <li><font size="-1" color="#663300"><code>ALLOCATE_SPACE(<i>based</i>, <i>top</i>)</code></font><font size="-1"> allocates enough space for <i><font color="#663300"><code>based</code></font></i> to insure that it contains at least <font color="#663300"><code><i>top</i>+1</code></font> records in total.  It will fail if we already have <font color="#663300"><code>RECORD_ALLOC(<i>based</i>)&gt;0</code></font>.</font></li>
    <li><font size="-1" color="#663300"><code>NEXT_ELEMENT(based)</code></font><font size="-1"> increments <font color="#663300"><code>RECORD_USED(<i>based</i>)</code></font>
 by 1, stealing the space from adjacent free memory or else reallocating
 and moving the entire array if necessary to do so.  This can only be 
used if space for <font color="#663300"><code><i>based</i></code></font> had been allocated by <font color="#663300"><code>ALLOCATE_SPACE</code></font>, and will instead cause an abend if <font color="#663300"><code><i>based</i></code></font> had been allocated by <font color="#663300"><code>RECORD_CONSTANT</code></font> (see below).</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_FREE(based)</code></font><font size="-1"> frees the data for <i><font color="#663300"><code>based</code></font></i>, returning the allocated space to the free pool.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_SEAL(<i>based</i>)</code>, <code>RECORD_UNSEAL(<i>based</i>)</code></font><font size="-1">:  Enables or disables the "constant" attribute of the <i><font color="#663300"><code>based</code></font></i>.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_CONSTANT(<i>based</i>, <i>top</i>, <i>moveable</i>)</code></font><font size="-1"> Like <font color="#663300"><code>ALLOCATE_SPACE(<i>based</i>, <i>top</i>)</code></font>, but additionally enables the "constant" property, and optionally enables the "unmovable" property.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_WIDTH(based)</code></font><font size="-1"> returns the record width of the <i><font color="#663300"><code>based</code></font></i>.</font></li>
    <li><font size="-1" color="#663300"><code>RECORD_LINK()</code></font><font size="-1"> prepares the data for transferring <font color="#663300"><code>COMMON</code></font> memory to the next program loaded.</font></li>
  </ul><font size="-1">
  </font>
</blockquote>

User code that initially allocates free memory — let's say 25 records to start with —  for a <font color="#663300"><code>BASED</code></font> variable is <i>typically</i> a two-step process that looks something like this:<br>
<blockquote>
  <pre><font color="#663300">BASED MYVARIABLE FIXED;<br>...<br>RECORD_CONSTANT(MYVARIABLE, 25, MOVEABLE); /* OR UNMOVEABLE */<br>RECORD_USED(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>) = RECORD_ALLOC(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>);</font><br></pre>
</blockquote>
Or, if you knew that you were going to need more elements later, you might allocate a bit extra, for example:<br>
<blockquote>
  <pre><font color="#663300">BASED MYBASED FIXED;<br>...<br>ALLOCATE_SPACE(</font><font color="#663300"><font color="#663300">MYBASED</font>, 30);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYBASED</font></font>) = 25;</font></pre>
</blockquote>

Having allocated the space for it, you can now use <font color="#663300"><code>MYBASED</code></font> just like any other array of <font color="#663300"><code>FIXED</code></font>, such as in assignments like "<font color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(27) = 6;</code></font>" or "<font color="#663300"><code>X = </code></font><font color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(N) + 12;</code></font>".&nbsp; <br>
<br>
To actually increase the number of elements later, you'd do something like this:<br>
<blockquote>
  <pre><font color="#663300">NEXT_RECORD(MYBASED);</font><br></pre>
</blockquote>
This will increment <font color="#663300"><code>RECORD_USED(MYBASED)</code></font> by 1 — if possible while still keeping it below <font color="#663300"><code>RECORD_ALLOC(MYBASED)</code></font> — or else will reallocate and possibly move <font color="#663300"><code>MYBASED</code></font> into a larger space, if possible.<br>
<br>
In a more-complex case, we might have a <font color="#663300"><code>BASED RECORD</code></font> variable:<br>
<blockquote>
  <pre><font color="#663300">BASED MYNEWBASED RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(9) FIXED,<br>END;<br>...<br>RECORD_CONSTANT(</font><font color="#663300"><font color="#663300">MYNEWBASED</font>, 30, MOVEABLE);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYNEWBASED</font></font>) = 25;</font></pre>
</blockquote>

Accessing <font color="#663300"><code>MYNEWBASE</code></font> requires the dotted style often used these days for 
accessing fields of structures or classes.&nbsp; Some examples include:<br>
<blockquote>
  <pre><font color="#663300">MYNEWBASED(6).F = 12;<br>MYNEWBASED(10).C = 'XPL is where it is at!';<br>MYNEWBASED(20).A(6) = 15;<br>X = MYNEWBASED(6).F;</font><br></pre>
</blockquote>
and so on.<br>
<div align="center"><b><font size="-1">The Exception<br>
    </font></b></div>
<blockquote><font size="-1">There is one — count 'em, <i>one</i>! — exception I've found to the <i>documented</i> behavior I've described above.&nbsp; This undocumented use is seen in the <font color="#663300"><code>IND_STACK</code></font> variable found in <b>PASS2</b> of <b>HAL/S-FC</b>.&nbsp; </font><font size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font> is declared using the following bastardized mash-up of a <font color="#663300"><code>DECLARE</code></font> statement and a <font color="#663300"><code>BASED</code></font> statement:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">   DECLARE IND_STACK(STACK_SIZE) RECORD:<br>         I_CONST        FIXED,<br>         I_INX_CON      FIXED, <br>         I_STRUCT_CON   FIXED,<br>         ...<br>         I_LIVREMT      BIT(8),<br>         I_NAMEVAR      BIT(8),<br>         I_STRUCT_WALK  BIT(8),<br>         I_AIADONE      BIT(8),<br>      END;</font><br></pre>
  </blockquote>
  <font size="-1">Unlike a </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font>
 declaration, in which specifying an array size at compile time is 
illegal, or as IR-182-1 states, "ignored if present", the array size is 
indeed found in this declaration.&nbsp; Nor is there any runtime 
adjustment to the size, as would be expected with a </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font></font>.&nbsp; Nonetheless, </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font></font> is subsequently accessed by the dotted, structure-type notation used only by </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables. <br>
    <br>
Rather than implement an entirely new but undocumented class of structure objects to handle this single instance, <b>XCOM-I</b> implements this case as if it were a </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> declaration followed by an appropriate <font color="#663300"><code>RECORD_CONSTANT</code></font> operation.&nbsp; </font><font size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font> is one of the very few objects stored in <a moz-do-not-send="true" href="#MemoryModel">region 7 of the XPL memory model</a>, and by far the largest of them.<br>
  </font></blockquote>

<h3>LITERALLY and Macros</h3>Another attribute that can appear in <font color="#663300"><code>DECLARE</code></font> statements is the <font color="#663300"><code>LITERALLY</code></font> attribute.&nbsp; Here's an example:<br>
<blockquote>
  <pre><font color="#663300">DECLARE ARRAYTOP LITERALLY '255';<br>DECLARE MYARRAY(ARRAYTOP) FIXED;</font><br></pre>
</blockquote>
Notice that <font color="#663300"><code>ARRAYTOP</code></font> has no 
datatype assigned to it.&nbsp; That's because its declaration is not 
actually the declaration of a variable called "ARRAYTOP", but rather of a
 macro of that name.&nbsp; Wherever the identifier <font color="#663300"><code>ARRAYTOP</code></font> is encountered subsequently, it's simply replaced literally by the string <font color="#663300"><code>255</code></font>, now unquoted:<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYARRAY(255) FIXED;</font><br></pre>
</blockquote>
This clarifies an example of a commonly-desirable declaration I gave in 
the preceding section, which in this section would be expressed as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE RECSIZE LITERALLY '3600';<br>DECLARE BUFFER(RECSIZE-1) BIT(8);</font><br></pre>
</blockquote>

As noted in the preceding section, standard XPL's grammar wouldn't allow an expression (like <font color="#663300"><code>RECSIZE-1</code></font>) in that context, so this particular convenience in making declarations is only available in XPL/I.<br>
<br>
Macro expansions — not macro <i>declarations</i> (I hope!) — can be nested, so you can do things like this if you want:<br>
<blockquote>
  <pre><font color="#663300">DECLARE DEVICE LITERALLY '6', DECLARE OUT LITERALLY 'OUTPUT(DEVICE)';<br>OUT = 'My message';</font><br></pre>
</blockquote>
This expands to<br>
<blockquote>
  <pre><font color="#663300">OUTPUT(6) = 'My message';</font><br></pre>
</blockquote>
Macros can expand to portions of statements, as the ones above have, or to multiple statements, such as<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYBLOCK LITERALLY 'DO; X=1; Y=X+3; END';<br>...<br>IF X=7 THEN;<br>    MYBLOCK;</font><br></pre>
</blockquote>
which expands to:<br>
<blockquote>
  <pre><font color="#663300">IF X=7 THEN;<br>    DO; X=1; Y=X+3; END;</font><br></pre>
</blockquote>
Macros can also have arguments.&nbsp; Consider the following:<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYMAC(2) LITERALLY '%1% = %2%';</font><br></pre>
</blockquote>
This declaration means that <font color="#663300"><code>MYMAC</code></font> has 2 arguments, and that when the macro is expanded, the first argument will replace <font color="#663300"><code>%1%</code></font> and the second argument will replace <font color="#663300"><code>%2%</code></font>.&nbsp; Thus "<font color="#663300"><code>MYMAC(X, 3 * Y)</code></font>" expands to "<font color="#663300"><code>X = 3 * Y</code></font>".<br>
<blockquote><font size="-1"><b>Warning:</b>&nbsp; As with macros in any other computer language, this can quickly get out of hand.&nbsp; <b>XCOM-I</b>,
 for example, won't detect recursive, endlessly-expanding macros.&nbsp; 
There's also no guarantee when multiple macros are in play that <b>XCOM-I</b> will necessarily expand macros in the same order that <b>XCOM</b> would have.&nbsp; Neither McKeeman nor Intermetrics documentation makes any mention of what that ordering should be.<br>
    <br>
    <b>Warning:</b>&nbsp; The scope of macro definitions is also 
different in XPL vs XPL/I.&nbsp; In XPL, macro definitions don't respect
 any nested scopes they appear in; i.e., any macro definition will 
simply remain in effect until the end of the source code.&nbsp; In 
XPL/I, macro definitions remain in effect only until the end of the 
procedure in which they're defined, including embedded procedures.&nbsp;
 In neither case does a macro definition have any effect on source code 
prior to it.<br>
  </font></blockquote>
<h3>Perplexing Multiple Assignments</h3>
<p>XPL allows multiple variables to be assigned the same value in a single assignment statement, with a syntax like:<br>
</p>
<blockquote>
  <pre><font color="#663300">X1, X2, ..., XN = Y;</font><br></pre>
</blockquote>
<p>According to McKeeman (p. 137), these assignments are performed in right-to-left order.&nbsp; In other words, it <i>should</i> be equivalent to:<br>
</p>
<blockquote>
  <pre><font color="#663300">XN = Y;<br>.<br>.<br>.<br>X1 = Y;</font><br></pre>
</blockquote>
<p>In most cases, the ordering of these assignments is of no significance, and in fact I've found no legacy <i>standard</i> XPL programs in which the ordering matters.&nbsp; However, there are instances in XPL/I code, specifically in <b>PASS1</b> of <b>HAL/S-FC</b> in which the order matters a lot.&nbsp; That's when you have assignments of the form:<br>
</p>
<blockquote>
  <pre><font color="#663300">Y(I), I = J;</font><br></pre>
</blockquote>
<p>because obviously<br>
</p>
<blockquote>
  <pre><font color="#663300">I = J;<br>Y(I) = J;</font><br></pre>
</blockquote>
<p>is a lot different than<br>
</p>
<blockquote>
  <pre><font color="#663300">Y(I) = J;<br>I = J;</font><br></pre>
</blockquote>
<p><i>Unfortunately</i>, in the cases I've encountered, the XPL/I code 
seems to rely on the latter interpretation.&nbsp; I.e., it seems to 
believe that the assignments are performed in left-to-right order, in 
direct contradiction to McKeeman.&nbsp; What's going on here?<br>
</p>
<p>Of course, we have no way of knowing what Intermetrics XCOM did with this, but as far as <i>A Compiler Generator</i>'s
 XCOM, it appears (thanks to Dan Weaver for this explanation) that while
 the assignments are indeed performed in a right-to-left manner as 
documented, the peculiarities of the IBM 360 object-code generation in 
McKeeman XCOM, shove the index <font color="#663300"><code>I</code></font> into a CPU register and reuse it without change throughout both assignments.&nbsp; So seemingly by accident, the net result is that the assignments <i>appear</i> to have been done in a left-to-right order.<br>
</p>
<p>I can only regard this a bug in McKeeman XCOM.&nbsp; Plus, it's not 
reliable:&nbsp; what if there are more than 2 assignments on the 
left-hand side, and if they don't all use the same index <font color="#663300"><code>I</code></font>?&nbsp; What would the order appear to be then?&nbsp; <br>
</p>
<p>As a result of all that:<br>
</p>
<blockquote><font size="-1"><b>Important Note</b>:&nbsp; <b>XCOM-I</b> <i>ignores</i> the statement in <i>A Compiler Generator</i>
 that assignments are performed in a right-to-left manner.&nbsp; Rather,
 they are performed in a left-to-right manner, and any indices of arrays
 are computed at the moment the assignment is performed.</font><br>
</blockquote>
<h3>Logical Expressions</h3>

<p>XPL's logical operators are <font color="#663300"><code>&amp;</code></font>, |, and <font color="#663300"><code>~</code></font> (<font color="#663300"><code>¬</code></font>, <font color="#663300"><code>^</code></font>), for "and", "or", and "not", respectively.  The documentation in <i>A Compiler Generator</i>
 is maddeningly unclear as to what these operators do.  True, table 
6.8.1 calls them "logical and", "logical or", and "logical complement", 
but the word "logical" isn't defined ... just as my sloppy usage of the 
word "logical" at the beginning of this paragraph makes no distinction. 
Which leaves open a few loopholes that have to be closed up. The issues 
which we must understand are:<br></p>
<ul>
  <li>Are these operations bitwise or narrowly "logical".  I.e., do they
 operate in parallel on each bit position in a numerical value, or do 
they simply produce bipolar results of 1 (true) or 0 (false)?</li>
  <li>Do these operations short circuit?  E.g., if we have an expression of the form (say) <font color="#663300"><code><i>expression1</i>&amp;<i>expression2</i></code></font>, and <i><font color="#663300"><code>expression1</code></font></i> evaluates to 0, is <i><font color="#663300"><code>expression2</code></font></i> even evaluated?</li>
</ul>
<p>In case you're not in the mood for a technical discussion of the 
matter, I'll give you the short answer up front, and having read that, 
you can proceed to the long discussion if you want:<br></p>
<ul>
  <li>The logical operations are indeed bitwise.</li>
  <li>Under some limited circumstances, the original <b>XCOM</b> may 
have short-circuited evaluation of logical operations, even though 
there's no short-circuiting observed in the examples I've constructed.  <b>XCOM-I</b> does not at present attempt any short-circuiting.<br></li>
</ul>
<p>As for how I came up with this "information", there are several 
places we can look for guidance in guessing the answers.  For one thing,
 according to McKeeman's account, the XPL language was derived from the 
PL/I language, so we can look at PL/I documentation and hope that it 
applies to XPL.  Of course, we can look at the source code for 
McKeeman's XPL compiler (<b>XCOM</b>) as listed in the book, and see if there are any hints there.  Or we can even examine the IBM 360 object code that <b>XCOM</b>
 generates for these operators.   (All the while wondering how things 
came to this, that we have to resort to lame measures like consulting 
object code to figure out the basic features of the language?)<br></p>
<p>As far as PL/I is concerned, <a moz-do-not-send="true" href="https://www.ibm.com/docs/en/SSY2V3_5.1.0/com.ibm.ent.pl1.zos.doc/lrm.pdf">IBM's PL/I Language Reference</a> (2017) tells us on p. 66 that for the <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> operators, "bit operations are performed on a bit-by-bit basis".  As far as object code produced by <b>XCOM</b> is concerned, McKeeman (p. 150) shows an example in which object code for the expression "<font color="#663300"><code>SHL(K,1) &amp; SHR(I,J)</code></font>" is produced, and we do find that it simply uses the IBM 360 <font color="#663300"><code>NR</code></font> ("And Logical") instruction:<br></p>
<blockquote>
  <p align="left"><img moz-do-not-send="true" src="shortCircuit.jpg" alt="" width="768" height="123"></p>
</blockquote>
<p>Although I had to consult more than one IBM assembly-language manual 
to find the answer to the seemingly-simple question of what <font color="#663300"><code>NR</code></font> does, <a moz-do-not-send="true" href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf">IBM's z/Architecture Principles of Operation</a> (p. A-8) does tell us that the <font color="#663300"><code>NR</code></font> (and its cousins <font color="#663300"><code>N</code></font>, <font color="#663300"><code>NC</code></font>, and <font color="#663300"><code>NI</code></font>) are indeed bitwise operations.<br></p>
<blockquote><font size="-1"><b>Aside:</b>  <a moz-do-not-send="true" href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf#page=940">Figure B-2, "Instructions Arranged by Mnemonic"</a> of the latter document is very helpful in trying to decipher such listings of IBM 360 object code.<br>
  </font></blockquote>
<p>Short-circuiting is a natural consideration for strictly bipolar 
operands and operators, but is a bit trickier to consider once we've 
concluded that the logical operators operate bitwise rather than in a 
bipolar fashion.  Certainly the object-code example from <i>A Compiler Generator</i> that was mentioned in the preceding paragraph shows no signs at all of short circuiting:  Both of the operands of the <font color="#663300"><code>&amp;</code></font>
 operator in that example are evaluated, with no attempt at checking the
 value of the first operation before proceeding to the second one.  On 
the other hand, that example of object-code generation by <b>XCOM</b> happens to be for an assignment statement rather than for the conditional expression of an <font color="#663300"><code>IF</code></font>, <font color="#663300"><code>DO WHILE</code></font>, or <font color="#663300"><code>DO UNTIL</code></font>.
   Perhaps the evaluation of a conditional expression might be very 
different in those contexts.  One reason to believe that it might be 
different is that the final result of a conditional expression is masked
 to just the least-significant bit, and thus (eventually) is indeed a 
bipolar value; i.e., even if all of the bits were involved in the 
computation, all but one of them is discarded in the end, so perhaps the
 extra bits are discarded at the beginning rather than at the end of the
 computation, even though it's more work to do so.  Moreover, the PL/I 
Language Reference document mentioned earlier does cover short-circuit 
evaluation (see p. 245), and it says that short-circuiting is <i>only</i> in the context of the conditional of an <font color="#663300"><code>IF</code></font>
 statement (versus assignment statements).  Plus, even then the 
short-circuiting occurs only in certain special circumstances, such as 
the leading operand being a <font color="#663300"><code>BIT(1)</code></font>
 literal or constant variable, which leads one to believe that the value
 of the leading operand has to be determined to be 0 or 1 at 
compile-time rather than at run-time for the short-circuiting to occur.<br></p>
<p>Unfortunately, the example of object-code generation in McKeeman doesn't show us how an <font color="#663300"><code>IF</code></font> statement would compile.  But <a moz-do-not-send="true" href="#compilingXCOM">as we saw earlier</a>, we have been able to use <b>XCOM-I</b> to create a working copy of McKeeman's <b>XCOM</b>, so we can make our own example of <font color="#663300"><code>IF</code></font>, compile it with <b>XCOM</b> and see!  Imagine we have the following ridiculous little XPL program:<br></p>
<blockquote>
  <pre><font color="#663300"> DECLARE I FIXED;<br> DO I = 1 TO 10;<br>     IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br> DO I = 1 TO 10;<br>     IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br>EOF<br></font></pre>
</blockquote>
<blockquote>
  <p><font size="-1"><b>Aside:</b> By the way, compiling an XPL program with McKeeman's <b>XCOM</b> is a bit more constrained than compiling a similar program with <b>XCOM-I</b>.  For one thing, to avoid an irritating if harmless warning message, the <font color="#663300"><code>EOF</code></font> token must be present at the end of the source code, whereas <b>XCOM-I</b>
 doesn't care.  For another, even though XPL is case-insensitive other 
than inside of quoted strings, and even though all of the XPL source 
code in <i>A Compiler Generator</i> is printed in lower case, <b>XCOM</b> will in fact choke on any XPL source code that isn't fully upper case.  Go figure!</font><br></p>
</blockquote>
Compiling this silly program with <b>XCOM</b>, and pulling just the relevant portion of the <b>XCOM</b>'s report gives us the following IBM 360 object code for the conditional expressions of the <font color="#663300"><code>IF</code></font> statements:<br>
<pre><font color="#663300">  20 |    IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';                           |  1314 C7 = 10.<br>                                                                      1314: CODE = L    1,1340(0,11)<br>                                                                      1318: CODE = M    0,1340(0,11)<br>                                                                      1322: CODE = L    2,1340(0,11)<br>                                                                      1326: CODE = L    3,1340(0,11)<br>                                                                      1330: CODE = MR   2,2<br>                                                                      1332: CODE = LA   2,100(0,0)<br>                                                                      1336: CODE = SR   2,3<br>                                                                      1338: CODE = NR   1,2<br>                                                                      1340: CODE = N    1,164(0,11)<br>                                                                      ...<br> 24 |    IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';                                 |  1400<br>                                                                      1400: CODE = L    1,1340(0,11)<br>                                                                      1404: CODE = M    0,1340(0,11)<br>                                                                      1408: CODE = LA   2,100(0,0)<br>                                                                      1412: CODE = SR   2,1<br>                                                                      1414: CODE = N    2,1300(0,1048571)<br>                                                                      1418: CODE = N    2,164(0,11)<br>                                                                      ...<br><br></font></pre>
<p>Not shown above is that the symbol table tells us variable <font color="#663300"><code>I</code></font>
 is stored at address 1340(11), which is why all of the 1340(0,11)'s 
appear above.  I don't understand IBM 360 assembly language, but what I <i>think</i> the code probably does is:<br></p>
<ul>
  <li>The first <font color="#663300"><code>IF</code></font>:</li>
  <ul>
    <li>1314 through 1318:  Compute the left-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>I*I</code></font>.</li>
    <li>1322 through 1336:  Compute the right-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>100-I**</code></font>. </li>
    <li>1338: Perform a bitwise-AND of the two operands.</li>
    <li>1340: Mask off all but the least-significant bit.<br></li>
  </ul>
  <li>The second <font color="#663300"><code>IF</code></font>:</li>
  <ul>
<li>1400-1412:  Compute the <i>right</i>-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>I*I</code></font>.</li><li>1414: Perform a bitwise-AND with 0.  Admittedly, I'm not quite sure <i>why</i> it would be 0 it's AND'ing with, but it's certainly AND'ing with something.</li><li>1418: Mask off all but the least-significant bit.</li>
  </ul>
</ul>
<p>But whether or not my interpretation is 100% correct, at least in 
this example there's no evidence of short-circuiting.  The 2nd <font color="#663300"><code>IF</code></font>
 in particular is pretty shocking.  Perhaps there's supposed to be some 
subsequent optimization I'm not aware of that would have cleaned it up.<br></p>

<h3><a name="common"></a>COMMON Memory</h3>
XPL/I also introduces the notion of <font color="#663300"><code>COMMON</code></font> memory, not present in XPL.&nbsp; The notion behind <font color="#663300"><code>COMMON</code></font>
 memory is that a very large application program like <b>HAL/S-FC</b> won't be 
loaded entirely in memory at once, but will instead be run as a sequence
 of "passes".&nbsp; <font color="#663300"><code>COMMON</code></font> memory is not supported in standard XPL, and compiling a program with <b>XCOM-I</b>'s <font color="#663300"><code>--xpl</code></font> switch will disable the <font color="#663300"><code>COMMON</code></font> memory features described in this sections.<br>
<br>
Thus, <b>HAL/S-FC</b> isn't a single application program, but rather a set of 
them:&nbsp; <b>PASS1</b>, <b>FLO</b>, <b>OPT</b>, <b>AUX</b>, <b>PASS2</b>, <b>PASS3</b>, and <b>PASS4</b>.&nbsp; Each of
 these applications is loaded, run, and unloaded from memory, in succession.<br>
<br>
But!&nbsp; Each of these application programs may receive some kind of 
input data or state data from the preceding application program, and 
transmit output data or state data to the next application program in 
succession.&nbsp; In XPL/I's visualization, <i>some</i> of that data is 
passed in files.&nbsp; But other data is instead just assumed to
 remain in computer memory, unchanged from whatever the preceding 
application has left behind.&nbsp; The term XPL/I applies to this 
leftover memory is <font color="#663300"><code>COMMON</code></font> memory.&nbsp; It's formalized when you explicitly declare variables as being in <font color="#663300"><code>COMMON</code></font>.&nbsp; Variables declared to be in <font color="#663300"><code>COMMON</code></font>
 are not initialized by an XPL/I program, except for the very first program in a chain of programs, but are simply assumed to 
already contain the data needed.&nbsp; On the other hand, variables <i>not</i> declared <font color="#663300"><code>COMMON</code></font>
 are up for grabs, and no assumption can be made about their initial 
contents other than whatever initialization their declarations 
explicitly provide.<br>
<br>
Syntactically, <font color="#663300"><code>COMMON</code></font> data is declared in XPL/I by three methods:<br>
<ul>
  <li>Using the keyword <font color="#663300"><code>COMMON</code></font> in place of the keyword <font color="#663300"><code>DECLARE</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON ARRAY</code></font> in place of the keyword <font color="#663300"><code>ARRAY</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON BASED</code></font> in place of the keyword <font color="#663300"><code>BASED</code></font>.</li>
</ul>
<p>Another distinction is that <font color="#663300"><code>CHARACTER</code></font> variables cannot declared in <font color="#663300"><code>COMMON</code></font>, though <font color="#663300"><code>CHARACTER</code></font> variables can appear as fields in <font color="#663300"><code>COMMON BASED RECORD</code></font> variables.  <b>XCOM-I</b> actually relaxes this restriction.<br></p>
<p>It's not documented anywhere, as far as I know, but I would <i>assume</i> that there was originally an expectation that each cooperating application running in succession needed to declare <font color="#663300"><code>COMMON</code></font> in exactly the same way, using exactly the same ordering of variables and the same datatypes.  <b>XCOM-I</b> relaxes this restriction to a certain extent, but the data of <b>BASED</b> variables always resides at the same memory addresses in adjacent programs of a chain.&nbsp; When <a moz-do-not-send="true" href="#basedManagement">"dope vectors" of <b>BASED</b> variables</a> were discussed earlier, it was mentioned that <b>BASED</b>
 variables could be set as "constant" or "unmoveable", and this 
necessity for remaining at the same location when successor programs are
 executed is part of the reason for this feature.<br>
</p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; If <b>BASED</b>
 variables were always manipulated by XPL/I program as intended by the original compiler design — 
i.e., allowing SPACELIB to manipulate them via their dope vectors — 
there would be no reason for these restrictions on moveability.&nbsp; 
However, the "virtual memory" system employed by <b>HAL/S-FC</b>, as implemented by the files HALINCL/VMEM<i>x</i>.xpl,
 bypasses the dope-vector system.&nbsp; Specifically, "pages" of memory 
managed by the virtual-memory system are tracked only by an array of 
addresses (rather than dope vectors).&nbsp; But SPACELIB manages dope 
vectors, and has no cognizance of arrays of addresses whose 
interpretation exists only in the mind of a programmer.&nbsp; It is 
therefore necessary to make sure that the virtual-memory system's pages 
of memory never move.&nbsp; One might ask the programmer why they didn't
 use arrays of dope vectors rather than arrays of addresses?&nbsp; But 
that might be interpreted as being rude.&nbsp; On the other hand, I've 
known enough engineers to be pretty sure they'd think that since it 
worked for them, that was good enough.</font><br>
</blockquote>

<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; Speaking of the relationship between <font color="#663300"><code>BASED</code></font> variables and <font color="#663300"><code>COMMON</code></font> memory, it's important to note the following points:<br>
    </font></p>
  <ul>
    <li><font size="-1">For </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables appearing in </font><font size="-1"><font size="-1"><font color="#663300"><code>COMMON</code></font></font>, space is allocated for them via <font color="#663300"><code>RECORD_CONSTANT</code></font> or <font color="#663300"><code>ALLOCATE_SPACE</code></font> <i>only</i>
 in the first of the chained programs that needs to use them.&nbsp; 
Subsequent programs in the chain use them as-is, without allocation.</font></li>
    <li><font size="-1">Memory for </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables <i>not</i> appearing in </font><font size="-1"><font size="-1"><font color="#663300"><code>COMMON</code></font></font> must be explicitly freed via <font color="#663300"><code>RECORD_FREE</code></font>
 prior to exiting whatever program of the chain allocated their 
memory.&nbsp; If this is not done, then the memory-management system 
(Intermetrics SPACELIB) will abort the program with an error and fail to
 prepare the <font color="#663300"><code>COMMON</code></font> data for use by the next program in the chain.<br>
      </font></li>
  </ul>
</blockquote>
<p>Of course, <b>XCOM-I</b> makes no effort at all to pass <font color="#663300"><code>COMMON</code></font>
 data from one application to another using actual memory.  Rather, each XPL/I application program compiled by <b>XCOM-I</b> can optionally (depending on its command-line options) load a <i>file</i> containing data into its <font color="#663300"><code>COMMON</code></font> areas of memory; and similarly, it automatically writes out its <font color="#663300"><code>COMMON</code></font> areas of memory into a file upon termination.  By using the <font color="#663300"><code>--commoni</code></font> and <font color="#663300"><code>--commono</code></font> command-line switches of the application, a close degree of control can be exercised over which previously-saved <font color="#663300"><code>COMMON</code></font> blocks, if any, are passed to which application programs.&nbsp; The command-line options are needed because by <i>default</i>, an executable produced by <b>XCOM-I</b> does not read in a <font color="#663300"><code>COMMON</code></font>
 file at startup, and outputs a file literally called "COMMON.out" upon 
termination.&nbsp; The command-line options override either or both of 
those defaults.<br>
</p>

<p><font color="#663300"><code>COMMON</code></font> files are in a human-readable format.&nbsp; See the comments for the <font color="#663300"><code>writeEntryCommon</code></font>
 function in the runtime-library file runtimeC.c if you have any 
interest in the file format.&nbsp; It's actually pretty useful for 
debugging certain kinds of problems.<br>
</p>

<blockquote>
</blockquote>
<h3><a name="MemoryModel"></a>Memory Model for a Compiled XPL Program<br>

</h3>
<table width="100%" cellspacing="10" cellpadding="0">
  <tbody>
    <tr>
      <td valign="top">
<p>The theoretical memory space available at runtime for a compiled XPL program is 2<sup>24</sup>=16,777,216
 bytes in size, although the Wikipedia article on IBM System/360 tells 
us that the actual physical maximum was only 8 MB.&nbsp; In the C object
 code generated by XCOM-I, this is represented by the byte array called <font color="#663300"><code>memory</code></font>.</p>
<p>
For the original XPL and XPL/I compilers, the lowest portion and highest
 portion of this (theoretical) 16 MB space was dedicated to the 
executable code for the program and the data used by it.&nbsp; The 
middle of the area was used for the program's data.&nbsp; But in the <b>XCOM-I</b>
 framework, all of the program code is stored elsewhere, thus the entire
 16MB space can be dedicated just for the variables actually <font color="#663300"><code>DECLARE</code></font>'d
 in the XPL source code ... plus those few elements of data which the 
operating system needs to communicate to the program, such as run-time 
program options, and a few other items I'll talk about in a moment.<br></p>

<p>The memory nevertheless still needs to be partitioned into blocks 
dedicated to specific types of data, in order to facilitate management 
of dynamic data like <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT</code></font><font color="#663300"><code>(n&gt;32)</code></font> strings and <font color="#663300"><code>BASED</code></font>
 variables.&nbsp; I try to follow the same partitioning scheme as used 
by the original compilers, at least roughly.&nbsp; The broad outline of 
this partitioning scheme is seen in the diagram to the right.<b>&nbsp; <br></b></p>
<p>Regions 4 and 6 naturally did not exist in XPL, since <font color="#663300"><code>BASED</code></font> variables are an XPL/I extension to standard XPL.&nbsp; So when <b>XCOM-I</b> is run with the <font color="#663300"><code>--xpl</code></font> command-line switch, those regions both have fixed sizes of 0.<br></p>
<p>Mostly, the boundaries of these memory regions are established at compile-time, by which I mean they're established by <b>XCOM-I</b>
 and don't change thereafter.  The exceptions are the boundaries between
 regions 5, 6, and 7.  As you may recall, at program startup, <font color="#663300"><code>BASED</code></font> variables have already been <font color="#663300"><code>DECLARE</code></font>'d and <b>XCOM-I</b>
 has thus made space for their dope vectors (region 4), but considered 
as arrays their sizes are 0.  At program start, region 6 is empty.  But 
memory region 6 grows <i>downward</i> when <font color="#663300"><code>BASED</code></font>
 variables are allocated memory at runtime, simultaneously shrinking the
 free-string memory region 5.  String data meanwhile occupies the space 
from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> in region 5, which means that the space between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available both for growing the string data upward (thus increasing <font color="#663300"><code>FREEPOINT</code></font>) or growing the <font color="#663300"><code>BASED</code></font> data downward (thus decreasing <font color="#663300"><code>FREELIMIT</code></font>).<br></p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; It would seem reasonable, at least to me, that if </font><font size="-1"><font color="#663300"><code>BASED</code></font> allocations proceed downward in memory, then the indices of the </font><font size="-1"><font color="#663300"><code>BASED</code></font> should also proceed downward as well.&nbsp; I mean that if we had a decoration such as <font color="#663300"><code>BASED MYBASED</code></font>, then <font color="#663300"><code>MYBASED(0)</code></font> would be at a higher address than </font><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED(1)</code></font></font>, which would be at a higher address than </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED(2)</code></font></font></font>, and so on.&nbsp; If that were the case, then growing </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED</code></font></font></font>
 after its initial allocation would be more efficient (if it happened to
 border on unallocated space), since it just involves snatching an 
unallocate chunk of memory rather than moving the entire array.&nbsp; 
However, if I am reading the code in SPACELIB correctly this does not 
appear to be the case:&nbsp; Indices of </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables seem to increase upward in memory, just as they do in any other XPL/I array.&nbsp; </font><br>
</blockquote>Region 7 is a bit trickier to explain.&nbsp; It is an 
area dedicated to data which <b>XCOM-I</b> wants to use for XPL objects 
it creates at compile time that need to be accessible to the XPL program
 as normal XPL variables, but that need to be exempt from the normal 
memory-management 
procedures applied to regions 5 and 6.&nbsp; These are items which the 
original XPL compilers would have stored in regions 1 through 6, but 
that the different implementation of <b>XCOM-I</b> would have made difficult.&nbsp; <b>XCOM-I</b> allocates this area and the objects in it at compile-time.&nbsp; Though shown as beginning at <font color="#663300"><code>0xFFE000</code></font>, that's misleading.&nbsp; The <font color="#663300"><code>0xFFE000</code></font> limit is the default, and is appropriate for compiling <b>HAL/S-FC</b>, but in fact is controlled by <b>XCOM-I</b>'s <font color="#663300"><code>--reserved=<i>N</i></code></font>
 (default 8192) command-line option.&nbsp; There will be compile-time 
messages if the size of the reserved memory needs to be increased.&nbsp;
 It's important to note that all XPL programs sharing the same <font color="#663300"><code>COMMON</code></font> memory need to have the same size for region 7.&nbsp; Specifically, all passes of <b>HAL/S-FC</b> need to have the same size of reserved memory, and that's why this particular default value for it was chosen.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; In fact, the use of 
reserved memory has proven to be extremely rare.&nbsp; The only 
instances of use, to date, have been in <b>PASS2</b> and <b>PASS4</b> of <b>HAL/S-FC</b>, each of which stores a single object declared in a previously-unencountered, idiosyncratic way.</font><br>
</blockquote>
<br>
<blockquote>
</blockquote>


</td>
      <td valign="middle">
        <table width="100%" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Memory Layout</b></font></caption>

  <tbody>
    <tr>
  <th valign="bottom"><font size="-1">Addresses<br>
    </font></th>
  <th valign="bottom"><font size="-1">Description<br>
    </font></th>
  <th valign="bottom"><font size="-1">Region Number<br>
    </font></th>
</tr>

<tr>
  <td valign="top" align="right"><font color="#663300"><code><font size="-1">0xFFFFFF<br>
<br>
<br>
0xFFE000<br>
</font></code></font></td>
  <td valign="middle" align="center"><font size="-1"><br>Reserved memory<br>
      <br>
    </font></td>
  <td valign="middle" align="center">7<br>
  </td>
</tr>
<tr>
            <td valign="top" align="right"><br>
<br>
<br>
<br>
<br>
<br>
<br>
              <font color="#663300"><code></code></font></td>
            <td valign="middle" align="center"><font size="-1"><br>
                <br>
Data pointed to by "dope vectors" of </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font><br>
                <br>
                <br>
              </font></td><td valign="middle" align="center">6<br>
</td>

          </tr>
<tr>
  <td valign="bottom" align="right"><font color="#663300"><code><font size="-1">FREELIMIT</font></code></font></td>
  <td valign="middle" align="center"><font size="-1"><br>
512-byte zone<br>
      <br>
    </font></td>
  <td valign="middle" align="center"><font size="-1">5z</font><br>
  </td>
</tr>
<tr>
      <td valign="top" align="right"><font color="#663300"><code><font size="-1"><br>
                  <br>
                  <br>
                  <br>
FREEPOINT<br>
                  <br>
<br>
<br>
FREEBASE</font><br>
              </code></font></td>
<td valign="middle" align="center"><br>
          <font size="-1"><font size="-1">Data pointed to by "string descriptors" of <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT(&gt;32)</code></font><br>
              <br>
            </font></font>
      </td><td valign="middle" align="center">5<br>
</td>

    </tr>
    
    
    <tr>
  <td valign="middle" align="center"><font size="-1"><br>
    </font></td>
  <td valign="middle" align="center"><font size="-1"><font size="-1"><font color="#663300"><code><br>
BASED</code></font></font> dope vectors for non-<font color="#663300"><code>COMMON</code></font><br>
      <br>
    </font></td><td valign="middle" align="center">4<br>
</td>

</tr>
<tr>
  <td valign="bottom" align="right"><font size="-1"><font color="#663300"><code>DESCRIPTOR</code></font><br>
    </font></td>
  <td valign="middle" align="center"><font size="-1"><font size="-1"><font color="#663300"><code><br>
CHARACTER</code></font> or <font color="#663300"><code>BIT(&gt;32)</code><font color="#000000"> string descriptors<br>
        <br>
      </font></font></font></font></td><td valign="middle" align="center">3<br>
</td>

</tr>
<tr>
      <td valign="bottom" align="right"><br>
</td>
<td valign="middle" align="center"><font size="-1"><br>
            </font><font color="#663300"><font size="-1" color="#000000"><font size="-1"><font color="#663300"><font color="#000000"><font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(</code><code>≤32)</code></font> , and <font color="#663300"><code>BASED</code></font> dope vectors for</font></font></font></font></font><font size="-1"><font color="#663300"><font color="#000000"> non-<font color="#663300"><code>COMMON</code></font></font></font></font><font size="-1"><br>
            <br>
          </font>
      </td><td valign="middle" align="center">2<br>
</td>

    </tr>
    <tr>
            <td valign="top"><br>
            </td>
            <td valign="middle" align="center"><font color="#663300"><code><br>
</code></font><font color="#663300"><font size="-1" color="#000000"><font size="-1"><font color="#663300"><font color="#000000"><font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(</code><code>≤32)</code></font> , and <font color="#663300"><code>BASED</code></font> dope vectors for </font><code>COMMON</code></font></font><font color="#663300"><code></code></font></font><code><br>
                  <br>
                </code></font></td><td valign="middle" align="center">1<br>
</td>

          </tr>
<tr>
      <td valign="bottom" align="right"><font color="#663300"><code><font size="-1">0x000000</font></code></font></td>
<td valign="middle" align="center"><br>
<font size="-1"><font color="#663300"><code><font color="#663300"><font size="-1" color="#000000">Data supplied by <font color="#663300"><code>MONITOR(13)</code></font> and <font color="#663300"><code>MONITOR(23)<br>
        <br>
</code></font></font></font>
    
    </code></font>
            
          </font>
      </td><td valign="middle" align="center">0<br>
</td>

    </tr>
    
    
    
    
    
  </tbody>
        </table>
        </td></tr></tbody></table>
<h3><a name="compactify"></a>Understanding COMPACTIFY</h3>
<p>At runtime, changes to sizes of <font color="#663300"><code>BASED</code></font>
 arrays may cause those arrays to move around within memory region 6 
(see the preceding section).  Depending on the type of changes, this can
 cause "holes" of unused memory to develop in memory region 6.  
Similarly, operations on <font color="#663300"><code>CHARACTER</code></font> variables such as <font color="#663300"><code>INPUT</code></font> or string concatenation (<font color="#663300"><code>||</code></font>) can cause holes of unused memory to develop in memory region 5.  As long as <font color="#663300"><code>FREEPOINT</code></font> is comfortably less than <font color="#663300"><code>FREELIMIT</code></font>,
 these holes don't cause any problem and can just be ignored.  However, 
it may eventually become necessary to repack these memory regions to 
consolidate the free space and eliminate the holes.  <br></p>
<p>As far as memory region 6 is concerned, that's handled transparently by the tools already discussed in <a moz-do-not-send="true" href="#basedManagement">the section on <font color="#663300"><code>BASED</code></font> variables</a> earlier, and won't be discussed here.  The <font color="#663333"><code>COMPACTIFY</code></font>
 procedure which handles this for memory region 5, unfortunately, does 
require some clarification, even though you typically don't need to 
explicitly call <font color="#663300"><code></code></font><font color="#663333"><code>COMPACTIFY</code></font> yourself, and can assume it will just be called automatically whenever needed.<br></p>
<p>Most importantly, while <font color="#663333"><code>COMPACTIFY</code></font> doesn't handle memory management of <font color="#663300"><code>BASED</code></font> variables, the existence of based variables <i>does</i> affect how <font color="#663333"><code>COMPACTIFY</code></font> operates, with the result that different versions of <font color="#663333"><code>COMPACTIFY</code></font> must be used for XPL code than for XPL/I code.  But there's a quirk in XPL's implementation:  While <font color="#663333"><code>COMPACTIFY</code></font> is considered a "built-in" function of the XPL runtime library, in point of fact it's <i>not</i> present in the XPL (or XPL/I) runtime library, and must instead be explicitly provided in the form of XPL source code.<br></p>
<p>Fortunately, that doesn't entail any effort on your part, since <b>XCOM-I</b>
 can usually figure out what to do on its own.  But still, it may be 
helpful to understand what's going one behind the scenes, for those 
cases in which you need to intervene.  The <b>XCOM-I</b> approach to the inclusion of <font color="#663333"><code>COMPACTIFY</code></font>
 is that prior to loading any of the XPL or XPL/I source-code files you 
explicitly specify, it automatically preloads a "library file", which is
 an XPL or XPL/I source-code file containing <i>at least</i> the source code for <font color="#663333"><code>COMPACTIFY</code></font>.  The library file it chooses is governed by the following rules:<br></p>
<ol>
  <li>By default, it chooses SPACELIB.xpl, which is a duplicate of the 
Intermetrics file of the same name provided with the XPL/I source code 
for the <b>HAL/S-FC</b> program.  It should be good for compiling all XPL/I source code.</li>
  <li>But if the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--xpl</code></font>
 is used, the default library changes to XPL.LIBRARY.xpl.  This a 
duplicate of the library of the same name provided with the source code 
of McKeeman's <b>XCOM</b> program.  It should be good for compiling all standard XPL source code.</li>
  <li>But if the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--lib-file=<i>FILENAME</i></code></font> is used, then <font color="#663300"><code><i>FILENAME</i></code></font> is used in place of the default library file.  This gives you the option of using some other version of <font color="#663333"><code>COMPACTIFY</code></font>, perhaps experimenting with it yourself.  If used along with an <font color="#663300"><code>--xpl</code></font> switch, then <font color="#663300"><code>--lib-file</code></font> must <i>follow</i> <font color="#663300"><code>--xpl</code></font> on the command line.<br></li>
</ol>
That's all you really <i>need</i> to know, and perhaps more.&nbsp; Unfortunately, <i>I</i> need to know more about it, in order to make it work in <b>XCOM-I</b>, and here's as good a place as any to write down some of that need-to-know info!<br>
<br>
The principal difficulty is that while XPL.LIBRARY.xpl works immediately
 for XPL program, as-is, as long as the memory partitioning described in
 the preceding section is compatible <i>enough</i> with McKeeman, the same cannot be said of SPACELIB.xpl for XPL/I programs.<br>
<br>
In brief, here's how the XPL <font color="#663333"><code>COMPACTIFY</code></font>
 of XPL.LIBRARY.xpl works.&nbsp; All of the "string descriptors" 
(providing the addresses and sizes of the character strings in region 5 
which need to be repacked) are found, contiguously, in memory region 3, 
which they completely fill.&nbsp; Because of this convenient 
arrangement, all of the string descriptors can all be accessed as if 
they were a single <font color="#663300"><code>FIXED</code></font> array.&nbsp; Standard XPL's built-in <font color="#663300"><code>DESCRIPTOR</code></font> and <font color="#663300"><code>NDESCRIPT</code></font>
 respectively give the location and size of this array of string 
descriptors.&nbsp; Repacking region 5 is a relatively-simple matter of 
sorting <font color="#663300"><code>DESCRIPTOR</code></font> array by 
address, using the sorted array to find the "holes", then moving the 
string data downward in region 5 to eliminate the holes, and finally 
updating the original descriptors in the <font color="#663300"><code>DESCRIPTOR</code></font> array to preserve the strings but to change the addresses.<br>
<br>
The only mild complication in the description above is that the <font color="#663300"><code>DESCRIPTOR</code></font> array can't be sorted <i>in place</i>.&nbsp; Rather, a separate scratch array is needed to help out the process:<br>
<blockquote>
  <pre><font color="#663300">DECLARE DX_SIZE LITERALLY '500', DX(DX_SIZE) BIT(16);</font><br></pre>
</blockquote>
This <font color="#663300"><code>DX</code></font> array is set up to contain the indices into the <font color="#663300"><code>DESCRIPTOR</code></font> array, and it's <font color="#663300"><code>DX</code></font> that's sorted rather than <font color="#663300"><code>DESCRIPTOR</code></font>.&nbsp; This is undoubtedly a good strategy, although it limits the total number of <font color="#663300"><code>DECLARE</code></font>'d <font color="#663300"><code>CHARACTER</code></font>
 variables to 500.&nbsp; On the other hand, the limit of 500 is 
completely arbitrary, and if you have enough memory (we do!) there's no 
reason it couldn't be increased as high as 64K.&nbsp; And by the simple 
expedient of declaring <font color="#663300"><code>DX</code></font> as <font color="#663300"><code>FIXED</code></font> rather than <font color="#663300"><code>BIT(16)</code></font>, the limit could be made much higher.<br>
<br>
Unfortunately, the relatively-simple processing fails for XPL/I code — or at least, for any XPL/I code having <font color="#663300"><code>BASED</code></font> variables containing <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT(≥32)</code></font>
 data — because no longer are all of the string descriptors nicely lined
 up for us in memory region 3.&nbsp; Rather, many of them are smeared 
all over memory region 6.&nbsp; Nor is a limit of 500 strings remotely 
adequate for compiling programs like <b>HAL/S-FC</b>.&nbsp; Here is what I understand of the differences between how the XPL/I <font color="#663333"><code>COMPACTIFY</code></font> has to operate, as compared to the description I just gave of the XPL <font color="#663333"><code>COMPACTIFY</code></font>:<br>
<ul>
  <li>While the built-ins called <font color="#663300"><code>DESCRIPTOR</code></font> and <font color="#663300"><code>NDESCRIPT</code></font> still exist, and still provide exactly the same info about memory region 3, they are no longer relevant to <font color="#663333"><code>COMPACTIFY</code></font>.</li>
  <li><font color="#663300"><code>DX</code></font> is now a <font color="#663300"><code>BASED FIXED</code></font>,
 because it contains pointers to the string descriptors (i.e. it 
contains memory addresses of the string descriptors) rather than just 
indices into region 3.</li>
  <li><font color="#663300"><code>DX_SIZE</code></font> gives the number of elements of <font color="#663300"><code>DX</code></font>, but as it's nowhere <font color="#663300"><code>DECLARE</code></font>'d in the library, I suppose it must be an undocumented XPL/I built-in.</li>
</ul>
<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">  I'd venture the guess that </font><font size="-1"><font color="#663300"><code>DX_SIZE</code></font> is initially set and space for </font><font size="-1"><font color="#663300"><code>DX</code></font> is initially allocate by the XPL/I compiler to handle the string descriptors which are </font><font size="-1"><font color="#663300"><code>DECLARE</code></font>'d and therefore known at compile time.  At runtime, SPACELIB would then take over the task of maintaining </font><font size="-1"><font color="#663300"><code>DX</code></font> and </font><font size="-1"><font color="#663300"><code>DX_SIZE</code></font> to handle additional string descriptors that come into existence (or leave it) when </font><font size="-1"><font color="#663300"><code>BASED</code></font> variables containing them grow (or shrink).</font><br></p>
</blockquote>
<ul>
  <li><br></li>
</ul>
<br>
TBD<br>
<h3>Structure of an XPL Program vs XPL/I<br>
</h3>

<p>An XPL program consists of any sequence of XPL <i>statements</i>, followed by the token <font color="#663333"><code>EOF</code></font>.&nbsp; In particular:<br></p>
<ul>
  <li>Declarations of variables can be intermixed with active statements such as assignments.</li>
  <li>Active code can exist at the global level, outside of any <font color="#663300"><code>PROCEDURE</code></font>s. <br></li>
</ul>

<blockquote>
  <p><font size="-1"><b>Note:</b>&nbsp; The original XPL compiler, which
 was called XCOM, performed a single pass.&nbsp; It required that the 
declaration of any particular identifier as an object (such as a 
variable) had to precede the use of that identifier, although there were
 provisions for making a forward declaration for a </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font>, so that the </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> could be used before it was defined.&nbsp; <b>XCOM-I</b> relaxes this requirement.<br></font></p></blockquote><font size="-1"></font>
<p>Each of the sample programs I've encountered in standard XPL so far has been contained in a single <i>relatively</i>-small file.  For example, <b>ANALYZER</b> has a little over 1500 lines of source code, while <b>XCOM</b> has a little over 4200 lines.   <br></p>
<p>In contrast, the XPL/I source code for Intermetrics's HAL/S compiler <b>HAL/S-FC</b>
 has over 120,000 lines of source code spread across over 600 files, 
though any individual pass of the compiler has no more than around 
35,000 lines.  This huge size, along with the huge difference from 
programs in standard XPL, necessitates different methods for managing 
that source-code base, and some of those methods are reflected by 
compiler directives embedded within the source code.  Insofar as <b>HAL/S-FC</b>
 and its related applications are concerned, the top-level source-code 
file  (##DRIVER.xpl) for each application always contains all of the 
necessary directives for compiling the other source-code files needed, 
in the correct order, so in using XCOM-I to compile these applications 
you don't need to worry about any file other than ##DRIVER.xpl itself.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> Well, the comment about ##DRIVER.xpl 
isn't exactly right.  Any XPL or XPL/I program will expect that there's a
 separate "library file" containing source code for the <font color="#663300"><code>COMPACTIFY</code></font>
 procedure, but the XPL/I source code for the program won't explicitly 
include the library file.  That's the compiler's responsibility.<br><b></b></font></p>
<p><font size="-1"><b>Aside:</b> Due to the lack of relevant 
Intermetrics documentation, what I'm about to describe is not only 
speculative on my part, but also represents certain pragmatic 
compromises that I don't believe literally existed in Intermetrics' XPL 
compiler or development procedures.  But if it will work for us using <b>XCOM-I</b> on <b>HAL/S-FC</b> and if there are no other lurking XPL/I programs that we need to worry about, why complain?</font><br></p>

</blockquote>
Compiler directives in XPL/I are comments or comment-like constructions 
which aren't documented in McKeeman and have no other obvious 
purpose.&nbsp; The specifics are covered by the subsections below.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/?<i>c</i> ... XPL/I source code ... ?/</code></font></h4>
This type of compiler directive is a conditional inclusion of source 
code, similar to the C language's <font color="#663300"><code>#if <i>c</i></code></font>.&nbsp; Here, <font color="#663300"><i><code>c</code></i></font>
 is supposed to be an upper-case alphabetical letter that represents the
 particular condition that needs to be "true".&nbsp; All conditions, <font color="#663300"><code>A</code></font> through <font color="#663300"><code>Z</code></font>, are by default "false".&nbsp; You make condition <font color="#663300"><i><code>c</code></i></font> "true" by using <b>XCOM-I</b>'s <font color="#663300"><code>--cond=<i>c</i></code></font> command-line switch.<br>
<br>
Interpretations of the possible conditions are entirely at the user's 
disposal; i.e., they vary by the particular source-code being compiled 
by <b>XCOM-I</b>.&nbsp; In the particular case of the XPL/I source code for the <b>HAL/S-FC</b> program, there are 4 
possible conditions <font color="#663300"><i><code>c</code></i></font> that I'm aware of:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Preprocessor Conditionals</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">XCOM-I Command-Line Switch<br>
      </th>
      <th valign="top">Interpretation<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=P</code></font><br>
      </td>
      <td valign="top"><b>HAL/S-FC</b> will be specialized for compiling the Space Shuttle's Primary Flight Software (PFS).</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=B</code></font> </td>
      <td valign="top"><b>HAL/S-FC</b> will be specialized for compiling the Space Shuttle's Backup Flight Software (BFS).<br>
        <b>Note:</b>&nbsp; Either <font color="#663300"><code>--cond=P</code></font> or <font color="#663300"><code>--cond=B</code></font> must be used, but not both at the same time.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=A</code></font></td>
      <td valign="top">Produce debugging output related to memory management of <font color="#663300"><code>BASED</code></font> variables.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=C</code></font></td>
      <td valign="top">Produces debugging output related to actions by the <font color="#663300"><code>COMPACTIFY</code></font> procedure.</td>
    </tr>
  </tbody>
</table>
<br>
<ul></ul>
<blockquote>
  <p><font size="-1"><b>Aside:</b> This implies that you don't just compile <b>HAL/S-FC</b> <i>once</i> to get a HAL/S compiler that works for all HAL/S programs.  Rather, you compile <b>HAL/S-FC</b> <i>twice</i>,
 once to get a version of the HAL/S compiler that works for the primary 
flight software, and once to get a version of the compiler that works 
for the backup flight software.</font></p>
</blockquote>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/%INCLUDE <i>module</i> %/</code></font></h4>
This type of compiler directive inserts an entire XPL/I source-code file, <i>module</i>.xpl, at the current point.&nbsp; It is used for importing <font color="#663300"><code>COMMON</code></font>-block
 declarations or macros which are used identically by all source-code 
files.&nbsp; By default, the included module is taken from the folder 
../HALINCL/.&nbsp; As far as I know this covers every use in <b>HAL/S-FC</b> source code.&nbsp; However, if necessary, <b>XCOM-I</b> has a command-line option (<font color="#663300"><code>--include=<i>folder</i></code></font>) which can be used to change the folder containing the modules.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/* ...comment... <i>$%module</i> */</code></font></h4>
This is a variant of the<font color="#663300"><code> /%INCLUDE <i>module</i> ...comment... %/</code></font>
 directive, which acts the same way, and for which my comments are otherwise the same.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/**MERGE <i>module</i> <i>procedure</i> */</code></font></h4>
This is yet another directive for including an XPL/I source-code file in
 the current XPL/I source-code file, but it differs from the other 
include-directives described above in that instead of importing 
definitions used in common by multiple source-code files, it instead is 
typically used for importing the source code for a single <font color="#663300"><code>PROCEDURE</code></font>.&nbsp; As above, <i>module</i>.xpl is the source-code file to include, while <i>procedure</i> is the name of the <font color="#663300"><code>PROCEDURE</code></font> contained in that file.&nbsp; In point of fact, <b>XCOM-I</b> simply ignores the procedure name.<br>
<blockquote><font size="-1"><b>Aside:</b> Procedure names don't match 
the filenames, usually, because the naming conventions for System/360 
files were severely limited vs identifiers in XPL.&nbsp; Thus the 
filenames were normalized, truncated forms of the procedure names.</font><br>
</blockquote>
Also, <i>module</i>.xpl is expected to be within the same folder as the 
source-code file being compiled; no other folders are searched for it, 
and there are no command-line switches to alter this behavior.<br>
<blockquote>
</blockquote>

<h3>PROCEDUREs, RETURNs, and Their Peculiarities<br>
</h3>
<p>In a view from a height, an XPL program consists of <font color="#663333"><code>PROCEDURE</code></font> definitions and of code that uses those definitions.<br></p>
<p>A procedure definition looks something like this:<br></p>
<blockquote>
  <pre><font color="#663300"><i>label</i>:<br>PROCEDURE(... <i>parameter list</i> ...) <i>ReturnType</i>;<br>	DECLARE ... <i>for the parameters</i> ...;<br>	DECLARE ... <i>for local variables</i> ...;<br><br>	... <i>code</i> ...;<br>END <i>label</i>;</font><br></pre>
</blockquote>

<p><font color="#663333"><font color="#000000">A lot of this is optional.  Thus while the initial <font color="#663300"><code><i>label</i>:</code></font> is required (since it's the name of the procedure), the </font></font><font color="#663333"><font color="#000000"><font color="#663333"><font color="#000000"><font color="#663300"><code><i>label</i></code></font></font></font>
 at the end of the definition is optional, and is really there only for 
readability purposes.  If the procedure needs no parameters, then the <font color="#663300"><i><code>parameter list</code></i></font>, <i>including</i> its enclosing parentheses, is omitted.  If the procedure returns no value, then <font color="#663300"><i><code>ReturnType</code></i></font> is omitted; if present, it is one of the basic non-subscripted datatypes <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(<i>n</i>)</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.  Each parameter in the </font></font><font color="#663333"><font color="#000000"><font color="#663333"><font color="#000000"><font color="#663300"><i><code>parameter list</code></i></font></font></font>
 must have a declaration within the body of the procedure, and while 
those declarations don't technically have to precede the declarations of
 the local variables as shown above, it was apparently customary to do 
so.</font></font></p><font color="#663333"><code>PROCEDURE</code></font> definitions in the source code can be nested, to any desired depth.  <font color="#663333"><code>PROCEDURE</code></font> definitions and <font color="#663300"><code>DO...END</code></font>
 blocks provide the program with a hierarchical structure of 
"scopes".&nbsp; The hierarchical structure is provided by the 
parent/child relationships among the scopes.  Variables are accessible 
within the scope in which they're declared, along with any descendant scopes.  If a
 variable is declared in more than one scope of the hierarchy, the one 
in the innermost enclosing scope is the one that is applicable.  <br>
<br>
In standard XPL, variables can be declared only at the global level or in a <font color="#663300"><code>PROCEDURE</code></font>, and not within <font color="#663300"><code>DO...END</code></font> blocks.&nbsp; <br>
<br>
In XPL/I, variable (and <font color="#663300"><code>PROCEDURE</code></font>) definitions can be declared anywhere, even within <font color="#663300"><code>DO...END</code></font> blocks.&nbsp; <b>XCOM-I</b> mimics the XPL/I usage, since it's compatible with standard XPL.&nbsp; But there's a trap!&nbsp; Or at least, it's a trap for <i>me</i>, and by projection, I assume it's a trap for you as well.&nbsp; The trap is that you'd suppose the scope of a variable or <font color="#663300"><code>PROCEDURE</code></font> was the <font color="#663300"><code>DO...END</code></font> block in which it was declared.&nbsp; Not so!&nbsp; The scope is the entire enclosing <font color="#663300"><code>PROCEDURE</code></font>
 and its descendants.&nbsp; So beware.&nbsp; Fortunately, such 
abominations are very rare, and only a handful appear in the entire <b>HAL/S-FC</b> source-code base.&nbsp; Here's an example from the <font color="#663300"><code>DUMP_SDF PROCEDURE</code></font> of <b>PASS4</b> of the compiler, cleaned up a little for readability.&nbsp; Observe the declaration and usage of the variable <font color="#663300"><code>SYM_DATA_CELL_ADDR</code></font> within the two distinct <font color="#663300"><code>DO...END</code></font> blocks:<br>
<blockquote>
  <pre>            IF NODE_B(3) &gt; 0 THEN <font color="#009900">DO; <br> 	       /* IN CASE OF SYMBOL XREF EXTENSION CELL, SAVE ADDR OF SYM DATA CELL */<br>               DECLARE <font color="#ff0000">SYM_DATA_CELL_ADDR</font> FIXED; <br>               <font color="#ff0000">SYM_DATA_CELL_ADDR</font>= COREWORD(ADDR(NODE_F)); <br>               CALL PRINT_XREF_DATA(SHR(NODE_B(3),1));<br>            END</font>; <br><br>            IF ASIP_FLAG &amp; (SCLASS=1 | SCLASS=2 &amp; NAME_FLAG) THEN <font color="#3333ff">DO;<br> 	       /* RESTORE NODE_F TO SYM_DATA_CELL_ADDR BEFORE GETTING AUXILIARY INFO. */<br>               COREWORD(ADDR(NODE_F))  = <font color="#ff0000">SYM_DATA_CELL_ADDR</font>;<br>               IF STYPE=16 &amp; ^NAME_FLAG THEN<br>                  CALL FORMAT_NAME_TERM_CELLS(I,NODE_F(-2));<br>               ELSE OUTPUT = X10||'INITIAL(NAME('|| <br>                  FORMAT_VAR_REF_CELL(NODE_F(-2)) || '))';<br>            END</font>; <br></pre>
</blockquote>
A <font color="#663333"><code>PROCEDURE</code></font> may be invoked in two different ways.&nbsp; If it returns a value via a <font color="#663300"><code>RETURN</code></font>
 statement, it can be used in an arithmetical expression or a string 
expression.&nbsp; If it doesn't return a value, or if it does return a 
value and you simply want to ignore the value, a <font color="#663333"><code>CALL</code></font> statement can be used to invoke the <font color="#663333"><code>PROCEDURE</code></font> but to discard any returned value.<br>

<p><b>Important:</b>&nbsp; All variables local to a <font color="#663333"><code>PROCEDURE</code></font> definition retain their values after the <font color="#663333"><code>PROCEDURE</code></font> returns.&nbsp; If the <font color="#663333"><code>PROCEDURE</code></font> is re-executed, those local variables retain the values they previously had in the prior invocation of the <font color="#663333"><code>PROCEDURE</code></font>.&nbsp; The values of those local variables, though retained, are inaccessible to code outside of the <font color="#663333"><code>PROCEDURE</code></font>,
 because the compiler enforces scopes of variables. (In C code, this 
would be the same thing as saying that every local variable of every 
function is automatically declared as <font color="#663333"><code>static</code></font>.)
</p>
<p><b><i>Very</i> important:</b> Any (or even all) <i>parameter</i>s at the trailing end of the calling list of a <font color="#663333"><code>PROCEDURE</code></font> can be omitted from when calling the <font color="#663333"><code>PROCEDURE</code></font>, and if omitted, they retain the same values as the last time the <font color="#663333"><code>PROCEDURE</code></font> was invoked <i>or</i> the values previously assigned to those parameters from within the <font color="#663333"><code>PROCEDURE</code></font> itself!&nbsp; (In essence, this is like saying that parameters of a <font color="#663333"><code>PROCEDURE</code></font> are not passed to the <font color="#663333"><code>PROCEDURE</code></font>, but rather that they are just aliases for some set of global variables dedicated to the <font color="#663333"><code>PROCEDURE</code></font>.)&nbsp; That's so weird that we need to see an example.&nbsp; Consider the following XPL <font color="#663333"><code>PROCEDURE</code></font> definition, and <font color="#663333"><code>CALL</code></font>s to it:
</p>
<blockquote>
  <pre><font color="#663333">weirdo: <br>procedure(x, y, z);<br>    declare (x, y, z) fixed;		/* Declare x,y,z as integers */<br>    output = x || ' ' || y || ' ' || z; /* Print out x,y,z */<br>    x = 29;<br>    y = y + 1;<br>end weirdo;<br><br>call weirdo(1, 2, 3);<br>call weirdo(4, 5);<br>call weirdo(6);<br>call weirdo();<br>call weirdo;</font><br></pre>
</blockquote>
<p>The five calls successively print out the following:
</p>
<blockquote>
  <pre>1 2 3<br>4 5 3<br>6 6 3<br>29 7 3<br>29 8 3<br></pre>
</blockquote>
<p><font color="#663333"><code>PROCEDURE</code></font>s cannot be recursive, either directly or indirectly.<br></p>
<p>Taking these facts altogether, <b>XCOM-I</b> implements both parameters and local variables of <font color="#663333"><code>PROCEDURE</code></font>s essentially as global variables in they way they are stored:&nbsp; i.e., each parameter and each local variable of each <font color="#663333"><code>PROCEDURE</code></font> has its own <i>static</i>
 address (in the global memory model), assigned at compile time and 
unchanging thereafter.&nbsp; The compiler enforces the logical scoping 
of these variables.<br></p>
<p>Regarding the <font color="#663300"><code>RETURN</code></font> statement, McKeeman explains that it is used to exit from a <font color="#663333"><code>PROCEDURE</code></font>
 and optionally to return a value.  Furthermore, the calling code can 
either use that return value or else ignore it.  Which makes perfect 
sense.  But  as usual, there are some documented and undocumented 
peculiarities to the <font color="#663300"><code>RETURN</code></font> statement as well:<br></p>
<ul>
  <li>McKeeman explains (p. 146) that calling code can <i>use</i> returned values from <font color="#663300"><code>PROCEDURE</code></font>s even if the <font color="#663300"><code>PROCEDURE</code></font> has no <font color="#663300"><code>RETURN</code></font> statement, or the <font color="#663300"><code>RETURN</code></font>
 statement specifies no value.  In this case, we are told, the return 
value is simply some unpredictable value from some unspecified 
System/360 register.  Which is rotten, of course, but so what?  This is 
never going to happen, right?  Wrong!  Actual XPL code does this from 
time to time.  <b>XCOM-I</b>, on the other hand, <i>always</i> returns a well-defined value from a <font color="#663300"><code>PROCEDURE</code></font>, whether or not there are any <font color="#663300"><code>RETURN</code></font> statements specifying a return value; the returned value in this case is 0 if <font color="#663300"><code>FIXED</code></font>, a <font color="#663300"><code>BIT</code></font> value of the appropriate width evaluating to 0, or else the empty string for a <font color="#663300"><code>CHARACTER</code></font>.</li>
  <li>McKeeman (probably!) does not mention that <font color="#663300"><code>RETURN</code></font>
 statements may exist at the global level, outside of the scope of any 
procedure, and may return a value when they do.  But they can.  <b>XCOM-I</b>
 treats these as exits from the program back to the operating system, 
with the returned value being the program's exit code.  It thus expects 
the return value to be a program status code.</li></ul>
<h3>Blocks and Loops</h3>
<p>Compound statements in XPL are groupings of simple statements (such 
as assignments or if-then-else statements) enclosed within a <font color="#663300"><code>DO ... END</code></font> block:<br></p>
<blockquote>
  <pre><font color="#663300">DO ...;<br>    ... simple statements ...<br>END;</font><br></pre>
</blockquote>
<p>There are five different kinds of <font color="#663300"><code>DO ... END</code></font> blocks.  First, there is a mere grouping:</p>
<blockquote>
  <pre><font color="#663300">DO;<br>    ... simple statements ...<br>END;</font></pre>
</blockquote>

<p>Then there are 3 different kinds of loops:</p>
<pre><font color="#663300">DO <i>COUNTER</i> = <i>START</i> TO <i>END</i> [BY <i>STEP</i>];<br>    ... simple statements ...<br>END;<br><br></font><font color="#663300">DO WHILE <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
<br><font color="#663300">DO UNTIL <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
</pre>

<p>Note that <font color="#663300"><code>DO UNTIL</code></font> is new in XPL/I and is not present in standard XPL.<br></p>
<p>In these loops, <i><font color="#663300"><code>COUNTER</code></font></i>, <i><font color="#663300"><code>START</code></font></i>, <i><font color="#663300"><code>END</code></font></i>, and the optional <i><font color="#663300"><code>STEP</code></font></i> are all integers.  <i><font color="#663300"><code>STEP</code></font></i> defaults to 1, but must be <i>positive</i>.  <i><font color="#663300"><code>START</code></font></i>, <i><font color="#663300"><code>END</code></font></i>, and <i><font color="#663300"><code>STEP</code></font></i>
 may be expressions, but if so they are evaluated only a single time, at
 the start of the loop, and are not reevaluated thereafter.  <i><font color="#663300"><code>CONDITION</code></font></i>,
 on the other hand, is an expression evaluated on each loop; it is 
treated as "true" if its least-significant bit is 1, or "false" if its 
least-significant bit is 0.&nbsp; When I say they are "integers", I don't mean that they are necessarily <font color="#663300"><code>FIXED</code></font>; they could also be <font color="#663300"><code>BIT(</code><code>≤32)</code></font>, which evaluate to integers.<br>
</p>
<p>The fifth kind of <font color="#663300"><code>DO ... END</code></font> block is:<br></p>
<blockquote>
  <pre><font color="#663300">DO CASE EXPRESSION;<br>    STATEMENT0;<br>    STATEMENT1;<br>    STATEMENT2;<br>    ...<br>END;</font><br></pre>
</blockquote>
<p>The <i><font color="#663300"><code>EXPRESSION</code></font></i> must also evaluate to an integer.  If 0, then <i><font color="#663300"><code>STATEMENT0</code></font></i> is executed; if 1, then <i><font color="#663300"><code>STATEMENT1</code></font></i>
 is executed; and so on.  At most, a single statement is executed, and 
there is no "fall through" from one statement to the next.  If the <i><font color="#663300"><code>EXPRESSION</code></font></i>
 is negative or beyond the number of available statements, McKeeman 
tells us that "a random jump is executed".  In <b>XCOM-I</b>, no statement is 
executed under those circumstances, and control passes to the next 
statement after the <font color="#663300"><code>END</code></font>.<br></p>
<h3><code>ESCAPE</code> and <code>REPEAT</code><br>
</h3>

<p>The <font color="#663300"><code>ESCAPE</code></font> and <font color="#663300"><code>REPEAT</code></font>
 keywords appear to be undocumented XPL/I features not present in 
standard XPL.  Unfortunately, from the available material I can't think 
of any way to be <i>sure</i> what they do, so I can only speculate.<br></p>
<p><font color="#663300"><code>ESCAPE</code></font> appears in two different forms:<br></p>
<ul>
  <li><font color="#663300"><code><font color="#663300"><code>ESCAPE;</code></font> <br></code></font></li>
  <li><font color="#663300"><code>ESCAPE <i>LABEL</i>;</code></font> <font color="#663300"><code></code></font></li>
</ul>
<p>It should be noted that the HAL/S language has the keyword <code><font color="#663300">EXIT</font></code>, which also has these two forms.  (<a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/Programming%20in%20HAL_S%20Sept%201978.pdf#page=96">See Ryer, p. 5-12</a>.)  <code><font color="#663300">EXIT</font></code> has the following behavior in HAL/S:<br></p>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>EXIT</code></font>;</code></font> — Exits from the innermost enclosing <font color="#663300"><code>DO ... END</code></font> block.  I.e., it's essentially a <font color="#663300"><code>GO TO</code></font> to just after the closest enclosing <font color="#663300"><code>END</code></font>.</li>
  <li><font color="#663300"><code>EXIT <i>LABEL</i>;</code></font> — Exits from an enclosing <font color="#663300"><code>DO ... END</code></font> that isn't necessarily the innermost one, but rather the one which instead has the specified <i><font color="#663300"><code>LABEL</code></font></i> attached to it.  By "attached to it", I mean that they're directly adjacent, as in "<font color="#663300"><code><i>LABEL</i>: DO ...</code></font>".<font color="#663300"><code></code></font></li>
</ul>
<p>Until a more-plausible explanation comes along, my assumption is that <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> in XPL/I has the same behavior as HAL/S's <font color="#663300"><code>EXIT</code></font>.<br></p>
<p>For example, consider the following XPL/I code:<br></p>
<blockquote><font color="#663300"><code>...</code><code></code></font><br>
  <font color="#663300"><code></code><code>MYBLOCK: </code><code></code></font><br>
  <font color="#663300"><code></code><code>DO ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; DO ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ESCAPE; /* Escape #1 */</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESCAPE MYBLOCK; /* Escape #2 */</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; END;</code><code></code></font><br>
  <font color="#cc0000"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Escape #1 comes here! */</code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code></font><br>
  <font color="#663300"><code>END;</code></font><br>
  <font color="#cc0000"><code></code><code>/* Escape #2 comes here! */</code></font><br>
  <font color="#663300"><code>...</code></font><br>
  <font color="#663300"><code></code></font></blockquote>
<font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> also appears in those same two forms:<br>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font> <br></code></font></li><li><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> <i>LABEL</i>;</code></font> </li>
</ul>
And again, there's a <font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font></code></font>
 keyword in HAL/S as well.&nbsp; In this case, though, from examining 
the actual usage in HAL/S-FC source code, I believe that while the 
keyword has a <i>similar</i> behavior in HAL/S and XPL/I, there is 
nevertheless a distinction between them.&nbsp; Here's what I believe the
 behavior is in XPL/I:<br>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font></code><font color="#000000"> </font></font>— "Repeats" the smallest enclosing <font color="#663300"><code>DO ... END</code></font>.  In case the smallest enclosing <font color="#663300"><code>DO ... END </code></font>is a loop — <font color="#663300"><code>DO WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font> or <font color="#663300"><code>DO I = X TO Y</code></font> — saying that it "repeats" has a pretty clear meaning: XPL/I <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> is like a Python or C <font color="#663300"><code>continue</code></font> statement.  On the other hand, if the immediately-enclosing <font color="#663300"><code>DO ... END</code></font> is <i>not</i> a loop, the expected behavior is less clear; nor are there any instances of <font color="#663300"><code>REPEAT</code></font> in non-loops in legacy XPL/I code from which we might get a clue.&nbsp; <b>XCOM-I</b> implements <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
 without a label simply as a jump to the beginning of the block, which 
means that you could form an infinite loop if there were no other code 
(like <font color="#663300"><code>ESCAPE</code></font> or <font color="#663300"><code>GO TO</code></font>) to exit the loop.</li>
<li><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> <i>LABEL</i>;</code></font> — Breaks out of inner loops as needed, until reaching an enclosing <font color="#663300"><code>DO ... END</code></font> loop that has the attached <i><font color="#663300"><code>LABEL</code></font></i>. <i>That's</i> the block that it repeats.</li>
</ul><ul>
</ul>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; The way my XPL/I implementation is different from HAL/S is that in HAL/S, <font color="#663300"><code>REPEAT</code></font> (without a label) goes to the beginning of the innermost enclosing <i>loop</i> (<font color="#663300"><code>DO WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font> or <font color="#663300"><code>DO I = X TO Y</code></font>) rather than the innermost enclosing <font color="#663300"><code>DO ... END</code></font>.&nbsp; Which makes sense, since that's what you'd normally want.<br>
  </font></blockquote>
<b>Note:</b>&nbsp; Neither <font color="#663300"><code>ESCAPE</code></font> nor <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> accepts a label attached to an arbitrary statement.&nbsp; It must be a label attached to a <font color="#663300"><code>DO ... END</code></font> block, and it must at some level enclose the <font color="#663300"><code>ESCAPE</code></font> or <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> statement itself.<br>
<h3>Counter Value After Normal Loop Termination<br>

</h3>

<font color="#663300"><code></code></font>For XPL code such as<br>
<blockquote>
  <pre><font color="#663300">DO I = 1 to 100;<br>    ...<br>END;</font><br></pre>
</blockquote>
it appears to be undocumented what value <font color="#663300"><code>I</code></font>
 holds after the loop ends.&nbsp; Not all computer languages handle this
 in the same way.&nbsp; My considered opinion is that the loop counter 
holds the value at which the condition for continuation fails: in this 
example, 101.&nbsp; Or, if the loop is broken prematurely (as with <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> from the preceding section), then the value the counter held when the <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> occurred is retained.<br>
<blockquote><font size="-1"><b>Aside:</b></font>&nbsp; This would match the behavior of C.&nbsp; Whereas in Python, for 
example, the counter for an equivalent loop would have the value 100 
rather than 101 after normal termination of the loop.<br>
</blockquote>
<h3><a name="programOptions"></a>Program Options</h3>
<p>The topic of program options is a confusing one, because there are 
many different programs under discussion, and all or most of them have 
their own sets of program options, or sometimes even their own unique 
ways of specifying those options.  There's <b>XCOM-I</b>, whose program options you can discover with the command "<font color="#663300"><code>XCOM-I.py --help</code></font>".  Then too, when you use <b>XCOM-I</b> to compile an XPL or XPL/I program, <b>XCOM-I</b> endows the executables it produces with a uniform set of options; if (say) you had compiled an XPL program such as <i>MyProgram</i>.xpl, via a command like "<font color="#663300"><code>XCOM-I.py <i>MyProgram</i>.xpl</code></font>", you could find out what <i><b>MyProgram</b></i>'s uniform options were with the command "<i>MyProgram</i> --help".<br></p>
<p>But that tells us only about options that are the same in all 
programs of the XCOM-verse.  What about options that influence the XPL 
or XPL/I program itself in program-specific ways?  What options specific to <i>MyProgram</i>.xpl are there, and how can those options be selected?&nbsp; What options did (say) <b>HAL/S-FC</b> have originally, and how are those options applied to it now?<br></p>
<p>Originally, programs run on the IBM 360 would have been associated 
with Job Control Language (JCL) cards that (among other things) would 
have set the program options via what's called the "PARM field".  For 
example, in these JCL "EXEC" cards,<br></p>
<blockquote>
  <pre><font color="#663300">// XPL  EXEC  PGM=MONITOR,<br>//            PARM='SYTSIZE=1800,REFSIZE=2000,LISTING2,$I,$V,$U,$W'<br>...</font><br></pre>
</blockquote>
the PARM field is <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=2000,LISTING2,$I,$V,$U,$W'</code></font>.&nbsp; Of course, we have no JCL in our <b>XCOM-I</b> framework, but the equivalent would be the <font color="#663300"><code>--parm</code></font> command-line option, <i>à la</i><br>
<blockquote>
  <pre><font color="#663300"><i>MyProgram</i> --parm=<code>'SYTSIZE=1800,REFSIZE=2000,LISTING2,$I,$V,$U,$W'</code></font></pre>
</blockquote>
Such a PARM field consists of individual options (or parameters), 
separated by commas (and no spaces surrounding the commas).&nbsp; So in 
this example, the parameters being selected for <i><b>MyProgram</b></i> are<br>
<blockquote>
  <pre><font color="#663300">SYTSIZE=1800<br>REFSIZE=2000<br>LISTING2<br>$I<br>$V<br>$U<br>$W</font><br></pre>
</blockquote>
As for how these parameters get from the PARM field to the XPL or XPL/I 
program itself — i.e., how do you write XPL code to access the 
parameters? —  there is unfortunately no standardized method.&nbsp; In 
the vision of <i>A Compiler Generator</i>, a vision which Intermetrics shared, there's an assembly-language program called the <i>submonitor</i>, separate from <b><i>MyProgram</i></b>,
 that parses the PARM field to find the individual parameters and 
decides what to do with them.&nbsp; Some of the parameters may influence
 the submonitor itself, and never even be made available to the XPL 
program at all.&nbsp; Others may be used to set the values of variables 
used by the XPL program.&nbsp; For example, McKeeman (p. 251) suggests 
some "possible" parameters, and McKeeman's sample submonitor 
program (XMON.bal) does various things with parameters of those 
suggested names.&nbsp; Indeed, I think all of McKeemans suggested parameters 
affect only the submonitor, which doesn't exist at all in <b>XCOM-I</b>, so none of these suggested options are implemented in <b>XCOM-I</b>.&nbsp; Or at least, not supported in the same way, as you'll see some or all of them reappear in a little bit.<br>
<br>
In other words, there's not meaningful support for program parameters for <i>standard</i> XPL in <b>XCOM-I</b>, because standard XPL itself had no standard method for dealing with them. <br>
<br>
For XPL/I, on the other hand, Intermetrics had an elaborate set of parameters for <b>HAL/S-FC</b>, as well as a system for making those parameters available available to the XPL/I program.&nbsp; <b>XCOM-I</b>
 fully supports passing these Intermetrics parameters to the XPL/I 
program.&nbsp; Take a look at the first page of a report from a typical 
run of <b>HAL/S-FC</b>:<br>
<blockquote>
  <pre><font color="#009900">  HAL/S REL32V0           T H E   V I R T U A L   A G C   P R O J E C T            MAY 17, 2024    16:43:5.39     PAGE 1<br><br><br>   HAL/S COMPILER PHASE 1 -- VERSION OF MAY 17, 2024.  CLOCK TIME = 9:15:17.00.<br><br><br>TODAY IS MAY 17, 2024.  CLOCK TIME = 16:43:5.39.<br> <br> PARM FIELD: TITLE=T H E   V I R T U A L   A G C   P R O J E C T<br><br><br> COMPLETE LIST OF COMPILE-TIME OPTIONS IN EFFECT<br><br><br>       *** TYPE 1 OPTIONS ***<br> <br>        NOADDRS<br>        NODECK<br>        NODUMP<br>        NOHALMAT<br>        NOHIGHOPT<br>        NOLFXI<br>        NOLIST<br>        NOLISTING2<br>        NOLSTALL<br>        NOPARSE<br>        NOREGOPT<br>          SCAL<br>        NOSDL<br>        NOSREF<br>        NOSRN<br>        NOTABDMP<br>          TABLES<br>        NOTABLST<br>        NOVARSYM<br>          ZCON<br><br><br>       *** TYPE 2 OPTIONS ***<br> <br>       BLOCKSUM = 400<br>       CARDTYPE = <br>       COMPUNIT = 0<br>            DSR = 1<br>      LABELSIZE = 1200<br>         LINECT = 59<br>      LITSTRING = 2500<br>      MACROSIZE = 500<br>          PAGES = 2500<br>        SYMBOLS = 200<br>          TITLE = T H E   V I R T U A L   A G C   P R O J E C T<br>       XREFSIZE = 2000<br> <br><br> *** NO LANGUAGE SUBSET IN EFFECT ***</font><br></pre>
</blockquote>
As you can see, the first thing such a typical run does is to print the PARM field as is, then then to print a list of the 
individual parameters in effect.&nbsp; Parameters are categorized as either "Type 
1", which means that they are simple on/off settings, or else as "Type 
2", which means that they accept numerical or string values.&nbsp; For 
example, the option allowing for production of HALMAT by <b>HAL/S-FC</b>'s first pass is of Type 1:&nbsp; It is turned "on" with the parameter <font color="#009900"><code>HALMAT</code></font> or turned "off" with the parameter <font color="#009900"><code>NOHALMAT</code></font>; its default is "off" (<font color="#009900"><code>NOHALMAT</code></font>).&nbsp;
 (Don't worry about the fact that you don't know what "HALMAT" is, or 
why one might want to produce it.)&nbsp; Whereas the option that 
overrides the company name in the page heading is of Type 2:&nbsp; Its 
default value is an empty string, meaning "don't override" the default 
company name, but in this case I've overridden it via a PARM field of <font color="#663300"><code>--parm='TITLE=T H E&nbsp;&nbsp; V I R T U A L&nbsp;&nbsp; A G C&nbsp;&nbsp; P R O J E C T'</code></font>.&nbsp;
 Notice that parameters whose values are strings are not enclosed in 
quotes, which might mean that a string parameter such as this one cannot
 contain a comma.<br>
<br>
In addition to Type 1 and Type 2, parameters are also categorized as <i>printable</i> or <i>unprintable</i>.&nbsp;
 The only distinction is that "printable" ones are printed out on the 
first page of the output listing, and the "unprintable" ones are 
not.&nbsp; In other words, there a lots of other parameters whose values <i>aren't</i> shown in the sample printout above.&nbsp; So there are actually 3 separate categories of parameters:&nbsp; Type 1 
printable, Type 1 unprintable, and Type 2 printable.&nbsp; (While in 
principle there are Type 2 unprintable parameters also, there are none presently 
defined in any existing options processor.)<br>
<blockquote><font size="-1"><b>Aside:</b> There are several exceptions too.  The parameter <font color="#009900"><code>LFXI</code></font> / <font color="#009900"><code>NOLFXI</code></font> is categorized as "non-printable" and yet special code was apparently inserted into <b>HAL/S-FC</b> to make it print anyway; the comments in the code explicitly say so.  The same section of code, on the other hand, explicitly <i>prevents</i> printing of the parameters <font color="#009900"><code>QUASI</code></font> and <font color="#009900"><code>TRACE</code></font>, even though they're categorized as printable. </font><br>
</blockquote>
I should note that not all of the parameters are documented ... though I
 suppose by now you probably shouldn't be very surprised by that.&nbsp; 
There's pretty good documentation of quite a few of them in the HAL/S-FC
 User's Manual (<a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/HAL_S-FC%20User's%20Manual%20Nov%202005.pdf#page=65">see Section 5.0</a>), and some less-reliable documentation in <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=830">IR-182 Sections 13.4</a> and <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=59">3.3</a>,
 which I assume you'll be able to read without my predigesting it for 
you.&nbsp; (That's a lie, by the way; I just don't understand all of 
them well enough to regurgitate them, or else I'm sure I would!)<br>
<blockquote><font size="-1"><b><a name="titan"></a>Aside:</b>&nbsp; I will comment on one of the parameters, though, namely the <font color="#663300"><code>TITLE</code></font>
 parameter.&nbsp; As I mentioned above, it's used to change the name of 
the company name in the page headings of printouts.&nbsp; The default 
company name is <font color="#663300"><code>'T I T A N&nbsp; S Y S T E M S&nbsp; C O R P .'</code></font>&nbsp; The program comments indicate that it was changed in March of 2002 from "Intermetrics".&nbsp; Why?&nbsp; According to <a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/AverStar">Wikipedia</a>,
 Intermetrics went through a sequence of mergers, acquisitions, and name
 changes, at one point of which was a merger with the Titan Corporation 
in March of 2000.&nbsp; So I guess that a couple of years after that, 
somebody was finally instructed to enshrine this change in the <b>HAL/S-FC </b>
source code.&nbsp; Naturally, that only lasted a couple of years before 
Titan was acquired by L-3 Communications.&nbsp; I wonder if the name was
 ever updated after that?&nbsp; Our copy of <b>HAL/S-FC</b> seems to be from 
mid-2005, so presumably the final name change wouldn't have had a chance
 to percolate into the source code yet by that point.</font><br>
</blockquote>



Parameters are delivered to the XPL/I program via the <font color="#663300"><code>MONITOR(13)</code></font> function.&nbsp; (<a moz-do-not-send="true" href="#MONITOR13">See here</a>
 to read about the precise mechanism.)&nbsp; In brief, there are several
 "options processors" available to parse the PARM field and provide the 
parsed contents to the XPL/I program.&nbsp; These options processors are
 specific to the XPL/I program you're compiling.&nbsp; The existing 
options processors built into the runtime library go by the names<br>
<ul>
  <li>COMPOPT (default).&nbsp; [Note that this is the options processor appropriate for <b>PASS1</b> of <b>HAL/S-FC</b>.&nbsp; Subsequent passes of <b>HAL/S-FC</b> prior to <b>PASS4</b> do not use <font color="#663300"><code>MONITOR(13)</code></font>, but instead receive command-line parameters from <b>PASS1</b> via <font color="#663300"><code>COMMON</code></font> memory.]<br>
</li>
  <li>LISTOPT.&nbsp; [Note that this is the options processor appropriate for <b>PASS4</b> of <b>HAL/S-FC</b>.]<br>
</li>
  <li>MONOPT<br></li>
</ul>
With <font color="#663300"><code>MONITOR(13)</code></font>, <i>one</i> 
of those options processors is selected; there's no mixing-and-matching 
allowed.&nbsp; We'll get to the topic of what to do if none of these 
meets your needs in a moment.<br>
<br>
If the XPL/I program being compiled is <b>HAL/S-FC</b>, these existing 
options processors can have different behavior depending when compiling 
the Primary Flight Software (PFS) vs the Backup Flight Software (BFS), 
vs compiling for the IBM 360 ... by which I mean that different options 
are supported in these cases.&nbsp; The following table gives very brief
 summary of the parameters supported by each existing options processor.<br>
<blockquote><font size="-1"><b>Note:</b>&nbsp; In the Type 1 sections of the table, what's given are the parameters to <i>enable</i> the settings.&nbsp; The parameters to <i>disable</i>
 the settings are the same, but prefixed by "NO"; for example, LISTING2 
vs NOLISTING2.&nbsp; Many of the parameters (both Type 1 and Type 2) 
also allow you to use an abbreviated nickname; for example, if you're 
too lazy to type LISTING2, you can instead use the nickname L2.&nbsp; If
 you want to negate a parameter nickname, you can prefix it with "N" (<i>not</i>
 "NO"); for example L2 vs NL2.&nbsp; In other words, LISTING2=L2 and 
NOLISTING2=NL2. &nbsp; Moreover, each parameter has a default value 
that's used if you don't explicitly specify a new one.&nbsp; In the table below, the 
parentheses after the parameter names give both the default values and 
the nicknames (if any).</font><br>
</blockquote>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>PARM-Field Options</b></font></caption>
  <tbody>
    <tr>
      <td valign="top" align="center"><b>COMPOPT<br>
PFS</b><br>
      </td>
      <th valign="top" align="center">COMPOPT<br>
BFS<br>
      </th>
      <th valign="top" align="center">COMPOPT<br>
360<br>
      </th>
      <td valign="bottom" align="center"><b>LISTOPT</b></td>
      <th valign="bottom" align="center">MONOPT</th>
    </tr>
    <tr>
      <td rowspan="1" colspan="5" valign="top" align="center"><i>Type 1, Printable</i><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">DUMP (off, DP)<br>
      </td>
      <td valign="top" align="center">DUMP (off, DP)</td>
      <td valign="top" align="center">DUMP (off, DP)</td>
      <td valign="top" align="center">TABLST (off, TL)<br>
      </td>
      <td valign="top" align="center">DUMP (off, DP)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LISTING2 (off, L2)<br>
      </td>
      <td valign="top" align="center">LISTING2 (off, L2)<br>
      </td>
      <td valign="top" align="center">LISTING2 (off, L2)</td>
      <td valign="top" align="center">TABDMP (off, TBD)<br>
      </td>
      <td valign="top" align="center">LISTING2 (off, L2)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LIST (off, L)<br>
      </td>
      <td valign="top" align="center">LIST (off, L)<br>
      </td>
      <td valign="top" align="center">LIST (off, L)</td>
      <td valign="top" align="center">ALL (off)<br>
      </td>
      <td valign="top" align="center">ALTER (off)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TRACE (on, TR)<br>
      </td>
      <td valign="top" align="center">TRACE (on, TR)<br>
      </td>
      <td valign="top" align="center">TRACE (on, TR)</td>
      <td valign="top" align="center">BRIEF (off)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">VARSYM (off, VS)<br>
      </td>
      <td valign="top" align="center">VARSYM (off, VS)<br>
      </td>
      <td valign="top" align="center">DECK (off, D)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">DECK (off, D)<br>
      </td>
      <td valign="top" align="center">DECK (off, D)<br>
      </td>
      <td valign="top" align="center">TABLES (on, TBL)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TABLES (on, TBL)<br>
      </td>
      <td valign="top" align="center">TABLES (on, TBL)<br>
      </td>
      <td valign="top" align="center">TABLST (off, TL)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TABLST (off, TL)<br>
      </td>
      <td valign="top" align="center">TABLST (off, TL)<br>
      </td>
      <td valign="top" align="center">ADDRS (off, A)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">ADDRS (off, A)<br>
      </td>
      <td valign="top" align="center">ADDRS (off, A)<br>
      </td>
      <td valign="top" align="center">SRN (off)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SRN (off)<br>
      </td>
      <td valign="top" align="center">SRN (off)<br>
      </td>
      <td valign="top" align="center">SDL (off)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SDL (off)<br>
      </td>
      <td valign="top" align="center">SDL (off)<br>
      </td>
      <td valign="top" align="center">TABDMP (off, TBD)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TABDMP (off, TBD)<br>
      </td>
      <td valign="top" align="center">TABDMP (off, TBD)<br>
      </td>
      <td valign="top" align="center">ZCON (on, Z)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">ZCON (on, Z)<br>
      </td>
      <td valign="top" align="center">ZCON (on, Z)<br>
      </td>
      <td valign="top" align="center">FCDATA (off, FD)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">HALMAT (off, HM)<br>
      </td>
      <td valign="top" align="center">HALMAT (off, HM)<br>
      </td>
      <td valign="top" align="center">SCAL (on, SC)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">REGOPT (off, R)<br>
      </td>
      <td valign="top" align="center">SCAL (on, SC)<br>
      </td>
      <td valign="top" align="center">MICROCODE (on, MC)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">MICROCODE (on, MC)<br>
      </td>
      <td valign="top" align="center">MICROCODE (on, MC)<br>
      </td>
      <td valign="top" align="center">SREF (off, SR)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SREF (off, SR)<br>
      </td>
      <td valign="top" align="center">SREF (off, SR)<br>
      </td>
      <td valign="top" align="center">QUASI (off, Q)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">QUASI (off, Q)<br>
      </td>
      <td valign="top" align="center">QUASI (off, Q)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TEMPLATE (off, TP)<br>
      </td>
      <td valign="top" align="center">REGOPT (off, R)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">HIGHOPT (off, HO)<br>
      </td>
      <td valign="top" align="center">TEMPLATE (off, TP)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">HIGHOPT (off, HO)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td rowspan="1" colspan="5" valign="top" align="center"><i>Type 1, Unprintable</i><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">PARSE (off, P)<br>
      </td>
      <td valign="top" align="center">PARSE (off, P)<br>
      </td>
      <td valign="top" align="center">PARSE (off, P)<br>
      </td>
      <td valign="top" align="center">X3 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LSTALL (off, LA)<br>
      </td>
      <td valign="top" align="center">LSTALL (off, LA)<br>
      </td>
      <td valign="top" align="center">LSTALL (off, LA)<br>
      </td>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LFXI (on)<br>
      </td>
      <td valign="top" align="center">LFXI (on)<br>
      </td>
      <td valign="top" align="center">LFXI (on)<br>
      </td>
      <td valign="top" align="center">X5 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X1 (off)<br>
      </td>
      <td valign="top" align="center">X1 (off)</td>
      <td valign="top" align="center">X0 (off)</td>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center">X1 (off)</td>
      <td valign="top" align="center">X7 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X5 (off)</td>
      <td valign="top" align="center">X5 (off)</td>
      <td valign="top" align="center">X2 (off)</td>
      <td valign="top" align="center">X8 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center">X3 (off)</td>
      <td valign="top" align="center">X9 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XB (off)</td>
      <td valign="top" align="center">XB (off)</td>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center">XD (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XC (off)</td>
      <td valign="top" align="center">XC (off)</td>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center">XE (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XE (off)</td>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center">XB (off)</td>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XC (off)</td>
      <td valign="top" align="center">XG (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XE (off)</td>
      <td valign="top" align="center">XH (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center">XI (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XJ (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XK (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XL (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XM (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XN (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XO (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XP (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td rowspan="1" colspan="5" valign="top" align="center"><i>Type 2, Printable</i><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TITLE ("", T)<br>
      </td>
      <td valign="top" align="center">TITLE ("", T)</td>
      <td valign="top" align="center">TITLE ("", T)</td>
      <td valign="top" align="center">TITLE ("", T)<br>
      </td>
      <td valign="top" align="center">LINECT (59, LC)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LINECT (59, LC)<br>
      </td>
      <td valign="top" align="center">LINECT (59, LC)</td>
      <td valign="top" align="center">LINECT (59, LC)</td>
      <td valign="top" align="center">LINECT (59, LC)<br>
      </td>
      <td valign="top" align="center">PAGES (250, P)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">PAGES (2500, P)<br>
      </td>
      <td valign="top" align="center">PAGES (2500, P)</td>
      <td valign="top" align="center">PAGES (250, P)<br>
      </td>
      <td valign="top" align="center">PAGES (10000, P)<br>
      </td>
      <td valign="top" align="center">MIN (50000)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SYMBOLS (200, SYM)<br>
      </td>
      <td valign="top" align="center">SYMBOLS (200, SYM)</td>
      <td valign="top" align="center">SYMBOLS (200, SYM)<br>
      </td>
      <td valign="top" align="center">LIST (1, L)<br>
      </td>
      <td valign="top" align="center">MAX (5000000)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">MACROSIZE (500, MS)<br>
      </td>
      <td valign="top" align="center">MACROSIZE (500, MS)</td>
      <td valign="top" align="center">MACROSIZE (500, MS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">FREE (14336)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LITSTRINGS (2000, LITS)<br>
      </td>
      <td valign="top" align="center">LITSTRINGS (2000, LITS)</td>
      <td valign="top" align="center">LITSTRINGS (2000, LITS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">COMPUNIT (0, CU)<br>
      </td>
      <td valign="top" align="center">COMPUNIT (0, CU)</td>
      <td valign="top" align="center">COMPUNIT (0, CU)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XREFSIZE (2000, XS)<br>
      </td>
      <td valign="top" align="center">XREFSIZE (2000, XS)</td>
      <td valign="top" align="center">XREFSIZE (2000, XS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">CARDTYPE ("", CT)<br>
      </td>
      <td valign="top" align="center">CARDTYPE ("", CT)</td>
      <td valign="top" align="center">CARDTYPE ("", CT)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LABELSIZE (1200, LBLS)<br>
      </td>
      <td valign="top" align="center">LABELSIZE (1200, LBLS)</td>
      <td valign="top" align="center">LABELSIZE (1200, LBLS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">DSR (1)<br>
      </td>
      <td valign="top" align="center">DSR (1)</td>
      <td valign="top" align="center">DSR (1)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">BLOCKSUM (400, BS)<br>
      </td>
      <td valign="top" align="center">BLOCKSUM (400, BS)</td>
      <td valign="top" align="center">BLOCKSUM (400, BS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">MFID ("")<br>
      </td>
      <td valign="top" align="center">OLDTPL ("", 0)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>If you've been eagerly absorbing every detail I've discussed — and I fail to see any reason you <i>wouldn't</i> have! — then you'll recall that <b>HAL/S-FC</b> has seven passes (<b>PASS1</b>, <b>FLO</b>, <b>OPT</b>,
 and so on), each of which is a stand-alone program.&nbsp; So you'll 
wondering why (or more likely, thanking your lucky stars) that I've 
listed a bunch of "<b>HAL/S-FC</b> options", without instead listing seven separate tables of <b>PASS1</b>'s options, <b>FLO</b>'s options, etc.&nbsp; That's because all of these PARM-field options were fed only into <b>PASS1</b>.&nbsp; The other passes accessed the options only via invormation passed to them by <b>PASS1</b> in <font color="#663300"><code>COMMON</code></font> memory, in some pre-digested form.<br>
<br>
In addition to these named parameters, <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=830">early documentation</a> indicates that <i>control toggles</i>
 can also appear in the PARM field. <br>

<br>

Control toggles are 
two-character strings which normally would be embedded in program 
comments.&nbsp; Generally speaking, program comments are ignored by 
compilers.&nbsp; But when these particular two-character strings are 
found within a program comment of an XPL program, they are used to 
enable certain program features from the point they appear until a 
countermanding control toggle is found.&nbsp; The control toggles I'm aware of that were supported by one or another version of <b>XCOM</b> are listed below.&nbsp; Not all of them are necessarily suitable for command-line usage anyway; for example, the action of "<font color="#663300"><code>$|</code></font>"
 depends on its particular punch-card column in which it appears.&nbsp; The list below has been merged 
from McKeeman (p. 148), IR-182-1 (section 13.4), and SUNY XCOM 4.5 
source code:<br>

<ul>

  <li><font color="#663300"><code>$B</code></font> — Interlist code bytes in hexadecimal.</li>
  <li><font color="#663300"><code>$D</code></font> — Print compilation statistics and symbol table at the end of compilation (initially enabled).</li>
  <li><font color="#663300"><code>$E</code></font> — Interlist emitted code (assembly format) and data.</li>
  <li><font color="#663300"><code>$I</code></font> — Print Impact 
summary, indicating variables outside the scope of any procedure which 
were referenced, plus procedures called.&nbsp; (Default = Off.)<br>
  </li>
  <li><font color="#663300"><code>$L</code></font> — List the compiled program (listing is initially enabled).</li>
  <li><font color="#663300"><code>$M</code></font> — List program without auxiliary information (speeds compilation by minimizing string storage usage).</li>
  <li><font color="#663300"><code>$N</code></font> — Produce a warning message if a procedure is called with fewer actual than formal parameters.</li>
  <li><font color="#663300"><code>$Q</code></font> — This toggle seems to have been available for a while and then discontinued.&nbsp; It <i>may</i> have caused compilation to terminate after processing the library file.<br>
  </li>
  <li><font color="#663300"><code>$R</code></font> — Collect cross-reference data for each symbol (based on statement numbers) and print with symbol table. (Default = On.)<br>
  </li>
  <li><font color="#663300"><code>$S</code></font> — Dump symbol table at the end of each procedure, if any local data is declared. (Default = Off.)<br>
  </li>
  <li><font color="#663300"><code>$T</code></font> — Begin tracing execution of XCOM at this point, during compilation.</li>
  <li><font color="#663300"><code>$U</code></font> — Terminate tracing of XCOM.</li>
  <li><font color="#663300"><code>$V</code></font> — Expand variable 
cross reference to include names of procedures referencing data and 
names of procedures calling other procedures.&nbsp; (Default = Off.)</li>
  <li><font color="#663300"><code>$X</code></font> — Do not abort compilation when ceiling on count of severe errors has been exceeded.<br>
  </li>
  <li><font color="#663300"><code>$Y</code></font> — Use <font color="#663300"><code>'|'</code></font> as margin marker rather than <font color="#663300"><code>'I'</code></font>.<br>
  </li>
  <li><font color="#663300"><code>$Z</code></font> — Allow the compiled program to execute in spite of severe errors.</li>
  <li><font color="#663300"><code>$|</code></font> — Set margin.&nbsp; 
The portion of succeeding cards starting from the column containing the |
 will be ignored.&nbsp; Note that this can only be used to make the card
 width <i>shorter</i> than 80 columns.<br>
  </li>
</ul>

If control 
toggles were able to appear in the PARM field (as well as inside of 
program comments), then in effect they'd act like unnamed Type 1 
parameters.&nbsp; Indeed, you can see examples of these in the sample 
JCL cards I showed you at the top of this section.&nbsp; But I am unclear as to 
whether control toggles survived into the latest versions of XPL/I or 
not, and whether they're acceptable in PARM fields.&nbsp; Currently, parameters with a leading '<font color="#663300"><code>$</code></font>'
 are 
accepted (in the sense that there's no error message or abend) in PARM 
fields, but 
ignored.&nbsp; However, in <b>XCOM-I</b>, there is a command-line option that can be made 
to serve the same purpose as control toggles in the PARM field:&nbsp; 
The <font color="#663300"><code>--extra=<i>N</i>,'<i>STRING</i>'</code></font> option causes the <font color="#663300"><code><i>STRING</i></code></font> to be returned to the XPL program upon the first invocation of <font color="#663300"><code>INPUT(<i>N</i>)</code></font>; subsequent invocations of <font color="#663300"><code>INPUT(<i>N</i>)</code></font> get data from the file attached to input <font color="#663300"><code><i>N</i></code></font>.&nbsp; So for example, if you wanted to use the control toggle <font color="#663300"><code>$E</code></font>, but didn't want to modify your XPL source code to add it into a comment, you could use the command-line option <font color="#663300"><code>--extra=0,'/* $E */'</code></font>.<br>

<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; </font><font size="-1">Again, to be clear, <b>XCOM-I</b>
 itself has no cognizance whatever of control toggles.&nbsp; Control 
toggles, if available, are provided to and used by legacy versions of <b>XCOM</b> which <b>XCOM-I</b> may have compiled for yo</font>
</blockquote>





If you're writing <i>new</i> XPL or XPL/I programs, of course, then 
these specific options processors aren't going to satisfy your 
needs.&nbsp; There are still ways you can process options for your own 
custom purposes.&nbsp; I don't want to go into
 great detail, since it's unclear who (if anybody) will actually be 
producing any new XPL programs, so here I'll just give it the 
once-over-lightly.&nbsp; There are three different approaches of greater
 or 
lesser difficulty and (in)convenience.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Several of the possible approaches involve providing your own C code to supplement the C code output by <b>XCOM-I</b> when it translates your XPL or XPL/I source code.&nbsp; That can be done via <font color="#663300"><code>CALL INLINE</code></font>
 statements in your XPL/I source code, but it's rather cumbersome to do 
so.&nbsp; A more-elegant way is to instead create an entire C 
source-code file, and then just place it into the folder of C code 
created by <b>XCOM-I</b>.&nbsp; Such a file should have an '<font color="#663300"><code>#include "runtimeC.h"</code></font>'
 in it, and proceed from there.&nbsp; If it involves any active code, 
versus compile-time initialization of variables, you'll still have to 
have a </font><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font></font> in your XPL/I code to actually call the new C function you've defined.<br>
    <br>
    <b>Very importan</b><b>t</b>:&nbsp; Any custom file you put into <b>XCOM-I</b>'s output folder for any given project will be <u><i>deleted</i></u> the next time <b>XCOM-I</b> builds that project.&nbsp; So make sure it's not your <i>only</i> copy!&nbsp; In this sense, using a filesystem link to your custom C file is safer than using the file itself.<br>
  </font></blockquote>

<ol>
  <li><a moz-do-not-send="true" href="#builtin">The built-in library function</a> <font color="#663300"><code>PARM_FIELD</code></font> returns a string containing the value of the <font color="#663300"><code>--parm</code></font> command-line switch as-is.  You could therefore just write XPL code to parse <font color="#663300"><code>PARM_FIELD</code></font>.  This will be your easiest course of action.</li>
  
  
<li>Or if you would prefer to do things "the Intermetrics way", you can 
devise an options processor that takes advantage of the machinery 
already in the <b>XCOM-I</b> runtime library.  This lets you feed in your parameters using the <font color="#663300"><code>--parm</code></font>
 command-line switch, using the same "PARM"/"NOPARM" syntax as the other
 options processors.  If you look at the source-code file 
XCOM-I/runtimeC.c, you'll find several instances of a datatype called <font color="#663300"><code>optionsProcessor_t</code></font>,
 which is a structure whose definition you can examine in the file 
runtimeC.h.  Basically, it's just a structure listing all of the Type 1 
and Type 2 parameter names, their abbreviated nicknames, the negations 
of both types of names, the default value of the parameter, and a 
"mask".  I'll explain what a mask is in a moment.  I hope it will be 
reasonably clear from looking at those examples just how to make your 
own custom <font color="#663300"><code>optionsProcessor_t</code></font>.  If you can do that, you'll be ready for XPL/I calls to <font color="#663300"><code>MONITOR</code></font> of the form "<font color="#663300"><code>CALL MONITOR(13, 'USEROPT');</code></font>".  Here, <font color="#663300"><code>'USEROPT'</code></font> is literal; you don't get a choice of what to call it. The C code you need to create to do all of that doesn't require any <font color="#663300"><code>CALL INLINE</code></font> statements, and looks something like the following:</li>
</ol>
<blockquote>
  <blockquote>
    <pre><font color="#663300">#include "runtimeC.h"<br>optionsProcessor_t <i>myOptionsProcessor</i> = {<br>	... <br>};<br>USEROPT = &amp;<i>myOptionsProcessor</i>;</font><br></pre>
  </blockquote>
</blockquote>
<ol>

</ol>

<ol start="3">
  <li>Or you could provide C code to directly process <font color="#663300"><code>argv[] </code></font>and <font color="#663300"><code>argc</code></font>.  
This may be the hardest approach of all, since as you'll recall, XPL 
variables are not modeled as C variables.  To get any parsed parameters 
into XPL variables requires numerically knowing the addresss at which 
the variables reside in the simulated IBM 360 memory (C array <font color="#663300"><code>memory</code></font>),
 as well as knowing the names of the C functions to convert the values 
into IBM 360 formats.  While there's only a handful of such functions (<font color="#663300"><code>putFIXED</code></font>, <font color="#663300"><code>putCHARACTER</code></font>, ...), I have not documented them as of yet, nor indeed <i>any</i> of the functions used privately by <b>XCOM-I</b>'s runtime library.</li>
</ol>
<p>As far as the "mask" is concerned, among the items returned by the <font color="#663300"><code>MONITOR(13)</code></font> function is a 32-bit (<font color="#663300"><code>FIXED</code></font>) value referred to as the "options code" or the "option bits".  Each type 1 parameter sets or resets (or <i>can</i>
 be made to set or reset) one bit position in the options code.  That's 
what the "mask" is:  A specification of the bit (or combination of bits)
 the parameter sets.  For example, the LISTING2 parameter is associated 
with mask 0x00000002, and therefore will bitwise OR the options code 
with 2; whereas NOLISTING2 would bitwise AND the options code with ~2 
(0xFFFFFFFE).    Or you can just use a mask of 0x00000000, and your new 
parameter(s) will leave the options code untouched.<br></p>

<blockquote>
</blockquote>

<font color="#663300"><code></code></font>
<ul>

</ul>

<h3><a name="builtin"></a>Built-In Runtime-Library Functions</h3>
<p>Standard XPL has a variety of so-called "built-ins", comprising 
runtime-library functions callable from XPL code.  Some of these 
bullt-ins can appear on either the right-hand or left-hand side of 
assignments, and some have to be <font color="#663300"><code>CALL</code></font>'d like user-defined <font color="#663300"><code>PROCEDURE</code></font>s.
 XPL/I has roughly the same built-ins, plus-or-minus a few, mostly (but 
not entirely) defined to have the same functionality.  The compiler 
recognizes these built-ins, and there is no need for them to be declared
 in any way prior to use.  Since these built-ins were mostly written 
originally in IBM System/360 basic assembly language, the runtime 
library supplied with XCOM-I has been entirely written in C, without any
 reference to the original runtime-library source code.<br></p>
<p>The list below is from McKeeman (p. 140-142), with some alterations 
due to XPL/I, and some hopefully-helpful notes from me.  The parameter 
descriptions in the list below identify the datatypes of parameters by 
the following convention:<br></p>
<ul>
  <li><font color="#663300"><code>FIXED</code></font> — <code><font color="#663300">NE</font></code><font color="#663300"><code><sub>x</sub></code></font></li>
  <li><font color="#663300"><code>CHARACTER</code></font> descriptor — <font color="#663300"><code></code><code>DE<sub>x</sub></code></font></li>
  <li>Symbolic name of a variable, with or without a subscript — <font color="#663300"><code></code><code>V</code></font></li></ul>
<p>I suppose I should make it clear that the <b>XCOM-I</b> environment 
is not precisely like that envisaged in the original XPL language as 
confined to an IBM 360 runtime environment, and as such, built-in 
functions don't work exactly the same way either.  What's described here
 is how <i>the </i><i><b>XCOM-I</b></i><i> runtime library's functions </i>corresponding to the original built-in functions work.<br></p>
<ul>

</ul>

<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>Built-Ins</b></font></caption>
  <tbody>
    <tr>
      <th valign="bottom" align="center">Library Function<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ABS(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the absolute value of <font color="#663300"><code>NE</code></font>.&nbsp;
 (Note: "80000000", the maximum negative number, has no representable 
absolute value and returns "7FFFFFFF", the maximum positive number.)<br>
      </td>
      <td valign="middle">(XPL/I only.)<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ADDR(V)</code></font></td>
      <td valign="middle">A function with numeric value which is the (at most) 24-bit absolute address of the variable (subscripted or not) <font color="#663300"><code>V</code></font>.&nbsp; Mostly used in conjunction with <font color="#663300"><code>COREWORD</code></font> or <font color="#663300"><code>COREBYTE</code></font>.<br>
      </td>
      <td valign="middle">If the variable has a subscript, then the 
returned address is that of a specific array element, rather than of the
 beginning of the array.&nbsp; For a <font color="#663300"><code>CHARACTER</code></font> or long <code><font color="#663300">BIT</font></code> string (i.e., for <font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> datatypes), the returned address is that of the <i>descriptor</i>
 for the variable, and if you want to find the actual data, you then 
must first fetch the value of the descriptor and then massage it 
further.&nbsp; For XPL/I's <font color="#663300"><code>BASED</code></font> variables (see IR-182-1 p. 13-3), using the unsubscribed name of the variable for <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> will return the address in memory where the pointer to the <font color="#663300"><code>BASED</code></font> variable's data is stored; whereas adding the subscript <font color="#663300"><code>(0)</code></font> to <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> returns the address of the variable's data itself.<br>
<br>
There are two exceptional cases, due to the fact that unlike the original XPL compilers, program code in <b>XCOM-I</b>
 exists in a separate memory space outside of the simulated XPL memory 
in which variable exist.&nbsp; Therefore, attempts to use <font color="#663300"><code>ADDR(V)</code></font>
 to find addresses in code space, such as addresses of XPL built-ins or 
of program labels, have to be treated very differently than addresses of
 variables, if sensible results are to be obtained.<br>
<br>
Insofar as addresses of runtime-library functions are concerned, the only case I'm aware of is <font color="#663300"><code>ADDR(DESCRIPTOR)</code></font>.&nbsp; In this case, <font color="#663300"><code>ADDR</code></font> returns the address immediately following <a moz-do-not-send="true" href="#common"><font color="#663300"><code>COMMON</code></font> memory</a>.&nbsp; The reason for this <i>ad hoc</i> behavior is that the XPL/I memory-management system (SPACELIB) uses the location of the built-in variable <font color="#663300"><code>DESCRIPTOR</code></font> (see below) to determine the cutoff between <font color="#663300"><code>COMMON</code></font> (in low memory) and non-<font color="#663300"><code>COMMON</code></font>
 (in higher memory).&nbsp; But I realized this fact too late in the 
development process, after I had made decisions about implementation and
 memory layout that were incompatible with the interpretation of <font color="#663300"><code>DESCRIPTOR</code></font> as a normal variable with the desired properties.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp;&nbsp; It isn't <i>terribly</i>
 difficult to undo the incompatible design decisions I mentioned, and 
sometime in the future I may do so.&nbsp; Technically, I think it's 
mainly a matter of swapping <a moz-do-not-send="true" href="#MemoryModel">memory regions 2 and 3</a>.&nbsp; Again technically, it is necessary for <a moz-do-not-send="true" href="#basedManagement">the dope vectors of all BASED variables</a> to reside in the lowest 64K of memory, so it would have the effect of reducing the possible number of non-<font color="#663300"><code>COMMON BASED</code></font> variables; fortunately, if existing XPL/I code is any guide, that's a pretty-negligible problem.<br>
</font></blockquote>Insofar as program labels are concerned, as far as I
 know, there's no mechanism in XPL itself for using the memory address 
of a program label.&nbsp; Consequently, the only reason for finding the 
address of an XPL program label is that assembly language (in a <font color="#663300"><code>CALL INLINE</code></font>) wants either to branch to that address, or else to somehow use the data in another <font color="#663300"><code>CALL INLINE</code></font> at that address.&nbsp; But this notion is based on various assumptions that are false in <b>XCOM-I</b>. &nbsp; Nevertheless, in spite of that fact, we still need some uniform method of handling such "addresses" that allows <font color="#663300"><code>ADDR</code></font> and <font color="#663300"><code>CALL INLINE</code></font> to interact smoothly.&nbsp; <br>
<br>
<b>XCOM-I</b> handles addresses of XPL labels as follows:&nbsp; The labels in any <font color="#663300"><code>PROCEDURE</code></font> are assigned a predictable sequence of unique <i>negative</i>
 addresses.&nbsp; Thus the first label encountered has the address -1, 
the second has address -2, and so on.&nbsp; The addresses are local to 
the <font color="#663300"><code>PROCEDURE</code></font>, and restart at -1 in each <font color="#663300"><code>PROCEDURE</code></font>.&nbsp; <font color="#663300"><code>ADDR</code></font> returns these negative addresses.&nbsp; C implementations of the branch instructions in <font color="#663300"><code>CALL INLINE</code></font> statements can exploit that by having a jump table of a form similar to:<br>
<blockquote>
  <pre>switch (address) {<br>  case -1: goto LABEL1;<br>  case -2: goto LABEL2;<br>  ...<br>}<br></pre>
</blockquote>
Admittedly, this is not a terribly-efficient solution, but C has no 
practical computed-goto other than this, as far as I'm aware. <br>
<blockquote><font size="-1">
  </font></blockquote>

</td></tr><tr><td valign="middle" align="center"><font color="#663300"><code>BYTE(DE,NE)<br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> 8 bits of the string described <font color="#663300"><code>DE</code></font>.<br>
      </td>
      <td valign="middle">By "string", McKeeman means either <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT</code></font> data.&nbsp; As far as <font color="#663300"><code>BIT</code></font> data is concerned, this function works for any data-width; i.e., for <font color="#663300"><code>BIT(1)</code></font> through <font color="#663300"><code>BIT(2048)</code></font>, and not just for "long" <font color="#663300"><code>BIT</code></font> string.&nbsp; However, there's some difference between how <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT</code></font> data is treated.&nbsp; <font color="#663300"><code>BIT</code></font> data is retrieved from memory as-is, whereas <font color="#663300"><code>CHARACTER</code></font>
 data is transparently translated between EBCDIC encoding (in memory) vs
 ASCII encoding (for manipulation) by the software.&nbsp; The latter 
behavior is specific to <b>XCOM-I</b>, and wouldn't have been needed by the original <b>XCOM</b>, since back then, all <font color="#663300"><code>CHARACTER</code></font>
 data was encoded in EBCDIC all the time, whether or not it resided in 
"memory".&nbsp; Moreover, if you try to do so, it is possible to fool <b>XCOM-I</b>'s <font color="#663300"><code>BYTE</code></font>
 function into thinking an area of memory is a different datatype than 
it really is, thus defeating the translation mechanism ... so please 
don't try to do that.<br>
        <br>
Note that <font color="#663300"><code>BYTE</code></font> can appear 
either in an expression (such as on the right-hand side of an assignment), in which case it returns a value as just 
described, or else on the left-hand side of an assignment, in which case
 it modifies the value stored in memory.&nbsp; McKeeman recommends not using <font color="#663300"><code>BYTE</code></font> on the left-hand side of an assigment, due to the possibility of unintended consequences.<br>
        <br>
The documentation does not explain what's supposed to happen if <font color="#663300"><code>NE</code><code>&lt;0</code></font> or <font color="#663300"><code>NE</code><code>&gt;=len(</code><code>DE</code><code>)</code></font>.&nbsp; Alas, that's not a theoretical question, because such uses of <font color="#663300"><code>BYTE</code></font> really appear in legacy XPL code.&nbsp; Given the sloppy subscripting accepted by XPL, my guess is that <font color="#663300"><code>BYTE</code></font> just grabs whatever happens to reside wherever <font color="#663300"><code>NE</code></font>
 leads it.&nbsp; Unlike the usual sloppy subscripting in XPL code, this 
would almost certainly be a mistake by the programmer, because the 
location of string data in memory is dynamically assigned and liable to 
change during the course of execution, so the programmer can't really 
know reliable what lies beyond the bounds of a string.&nbsp; Thus my 
guess is that when <font color="#663300"><code>NE</code></font> is out 
of bounds for the string size, it's probably a mistake on the part of 
the program that was never detected because it never produced any error 
messages.<br>
        <blockquote><font size="-1"><b>Aside:</b> For example, it happens in the <font color="#663300"><code>SCAN</code></font> procedure of <b>XCOM</b>, in the vicinity of line 835 at this writing,<br>
          </font>
          <blockquote>
            <pre><font size="-1" color="#663300">CP = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>DO WHILE BYTE(TEXT, CP) = BYTE(' ') &amp; CP &lt;= TEXT_LIMIT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>   CP = CP + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>END;&nbsp;&nbsp;</font><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></pre>
          </blockquote>
          <font size="-1">where <font color="#663300"><code>TEXT</code></font> happens to be a string with <font color="#663300"><code>LEN(TEXT)=1</code></font> containing a single blank space, and <font color="#663300"><code>TEXT_LIMIT=0</code></font>.&nbsp; Here, <font color="#663300"><code>BYTE(TEXT,CP)</code></font> is out of bounds on the very first iteration of the loop.&nbsp; In C, if the operands of the <font color="#663300"><code>&amp;</code></font> operator were reversed, then <font color="#663300"><code>BYTE(TEXT,CP)</code></font> would never be executed, and the problem would be avoided.&nbsp; But <i>if</i>
 that kind of optimization of conditionals is a feature of XPL, it's not
 a feature that's mentioned anywhere to my knowledge, and <b>XCOM-I</b> does not attempt it.</font><br>
        </blockquote>
Whether or not that's a true in interpretation, in <b>XCOM-I</b> the <font color="#663300"><code>BYTE</code></font> function returns a value of 0 (corresponding to an EBCDIC <font color="#663300"><code>NUL</code></font>) if <font color="#663300"><code>NE</code></font> is out of bounds, or else silently does nothing at all if on the left-hand side of an assignment.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE)<br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>BYTE(DE,0)</code></font></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>CLOCK_TRAP<br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.</td>
      <td valign="middle">And it's not supported in <b>XCOM-I</b> either.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COMPACTIFY<br>
          </code></font></td>
      <td valign="middle">A procedure called automatically to repack the free storage 
area for string data when it is exhausted. Calls can be triggered by <font color="#663300"><code>||</code></font>, <font color="#663300"><code>INPUT</code></font>, number-to-string conversions, or an explicit call:<br>
        <blockquote><font color="#663300"><code>CALL COMPACTIFY;<br>
            </code></font></blockquote>
        <font color="#663300"><code></code></font>The variables <font color="#663300"><code>FREEBASE</code></font>, <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>FREEPOINT</code></font>, <font color="#663300"><code>DESCRIPTOR</code></font>, and <font color="#663300"><code>NDESCRIPT</code></font> are used by <font color="#663300"><code>COMPACTIFY</code></font>.<br>
        <font color="#663300"><code></code></font></td>
      <td valign="middle">The "free-storage area" is where the data for <font color="#663300"><code>CHARACTER</code></font> and long <font color="#663300"><code>BIT</code></font>-string
 variables is stored.&nbsp; As a program which involves string variables
 executes, the strings tend to change size and move around in the 
free-storage area, thus causing unused "holes" in memory to 
develop.&nbsp; <font color="#663300"><code>COMPACTIFY</code></font> repacks the area so as to remove the holes.<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; While long <font color="#663300"><code>BIT</code></font>-strings (&gt;32 bits) are technically similar to <font color="#663300"><code>CHARACTER</code></font>
 strings, they differ in the fact that the amount of storage they 
require is determined at compile-time and does not change after 
that.&nbsp; The original McKeeman and Intermetrics compilers therefore 
stored them outside of the free-storage area — or at least in the very 
lowest addresses of the free-string area </font><font size="-1"><font size="-1">—</font>
 in order to save any execution time that would otherwise have been 
wasted during allocation of memory or garbage allocation.&nbsp; <b>XCOM-I</b>
 is not so picky, since even the most feeble modern computer will be 
approximately 14.3926 gazillion times faster than an IBM 360 was.&nbsp; <b>XCOM-I</b>
 thus saves (me) a little effort by grouping the long bit strings with 
the character strings in memory, at an immeasurably-small cost in 
execution time.</font><br>
</blockquote>
XPL/I's <font color="#663300"><code>BASED</code></font> variables are stored in a separate memory region and do not participate in garbage collection by <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp; <a moz-do-not-send="true" href="#MemoryModel">See the earlier discussion of this</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREBYTE(NE)<br>
          </code></font></td>
      <td valign="middle">A byte array identical to the IBM System/360 
memory.&nbsp; The subscript is the absolute byte address of the byte 
selected.&nbsp; <font color="#663300"><code>COREBYTE</code></font> may be used on either side of the replacement operator (i.e., <font color="#663300"><code>=</code></font>).<br>
      </td>
      <td valign="middle">The function returns a <font color="#663300"><code>FIXED</code></font>
 value, if used in an expression, but only the least-significant 8 bits 
contain the value.&nbsp; Similarly, if used on the left-hand side of an 
assignment, it receives a <font color="#663300"><code>FIXED</code></font> value from the right-hand side, but only stores the least-significant 8 bits at the specified memory address.&nbsp; The <b>XCOM-I</b> version of this function performs no EBCDIC translation as <font color="#663300"><code>BYTE</code></font> (see above) does, so it does not expect the data in memory to be <font color="#663300"><code>CHARACTER</code></font> data.&nbsp; Whether this will turn out to be an issue remains to be seen.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREWORD(NE)<br>
          </code></font></td>
      <td valign="middle">Like <font color="#663300"><code>COREBYTE</code></font>, except the subscript corresponds to the word address in memory.&nbsp; Thus an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code></font>.<br>
      </td>
      <td valign="middle">Since XPL has only a 24-bit address space, only the least-significant 3 bytes of the "4-byte word address" <font color="#663300"><code>NE</code></font> are used.&nbsp; According to IR-182-1 (p. 13-3), this function <i>differs</i> in XPL/I as follows:<br>
        <blockquote><font size="-1">According to "<i>A COMPILER GENERATOR</i>", <font color="#663300"><code>NE</code></font> is a word index, or word-aligned address. However, in the Intermetrics version, <font color="#663300"><code>NE</code></font> must be a byte address, and the user must himself guarantee that the lower-most two bits are 0's (full word aligned).</font><br>
        </blockquote>
I <i>think</i> that what's being implied by this cryptic comment is that McKeeman's <font color="#663300"><code>COREWORD</code></font> in XPL worked like this:<br>
        <ul>
          <li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(2) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li>and so on.</li>
        </ul>
        <p>whereas Intermetrics's <font color="#663300"><code>COREWORD</code></font> in XPL/I worked like this:<br></p>
        <ul>
<li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(2)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(3)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(4)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(5)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(6)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(7)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(8) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(9)</code></font> is illegal.</li>
<li>and so on.</li>
        </ul>
        <p>To my way of thinking, McKeeman's description doesn't say 
what IR-182-1 says it says, and unfortunately, McKeeman's clarification 
that "an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code><font color="#000000">", does not in fact clarify it very much either.<br></font></font></p>
        <p><font color="#663300"><font color="#000000"><b>XCOM-I</b> 
conforms to the latter (Intermetrics) usage, with the exception that 
addresses like 1, 2, 3, 5, 6, 7, 9, ... are perfectly fine:  </font></font><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(1)</code></font> through <font color="#663300"><code>COREBYTE(4)</code></font>, and so on.  Which conforms just fine to the description in McKeeman as well, if not necessarily to McKeeman's actual usage.<br></p>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In point of fact, </font><font size="-1"><font color="#663300"><code>COREWORD</code></font>
 is not used in any software written in standard XPL that's available to
 me, so I cannot determine empirically which of these choices (if 
either) is correct.&nbsp; If it is somehow discovered later that 
McKeeman's <b>XCOM</b> really does need to behave in the manner Intermetrics claimed that it did, then <b>XCOM-I</b>'s <font color="#663300"><code>--xpl</code></font>
 command-line switch will be extended to select between the two 
behaviors.&nbsp; But I don't intend to waste any effort implementing 
that until/unless I have enough evidence to justify it.&nbsp; For now, 
it's a moot point.</font><br>
        </blockquote>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE<br>
          </code></font></td>
      <td valign="middle">A function with the numeric value of the date, coded as<br>
        <blockquote>(day of year) + 1000 * (year - 1900)<br>
        </blockquote>
      </td>
      <td valign="middle">McKeeman doesn't inform us of anything so mundane as the time zone to which the <font color="#663300"><code>DATE</code></font> and <font color="#663300"><code>TIME</code></font> built-ins relate, at least not in the text of the book.&nbsp; <b><br>
</b><br>
I have been told that McKeeman would have use local time here.&nbsp; The
 submonitor function supplying this value would appear to be called <font color="#663300"><code>GETIME</code></font>, and identical versions of <font color="#663300"><code>GETIME</code></font> are used by the <b>XCOM3</b>, <b>XCOM45</b>, and <b>HAL/S-FC</b>
 submonitors, so if McKeeman used local time, then all other legacy 
compilers available at present did so as well.&nbsp; Exactly how <font color="#663300"><code>GETIME</code></font> works isn't clear to me.&nbsp; But if what I understand from looking at the <i>IBM System/360 Operating System MFT Supervisor</i>
 manual is correct, the IBM 360 seems to have had no conception of UTC 
at all, or for that matter, of local timezones either; it simply knew 
whatever time and date the operator&nbsp; manually input into the system
 at each power-up, and what the operator was supposed to input was the <i>local</i> time and date.<br>
<br>
Consequently, the <font color="#663300"><code>DATE</code></font> and <font color="#663300"><code>TIME</code></font> built-ins return the local date and time, according to whatever locale your computer is set for.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>DATE</code></font> during compilation of the program being run.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>DATE</code></font> above.
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DESCRIPTOR(NE)<br>
          </code></font></td>
      <td valign="middle">The description of the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> string as a numeric value.<br>
      </td>
      <td valign="middle">This cryptic description is 
referring to the fact that in the way memory is allocated for the 
variables declared by <b>XCOM</b>, the 32-bit string descriptors for all <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT(n)</code></font> (<font color="#663300"><code>n</code></font>&gt;32) variables appear consecutively in memory.&nbsp; By symbolically labeling the very first of those descriptors as <font color="#663300"><code>DESCRIPTOR</code></font>, and treating <font color="#663300"><code>DESCRIPTOR</code></font> as of the <font color="#663300"><code>FIXED</code></font> datatype, <font color="#663300"><code>DESCRIPTOR</code></font>
 becomes an easily-accessible array of all the string descriptors.&nbsp;
 This is useful, for example, for memory-management procedures like <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp; The number of elements of the array is given by the built-in <font color="#663300"><code>NDESCRIPT</code></font> (see below).<br>
</td></tr><tr><td valign="middle" align="center"><font color="#663300"><code>EXIT</code><code><br>
          </code></font></td>
      <td valign="middle">A procedure<br>
        <blockquote><font color="#663300"><code>CALL EXIT;</code></font><br>
        </blockquote>
which causes an abnormal exit form XPL execution. <br>
      </td>
      <td valign="middle">In fact, <b>XCOM-I</b> models this a C-language <font color="#663300"><code>exit(1)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FILE(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">An array-valued pseudovariable for manipulation of random-access bulk storage.&nbsp; Examples of its use are<br>
        <blockquote><font color="#663300"><code>DECLARE BUFF(3600) BIT(8);</code><code><br>
            </code><code>BUFF = FILE(I, J);</code><code><br>
            </code><code>FILE(I-1, J) = BUFF;</code></font><br>
        </blockquote>
One record is transferred into or out of the buffer array by the 
assignments shown above.&nbsp; FILE cannot appear on both sides of the 
same assignment.&nbsp; <br>
      </td>
      <td valign="middle"><a name="file"></a>I've actually truncated McKeeman's 
description of <font color="#663300"><code>FILE</code></font>, because it is so long and so much of it is specific to IBM 
System/360, while being quite irrelevant to us.&nbsp; The key facts are 
these:<br>
        <ul>
          <li>"Random access files" may be attached to the running program.&nbsp; <br></li>
          <li>Once attached, they are identified by a "device number" that ranges from 1 to 9.&nbsp; <br></li>
          <li>Each attached random-access file may be for input-only, output-only, or both.&nbsp; <br></li>
          <li>Each of the attached files consists of records of a fixed size.</li>
          <li>Different files may have different record sizes.</li>
          <li>These random-access files, and the associated <font color="#663300"><code>FILE</code></font> operations, are <i>completely distinct</i> from the "sequential files" (numbered 0 through 9) accessed via the <font color="#663300"><code>INPUT</code></font> and <font color="#663300"><code>OUTPUT</code></font> functions (see below).</li>
<li>Record sizes <i>typically</i> do not change during program execution.  (But see the continued comments below.)</li>
        </ul>
By default, no random-access files are attached to programs.&nbsp; 
Originally (back in 1970), they were attached at runtime via Job Control
 Language (JCL) <font color="#663300"><code>DD</code></font> 
cards.&nbsp; But with programs compiled via XCOM-I, files are attached 
at program startup by using the program's command-line switches.&nbsp; 
The relevant switch is <font color="#663300"><code>--raf</code></font>, and multiple instances can be used on the same command line.<br>
        <blockquote><font color="#663300"><code>--raf=<i>I,R,N,F</i></code></font><br>
        </blockquote>
The parameters of the <font color="#663300"><code>--raf</code></font> switch are:<br>
        <ul>
          <li><font color="#663300"><code>I</code></font> is either a 
literal I (for "input"), a literal O (for "output"), or a literal B (for
 "both input and output").  Note that for O, an empty file will always 
be created by the program; for B, if there's an existing file of the 
specified name, then it will be used, but an empty file will be created 
otherwise.</li>
          <li><font color="#663300"><code>R</code></font> is the record 
size associated with the file.  3600 and 7200 are typical values, but 
not the only ones in use.  They must match the expectations of the 
program's XPL code for using the data.</li>
          <li><font color="#663300"><code>N</code></font> is the device number, from 1 through 9, to which the file should be attached.</li>
          <li><font color="#663300"><code>F</code></font> is the relative or absolute path to the file.</li>
        </ul>
        
<p>In spite of what I said above, the XPL/I documentation (IR-182-1, p. 
13-5) does describe one way to change the record size of a random-access
 file once the program has begun operation, and that is via a call to <font color="#663300"><code>MONITOR(4,R,N)</code></font> (see below), where <font color="#663300"><code>R</code></font> and <font color="#663300"><code>N</code></font> have the same meanings as for <font color="#663300"><code>--raf</code></font>.  It also tells us that such a call must precede the first use of <font color="#663300"><code>FILE(N)</code></font>.  <b>XCOM-I</b>
 relaxes this restriction, though it seems that the original restriction
 should be treated as very good advice to follow.  Note, by the way, 
that the call to <font color="#663300"><code>MONITOR(4,R,N)</code></font>
 has no way to distinguish between input files and output files, so its 
record-size manipulation is applied simultaneously to input file <font color="#663300"><code>N</code></font> and output file <font color="#663300"><code>N</code></font>, if they differ.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEBASE</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the top of constant strings and thus the bottom of the repackable area.<br>
      </td>
      <td valign="middle">In <b>XCOM-I</b>, this is implemented as a function rather than a variable, and is not directly modifiable by user code.&nbsp; <br>
        <br>
What the description from the original documentation is trying to say is that most kinds of variables — such as <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(1)</code></font> types, or descriptors for <font color="#663300"><code>CHARACTER</code></font> or long <font color="#663300"><code>BIT</code></font>-string types, or arrays thereof, or pointers to <font color="#663300"><code>BASED</code></font>
 variables — are stored in memory at low addresses determined at compile
 time, and remain unchanged in address thereafter.&nbsp; In contrast, 
data for <font color="#663300"><code>CHARACTER</code></font> variables can grow or shrink or move at runtime.&nbsp; <font color="#663300"><code>FREEBASE </code></font>is the boundary between those regions of memory.<br>
        <br>
In <b>XCOM-I</b>, data allocated at runtime via the <font color="#663300"><code>MONITOR(6,...)</code></font> or <font color="#663300"><code>MONITOR(19,...)</code></font> function (see below), sometimes for storing data of for <font color="#663300"><code>BASED</code></font> variables,  also appears above the <font color="#663300"><code>FREEBASE</code></font> boundary.<font color="#663300"><code></code></font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREELIMIT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the last usable byte in the string-data area. <br>
      </td>
      <td valign="middle">I believe that the description lies, and that <font color="#663300"><code>FREELIMIT</code></font> is the first unusable byte beyond the string-data area, rather than the last usable byte in it.<br>
<br>
In XPL, all memory beyond <font color="#663300"><code>FREELIMIT</code></font> is unused by the program.&nbsp; In XPL/I, the data for <font color="#663300"><code>BASED</code></font> variables is stored at <font color="#663300"><code>FREELIMIT</code></font> and above.&nbsp; However, the memory-management technique for is to push <font color="#663300"><code>FREELIMIT</code></font> <i>downward</i> in order to make room for <font color="#663300"><code>BASED</code></font> variables.&nbsp; So for either XPL or XPL/I, the <i>initial</i> value of <font color="#663300"><code>FREELIMIT</code></font> is the highest memory location used by the program.&nbsp; XCOM-I sets the initial value of <font color="#663300"><code>FREELIMIT</code></font> at <font color="#663300"><code>"FFFC00"</code></font> (i.e., 1024 bytes below the top of physical memory), in order to leave a small amount of space for <font color="#663300"><code>COMPACTIFY</code></font> to use as scratch memory.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEPOINT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the next free byte in the string-data area.&nbsp; When <font color="#663300"><code>FREEPOINT</code></font> passes <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>COMPACTIFY</code></font> must be called.<br>
      </td>
      <td valign="middle">In other words, at any given time, only the memory region between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available for dynamically-allocating new free memory for <font color="#663300"><code>BASED</code></font> variables or <font color="#663300"><code>CHARACTER</code></font> variables.&nbsp; as the program continues to execute, dynamic memory allocation and subsequent memory-freeing may cause <font color="#663300"><code>FREEPOINT</code></font> to steadily creep upward, and the area from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> to become increasingly fully of unusable holes.&nbsp; Eventually, <font color="#663300"><code>COMPACTIFY</code></font> will be <i>automatically</i> called, repacking the data to eliminate the holes, and moving <font color="#663300"><code>FREEPOINT</code></font> downward in memory once again.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INLINE(NE<sub>1</sub>,...)<br>
          </code></font></td>
      <td valign="middle">Inserts arbitrary IBM System/360 machine code directly into the instruction stream.<br>
      </td>
      <td valign="middle">The applicability of the original 
functionality has change drastically in the 55 years (as of this 
writing) since <i>A Compiler Generator</i> was written.&nbsp; <b>XCOM-I</b>
 provides three different mechanisms for supporting direct insertion of 
inline non-XPL code, none of which are identical to those in 
McKeeman.&nbsp; Thankfully, no available legacy <i>standard</i> XPL program I've encountered contains any <font color="#663300"><code>CALL INLINE</code></font> statements, so the difficulties presented by them are limited to XPL/I code such as <b>HAL/S-FC</b>.<br>
<br>
<b>Support mechanism 1:&nbsp; insertion of C code</b><br>
        <br>
        You can use <br>
        <blockquote><font color="#663300"><code>CALL INLINE('<i>C-language source code</i>');</code></font><br>
        </blockquote>
to insert an arbitrary 
string of C-language source code directly into the instruction stream.&nbsp; If
 the string contains newline characters (<font color="#663300"><code>'\n'</code></font>), then a single <font color="#663300"><code>INLINE</code></font>
 can insert multiple lines of C code.&nbsp; But recall that an XPL 
string can be no longer than 256 characters, so the inserted C code can 
be no longer than 256 characters in any one <font color="#663300"><code>CALL INLINE</code></font> statement.<br>
        <br>
<b>Support mechanism 2:&nbsp; insertion of IBM 360 machine code</b><br>
<br>
<b>XCOM-I</b> will automatically translate IBM 360 machine code to 
C.&nbsp; Full-blown IBM 360 emulation is not provided, but support is 
available for those IBM 360 instructions used in XPL code I have 
personally encountered, which includes the entire source-code base of <b>HAL/S-FC</b>.&nbsp; Instructions that are not (yet) supported cause compilation to abort.<br>
<br>
This feature is not normally enabled.&nbsp; You must use the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--auto-inline</code></font> to enable it.<br>
<br>
<b>Support mechanism 3:&nbsp; other</b><br>
<br>
If <font color="#663300"><code>--auto-inline</code></font> is not 
enabled (see support mechanism 2 above), any CALL INLINE statements not 
caught by support mechanism 1 are commented out by default, but 
"patched" with C code if a "patch file" is available.&nbsp; &nbsp; <a moz-do-not-send="true" href="#hooks">This important but far from automatic mechanism is the topic of a later section</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the next record on input file <font color="#663300"><code>NE</code></font>.<br>
      </td>
      <td valign="middle">I've truncated McKeeman's rather roundabout description, because I don't find it very informative as-is to more-modern readers.<br>
        <br>
What McKeeman is trying to say is that any given program can have several files attached to it for so-called <i>sequential</i>
 input.&nbsp; You can think of these files as consisting of lines of 
text, and you can read them, one text-line at a time, by using the <font color="#663300"><code>INPUT</code></font> built-in function.&nbsp; For the original McKeeman <b>XCOM</b> (or the Intermetrics version of <b>XCOM</b>), the text in the sequential files would have been encoded in EBCDIC, but for use with <b>XCOM-I</b> they are encoded in ASCII.<br>
        <br>
Because XPL comes from the era and computing environment it did, it 
expects input to be supplied on computer punch cards.&nbsp; As such, it 
expects lines of input to actually be 80 columns wide, even if they need
 to be padded by spaces to do so.&nbsp; Not all XPL programs have 
problems with lines of other lengths have a problem with lines of a 
different length, but some do.&nbsp; Notably, the original <b>XCOM</b> is one of the programs that behaves incorrectly unless it gets its way.&nbsp; Because of that, <b>XCOM-I</b>'s built-in <font color="#663300"><code>INPUT</code></font> function transparently truncates lines to 80 columns or pads them 80 columns as necessary.<br>
        <br>
        <br>
There are up to 9 input files attached to the program, numbered, 0 through 9 — yes, I <i>know</i> that's 10 files, but just keep reading — and you access them via those "device numbers".&nbsp; For example,<br>
        <blockquote><font color="#663300"><code>DECLARE CHARACTER C;</code><code><br>
            </code><code>C = INPUT(5);</code></font><br>
        </blockquote>
reads a single line from sequential file number 5 into the variable <font color="#663300"><code>C</code></font>.<br>
        <blockquote><font size="-1"><b>Important:</b> These "sequential files" and the <font color="#663300"><code>INPUT</code></font> mechanism are completely separate from the "random-access files" described in <font color="#663300"><code>FILE</code></font>'s notes earlier!</font><br>
        </blockquote>
By default, there is a single sequential file attached to the program, though it is attached to <i>both</i> device number 0 and device number 1.&nbsp; The default attached file is <font color="#663300"><code>stdin</code></font>, and thus any text piped into the program via a redirector (<font color="#663300"><code>&lt;</code></font>) on the program's command line will be available on both <font color="#663300"><code>INPUT(0)</code></font> and <font color="#663300"><code>INPUT(1)</code></font>.<br>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In case you're wondering, I don't think that the reason two separate devices are associated with <font color="#663300"><code>stdin</code></font> is very deep or interesting.&nbsp; I imagine it's just kind of symmetric to the fact that <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below) are both attached by default to <font color="#663300"><code>stdout</code></font>.&nbsp; In situations like this I'm tempted to quote Emerson</font> <font size="-1">— "a foolish consistency is the hobgoblin of little minds" — but I suspect the decision was pragmatic rather than foolish.</font><br>
        </blockquote>
There's no explanation or obvious provision in the documentation for what happens when an end-of-file is reached, and <b>XCOM-I</b>
 makes no particular provision for it either.&nbsp; I suppose it must 
depend on the particular program.&nbsp; For example, some XPL programs 
assume that a blank line terminates a file.&nbsp; Other programs may 
look for special patterns, such as the string "EOF".&nbsp; <b>XCOM-I</b> returns an empty string for reads past the end of the file.<br>
        <br>
Additional input files can be attached via the program's command-line switch <font color="#663300"><code>--ddi</code></font>:<br>
        <blockquote><font color="#663300"><code>--ddi=<i>N,F</i></code></font><br>
        </blockquote>
Here, <font color="#663300"><code><i>F</i></code></font> is the pathname to the file, and <font color="#663300"><i><code>N</code></i></font>
 is the device number to which it should be attached.&nbsp; By the way, 
if you want to debug your program once it has been translated by <b>XCOM-I</b>
 to C and then the C has been compiled to an exectuable, I've sometimes 
found piping input into the program via a command-line redirector (<font color="#663300"><code>&lt;</code></font>)
 to be somewhat problematic.&nbsp; It's handy in those situations to 
override the default attachment of stdin to device 0 by using <font color="#663300"><code>--ddi=0,<i>F</i></code></font> instead of piping.&nbsp; <br>
        <br>
There is no way to change the attachments once the program is running, although there are <font color="#663300"><code>MONITOR</code></font> calls (see below) which can close attached files at runtime.<br>
        <br>
In XPL/I, there's an additional alternative, in which <i>Partioned Data Set</i> (PDS) files can be attached for use by <font color="#663300"><code>INPUT</code></font>
 instead of sequential files. A PDS is partitioned into sections, each 
with its own 8-character identifying name (right-padded with blanks if 
necessary).&nbsp; An attempted read past the end of a partition returns 
an empty string.<br>
        <br>
Only one partition of the PDS is available via <font color="#663300"><code>INPUT</code></font> at any given time, but <br>
        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(2, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
(see below) can be used at any time to switch device <font color="#663300"><code><i>N</i></code></font> to the partition whose name is contained in the string called <font color="#663300"><code><i>NAME</i></code></font>.&nbsp; The value returned, <font color="#663300"><code><i>F</i></code></font>, is 0 if the switch was successful, or 1 if there was no such partition.<br>
        <br>
A PDS is thus similar to a <i>folder</i> of sequential files, with the partition names corresponding to filenames within the folder.&nbsp; <br>
        <br>
By default, no there is no PDS attached to programs.&nbsp; However, a 
PDS can be attached for input via the program's command-line switch <font color="#663300"><code>--pdsi</code></font>:<br>
        <blockquote><font color="#663300"><code>--pdsi=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
Because of PDS similarity to folders, that's how they're implemented in <b>XCOM-I</b>. So <font color="#663300"><code><i>F</i></code></font> should be the pathname of a folder, and the partitions should be ASCII text files within the folder.&nbsp; <font color="#663300"><code><i>N</i></code></font>,
 of course, is the device number on which the attachment is to be 
made.&nbsp; However, no specific partition is selected for reading until
 the necessary <font color="#663300"><code>MONITOR(2, <i>N</i>, <i>NAME</i>)</code></font> call has been made.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT</code><code><br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>INPUT(0)</code></font><br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INTERRUPT_TRAP</code><code><br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.<br>
      </td>
      <td valign="middle">Not supported in <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LENGTH(DE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value equal to the number of characters in the string denoted by the parameter.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINE_COUNT</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the number of lines which have been printed on the SYSPRINT file since the last page eject.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; "SYSPRINT" refers to <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below).<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINK</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure performs the functions necessary to exit the current program phase and pass control to the next phase on the <font color="#663300"><code>PROGRAM DD</code></font> sequence, preserving <font color="#663300"><code>COMMON</code></font> data and any other dynamically allocated space which has not been deallocated.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; This refers to the notion 
that a sequence of XPL/I programs is being run via Job Control Language 
(JCL), with each program passing data to the next program in 
sequence.&nbsp; However, this <font color="#663300"><code>LINK</code></font> built-in is specific to the original computing environment, and performs no function in <b>XCOM-I</b>, which has a different mechanism sharing data between program passes.&nbsp; <a moz-do-not-send="true" href="#common">Refer to the extensive discussion concerning <font color="#663300"><code>COMMON</code></font> memory</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR(NE<sub>1</sub>,...)</code><code><br>
          </code></font></td>
      <td valign="middle">Calls the "submonitor".<br>
      </td>
      <td valign="middle">The "submonitor" is a separate program from 
whatever XPL or XPL/I program is being compiled and run, providing some 
kine of system-specific functionality.&nbsp; In so far as McKeeman is 
concerned, the submonitor's functionality and even it calling sequence 
was unknowable, and thus the McKeeman <b>XCOM</b> system simply discarded all calls to the submonitor.<br>
        <br>
Not so with XPL/I: There is an extensive set of functions provided by the submonitor, and the XPL/I program <b>HAL/S-FC</b> uses them extensively as well, so <b>XCOM-I</b>
 needs to support them.&nbsp; Most (I hope!) but not all submonitor 
functions are known from their descriptions in section 13.3 of 
IR-182-1.&nbsp; Besides which, <b>HAL/S-FC</b> source code contains the source code for <font color="#663300"><code>MONITOR</code></font> (written in IBM 360 Basic Assembly Language), from which additional information can be obtained.<br>
        <br>
Because of the complexity of <font color="#663300"><code>MONITOR</code></font>, <a moz-do-not-send="true" href="#monitor">an entire separate section is devoted to explaining it</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR_LINK</code><code><br>
          </code></font></td>
      <td valign="middle">A fixed array which can be used for transmission of information between a program and the submonitor.<br>
      </td>
      <td valign="middle">(See Table 8.4.6 in McKeeman.)&nbsp; I'm not presently aware of any need to implement this in <b>XCOM-I</b>.&nbsp; However, there are <font color="#663300"><code>MONITOR</code></font> functions (see above) whose operations remain a mystery, so there's a possibility that that could change.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>NDESCRIPT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the upper bound in the array <font color="#663300"><code>DESCRIPTOR</code></font> (see above) of the descriptions.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>DESCRIPTOR</code></font> above.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This is the analog of <font color="#663300"><code>INPUT</code></font> (see above) but for outputting textual data rather than inputting it.<br>
      </td>
      <td valign="middle">Most of the comments concerning <font color="#663300"><code>INPUT</code></font> (see above) are directly applicable to <font color="#663300"><code>OUTPUT</code></font>, or else are analogous in a very obvious way, so I'll try to confine my remarks to the clear differences between the two.<br>
        <br>
The most common use of <font color="#663300"><code>OUTPUT</code></font> is to "print" to the "SYSPRINT" device.&nbsp; Unlike the original <b>XCOM</b> computing environment, in which SYSPRINT was an actual printer, in <b>XCOM-I</b> SYSPRINT by default refers to <font color="#663300"><code>stdout</code></font>.&nbsp; And by default, <font color="#663300"><code>stdout</code></font> is attached to both <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font>. But there are differences between the two!&nbsp; Use of <font color="#663300"><code>OUTPUT(0)</code></font> is simpler, and therefore more common, but <font color="#663300"><code>OUTPUT(1)</code></font> is more flexible.&nbsp; Let's start with <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
Output statements via <font color="#663300"><code>OUTPUT(0)</code></font> might look something like this:<br>
        <blockquote><font color="#663300"><code>OUTPUT(0) = 'Hello, world!';</code><code><br>
            </code><code>OUTPUT(0) = 'Hello' || ',' || ' ' || 'world' || '!';</code><code><br>
            </code><code>OUTPUT(0) = 'This is OUTPUT statement number ' || 3;</code><code><br>
            </code><code>OUTPUT(0) = 25;</code></font><br>
        </blockquote>
Thus we can print any character strings or numbers we like, and can concatenate them using the string-concatenation operator (<font color="#663300"><code>||</code></font>), with <b>XCOM-I</b> doing the work of automatically converting numbers to strings where necessary.<br>
        <br>
Each use of <font color="#663300"><code>OUTPUT(0)</code></font> results in another physical line being printed.&nbsp; When printing messages with <font color="#663300"><code>OUTPUT</code></font>,
 since it is expected that the lines are being output to a physical 
printer, the system keeps track of the number of lines being printed, 
and automatically inserts page breaks in the output once a page has been
 filled up.&nbsp; At the tops of pages, a page number and optional 
headings and subheadings are also printed.&nbsp; The headings and 
subheadings, though, are simply whatever has been previously set up, and
 you can't change them or otherwise influence them using <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
With <font color="#663300"><code>OUTPUT(1)</code></font>, on the other 
hand, there's quite a bit of additional functionality.&nbsp; For 
example, it isn't necessarily true that each use of <font color="#663300"><code>OUTPUT(1)</code></font> prints another line.&nbsp; The <i>first</i> character of each <font color="#663300"><code>OUTPUT(1)</code></font> isn't directly printed, but instead is a "carriage-control character" (or "ANSI control character"), as follows:<br>
        <ul>
          <li>'<font color="#663300"><code> </code></font>' (i.e., a space) — Single-space the line and print.  This is the same behavior as <font color="#663300"><code>OUTPUT(0)</code></font>: i.e., any line you print to <font color="#663300"><code>OUTPUT(0)</code></font>, you could instead prefix it with a space character and send it to <font color="#663300"><code>OUTPUT(1)</code></font> instead.</li>
          <li>'<font color="#663300"><code>0</code></font>' — Double-space the line and print.</li>
          <li>'<font color="#663300"><code>-</code></font>' — Triple-space the line and print.</li>
          <li>'<font color="#663300"><code>+</code></font>' — Overstrike
 the preceding line.  In other words, go back to column 1, without 
advancing to the next line, and then print the remainder of the string. 
 Unfortunately, that's behavior suitable for a physical printer, but not
 really for outputting text to <font color="#663300"><code>stdout</code></font>
 on most computers today.&nbsp; Yes, we may be able to emulate it using 
strange maneuvers which most computers aren't set up for, but not in any
 universal, easily-set-up way.&nbsp; So in <b>XCOM-I</b>, the string is instead printed on a new line, almost as if the ANSI control character had been '<font color="#663300"><code> </code></font>'&nbsp; (see above) rather than '<font color="#663300"><code>+</code></font>'.&nbsp; Almost!&nbsp; You see, what these overstruck lines are mostly used for is underlining text.&nbsp; In <b>HAL/S-FC</b>,
 for example, text which has undergone replacement via macro expansion 
is underlined in compiler reports.&nbsp; The temptation is to mimic 
underlining by using underscore characters (_), but when underscore 
characters are printed on a separate line from the text they're 
underlining, they don't really look like underlining, but rather like 
overlining on the succeeding line ... which while it may be better than 
nothing, is absolutely <i>not</i> what you want it to look like!&nbsp; <b>XCOM-I</b>
 thus takes a slightly-different approach:&nbsp; It replaces such 
underscores by carats (^), which in my opinion are more-effective 
visually.&nbsp; For example, where one would have gotten something like <br>
</li></ul>
<blockquote>
  <blockquote>
    <pre><font color="#663300">... <code><u>MYTEXT</u> ...</code></font> </pre>
  </blockquote>
</blockquote>
<blockquote>on a line printer back in the olden times, today with <b>XCOM-I</b> you'll instead see the uglier but still effective<br>
</blockquote>
<blockquote>
  <blockquote>
    <pre><font color="#663300">... MYTEXT ...<br>    ^^^^^^</font><br></pre>
  </blockquote>
</blockquote>
<ul>

          <li>'<font color="#663300"><code>1</code></font>' — Form feed.
  I.e., advance to the top of the next page, regardless of how many 
left-over lines remain on the current page.  In <b>XCOM-I</b>, this is accomplished by embedding the ASCII form-feed character (<font color="#663300"><code>'\l'</code></font>) in the output.</li>
          <li>'<font color="#663300"><code>H</code></font>' — Heading 
line.  This doesn't print anything, but takes the remainder of the line 
and sets it as the heading for subsequent pages.</li>
          <li>'<font color="#663300"><code>2</code></font>' — Subheading
 line.  This doesn't print anything, but takes the remainder of the line
 and sets it as the subheading for subsequent pages.</li>
</ul>

<blockquote><b><font size="-1">Note:</font></b><font size="-1">&nbsp; What this explanation of </font><font size="-1"><font color="#663300"><code>OUTPUT(1)</code></font> fails to explain is what happens if the string <i>doesn't have</i>
 a first character; i.e., what if it's empty?&nbsp; Well, the obvious 
response would be that that would be an illegal use.&nbsp; Unfortunately
 for us, that obvious fact didn't stop some of the coders of <b>HAL/S-FC</b> from strewing their code — perhaps an exaggeration —  with assignments <font color="#663300"><code>OUTPUT(1) = ''</code></font>, thus forcing us to deal with it.&nbsp; Lacking any particular rationale for what such a thing might mean, <b>XCOM-I</b> treats it as <font color="#663300"><code>OUTPUT(0) = ''</code></font>; i.e., it prints a newline.<br>
  </font></blockquote>
If you experiment with <font color="#663300"><code>OUTPUT(1)</code></font>, and even to a certain extent with <font color="#663300"><code>OUTPUT(0)</code></font>, you may become very confused, because various things won't work as you expect.&nbsp; Or at least, <i>I</i> was very confused at first.&nbsp; To get past this confusion, you need to grasp the following<br>
        <blockquote><b>Very important point</b>:&nbsp; For the computer 
systems most people are familiar with today, when we print a line of 
text, we expect that line of text to end with an implicit advance to the
 next line; i.e., with a "newline" character, often signified in 
programming languages by <font color="#663300"><code>'\n'</code></font>.&nbsp; Whereas in System/360 (and therefore in XPL or XPL/I), the implicit newline occurs <i>prior</i> to the text being printed by the <font color="#663300"><code>OUTPUT</code></font> command.&nbsp; I.e., today we typically ask ourselves "what happens at the <i>end</i> of the line"", whereas for XPL you need to ask "what happens at the <i>beginning</i> of the line?".<br>
        </blockquote>
Similarly to <font color="#663300"><code>INPUT</code></font>, you can attach additional sequential output files (<font color="#663300"><code><i>F</i></code></font>) on device numbers (<font color="#663300"><code><i>N</i></code></font>),<br>

        <blockquote><font color="#663300"><code>--ddo=<i>N,F</i></code></font><br>
        </blockquote>

Or for Partitioned Data Sets,<br>
        <blockquote><font color="#663300"><code>--pdso=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
For selecting partitions of a PDS, you don't use the same <font color="#663300"><code>MONITOR</code></font> call as for <font color="#663300"><code>INPUT</code></font>, but instead use: <br>

        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(1, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
        <font color="#663300"><code>OUTPUT</code></font> commands 
targets for a PDS don't immediately write data to the physical 
PDS.&nbsp; Rather, the data being output is buffered in memory until the
 <font color="#663300"><code>MONITOR(1, <i>N</i>, <i>NAME</i>)</code></font> call occurs, and the data is then written out to the selected partition in its entirety.&nbsp; The return value (<font color="#663300"><code><i>F</i></code></font>)
 is 0 if the partition is new (i.e., if it didn't previously exist in 
the PDS), while it is 1 if the partion previously existed but has now 
been overwritten with entirely new contents.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT</code><code><br>
          </code></font></td>
      <td valign="middle">The same as <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>PARM_FIELD</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a character string which contains the entire parameter specification coded on the <font color="#663300"><code>PARM=</code></font> option on the <font color="#663300"><code>EXEC</code></font> card.&nbsp; If no <font color="#663300"><code>PARM</code></font> is specified, a null string will be returned.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; A program of any 
complexity generally has a number of options selectable at 
runtime.&nbsp; For XPL/I programs like <b>HAL/S-FC</b>, the mechanism for selecting such options was originally a Job Control Language (JCL) card such as:<br>
        <blockquote><font color="#663300"><code>PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font><br>
        </blockquote>
Thus, <font color="#663300"><code>PARM_FIELD</code><code> </code></font>would have had the value <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font> in such a case.<br>
        <br>
In <b>XCOM-I</b>, <font color="#663300"><code>PARM_FIELD</code></font> 
is implemented as a function rather than a variable, but nevertheless 
returns data of the kind described.&nbsp; Of course, there is no JCL 
supplying such parameters, but the compiled program nevertheless has a 
command-line option that does the same job:<br>
        <blockquote><font color="#663300"><code>--parm='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'<br>
</code></font></blockquote>
        <blockquote><b><font color="#663300"><code></code></font></b><font size="-1"><b>Aside:</b>
 Depending on your operating system, some trickery may be involved in 
correctly forming such a command-line option.&nbsp; In Linux or (I 
suppose) Mac OS, the command shell expects the dollar sign (<font color="#663300"><code>$</code></font>)
 to indicate that the value of an environment variable is desired.&nbsp;
 In other words, if the string in the command-line option shown above 
had no quotes, then (for example) <font color="#663300"><code>$I</code></font> would be replaced by the value of the environment-variable <font color="#663300"><code>I</code></font>
 ... probably a blank!&nbsp; And the same thing would happen if the 
option were enclosed in double-quotes.&nbsp; But by using single-quotes,
 we defeat that substitution, and <font color="#663300"><code>$I</code></font> is reported in </font><font size="-1"><font color="#663300"><code>PARM_FIELD</code></font> literally as <font color="#663300"><code>$I</code></font>.&nbsp; Alternate tricks to defeating substitution could include using the backslash (<font color="#663300"><code>'\'</code></font>) escape character in front of all dollar signs (<font color="#663300"><code>$</code></font>).&nbsp; <br>
            <br>
            <b>Aside:</b> It has been decades since I used Windows in 
any serious way, so I don't really know whether there's any similar 
problem with it.&nbsp; Probably not.</font><br>
        </blockquote>
        <font color="#663300"><code></code></font></td>
    </tr>
    <tr>
  <td valign="middle" align="center"><font color="#663300"><code>RECORD_WIDTH(V)</code></font><br>
  </td>
  <td valign="top"><br>
  </td>
  <td valign="middle">(XPL/I only.)&nbsp; IR-182-1 doesn't mention it, but it appears to me that <font color="#663300"><code>RECORD_WIDTH</code></font> is a new built-in in XPL/I which when given the symbolic name of a <font color="#663300"><code>BASED</code></font> variable returns the variable's record size (in bytes).&nbsp; In <b>HAL/S-FC</b>'s XPL/I source code (the only available example of use of <font color="#663300"><code>RECORD_WIDTH</code></font>), I find it used only for a couple of <font color="#663300"><code>BASED RECORD</code></font>
 variables, which makes sense according to the naming, but I have no way
 to tell just from those few examples what the actual applicability 
was.&nbsp; In <b>XCOM-I</b>, it will work for any <font color="#663300"><code>BASED</code></font> variable, <font color="#663300"><code>RECORD</code></font> or not.<br>
  </td>
</tr>
<tr>
      <td valign="middle" align="center"><font color="#663300"><code>SET_LINELIM(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure establishes the number of lines
 which will be printed on the SYSPRINT file before an automatic page 
eject and header line will be printed.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; See <font color="#663300"><code>OUTPUT(NE)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHL(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value given by shifting the value of <font color="#663300"><code>NE<sub>1</sub></code></font> left (logical shift, zeroes appear in the least significant bit position) the number of positions indicated by the value of <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">One point I found confusing for quite a while is that you'd suppose that logical shifts would operate on <font color="#663300"><code>BIT</code></font> variables, and particularly on long-<font color="#663300"><code>BIT</code></font> variables, for which XPL provides no conveniences at all for accessing individual bits.&nbsp; Not so!&nbsp; <font color="#663300"><code>SHL</code></font> operates only on <font color="#663300"><code>FIXED</code></font> values, and can only shift by up to 32 positions.&nbsp; <font color="#663300"><code>BIT</code></font> variables are converted to <font color="#663300"><code>FIXED</code></font> if shift operations on them are needed.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHR(</code></font><font color="#663300"><code><font color="#663300"><code>NE<sub>1</sub>,NE<sub>2</sub></code></font>)</code><code><br>
          </code></font></td>
      <td valign="middle">Logical shift right.&nbsp; <font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font> are used in conjunction with <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> for masking and data packing.<br>
      </td>
      <td valign="middle">But recall that it is preferable to use <font color="#663300"><code>~</code></font> rather than <font color="#663300"><code>¬</code></font> with <b>XCOM-I</b>. </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING(<i>IDENTIFIER</i>)<br>
STRING(<i>INTEGER</i>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function transforms the variable <font color="#663300"><code>NE</code></font> (which should be <font color="#663300"><code>FIXED</code></font> for proper usage) into a <font color="#663300"><code>CHARACTER</code></font> descriptor.&nbsp; <font color="#663300"><code>NE</code></font> should have the form:<br>
        <br>
        <table align="center" cellspacing="2" cellpadding="2" border="1">
          <tbody>
            <tr>
              <th valign="middle" align="center">Length - 1<br>
              </th>
              <th valign="middle" align="center">&nbsp;Data Address<br>
              </th>
            </tr>
            <tr>
              <td valign="middle" align="center">8 bits<br>
              </td>
              <td valign="middle" align="center">24 bits<br>
              </td>
            </tr>
          </tbody>
        </table>
        <br>
      </td>
      <td valign="middle">(XPL/I only.) I admit that the description at 
left is confusing.&nbsp; The whole concept is confusing.&nbsp; Here's my
 take on it:&nbsp; I believe that <font color="#663300"><code>STRING</code></font> is used in one of two situations:<br>
<ul>
  <li>You have an <font color="#663300"><code><i>IDENTIFIER</i></code></font> for a <font color="#663300"><code>CHARACTER</code></font> variable, and you want the string descriptor for the string contained in that variable; or</li>
  <li>By some kind of arithmetical process, a <font color="#663300"><code><i>INTEGER</i></code></font> value has been created that you want to treat as a string descriptor.<br></li>
</ul>
These are respectively equivalent to<br>
<ul>
  <li><font color="#663300"><code>COREWORD(ADDR(IDENTIFIER))</code></font></li>
  <li><font color="#663300"><code>INTEGER</code></font></li>
</ul>
<p><b>XCOM-I</b> implements <font color="#663300"><code>STRING</code></font> using these equivalences, and there is no runtime library function as such that's called <font color="#663300"><code>STRING</code></font>.<br></p>
<p>To make things a bit more confusing, <font color="#663300"><code>STRING</code></font> is the one built-in I'm aware of that is <i>also</i>
 commonly used as a name for a variable.  If names of built-ins are 
declared as variables (or procedures), the user's declaration overrides 
the built-in for the scope of the declaration.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING_GT(DE<sub>1</sub>,DE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a <font color="#663300"><code>TRUE</code></font> value if the contents of string <font color="#663300"><code>DE<sub>1</sub></code></font> is greater than the contents of string <font color="#663300"><code>DE<sub>2</sub></code></font>, based on the collating sequence of the characters, irrespective of the lengths of <font color="#663300"><code>DE<sub>1</sub></code></font> and <font color="#663300"><code>DE<sub>2</sub></code></font>. Otherwise, the value is <font color="#663300"><code>FALSE</code></font>. This is functionally equivalent to padding the shorter of <font color="#663300"><code>DE<sub>1</sub></code></font> or <font color="#663300"><code>DE<sub>2</sub></code></font> with blanks and then comparing the strings.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; If this seems confusing, it may be helpful to recall that when the XPL relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>&lt;=</code></font>, and <font color="#663300"><code>&gt;=</code></font> compare two <font color="#663300"><code>CHARACTER</code></font>
 values, they look first at the lengths of the values, and only if the 
lengths are equal do they compare the actual character data.&nbsp; For 
example,<br>
        <blockquote><font color="#663300"><code>'ZZZ' &lt; 'AAAA'</code></font><br>
        </blockquote>
because <font color="#663300"><code>'ZZZ'</code></font> has only 3 characters, while <font color="#663300"><code>'AAAA'</code></font> has 4.&nbsp; Presumably <font color="#663300"><code>STRING_GT</code></font> was introduced because somebody at Intermetrics didn't think that kind of behavior was great, and thus <font color="#663300"><code>STRING_GT('ZZZ', 'AAAA')</code></font> will report instead that <font color="#663300"><code>'ZZZ'</code></font> is greater than <font color="#663300"><code>'AAAA'</code></font>.<br>
        <br>
The collating sequence in either case is EBCDIC rather than the 
more-usual ASCII.&nbsp; The primary visually-obvious consequence of this
 is that digits come after letters rather than before them.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the substring of the string specified by <font color="#663300"><code>DE</code></font>, starting at position with <font color="#663300"><code>NE<sub>1</sub></code></font> with length <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">I.e., it allocates and returns a new string created by taking a substring of length <font color="#663300"><code>NE<sub>2</sub></code></font>, starting at position <font color="#663300"><code>NE<sub>1</sub></code></font> in string <font color="#663300"><code>DE</code></font>.<sub><code></code></sub><sub><code></code></sub><font color="#663300"><code></code></font> </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE)</code><code><br>
          </code></font></td>
      <td valign="middle">Like the above except that all characters from <font color="#663300"><code>NE</code></font> to the end of the string are taken.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME</code><code><br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the time-of-day coded as centiseconds since midnight.<br>
      </td>
      <td valign="middle">See the notes for the <font color="#663300"><code>DATE</code></font> function above.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>TIME</code></font> during compilation of the program.<br>
      </td>
      <td valign="middle"><font color="#663300"><code>TIME</code></font> (see above) isn't literally available during compilation.&nbsp; Moreover, <b>XCOM-I</b>
 implements this as a function rather than as a variable, which should 
be transparent to the programmer.&nbsp; <br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL TRACE;</code></font><br>
        </blockquote>
which causes activation of the instruction-by-instruction trace at runtime.<br>
      </td>
      <td valign="middle">This is described in quite a lot of detail in 
McKeeman's Appendix 2.&nbsp; At present, it is accepted during 
compilation but does nothing at runtime in code generated by <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>UNTRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL UNTRACE;</code></font><br>
        </blockquote>
which turns off run-time trace.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>TRACE</code></font>.<br>
      </td>
    </tr><tr>
  <td valign="middle" align="center"><font color="#663300"><code>XPL_COMPILER_VERSION</code></font><br>
  </td>
  <td valign="middle"><code></code><code></code><font color="#663300"><code></code></font> An array of length 2 — actually a function in the <b>XCOM-I</b> runtime library —  in which the first element is the major version of the XPL compiler (<b>XCOM-I</b> in this case), and the second element is the minor version, both in the range 0-99.<br>
  </td>
  <td valign="middle">This is just speculation on my part, based on how 
an undeclared variable with this name is used when it appears a couple 
of times in <b>PASS2</b> of <b>HAL/S-FC</b>.&nbsp; Nearby code also provides the interesting information that the XPL version <i>name</i> is "TITAN--XPL".&nbsp; You may recall my <a moz-do-not-send="true" href="#titan">earlier observation</a>
 that Intermetrics merged with Titan Corporation in March 2000, which is
 obviously the origin of the "TITAN" portion of the name.&nbsp; The 
other interesting&nbsp; point is that no effort is made to distinguish 
it in any way from <i>standard</i> XPL.<br>
    <br>
Of course, I have no inkling whatever of how the versions for the 
Intermetrics/Titan XPL compiler were numbered.&nbsp; I was tempted to 
set the major version to 32 and the minor version to 0, but that would 
only serve to obscure the fact that <b>XCOM-I</b> is in fact <i>not</i> TITAN--XPL, nor even related to it other than that I've tried to imitate it.&nbsp; Instead, <b>XCOM-I</b>
 will always return a major and minor versions appropriate to 
itself:&nbsp; major = 0 preliminary versions, 1 for first release, and 
so on.<br>
    <br>
As an <i>ad hoc</i> measure, <b>XCOM-I</b> also transparently performs string substitions replacing 'TITAN--XPL', wherever it may be found, by 'RSB-XCOM-I'.<br>
  </td>
</tr>

  </tbody>
</table>
<br>
<h3><a name="monitor"></a>The MONITOR Built-In Runtime-Library Function</h3>
<p>As mentioned before, an XPL/I program obtained various services 
outside what the XPL/I language proper or runtime library could provide,
 by instead making requests to the separate "submonitor" program.  The 
mechanism was a call of the <font color="#663300"><code>MONITOR</code></font> procedure.  For <b>XCOM-I</b>, on the other hand, there is no separate submonitor program, and we may as well think of <font color="#663300"><code>MONITOR</code></font> as being just another built-in runtime-library function.  Well, not just <i>any</i>
 runtime-library function.  A big difference is that it provides a very 
large number of functions, each one of which can require its own unique 
syntax, thus necessitating a somewhat more-flexible discussion of how to
 use it.</p>
<p>The only uniform feature among the many aspects of <font color="#663300"><code>MONITOR</code></font> usage is that each separate function it provides is identified by a number, and such a function number is passed to <font color="#663300"><code>MONITOR</code></font>
 as its first parameter.  My explanations in the table below are mostly 
pulled from Chapter 13 of IR-182-1, and then altered according to my 
understanding (or lack thereof).  Functions 24 through 32 are deduced, 
poorly, from the <b>HAL/S-FC</b> BAL source-code file for the submonitor program (which happens to be called "MONITOR").<br></p>
<p>A number of the <font color="#663300"><code>MONITOR(...)</code></font>
 functions work with what's called "IBM hexadecimal floating-point" 
format, and specifically to the 64-bit (double-precision) version of 
that format, as opposed to the 32-bit (single-precision) version of it. 
To make the discussion more concise, I'll just refer to it as "DP 
floating point".  <br></p>
<p>To be perfectly clear, there is <i>no</i> floating-point datatype in 
XPL/I, there are no floating-point literal constants, and there is no 
provision whatever to make it convenient for you (the programmer!) to 
hard-code such constants into your XPL source code, nor to interpret any
 such hexadecimal constant you find within legacy source code.  Rather, 
you must somehow obtain the hexadecimal equivalents for whatever 
floating-point constants you wish to use, and then hard-code those 
hexadecimals into your code.  For your convenience — or more accurately,
 for <i>mine</i> — I've included a little utility called ibmHex.py that 
you can use to convert back-and-forth between human-readable 
floating-point numbers and DP floating point.  Just run <font color="#663300"><code>ibmHex.py --help</code></font> for instructions.  This little utility can either be run in a stand-alone fashion, or else <font color="#663300"><code>import</code></font>ed as a Python module.  But I digress!<br></p>
<p>To understand DP floating point, imagine 8 groups of 8 bits each:<br></p>
<blockquote>
  <pre><font color="#663300">SEEEEEEE FFFFFFFF FFFFFFFF ... FFFFFFFF</font></pre>
</blockquote>
<p>where <font color="#663300"><code>S</code></font> is the sign, <font color="#663300"><code>E</code></font> is the exponent, and <font color="#663300"><code>F</code></font> is the fraction.  (SP floating point is the same, but with 3 <font color="#663300"><code>FFFFFFFF</code></font>-groups rather than 7 of them.)  The exponent is a power of 16, biased by 64, and thus represents 16<sup>-64</sup> through 16<sup>63</sup>.
  The fraction is an unsigned number, of which the leftmost bit 
represents 1/2, the next bit represents 1/4, and so on.  As a special 
case, 0 is encoded as all zeroes.<br><br>For example, the 64-bit hexadecimal pair 0x42640000 0x00000000 parses as:<br></p>
<ul>
  <li>Sign = 0 (i.e., positive)</li>
  <li>Exponent = 16<sup>0x42-0x40</sup> = 16<sup>2</sup> = 2<sup>8</sup>.</li>
  <li>Fraction = 0.0110 0100 ...</li>
</ul>
<p>or in total, 1100100 (binary), or 100 decimal.<br></p>
<p>As in the preceding section, I want to make it clear that the descriptions given here are how <i>the <b>XCOM-I</b> runtime library's <font color="#663300"><code>MONITOR</code></font> functions</i> work, and not how the original <font color="#663300"><code>MONITOR</code></font> functions as confined to an IBM 360 runtime environment worked!</p>

<table align="center" cellspacing="2" cellpadding="2" border="1">
  <caption><font size="+1"><b>MONITOR Functions</b></font></caption>

  <tbody>
    <tr>
      <th valign="bottom" nowrap="nowrap" align="center">MONITOR Call<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(0,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes output file <i><font color="#663300"><code>n</code></font></i>.<br>
</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(1,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to output device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Physically writes any data previously buffered in memory by <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font> operations into the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp; Returns 0 if the member hadn't existed previously in 
the PDS, or 1 if the contents of an existing member of that name was 
replaced.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(2,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to input device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Sets future <font color="#663300"><code>INPUT(n)</code></font> operations to pull data from the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp;  Returns 0 if the member was found, or 1 if it was not 
found.<br>
</td>
      <td valign="middle">The end-of-data for the member is detected when an input string of 0 length is encountered.<br>
  <br>
IR-182-1 asserts that devices 4 and 7 have the following abnormal <i>ad hoc</i> behavior very specific to <b>HAL/S-FC</b>.&nbsp;
 A PDS called "INCLUDE" is normally attached to input device 4, while 
either "INCLUDE" or "OUTPUT6" is normally attached to input device 
7.&nbsp; But member <code><font color="#663300"><i>name</i></font></code>&nbsp; is sought in device 4 or 7, then <code><font color="#663300"><i>name</i></font></code> is first sought in "INCLUDE" but upon failure is then sought in "OUTPUT6".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(3,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes input file <i><font color="#663300"><code>n</code></font></i>.</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>INPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(4,<i>n</i>,<i>b</i>);<br>
    </font></code></td>
      <td valign="middle">Changes the record size of random-access file <code><font color="#663300"><i>n</i></font></code> to <code><font color="#663300"><i>b</i></font></code>.&nbsp; Must precede the first use of <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(5,ADDR(DW));<br>
    </font></code></td>
      <td valign="middle">Sets the location of the double-word work area (<font color="#663300"><code>DW</code></font>) for subsequent use by <font color="#663300"><code>MONITOR(9,...)</code></font> and <font color="#663300"><code>MONITOR(10,...)</code></font>.<br>
</td>
      <td valign="middle"><code><font color="#663300">DW</font></code> is meant to be literal here, at least for <b>HAL/S-FC</b>, and should not be replaced by anything else.<br>
  <br>
  <code><font color="#663300">DW</font></code> refers to an array of <font color="#663300"><code>FIXED</code></font>
 variables used in pairs, to hold 64-bit values. In particular, these 
pairs are often used to hold double-precision floating-point numbers in 
IBM System/360 format.&nbsp;&nbsp; <code><font color="#663300">MONITOR(9,<i>op</i>)</font></code> <font color="#663300"><font color="#000000">(see
 below) is then capable of performing various arithmetical operations on
 those numbers.&nbsp; Since XPL/I itself has no facilities for 
floating-point variables or operations on them, this workaround is the 
only available way to employ floating-point numbers in XPL/I programs.<br>
<br>
In legacy HAL/S code, I've found that at least 14 words of memory are 
needed for this work area.&nbsp; In the XCOM-I implementation, the </font></font><font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(5)</font></code> call is rejected within 14 words of the end of memory.</font></font><code><font color="#663300"><br>
    </font></code></td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Allocates <font color="#663300"><i>n</i></font> bytes of storage in free memory, clearing that memory to 0, and assigns the pointer of the <font color="#663300"><code><i>basedVariable</i></code></font> to point to that newly-allocated space.&nbsp; Returns 0 upon success, or 1 upon failure.<br>
</td>
      <td valign="middle">It would be natural to suppose that <code><font color="#663300">MONITOR(6)</font></code> is the mechanism used to allocate memory for <font color="#663300"><code>BASED</code></font>
 variables declared in the XPL/I code.&nbsp; In general, this is <i>not</i> true.&nbsp; Memory for <font color="#663300"><code>BASED</code></font>
 variables declared in user XPL code comes from a large pre-allocated 
contiguous block of memory, and the sub-allocations of individual <font color="#663300"><code>BASED</code></font> variables within that large block are managed using means other than <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font> and <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(7)</font></code></font></font>.<br>
<blockquote>
  <b><font size="-1">Aside:</font></b><font size="-1">&nbsp; It appears to me that once upon a time, the intention may indeed have been for </font><font size="-1"><font color="#663300"><code>BASED</code></font> variables to be managed by </font><font size="-1"><code><font color="#663300">MONITOR(6)</font></code>.&nbsp; The evidence for this is a procedure called <font color="#663300"><code>DESCRIPTOR_MONITOR</code></font> in SPACELIB, which does try to allocate or deallocate space for </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables in just that fashion.&nbsp; However, </font><font size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font> is never called, and some of the variables upon which it depends are never declared, making </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font></font> uncompilable.&nbsp; (<b>XCOM-I</b> transparently deletes it, and other functions which are never called.) &nbsp; But in spite of the historical evidence of </font><font size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font>, I see no such behavior in any of the <i>active</i> code, with a single exception:&nbsp; The memory-management system itself (i.e., SPACELIB) does have a </font><font size="-1"><font color="#663300"><code>BASED</code></font> variable, <font color="#663300"><code>DX</code></font>, which it continues to manage using <font color="#663300"><code>MONITOR(6)</code></font> and <font color="#663300"><code>MONITOR(7)</code></font>.<br>
  </font></blockquote>
My observation is that <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font> must update more of the <font color="#663300"><code><i>basedVariable</i></code></font> than just its pointer to its data.<font color="#663300"><font color="#000000">&nbsp;&nbsp; </font></font>Recall that a <font color="#663300"><code>BASED</code></font> variable is associated with a 28-byte structure known as a <a moz-do-not-send="true" href="#DopeVectors">"dope vector"</a>,
 of which the pointer to the data comprises only bytes 0-3.&nbsp; Beyond
 that, bytes 4-5 give the sizes (in bytes) of each record, while bytes 
8-11 give the total number of records allocated so far.&nbsp; (Not to be
 confused with the total number of records in use; for growth, more 
records may have been allocated than were strictly needed at that 
moment.)&nbsp; While <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font>
 may not need an entire dope vector to be present at the address it has 
been given, it needs the first 12 bytes to be present, so that it can 
use/update the fields just mentioned.&nbsp; I don't see evidence of that
 in the submonitor source code, but then I don't fully understand that 
source code; at any rate, this is how <b>XCOM-I</b> treats it.<br>
<br>
Note that <font color="#663300"><code>MONITOR(6)</code></font> <i>increases</i> the size of <code><font color="#663300"><i>basedVariable</i></font></code> by <code><font color="#663300"><i>n</i></font></code> bytes; it does not <i>set</i> the size to <code><font color="#663300"><i>n</i></font></code> bytes.<br>
</td></tr><tr><td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(7,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Frees memory previously allocated via <code><font color="#663300">MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>)</font></code>.&nbsp; However, <code><font color="#663300"><i>basedVariable</i></font></code>'s pointer is not changed, and thus will continue to point to the freed area until explicitly changed.<br>
</td>
      <td valign="middle" bgcolor="transparent">See the comments for <code><font color="#663300">MONITOR(6)</font></code>.&nbsp; <br>
<br>
If <code><font color="#663300"><i>n</i></font></code> is less than the total number of bytes allocated for <code><font color="#663300"><i>basedVariable</i></font></code>, then the number of records available in <code><font color="#663300"><i>basedVariable</i></font></code> has shrunk, but <code><font color="#663300"><i>basedVariable</i></font></code> continues to be usable, with a reduced number f records.<br>
<br>
Although described as having the address of a <font color="#663300"><code>BASED</code></font> variable as a parameter, this isn't entirely true.&nbsp; It is also sometimes the address of a <font color="#663300"><code>FIXED</code></font> variable.<br>
</td></tr><tr><td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(8, <i>dev</i>, <i>filenum</i>);<br>
    </font></code></td>
      <td valign="middle">Set PDS DDNAME.<br>
</td>
      <td valign="middle" bgcolor="transparent">Apparently, the use of <code><font color="#663300">MONITOR(8)</font></code>
 changed after the only documentation of it (in IR-182-1) was produced, 
leaving us to try to infer its usage from context in the <b>HAL/S-FC</b> and <code><font color="#663300">MONITOR</font></code>'s source code.&nbsp; The purpose seems to be to change the association of files to device numbers, <i>à la</i> <font color="#663300"><code>DD</code></font>'s in JCL, but to do so dynamically during execution rather than statically at program startup.&nbsp; <br>
<br>
The <font color="#663300"><code><i>dev</i></code></font> parameter, an integer, would appear to be the logical device number as used in an <code>XPL <font color="#663300">INPUT(<i>dev</i>)</font></code> or <font color="#663300"><code>OUTPUT(<i>dev</i>)</code></font> (or in a HAL/S <font color="#663300"><code>READ(<i>dev</i>)</code></font> or <font color="#663300"><code>WRITE(<i>dev</i>)</code></font>).<br>
<br>
The <i><font color="#663300"><code>filenum</code></font></i> parameter is trickier for me to understand, because I'm unclear how <font color="#663300"><code>DD</code></font>
 in JCL associates a dataset name with a file number, so take what I say
 with a grain of salt.&nbsp; My inference, subject to change, is that if
 you have a dataset identified with the <font color="#663300"><code>DD</code></font> name "<font color="#663300"><code>INPUT<i>n</i></code></font>" (where <font color="#663300"><code><i>n</i></code></font> is a digit), then that is <font color="#663300"><code><i>filenum</i>=<i>n</i></code></font>; whereas a dataset named "<font color="#663300"><code>OUTPUT<i>n</i></code></font>" is associated with <font color="#663300"><code><i>filenum</i>="80000000"|<i>n</i></code></font>.&nbsp; Recall that <font color="#663300"><code>"80000000"</code></font> is XPL-speak for 0x80000000.&nbsp; So the <i><font color="#663300"><code>filenum</code></font></i> is implicit in the dataset name, and the most-significant bit is used to indicate the direction of data flow.<br>
<br>
For example, <font color="#663300"><code>INPUT(4)</code></font> invocations might normally input data from <font color="#663300"><code>INPUT4</code></font>, but you could associate it instead with <font color="#663300"><code>INPUT2</code></font> via<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 2);</font><br></pre>
</blockquote>
and then reassociate it later with <font color="#663300"><code>INPUT4</code></font> via<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 4);<br></font></pre></blockquote>
The description "Set PDS DDNAME" I've given as the description comes 
from the associated program comment in MONITOR.bal, the source-code for 
the <font color="#663300"><code>MONITOR</code></font> procedure.&nbsp; 
It would seem to imply that it has something specifically do with 
Partitioned Data Sets (PDS).&nbsp; It's difficult to see why that would 
be so; I think it merely reflects the specific usage in HAL/S-FC, which 
indeed relates to PDS.&nbsp; The XCOM-I runtime library allows it to be 
used for and PDS <i>or</i> sequential dataset.&nbsp; It is not applicable to random-access files.<br>
<br>
Of course, there is no JCL, and consequently no DD statements, associated with an XPL or XPL/I file compiled with <b>XCOM-I</b>, nor with a HAL/S file compiled with <b>HAL/S-FC</b>.&nbsp; The description above has to be applied instead to command-line switches in a hopefully-obvious way.<br>
<blockquote>
</blockquote>


</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(9,<i>op</i>);<br>
    </font></code></td>
      <td valign="middle">Performs floating point evaluation as specified by value of <code><font color="#663300"><i>op</i></font></code>.&nbsp; Operands are obtained from work area whose address was set up via a <font color="#663300"><code>MONITOR(5)</code></font>
 call. The first operand is taken from the first double word of the work
 area and the second operand from the second double word. The result is 
placed in the first double word of the work area. The return code is 0 
if the operation succeeds, or 1 if the operation fails (under or 
overflow).<br>
  <br>
The values of <code><font color="#663300"><i>op</i></font></code> are:<br>
  <table align="center" cellspacing="2" cellpadding="2" border="1">
    <tbody>
      <tr>
        <th valign="top">OP<br>
        </th>
        <th valign="top">Function<br>
        </th>
      </tr>
      <tr>
        <td valign="top" align="center">1<br>
        </td>
        <td valign="top" align="center">arg1 + arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">2<br>
        </td>
        <td valign="top" align="center">arg1 - arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">3<br>
        </td>
        <td valign="top" align="center">arg1 * arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">4<br>
        </td>
        <td valign="top" align="center">arg1 / arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">5<br>
        </td>
        <td valign="top" align="center">arg1<sup>arg2</sup><br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">6<br>
        </td>
        <td valign="top" align="center">sin(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">7<br>
        </td>
        <td valign="top" align="center">cos(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">8<br>
        </td>
        <td valign="top" align="center">tan(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">9<br>
        </td>
        <td valign="top" align="center">exp(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">10<br>
        </td>
        <td valign="top" align="center">log(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">11<br>
        </td>
        <td valign="top" align="center">sqrt(arg1)<br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
</td>
      <td valign="middle">"arg1" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(0),DW(1)</code></font>.<br>
  <br>
"arg2" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(2),DW(3)</code></font>.<br>

  <br>
The DP floating-point result of the operation is stored back into <font color="#663300"><code>DW(0),DW(1)</code></font>, although not all of the operations can necessarily produce results of full DP accuracy from DP operands.<br>
  <br>
The angular unit for trigonometric operations is the radian.<br>
<br>
Note that the values stored in these registers of the work-area are in 
the binary format of "IBM hexadecimal floating-point", which are not 
used anywhere else in XPL memory (unless copied from the working area).<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(10,<i>string</i>);<br>
    </font></code></td>
      <td valign="middle">Performs character to DP floating-point conversion upon characters in <code><font color="#663300"><i>string</i></font></code>.
 The return code is 0 if the result is valid, or 1 if conversion was not
 possible. The result is placed in the first double word of the work 
area provided by the <font color="#663300"><code>MONITOR(5)</code></font> call.<br>
</td>
      <td valign="middle">In other words, <code><font color="#663300"><i>string</i></font></code> is interpreted as a DP floating-point number and stored in <font color="#663300"><code>DW(0),DW(1)</code></font>.&nbsp; Any of the usual representations for decimal numbers are accepted in the string, including the usual <font color="#663300"><code>E</code></font> notation for exponents.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(11);<br>
    </font></code></td>
      <td valign="middle">No-op.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>string</i>=MONITOR(12,<i>p</i>);<br>
    </font></code></td>
      <td valign="middle">Converts floating-point number in the first double word of the work area to standard HAL/S character form. Value of <code><font color="#663300"><i>p</i></font></code> indicates whether the operand is SP (<code><font color="#663300"><i>p</i></font></code>=0) or DP (<code><font color="#663300"><i>p</i></font></code>=8).<br>
</td>
      <td valign="middle">In other words, this is the inverse of <code><font color="#663300">MONITOR(10,<i>string</i>)</font></code> (see above).<br>
  <br>
As far as the "standard HAL/S character form" is concerned, it's described in HAL/S documentation (<i>Programming in HAL/S</i>, p. 3) as follows:<br>
  <ul>
    <li>0.0: Printed as " 0.0" (notice the leading space).</li>
    <li>Positive:  Printed as " d.ddd...E±ee"</li>
    <li>Negative:  Printed as "-d.ddd...E±ee"</li>
  </ul>
Except for the special case 0.0, the number of printed fractional digits
 is always the same, although we're not told exactly how many that it 
is:&nbsp; merely that it is "implementation dependent".&nbsp; I believe,
 without any basis — and therefore <b>XCOM-I</b> implements — that the 
number of fractional digits is chosen to provide the maximum accuracy, 
which is 6 for single precision and 15 for double precision.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>address</i>=MONITOR(13,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Performs DELETE of current option processor and then LOADs an option processor specified by <code><font color="#663300"><i>name</i></font></code>.
 The option processor loaded is called and passed a pointer to the PARM 
field in effect at the time of compiler invocation. The option processor
 passes the PARM field and establishes an options table (see Chapter 9 
[of document IR-182-1]) whose address is passed back as a return 
value.&nbsp; If <code><font color="#663300"><i>name</i></font></code> is a null string, the pointer to the existing options table is returned.<br>
</td>
      <td valign="middle"><a name="MONITOR13"></a><a moz-do-not-send="true" href="#programOptions">See the earlier discussion concerning program options</a>.&nbsp;
 In brief, each XPL or XPL/I program has some defined set of "Type 1" 
options and "Type 2" options.&nbsp; The former are binary (on/off) 
options, whereas the latter are options with integer or string values.<br>
<br>
<code><font color="#663300">MONITOR(13,<i>name</i>)</font></code>
 returns an address which is used by the XPL program to find options settings for it that have been
 set up by the run-time library.&nbsp; In C terms, it's the equivalent 
for <font color="#663300"><code>argv[]</code></font> but with more 
behind-the-scenes interpretation of the parameters.&nbsp; Those program 
options would originally have been provided by the Job Control 
Language (JCL) which initiated execution of the program, by means a 
"PARM field" given on one of the JCL cards.&nbsp; For example, in the 
JCL<br>
<blockquote>
  <pre><font color="#663300">//XPL EXEC PGM=MONITOR,<br>//         PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</font><br></pre>
</blockquote>
the PARM field is the string <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font>,
 and the comma-delimited items are the individual options 
selected.&nbsp; Presumably, the operating system wouldn't have been able
 to directly interpret the meaning of this PARM field on its own, since 
the types of options would have been specific to the program being 
run.&nbsp; So an "option processor" specific to the allowed parameters
must be loaded to perform that interpretation.&nbsp; In the case of 
the Intermetrics version of <b>HAL/S-FC</b>, the particular options processor for compiler pass 1 was <code><font color="#663300"><i>name</i></font></code><font color="#663300"><code>='COMPOPT '</code></font>, whereas it was an empty string for passes 2 and 3, and <font color="#663300"><code>'LISTOPT '</code></font>
 for pass 4.&nbsp; (Note the trailing spaces to make the non-empty 
strings come out to 8 characters.&nbsp; These trailing spaces are not required in <b>XCOM-I</b>.)&nbsp; <br>
<br>
Again, just to be doubly clear, <code><font color="#663300">MONITOR(13)</font></code> provides access to options settings <i>not</i> for <b>XCOM</b> or <b>XCOM-I</b>, but rather for the XPL program being compiled by <b>XCOM-I</b>, and specifically for <b>HAL/S-FC</b>. <br>
<br><b>XCOM-I</b> supports the pre-existing built-in options processors 
'COMPOPT', 'LISTOPT' and 'MONOPT'.&nbsp; (MONOPT provides the parameters
 described in McKeeman, but they are passed to the XPL/I program in the 
Intermetrics manner rather than being confined to the submonitor as in 
McKeeman.)&nbsp; Plus, it is possible (as described in the discussion of
 program options) for the user to define their own custom options 
processor called 'USEROPT'.&nbsp; Whenever <code><font color="#663300">MONITOR(13)</font></code> is called, it saves the <code><font color="#663300"><i>name</i></font></code> and the PARM field to a file called "monitor13.parms".&nbsp; If called with an empty <code><font color="#663300"><i>name</i></font></code>, or more typically as <code><font color="#663300">MONITOR(13,0)</font></code>, it simply reloads the contents of monitor13.parms and reuses those.<br>
<br>
The <code><font color="#663300"><i>address</i></font></code> returned by <code><font color="#663300">MONITOR(13)</font></code> is a pointer in memory to the beginning of a block of 6 consecutive <font color="#663300"><code>FIXED</code></font> values<font size="-1"><b>:</b></font><br>
<ul>
  <li><font color="#663300"><font color="#000000">The<b> </b>first is a <font color="#663300"><code>FIXED</code></font> value (called </font></font><font color="#663300"><font color="#000000"><font color="#663300"><code>OPTIONS_CODE</code></font> or <font color="#663300"><code>OPTION_BITS</code></font>) that collects</font></font>
 32 bit flags, each of them (in principle) itself representing a type 1 
(on/off) option.  Refer to the source-code files COMPOPT.bal, 
LISTOPT.bal, and MONOPT.bal (in the MONITOR.ASM folder of the <b>HAL/S-FC</b> source code) for the detailed list of which options correspond to which of the 32 bits.</li><li><font color="#663300"><font color="#000000">The remaining five values are the pointer addresses for <font color="#663300"><code>BASED FIXED</code></font> arrays:  </font><code>CON</code></font>, <font color="#663300"><code>PRO</code></font>, <font color="#663300"><code>TYPE2</code></font>, <font color="#663300"><code>VALS</code></font>, <font color="#663300"><code>NPVALS</code></font> (or <font color="#663300"><code>MONVALS</code></font>), each of which the options processor has already allocated memory for and equipped with data:</li>
  
<ul>

    <li><font color="#663300"><code>CON</code></font>:  This is an array of string descriptors for the selected type 1 options.  <b>HAL/S-FC</b> uses it just for printing a report in pass 1, while using <font color="#663300"><code>OPTIONS_CODE</code></font> in place of it for any more-significant purpose. <a moz-do-not-send="true" href="#programOptions">Our earlier section on program options</a> lists the order in which the parameters appear in <font color="#663300"><code>CON</code></font>.</li><li><font color="#663300"><code>PRO</code></font>:  In principle, this is like <font color="#663300"><code>CON</code></font>, but instead contains the opposites of the selected options.  For example, if "LISTING2" appears in <font color="#663300"><code>CON</code></font>, then "NOLISTING2" appears in <font color="#663300"><code>PRO</code></font>.</li>
    <li><font color="#663300"><code>TYPE2</code></font>:  This array 
contains the names (as string descriptors) of options of type 2 (i.e., 
options which can be assigned value other than on/off).  They are 
presented in the order listed in the discussion of program options. <br></li>
    <li><font color="#663300"><code>VALS</code></font>:  This array contains the values of the options of type 2, in the same order as the names in the <font color="#663300"><code>TYPE2</code></font> array.  Once again, see the discussion of program options.</li>
    <li><font color="#663300"><code>NPVALS/MONVALS</code></font>: This is like <font color="#663300"><code>CON/PRO</code></font>, except that in principle it contains values of options which are <i>not</i> among the list printed by <b>HAL/S-FC</b>, which roughly speaking, is half of them.</li>
  
</ul>
</ul>
<ul>

</ul>



</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(14,<i>n</i>,<i>a</i>);<br>
    </font></code></td>
      <td valign="middle">For creating Simulation Data Files.&nbsp; The value of <code><font color="#663300"><i>n</i></font></code> selects a function; the value of <code><font color="#663300"><i>a</i></font></code> supplies supplementary data:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="top"><code><font color="#663300"><i>n</i></font></code></th>
      <th valign="top">Function<br>
      </th>
      <th valign="top"><code><font color="#663300"><i>a</i></font></code></th>
    </tr>
    <tr>
      <td valign="middle" align="center">0<br>
      </td>
      <td valign="middle" align="center">Open<br>
      </td>
      <td valign="middle" align="center">option flags<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">1<br>
      </td>
      <td valign="middle" align="center">Write<br>
      </td>
      <td valign="middle" align="center">area address<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center">2<br>
      </td>
      <td valign="middle" align="center">Stow &amp; Close<br>
      </td>
      <td valign="middle" align="center">member name<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
</td>
      <td valign="middle">Unfortunately, the only documentation of this is from 1976, and it may be somewhat preliminary in nature.<br>
<br>
For example, from the source code of <b>HALS/FC</b> (see the <font color="#663300"><code>OUTPUT_SDF</code></font> procedure in <b>PASS3</b>), the function numbers (<code><font color="#663300"><i>n</i></font></code>) appear to be 0, 4, and 8 (rather than 0, 1, and 2 as it says in the description to the neighboring column).<br>
<br>
It appears to me that it's used somewhat like this:&nbsp; <br>
<ol>
  <li>First you "open" the SDF file.&nbsp; It apparently consists of 
"pages", numbered from 0 upward.&nbsp; The only "option" you can give it
 is the maximum page number.</li>
  <li>Then you "write" to the file a page at a time, starting at page 
0.&nbsp; Each "write" transfers data from the "area address" you specify
 to the next higher page in the buffer.</li>
  <li>Finally, you "stow&amp;close" the SDF file.&nbsp; This is the step
 which writes the memory buffer out to the actual SDF file (if it hasn't
 been doing so already), which is a partitioned data set (PDS).&nbsp; 
The member name of the PDS is assigned at this point.&nbsp; Note that 
the member name can be one that already exists in the PDS, which will 
cause the existing member to be overwritten.<br>
  </li>
</ol>
<p>Thus you start with a presumably-empty PDS (which happens to be 
attached to output device 5), and end up with a PDS populated with lots 
of named members, each one of which consists of some integral number of 
"pages".<br>
</p>

</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(15);<br>
    </font></code></td>
      <td valign="middle">Returns Revision Level and Catenation Number from last <font color="#663300"><code>MONITOR(2)</code></font>
 call.&nbsp; Catenation number is obtained from PDS directory data and 
Revision Level from user data field as specified in the HAL/SDL ICD. The
 values are returned in the left and right halfwords of the result.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(16,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Sets flags in byte to be returned as high 
order byte of return code at end of compilation. Flags are passed as 
right most byte of fullword <code><font color="#663300"><i>n</i></font></code>. If high order bit of <code><font color="#663300"><i>n</i></font></code> is zero, flags are OR'ed into existing flags. If high order bit of <code><font color="#663300"><i>n</i></font></code> is one, flags replace existing flags.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(17,name);<br>
    </font></code></td>
      <td valign="middle">Causes <i><code><font color="#663300">name</font></code></i> to be copied to third parm field (if any) passed to <font color="#663300"><code>MONITOR</code></font> by the program that invoked the compiler. See HAL/SDL ICD.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>T</i>=MONITOR(18);<br>
    </font></code></td>
      <td valign="middle">Returns elapsed CPU time since beginning of run in units of .01 seconds.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(19,<i>addressList</i>,<i>sizeList</i>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(6)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes.&nbsp; Unlike <font color="#663300"><code>MONITOR(6)</code></font>, the newly-allocated blocks of memory are not cleared to 0.<br>
</td>
      <td valign="middle"><b>XCOM-I</b> does not implement this function.&nbsp; Besides, it's unclear how to represent a "list".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(20,</font></code><code><font color="#663300"><code><font color="#663300"><i>addressList</i>,<i>sizeList</i></font></code>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(7)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes. <br>
</td>
      <td valign="middle"><b>XCOM-I</b> does not implement this function.
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(21);<br>
    </font></code></td>
      <td valign="middle">Returns remaining amount of memory (in bytes) that's free for allocation via <font color="#663300"><code>MONITOR(6)</code></font>.<br>
</td>
      <td valign="middle">For Intermetrics <b>XCOM</b>, I believe, <font color="#663300"><code>MONITOR(6)</code></font> could use <i>any</i> contiguous block of free memory, including those that were candidates for garbage collection.&nbsp; Whereas <b>XCOM-I</b>
 only allocates memory within the contiguous block at the end of the 
free-memory space.&nbsp; Consequently, this function would originally 
have found the largest free block wherever it was located, whereas <b>XCOM-I</b> merely reports the size of the final block of free memory.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i><code><font color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i><code><font color="#663300"><code><font color="#663300">=MONITOR(22,0,<i>n</i><i><sub>2</sub></i>);</font></code></font></code><i><code><font color="#663300"><code><font color="#663300"><br>
            </font></code></font></code>F</i>=MONITOR(22,<i>n<sub>1</sub></i>);</font></code><br>
<code><font color="#663300"><code></code>
    </font></code></td>
      <td valign="middle">Calls SDF access package.<br>
</td>
      <td valign="middle">SDF stands for Simulation Data File.&nbsp; The
 "SDF access package" (SDFPKG) was a separate program, similar to the 
submonitor itself, with which the XPL/I program could communicate via <font color="#663300"><code>MONITOR(22)</code></font>.&nbsp; And like the submonitor, in the <b>XCOM-I</b>
 framework, SDFPKG equivalents are built into the runtime library rather
 than being provided by a separate SDFPKG program.&nbsp; <br>
<br>
Documentation can be found in TBD.&nbsp; There is not space for a full 
description here, so I'm only giving a brief summary; the documentation 
should be consulted for more details.<br>
<br>
The first form, <code><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code><font color="#663300"><i><code><font color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i><code><font color="#663300"><code><font color="#663300">=</font></code></font></code></font></code>MONITOR(22,0,<i>n</i><i><sub>2</sub></i>)</font></code></font></code></font></code>, initializes the SDFPKG functionality.&nbsp; The <code><font color="#663300"><code><font color="#663300"><code><font color="#663300"><i>n</i><i><sub>2</sub></i></font></code></font></code></font></code> parameter points to an array of 30 <font color="#663300"><code>FIXED</code></font> values which serves as a "communications area" holding data for subsequent calls. <br>
<br>
For calls of the second form, <code><font color="#663300"><i>F</i>=MONITOR(22,<i>n<sub>1</sub></i>)</font></code>, the <code><font color="#663300"><i>n<sub>1</sub></i></font></code> parameter specifies a function number ("mode"):<br>
<ol>
  <li>Terminate SDFPKG.</li>
  <li>Augment paging area.</li>
  <li>Rescind paging area augments.</li>
  <li>Select an SDF.</li>
  <li>Locate pointer.</li>
  <li>Set disposition parameters.</li>
  <li>Locate directory root cell.</li>
  <li>Locate block data cell given block number.</li>
  <li>Locate symbol data cell given symbol number.</li>
  <li>Locate statement data cell given statement number.</li>
  <li>Locate block data cell given block name.</li>
  <li>Locate symbol data cell given block name and symbol name.</li>
  <li>Locate symbol data cell given only symbol name.</li>
  <li>Locate statement data cell given SRN.</li>
  <li>Locate block node given block number.</li>
  <li>Locate symbol node given symbol number.</li>
  <li>Locate statement node given statement number.</li>
  <li>Locate initialization data given symbol number. <br>
  </li>
  <li>Deselect an SDF.<br>
  </li>
</ol>
There's some confusion in the available software/documentation, in that 
sometimes function #19 is missing; and when #19 is missing, #18 may 
either be as shown or else may be deselection of the SDF.&nbsp; I have 
no explanation for that discrepancy.&nbsp; However, the functional 
lineup listed above is consistent with the version of HAL/S-FC source 
code we have.<br>
<br>
Additionally, the function number <code><font color="#663300"><i>n<sub>1</sub></i></font></code> may have high-order bits set, such as 0x10000006 or 0x80000007.&nbsp; The significance of that is TBD.<br>
<br>
The return code, <code><font color="#663300"><i><code><font color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i></font></code>, for all calls is 0 upon success, or non-zero for various failures.&nbsp; See section 11 of the documentation.<br>

</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>descriptor</i>=MONITOR(23);<br>
    </font></code></td>
      <td valign="middle">Returns the <code><font color="#663300"><i>descriptor</i></font></code> of the 10-character string obtained from 
the ID field of the File Control Block of the first phase of the 
compiler.&nbsp; The ID field is maintained by the <b>XPLZAP</b> program and contains the identifying string printed on the header of each page of the HAL listing".
</td>
      <td valign="middle">I think that what the original documentation was trying to get at is that <b>HAL/S-FC</b>'s version code, printed on each of the report pages printed by <b>XCOM</b> (or now, <b>XCOM-I</b>), is given by this ID string, and that the ID string is provided to each pass of <b>HAL/S-FC</b> via a call to <code><font color="#663300">MONITOR(23)</font></code>.&nbsp; Of course, in the modern reimplementation, there is no <b>XPLZAP</b> program, and it wouldn't be compatible with <b>XCOM-I</b> if there were one.&nbsp; In <b>XCOM-I</b>, the ID string itself is by default 'REL32V0&nbsp;&nbsp; ', but it can be changed via the <b>XCOM-I</b> command-line parameter <font color="#663300"><code>--identifier</code></font>.<br>
<br>
As for what a "descriptor" is, see <a moz-do-not-send="true" href="#datatypes">the description of the CHARACTER datatype</a>.&nbsp;&nbsp; In brief, the return value is not itself the ID string, but an integer value (i.e., of the <font color="#663300"><code>FIXED</code></font> datatype) that provides an index for finding the ID string in memory. <br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(24)<br>
    </font></code></td>
      <td valign="middle">Read a block of a load module.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(25)<br>
    </font></code></td>
      <td valign="middle">Read a mass-memory load block.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(26)<br>
    </font></code></td>
      <td valign="middle">Read a MAF (memory analysis file) block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(27)<br>
    </font></code></td>
      <td valign="middle">Write a MAF block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(28)<br>
    </font></code></td>
      <td valign="middle">Link to dump analysis service routine<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(29)<br>
    </font></code></td>
      <td valign="middle">Return current page number<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(30)<br>
    </font></code></td>
      <td valign="middle">Return JFCB as string<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(31</font></code><code><font color="#663300"><code><font color="#663300">,<i>n</i></font></code>,<i>recnum</i>)<br>
    </font></code></td>
      <td valign="middle">Virtual-memory lookahead service.<br>
</td>
      <td valign="middle">This function is seemingly only used internally by the virtual-memory system.<br>
<br>
In looking at the the usage in actual XPL/I code, as well as the assembly-language source code for the submonitor (see <font color="#663300"><code>VMEMSRV</code></font> in <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM/MONITOR.bal">MONITOR.bal</a>),
 which admittedly I can only follow very imperfectly,&nbsp; it appears 
to me that this function is used in three distinct ways:<br>
<ul>
<li><font color="#663300"><code>MONITOR(31,<i>n</i>,-1)</code></font>, <font color="#663300"><code><i>n</i> &gt; 0</code></font>, sets the default file number for future <font color="#663300"><code>MONITOR(31,...)</code></font> calls to <code><font color="#663300"><code><font color="#663300"><i>n</i></font></code></font></code>.&nbsp;&nbsp;&nbsp; The default file number is initially 2.<br>
<font color="#663300"><code></code></font></li><li><font color="#663300"><code>MONITOR(31,<i>bufferAddress</i>,<i>recnum</i>)</code></font> , <font color="#663300"><code><i>recnum</i> </code><code>≥ 0</code></font>, immediately initiates an operation that reads record <font color="#663300"><code><i>recnum</i></code></font> from the default file, into a memory buffer at address <font color="#663300"><code><i>bufferAddress</i></code></font>.&nbsp;
 In IBM 360 terms, that's an "XDAP" operation.&nbsp; I think it's like 
what we'd call a DMA operation now, so this read operation may take some
 time to complete, but it's a background operation while it's doing so.<br>
</li>
  <li><font color="#663300"><code>MONITOR(31,0,-1)</code></font> waits until a previously-initiated read operation on the default file has completed. <br>
  </li>
</ul>
There's an additional subtlety — really, that's astounding?! —, in that the <font color="#663300"><code><i>bufferAddress</i></code></font> in <font color="#663300"><code>MONITOR(31,<i>bufferAddress</i>,<i>recnum</i>) </code></font>may
 sometimes have its most-significant bit set to 1, thus turning it into a
 negative number.&nbsp; I think in that case what happens is that the 
function waits for any background read-operation already in progress to 
complete, and then clears the sign bit of <font color="#663300"><code><i>bufferAddress</i></code></font> and commences a new read operation.<br>
<br>
The <b>XCOM-I</b> runtime library, doesn't really need any of these subtleties, so implements this function basically as immediate <font color="#663300"><code>FILE</code></font> operations, as appropriate.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(32)<br>
    </font></code></td>
      <td valign="middle">Find out subpool minimum size<br>
</td>
      <td valign="middle">The memory-allocation and -deallocation functions (<code><font color="#663300">MONITOR</font></code>
 6, 7, 19, and 20) are supposed to get their memory from something 
called "SUBPOOL 22".&nbsp; SUBPOOLs apparently have block-sizes which 
are either 2048 or 4096 bytes, depending on the operating system.&nbsp; <code><font color="#663300">MONITOR(32)</font></code>
 returns the appropriate block size for the operating system.&nbsp; 
Given that the block size is bigger in later versions of the operating 
system, I infer that bigger is better, within certain limits, and hence <b>XCOM-I</b> arbitrarily returns 4096.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(33)<br>
    </font></code></td>
      <td valign="middle">Find out FILE max REC# and BLKSIZ<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    
    
    
    
    
    
  </tbody>
</table><br>
<h1><a name="debugging"></a>Debugging XPL Programs</h1>

<p>It is admittedly unlikely that many people will be writing new XPL or
 XPL/I programs nowadays, and will instead be compiling only legacy XPL 
or XPL/I programs ... assuming that I haven't already compiled all of 
them first!  (Which is a distinct possibility.)  Since such legacy 
programs will presumably all have been debugged decades before, there's 
not as much need for a debugger as there is for computer languages in 
which there are many active developers.  Nevertheless, XPL or XPL/I 
programs can be run under a debugger to a certain extent.<br></p>
The trick is to realize that while we have no debugger for the XPL language, we do have debuggers for C, and once <b>XCOM-I</b>
 has translated XPL or XPL-I software into C, such C debuggers can be 
used.  It is merely necessary when compiling the C code to include the 
necessary command-line switches that cause the C compiler to incorporate
 debugging information into the executable.  For the <b>gcc</b> C compiler, that command-line switch is <font color="#663300"><code>-ggdb</code></font>, and incorporating it can be done simply by adding it to the <b>make</b> command like via<br>
<blockquote><font color="#663300"><code>make EXTRA=-ggdb ...</code></font><br>
</blockquote>
Having done this, any debugger which can accept <b>gdb</b> style debugging info, such as <b>gdb</b> itself or full-screen wrappers for <b>gdb</b>, can now be used for debugging.&nbsp; For other C compilers or other debuggers, perhaps different switches would be needed.<br>
<br>
But debugging XPL code via its C translation is not as convenient as a native XPL debugger would be.<br>
<br>
The principal difficulty in debugging the code in C vs in XPL is that <b>XCOM-I</b> doesn't model XPL variables as C variables, but rather as numerical locations in an array called <font color="#663300"><code>memory</code></font>.&nbsp;
 Moreover, the format of this data in "memory" is that of the IBM 
System/360 rather than the native format of the computer on which 
debugging is being performed.&nbsp; While in my opinion, these design 
choices for <b>XCOM-I</b> were are all necessary and unavoidable, 
there's no denying that they make it trickier to use a debugger to see 
the how the values of variable change during execution.&nbsp; <br>
<br>
I have, however, provided a few C functions in the runtime library to make it a <i>little</i> less painful to examine XPL variables within a debugger.&nbsp; You can also use the XPL <font color="#663300"><code>CALL INLINE</code></font>
 feature to directly embed calls to these functions within your program,
 without running a debugger at all, if it's more convenient for you to 
do so.<br>
<br>
The debugging functions are:<br>
<ul>
  <li><font color="#663300"><code>void printMemoryMap(char *heading)</code></font>
 — This function prints out the entire current state of the memory map. 
 I.e., the addresses of all variables, including dynamically-allocated 
ones, and the contents of all of those variables.  Of course, for an XPL
 program any complexity, the printout is quite long, so this function is
 presumably used sparingly.  The <font color="#663300"><code>heading</code></font> parameter is simply a message printed at the top, which can be helpful if you call <font color="#663300"><code>printMemoryMap</code></font> several times (perhaps via <font color="#663300"><code>CALL INLINE</code></font>) in the same program run.  In a <b>gdb</b> console, you could run it via the command <font color="#663300"><code>call printMemoryMap("...")</code></font>, whereas you could instead embed it in your XPL source code via <font color="#663300"><code>CALL INLINE('</code><code>printMemoryMap("...")</code><code>');</code></font>.<br></li>
  <li><font color="#663300"><code>char *getXPL(char *identifier)</code></font> — Returns (as a C string) the value of a single XPL variable whose name is given by the <font color="#663300"><code>identifier</code></font>.  The <font color="#663300"><code>identifier</code></font>
 string can be any identifier expression that's syntactically correct in
 XPL/I, provided that subscripts consist entirely of decimal digits, 
possibly with a leading minus sign.  This includes expressions like <font color="#663300"><code>"V"</code></font>, <font color="#663300"><code>"V(5)"</code></font>, <font color="#663300"><code>"B(3).V"</code></font>, or <font color="#663300"><code>"B(3).V(-5)"</code></font>.  Recall that in XPL/I, subscripts can be applied to scalar variables.  If you are querying a <font color="#663300"><code>BASED RECORD</code></font>, then be sure to include the desired field, since while <font color="#663300"><code>getXPL</code></font> knows how to print an individual field of a <font color="#663300"><code>RECORD</code></font>, it does not know how to print a <i>collection</i> of fields such as a <font color="#663300"><code>RECORD</code></font>.  In a <b>gdb</b> console, you could use <font color="#663300"><code>getXPL</code></font> with a command like <font color="#663300"><code>print getXPL(...)</code></font>.   For example, <font color="#663300"><code>print getXPL("C1(4)")</code></font>. <br></li>
  <li><font color="#663300"><code>void printXPL(char *identifier)</code></font> — This provides the same functionality as <font color="#663300"><code>getXPL</code></font>, except that it prints its output to <font color="#663300"><code>stdout</code></font> rather than returning it as a string.  In a <b>gdb</b> console, you could run it via the command <font color="#663300"><code>call printXPL("...")</code></font>, or you could instead embed it in your XPL source code via <font color="#663300"><code>CALL INLINE('</code><code>printXPL("...")</code><code>');</code></font>.</li>
  <li><font color="#663300"><code>int bitBits</code></font> — By default, <font color="#663300"><code>getXPL</code></font> and <font color="#663300"><code>printXPL</code></font> print the data of a <font color="#663300"><code>BIT</code></font> variable in hexadecimal notation.  In contrast, legacy XPL source code has often logically partitioned the data in <font color="#663300"><code>BIT</code></font>
 strings into subgroupings of 1, 2, or 3 bits (rather than 4 as for 
hexadecimal), thus using literal constants (such as initializers in 
declarations) that are in binary, base-4, or octal notation.  In those 
cases, it's difficult to relate hexadecimal strings returned by <font color="#663300"><code>getXPL</code></font> with the literals shown in the XPL source code.  The global variable <font color="#663300"><code>bitBits</code></font> addresses this by allowing you to change the radix used for the <font color="#663300"><code>BIT</code></font> data.  By default <font color="#663300"><code>bitBits</code></font> is 4 (hexadecimal), but can be changed to 1 (binary), 2 (base-4), or 3 (octal)<font color="#663300"><code></code></font>.  In a <b>gdb</b> console, you could change via a command like <font color="#663300"><code>set bitBits=2</code></font>.</li>
</ul>
<p>In using these debugging functions, note that they all require <i>mangled</i> forms of variable names and parameters of <code>PROCEDURE</code>s.  Mangled names consist of the names of the variables or parameters as <font color="#663300"><code>DECLARE</code></font>d in the XPL source code, but <i>prefixed</i> by the names of all of the parent <font color="#663300"><code>PROCEDURE</code></font>s.  Perhaps an example would make this clearer.  Suppose your XPL source code looked like the following:<br></p>
<blockquote>
  <pre><font color="#663300">DECLARE X FIXED, Y FIXED, Z FIXED;<br></font></pre>
  <pre><font color="#663300">PROC1:<br>PROCEDURE(X, Y);<br>   DECLARE X FIXED, Y FIXED, Z FIXED;<br><br>   PROC2:<br>   PROCEDURE(X, Y);<br>      DECLARE X FIXED, Y FIXED, Z FIXED;<br>      ...<br>   END PROC2;<br><br>END PROC1;</font><br></pre>
</blockquote>
<p>Then the mangled variable and parameter names we'd find in our memory map (and just for reference, <font color="#663300"><code>PROCEDURE</code></font> names), as well as being used in our debugging functions, would be:<br></p>
<blockquote>
  <pre><font color="#663300">X<br>Y<br>Z<br>PROC1<br>PROC1xX<br>PROC1xY<br>PROC1xZ<br>PROC1xPROC2<br>PROC1xPROC2xX<br>PROC1xPROC2xY<br>PROC1xPROC2xZ</font><br></pre>
</blockquote>
Thus while we have lots of global and local variables and function parameters named <font color="#663300"><code>X</code></font>, <font color="#663300"><code>Y</code></font>, and <font color="#663300"><code>Z</code></font>, their mangled names are all distinct. <br>
<blockquote><font size="-1"><b>Aside:</b> By the way, the lower-case '<font color="#663300"><code>x</code></font>' characters appearing in the mangled names have nothing to do with the fact that one of our identifiers is '<font color="#663300"><code>X</code></font>'.&nbsp; That's a coincidence.&nbsp; Rather, they're just convenient separators <b>XCOM-I</b> conventionally uses between scope names and the variable names.&nbsp; Recall that XPL identifiers are case-insensitive.&nbsp; <b>XCOM-I</b> translates them all internally to upper case.&nbsp; Hence, lower-case 'x' is not a character that can appear in <i>un</i>mangled identifiers or names of scopes.</font><br>
</blockquote>
<h1>


  <a name="hooks"></a>Patches for Insertion of Arbitrary Inline Code</h1>A serious difficulty in working with XPL or XPL/I code is that they are often not 
written entirely in XPL/I, but also have insertions of inline machine code at various junctures.&nbsp; <br>
<br>
For example, <b>XCOM45</b> and <b>HAL/S-FC</b> source code both have such inlined code.&nbsp; However good 
<b>XCOM-I</b> may (or may not) be at translating XPL or XPL/I to C, it 
is not capable of inferring the intent of arbitrary assembly language, 
nor of translating such code into C with the level of reliability 
required for automating it.&nbsp;&nbsp; While it can <i>help</i> with such translation (as described in the <a moz-do-not-send="true" href="#inlines">next section</a>),
 some amount of manual intervention is still required on the part of the
 coder.&nbsp; The basic principles underlying the framework provided for
 that are discussed in this section.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; In reality, such inlined code is numerical in nature, and consists of IBM 360 <i>machine code</i>
 ... whereas the term "assembly language" implies that the insertions 
are symbolic in nature rather than just numbers.&nbsp; I'll continue to 
call the insertions BAL, because they undoubtedly began as BAL before 
somebody assembled them to determine which numerical values to 
use.&nbsp; But it is certainly technically incorrect to do so.<br>
</font>
</blockquote>Of course, one possible approach would be to replace 
offending inline code directly by C code in the XPL source-code files of
 the program being compiled, using the property of the <b>XCOM-I</b> built-in <font color="#663300"><code>INLINE</code></font> function,<br>
<blockquote>
  <pre>CALL INLINE('<i>...arbitrary C code of no more than 256 characters...</i>');<br></pre>
</blockquote>
In your use case, whatever that may be, perhaps that's adequate.&nbsp; 
However, the Virtual AGC Project aims to provide a way to work with 
legacy code — i.e., code from the past, rather than newly-written code 
—, and that implies being able to compile such source code as-is, 
without syntactical or functional modification to source code.&nbsp; 
Which means that from our point of view, irreversible modification of 
legacy source code is unacceptable.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; It is, of course, 
arguable the extent to which modifications are acceptable.&nbsp; The 
Virtual AGC Project allows insertion of modern comments, as long as 
modern comments are clearly distinguishable from original program 
comments.&nbsp; It has occasionally allowed clearly-commented simple 
changes of a line or two of code, when it was thought impossible for 
modern compilers to duplicate some undocumented behavior of the original
 compilers ... although improvements to the modern compilers almost 
always eventually allowed reversal of such modifications.&nbsp; My 
personal judgment is that replacement of dozens or hundreds of lines of 
code by code that's not obviously functionally identical, written in 
another language, is taking it farther than I'd like.&nbsp; Better to 
leave the source code the same, so that it's verifiable by the user.</font><br>
</blockquote>
Don't worry!&nbsp; <b>XCOM-I</b> lets us satisfy these criteria.&nbsp; But to understand <i>how</i>, you need to know a 
little more about this IBM Basic Assembly Language (BAL) code that's causing the problem.<br>
<br>
Let's let a real-life example guide the discussion.&nbsp; The XPL source-code for SUNY's <b>XCOM45</b>
 program — which as you'll recall is an XPL compiler from the State 
University of New York in the mid-1970's  — contains a single block of 
19 consecutive <font color="#663300"><code>CALL INLINE</code></font> statements that we need to work around if we want to compile <i>and run</i> a version of <b>XCOM45</b> with <b>XCOM-I</b>:<br>
<blockquote>
  <pre><font color="#663300">SCAN_FINDS_END_OF:<br>   PROCEDURE(TABLE) BIT(1);<br>      DECLARE TABLE FIXED;<br>      DECLARE TRT(1) FIXED INITIAL("DD003000", "10000000");<br><br>      /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */<br>      CALL INLINE("58", 3, 0, TEXT);     /* LOAD STRING DESCRIPTOR */<br>      CALL INLINE("1B", 2, 2);           /* CLEAR REG. 2 */<br>      CALL INLINE("19", 3, 2);           /* CHECK FOR TEXT = NULL STRING */<br>      CALL INLINE("07", 8, 12);          /* RETURN FALSE IF TEXT IS NULL */<br>      CALL INLINE("8D", 2, 0, 0, 8);     /* SHIFT LENGTH FIELD TO REG. 2 */<br>      CALL INLINE("88", 3, 0, 0, 8);     /* RESTORE STRING ADDRESS  */<br>      CALL INLINE("58", 1, 0, TABLE);    /* LOAD BASE ADDRESS OF TRANS_TABLE */<br>      CALL INLINE("41", 12, 0, TRT);     /* LOAD ADDRESS OF TRT INSTRUCTION */<br>      CALL INLINE("44", 2, 0, 12, 0);    /* EXECUTE TRT INSTRUCTION */<br>      CALL INLINE("05", 12, 0);          /* LOAD BRANCH REGISTER  */<br>      CALL INLINE("47", 7, 0, 12, 18);   /* BRANCH ON CC~=0  */<br>      CALL INLINE("18", 1, 2);           /* LOAD REG. 1 WITH LENGTH(\) - 1 */<br>      CALL INLINE("41", 0, 0, 0, 1);     /* LOAD REG. 0 WITH 1  */<br>      CALL INLINE("1A", 1, 0);           /* ADD TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("1B", 3, 3);           /* PUT 0 INTO RETURN REGISTER */<br>      CALL INLINE("47", 15, 0, 12, 24);  /* BRANCH AROUND NEXT TWO INSTR*/<br>      CALL INLINE("1B", 1, 3);        /* SUBTRACT TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("41", 3, 0, 0, 1);     /* LOAD 1 INTO RETURN REGISTER */<br>      CALL INLINE("50", 1, 0, CP);       /* STORE IDENTIFIER LENGTH */<br>   END SCAN_FINDS_END_OF;</font><br></pre>
</blockquote>
Actually, to be clear, <b>XCOM-I</b> will <i>compile</i> <b>XCOM45</b> 
just fine, whether we work around this embedded assembly-language stuff 
or not; the compiled program simply won't run correctly, because vital 
IBM 360 instructions will be missing in the midst of the program.&nbsp; 
As it 
happens, though, part of the process of creating the workaround <i>depends</i> on us compiling <b>XCOM45</b> in advance, without any workarounds in place.&nbsp; So let's just do that.&nbsp; In the compilation process, the XPL procedure <font color="#663300"><code>SCAN_FINDS_END_OF</code></font> turns into a C file called SCANxSCAN_FINDS_END_OF.c that contains the following harmless but useless C representation of it:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-19 12:14:14.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>bit_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br>  ; // (0) CALL INLINE( 88, 3, 0, TEXT);<br>  ; // (1) CALL INLINE( 27, 2, 2);<br>  ; // (2) CALL INLINE( 25, 3, 2);<br>  ; // (3) CALL INLINE( 7, 8, 12);<br>  ; // (4) CALL INLINE( 141, 2, 0, 0, 8);<br>  ; // (5) CALL INLINE( 136, 3, 0, 0, 8);<br>  ; // (6) CALL INLINE( 88, 1, 0, TABLE);<br>  ; // (7) CALL INLINE( 65, 12, 0, TRT);<br>  ; // (8) CALL INLINE( 68, 2, 0, 12, 0);<br>  ; // (9) CALL INLINE( 5, 12, 0);<br>  ; // (10) CALL INLINE( 71, 7, 0, 12, 18);<br>  ; // (11) CALL INLINE( 24, 1, 2);<br>  ; // (12) CALL INLINE( 65, 0, 0, 0, 1);<br>  ; // (13) CALL INLINE( 26, 1, 0);<br>  ; // (14) CALL INLINE( 27, 3, 3);<br>  ; // (15) CALL INLINE( 71, 15, 0, 12, 24);<br>  ; // (16) CALL INLINE( 27, 1, 3);<br>  ; // (17) CALL INLINE( 65, 3, 0, 0, 1);<br>  ; // (18) CALL INLINE( 80, 1, 0, CP);<br>  return 0;<br>}</font><br></pre>
</blockquote>


Basically, <b>XCOM-I</b> has simply commented out each <font color="#663300"><code>CALL INLINE</code></font>
 statement, while replacing it with an empty statement.&nbsp; So why did
 we bother compiling it at all?&nbsp; The answer is that we want the 
parenthesized numbers that have been added to the comments!&nbsp; The 
parenthesized numbers will be the same every time we compile <b>XCOM45</b>, unless you take it upon yourself to mess us up by removing some of the <font color="#663300"><code>CALL INLINE</code></font> statements or adding new ones in the meantime.&nbsp; <b>Pro tip:</b>&nbsp; Don't do that!<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; There is even one (!) instance in <b>HAL/S-FC</b> in which there is a <font color="#663300"><code>RETURN INLINE</code></font> statement as well, and it is treated by <b>XCOM-I</b> the same way as <font color="#663300"><code>CALL INLINE</code></font>s
 are treated:&nbsp; namely, it is numbered and commented out.&nbsp; As 
it happens, McKeeman does not give even the slightest hint that <font color="#663300"><code>INLINE</code></font> can return a value.&nbsp; In point of fact, I don't think the value returned by the </font><font size="-1"><font color="#663300"><code>RETURN INLINE</code></font> statement in the case I mention even comes from the </font><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font></font> at all, but is instead generated by other means.&nbsp; Technically, I think that if you have a block of <font color="#663300"><code>CALL INLINE</code></font>s terminated by a <font color="#663300"><code>RETURN INLINE</code></font>, then whatever value happens to remain in the CPU's R0 register will be returned, regardless of where in the block of </font><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font>s</font> R0 was set up.&nbsp; But regardless of the underlying details, it demonstrates that <i>syntactically</i>, both <font color="#663300"><code>CALL INLINE</code></font> and <font color="#663300"><code>RETURN INLINE</code></font> are possible in XPL/I source code.<br>
<br>
<b>Important note:</b>&nbsp; If you must write a C-language patch-file for a block of <font color="#663300"><code>INLINE</code></font>s that include an </font><font size="-1"><font size="-1">XPL </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN INLINE(...)</code></font></font></font>, you should use the C macro <font color="#663300"><code>RETURN()</code></font> rather than simply <font color="#663300"><code>return</code></font>, or </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(<i>something</i>)</code></font></font> rather than <font color="#663300"><code>return <i>something</i></code></font>.&nbsp; That's because the </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(...)</code></font></font> macro takes into account extra code which <b>XCOM-I</b> may need to insert in conjunction with XPL </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN</code></font></font> statements.&nbsp; For example, if <b>XCOM-I</b> is run with its <font color="#663300"><code>--reentry-guard</code></font> switch, then <b>XCOM-I</b> inserts code at the entry point and exit points of each XPL <font color="#663300"><code>PROCEDURE</code></font> that allows the runtime library to detect illegal reentries.&nbsp; (Recall that recursion is illegal in XPL.)&nbsp; The </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(...)</code></font></font></font> macro handles this for you transparently, and if a simple </font><font size="-1"><font size="-1"><font color="#663300"><code>return</code></font></font> is used instead, then the runtime library will falsely detect recursion the second time any individual </font><font size="-1"><font size="-1"><font color="#663300"><code>PROCEDURE</code></font></font> is executed.<br>
  </font></blockquote>


In this particular example, since <b>XCOM45</b> has a single block of <font color="#663300"><code>CALL INLINE</code></font> statements, we were guaranteed in advance that the block would start with number 0.&nbsp; In a more-complex example like <b>HAL/S-FC</b>, there would be a number of blocks of inlines, strewn throughout the source code, and lieu of <b>XCOM-I</b>
 printing them all out for us the numbering would be 
unpredictable.&nbsp; But because the numbers never change, we can use 
them as unique, persistent identifiers for the <font color="#663300"><code>CALL INLINE</code></font> statements.&nbsp; <br>
<br>
Why is that important?&nbsp; The way we're going to work around the <font color="#663300"><code>CALL INLINE</code></font>
 statements is to create a series of numbered "patch files", written in 
C:&nbsp; patch0.c, patch1.c, patch2.c, and so on.&nbsp; The patch files 
are placed in the same folder that contains the source code of the XPL 
program being compiled, though <b>XCOM-I</b> does have a command-line 
option (<font color="#663300"><code>--patch=<i>PATHNAME</i></code></font>)
 that allows a different folder to be specified.&nbsp; When <b>XCOM-I</b> encounters a <font color="#663300"><code>CALL INLINE</code></font> statement, it looks for a patch file with the same number, and <i>if</i>
 it finds one, it directly inserts the contents of the patch file into 
the object code. &nbsp; If there's no matching patch file, then the <font color="#663300"><code>CALL INLINE</code></font> simply remains a comment.&nbsp; In principle, you could have a different patch file for each <font color="#663300"><code>CALL INLINE</code></font>, but it's usually more practical and more aesthetically pleasing to have a single patch file for each contiguous block of <font color="#663300"><code>CALL INLINE</code></font> statements.&nbsp; <br>
<blockquote><b><font size="-1">Note:</font></b><font size="-1">&nbsp; In working with the source code for <b>HAL/S-FC</b>
 specifically, it's a little more complex than what I just 
indicated.&nbsp; As I've mentioned previously, there are two different 
methods of compiling <b>HAL/S-FC</b> source code:&nbsp; One to create a compiler intended to compile Primary Flight Software (PFS) via <b>XCOM-I</b>'s <font color="#663300"><code>--cond=P</code></font> command-line switch, and one to create a compiler intended to compile Backup Flight Software (BFS) via <b>XCOM-I</b>'s <font color="#663300"><code>--cond=B</code></font> command-line switch.&nbsp; Unfortunately, the numbering of the <font color="#663300"><code>CALL INLINE</code></font> statements is a bit different in these two cases, which makes it unwieldy to rely on the generic naming patch<i>N</i>.c for the patch files.&nbsp; My description above is what happens when neither </font><font size="-1"><font size="-1"><font color="#663300"><code>--cond=P</code></font></font> nor </font><font size="-1"><font size="-1"><font color="#663300"><code>--cond=B</code></font></font> is used.&nbsp; But if </font><font size="-1"><font size="-1"><font color="#663300"><code>--cond=P</code></font></font> is used, then <b>XCOM-I</b> actually looks for patch files with names like patch<i>N</i>p.c first, falling back to patch<i>N</i>.c if patch<i>N</i>p.c isn't found.&nbsp; And similarly, if </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>--cond=B</code></font></font></font> is used, it prefers patch files named patch<i>N</i>b.c, falling back to patch<i>N</i>.c.&nbsp; This method allows the generic names patch<i>N</i>.c to be used up the point at which the numbering of the </font><font size="-1"><font color="#663300"><code>INLINE</code></font>s begins to differ, switching to the patch<i>N</i>p.c/patch<i>N</i>b.c naming thereafter, without any ambiguity or conflicts between the two.</font><br>
</blockquote>


In this real-life example, since there's a single block of <font color="#663300"><code>CALL INLINE</code></font> statements, we need a single patch file, patch0.c.<br>

<blockquote>
  <pre><font color="#663300">/*<br> * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br> * by XCOM-I.py.<br> *<br> * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br> * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br> * the entire xcom4 program.<br> *<br> * What the procedure does is this:  It's given the address of a "translation<br> * table" of one of the following types:<br> *      `BLANKTABLE`  (Blanks)<br> *      `ALPHATABLE`  (Identifier)<br> *      `STRINGTABLE` (Quoted string)<br> *      `COMMENTABLE` (Comment)<br> * Starting at position `CP=0` (already set up upon entry so that we know the<br> * first character is of the asked-for type) in the string `TEXT`, searches<br> * for the end of the pattern of the selected type, and updates `CP` to the<br> * length of the found string.  It returns 0 on failure and 1 on success.  An<br> * empty string counts as a failure.<br> *<br> * This was apparently coded in BAL because the IBM 360 has a translation-table<br> * instruction, TRT, that does this efficiently.  But from my perspective,<br> * considering that there's no other embedded BAL code in the entire program,<br> * it seems as though it's a big price to pay, maintenance-wise and<br> * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br> * always make assembly-language go faster than a high-level language; this is<br> * news?<br> */<br><br>static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>      *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>char *s, *TEXT;<br>uint32_t TABLE;<br><br>if (mapCP == NULL)<br>  {<br>    mapCP = lookupVariable("CP");<br>    mapTEXT = lookupVariable("TEXT");<br>    mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>    mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>    mapALPHATABLE = lookupVariable("ALPHATABLE");<br>    mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>    mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>  }<br><br>TABLE = getFIXED(mapTABLE-&gt;address);<br>TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br><br>if (*TEXT == 0)<br>  return fixedToBit(1, 0);<br>if (TABLE == mapBLANKTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>  }<br>else if (TABLE == mapALPHATABLE-&gt;address)<br>  {<br>    for (s = TEXT;<br>         isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>         s++);<br>  }<br>else if (TABLE == mapSTRINGTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br><br>  }<br>else if (TABLE == mapCOMMENTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>  }<br>else<br>  abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>if (*s == 0)<br>  {<br>    putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>    return fixedToBit(1, 0);<br>  }<br>putFIXED(mapCP-&gt;address, s - TEXT);<br>return fixedToBit(1, 1);<br></font><br></pre>
</blockquote>

Now that we actually have a patch file, when <b>XCOM-I</b> again compiles <b>XCOM45</b>, the <font color="#663300"><code>SCAN_FINDS_END_OF</code></font> procedure is now translated to the following C code:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-25 14:05:21.<br>*/<br><br>#include "runtimeC.h"<br><br>descriptor_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br><br>  { // (0) CALL INLINE ( 88, 3, 0,TEXT);<br>    /*<br>     * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br>     * by XCOM-I.py.<br>     *<br>     * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br>     * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br>     * the entire xcom4 program.<br>     *<br>     * What the procedure does is this:  It's given the address of a "translation<br>     * table" of one of the following types:<br>     *      `BLANKTABLE`  (Blanks)<br>     *      `ALPHATABLE`  (Identifier)<br>     *      `STRINGTABLE` (Quoted string)<br>     *      `COMMENTABLE` (Comment)<br>     * Starting at position `CP=0` (already set up upon entry so that we know the<br>     * first character is of the asked-for type) in the string `TEXT`, searches<br>     * for the end of the pattern of the selected type, and updates `CP` to the<br>     * length of the found string.  It returns 0 on failure and 1 on success.  An<br>     * empty string counts as a failure.<br>     *<br>     * This was apparently coded in BAL because the IBM 360 has a translation-table<br>     * instruction, TRT, that does this efficiently.  But from my perspective,<br>     * considering that there's no other embedded BAL code in the entire program,<br>     * it seems as though it's a big price to pay, maintenance-wise and<br>     * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br>     * always make assembly-language go faster than a high-level language; this is<br>     * news?<br>     */<br>    <br>    static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>          *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>    char *s, *TEXT;<br>    uint32_t TABLE;<br>    <br>    if (mapCP == NULL)<br>      {<br>        mapCP = lookupVariable("CP");<br>        mapTEXT = lookupVariable("TEXT");<br>        mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>        mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>        mapALPHATABLE = lookupVariable("ALPHATABLE");<br>        mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>        mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>      }<br>    <br>    TABLE = getFIXED(mapTABLE-&gt;address);<br>    TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br>    <br>    if (*TEXT == 0)<br>      return fixedToBit(1, 0);<br>    if (TABLE == mapBLANKTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>      }<br>    else if (TABLE == mapALPHATABLE-&gt;address)<br>      {<br>        for (s = TEXT;<br>             isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>             s++);<br>      }<br>    else if (TABLE == mapSTRINGTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br>    <br>      }<br>    else if (TABLE == mapCOMMENTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>      }<br>    else<br>      abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>    if (*s == 0)<br>      {<br>        putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>        return fixedToBit(1, 0);<br>      }<br>    putFIXED(mapCP-&gt;address, s - TEXT);<br>    return fixedToBit(1, 1);<br>  }<br>  ; // (1) CALL INLINE ( 27, 2, 2);<br>  ; // (2) CALL INLINE ( 25, 3, 2);<br>  ; // (3) CALL INLINE ( 7, 8, 12);<br>  ; // (4) CALL INLINE ( 141, 2, 0,0,8);<br>  ; // (5) CALL INLINE ( 136, 3, 0,0,8);<br>  ; // (6) CALL INLINE ( 88, 1, 0,TABLE);<br>  ; // (7) CALL INLINE ( 65, 12, 0,TRT);<br>  ; // (8) CALL INLINE ( 68, 2, 0,12,0);<br>  ; // (9) CALL INLINE ( 5, 12, 0);<br>  ; // (10) CALL INLINE ( 71, 7, 0,12,18);<br>  ; // (11) CALL INLINE ( 24, 1, 2);<br>  ; // (12) CALL INLINE ( 65, 0, 0,0,1);<br>  ; // (13) CALL INLINE ( 26, 1, 0);<br>  ; // (14) CALL INLINE ( 27, 3, 3);<br>  ; // (15) CALL INLINE ( 71, 15, 0,12,24);<br>  ; // (16) CALL INLINE ( 27, 1, 3);<br>  ; // (17) CALL INLINE ( 65, 3, 0,0,1);<br>  ; // (18) CALL INLINE ( 80, 1, 0,CP);<br>  return 0;<br>}<br></font><br></pre>
</blockquote>
Notice that the patch is <i>automatically</i> placed within a C <font color="#663300"><code>{...}</code></font> block, which is important if the <font color="#663333"><code>CALL INLINE(...)</code></font> happens to have been preceded by something like <code><font color="#663300">IF ... THEN</font></code> or <font color="#663300"><code>ELSE</code></font>. <br>
<h1><a name="inlines"></a>IBM 360 Inline Code<br>
</h1>
<p>Let's start with the executive summary: <br>
</p>
<p>In this section, we revisit the problem of inline machine code discussed in <a moz-do-not-send="true" href="#hooks">the preceding section</a>, describing a tool that may be of assistance in writing patch files for IBM 360 inline code.&nbsp; In brief, if you run <b>XCOM-I</b> with the command-line switch <font color="#663300"><code>--guess=-1</code></font>,&nbsp; it will create a set of files (guess*.c) that are <b>XCOM-I</b>'s best guess of what the patch-files (patch*.c) should be like.&nbsp; (You can also use <font color="#663300"><code>--guess=<i>N</i><i><sub>1</sub></i>,<i>N</i><sub><i>2</i></sub>,<i>N<sub>3</sub></i>,...</code></font> to generate just the files for specific patch numbers, whereas -1 generates <i>every</i>
 patch.)&nbsp; You can then manually tweak these "guessed" files with 
(hopefully!) much-reduced effort to get patch-files you're satisfied 
with.&nbsp; There are three ways in which this guessing facility is 
known to fail,&nbsp; and thus to require manual fixes:<br>
</p>
<ol>
  <li>Only the IBM 360 instructions I've actually encountered in legacy XPL programs (specifically, <b>XCOM3</b>, <b>XCOM4</b>, and <b>HAL/S-FC</b>) are supported.&nbsp; At this writing, that's about ~10% of the full IBM 360 instruction set.</li>
  <li>Self-modifying code, or pseudo-self-modifying code due to the use of the IBM 360 instruction EX, will not work properly.&nbsp;
 Translations of the EX instruction are specifically detected and marked
 with a comment of "***FIXME***".&nbsp; In my experience, most manual 
tweaks are related to these EX instructions, and specifically to the use
 of EX to execute modified MVC instructions; this is covered in more 
detail later.<br>
  </li>
  <li>Code which accesses or modifies CPU registers associated with subroutine linkage requires attention, because XCOM-I does <i>not</i>
 set up these registers upon entry to a procedure, nor does it use the 
contents of these registers upon exit from a procedure.&nbsp; Or more 
succinctly, C translations of XPL procedures do not follow IBM 360 
calling conventions.&nbsp; This is rare problem in my experience.<br>
  </li>
</ol>
<p>That's the summary, which may be everything you actually need to know.&nbsp; Here's the longer explanation.<br>
</p>
Having now gone through the process of manually writing many patch files
 for IBM 360 inline code, I've come to realize that I had overestimated 
the difficulty of translating that inline code to C code.&nbsp; With 
experience, I've now observed that:
<ul>
  <li>The number of different IBM 360 instructions used in these is very
 limited, with just a handful of mostly-simple instructions making up 
the bulk of them.</li>
  <li>All those instructions do is to read and write to memory and to a 
subset of the CPU's general registers, floating-point registers, and 
condition-code register.<br>
  </li>
  <li>And, of those particular CPU registers inlined in legacy XPL or XPL/I code, you can <i>mostly</i> assume that there are no side effects associated with doing so.</li>
</ul>
As part of a systematic framework for exploiting this, the <b>XCOM-I</b> the runtime library defines the IBM 360 CPU registers as the following global variables:
<blockquote>
  <pre><font color="#663300">int32_t GR[16]; // CPU general-purpose registers.<br>double FR[16];  // CPU floating-point registers.<br></font><font color="#663300">uint8_t CC; // CPU condition code register. Only the least two bits are significant.</font><br></pre>
</blockquote>
<blockquote>
  <p><font size="-1"><b>Aside:</b> If unlike me you're actually familiar
 with IBM 360 programming, I'm sure you'll call the CPU's 
general-purpose registers R0, R1, R2, and so on.&nbsp; IBM documentation
 calls them that.&nbsp; It also calls the floating-point registers, 
which are completely separate and independent of the general-purpose 
registers,
 by those very same names:&nbsp; R0, R1, R2, ....&nbsp; Perhaps it's 
just me, but I found that confusing.&nbsp; And because I was so stupid 
as to be confused by this <i>apparently</i> obvious and trivial point, 
it has cost me considerable amount of time.&nbsp; Consequently, I now 
make a point of calling the general-purpose registers GR<i>n</i> and the floating-point registers FR<i>n</i>.&nbsp;
 Yes, it's a departure from tradition.&nbsp; No, in this particular case
 I don't care that I've departed from tradition.&nbsp; A foolish 
consistency is the hobgoblin of little minds.</font><br>
  </p>
</blockquote>
<p>Meanwhile, memory can always be accessed and/or converted from IBM 360 formats to native C formats, also via <b>XCOM-I</b> runtime-library features:<br>
</p>
<ul>
  <li><font color="#663300"><code>uint8_t memory[0x1000000]</code></font> — for reading and writing 8-bit bytes from/to memory.</li>
  <li><font color="#663300"><code>int32_t COREWORD(uint32_t <i>address</i>)</code></font> and <font color="#663300"><code>void COREWORD2(uint32_t <i>address</i>, int32_t <i>value</i>)</code></font> <font color="#663300"><code></code></font> — for reading and writing 32-bit words from/to memory, respectively.</li>
  <li><font color="#663300"><code>int16_t COREHALFWORD(uint32_t <i>address</i>)</code></font> and <font color="#663300"><code>void COREHALFWORD2(uint32_t <i>address</i>, int16_t <i>value</i>)</code></font> <font color="#663300"><code></code></font> — for reading and writing 16-bit half-words from/to memory, respectively.</li>
  <li><font color="#663300"><code>double fromFloatIBM(uint32_t <i>msw</i>, uint32_t <i>lsw</i>)</code></font> and <font color="#663300"><code>void toFloatIBM(uint32_t *<i>msw</i>, uint32_t *<i>lsw</i>, double <i>value</i>)</code></font> <font color="#663300"><code></code></font> — for converting pairs of 32-bit words to/from C double-precision floats, respectively.</li>
  <li><font color="#663300"><code>void setCC(void)</code></font> and <font color="#663300"><code>void setCCd(void)</code></font> <font color="#663300"><code></code></font> — for adjusting the condition-code register after integer operations or floating-point operations, respectively.<br>
  </li>
</ul>
<p>Additional globals are provided by the runtime library for holding commonly-needed temporary results:<br>
</p>
<blockquote>
  <pre><font color="#663300">int32_t address360A, address360B, dsw360, lsw360;<br>int64_t scratch;   // Results of integer operations; input to setCC (see above).<br>double scratchd;   // Results of floating-point operations; input to setCCd (see above).<br>int64_t dummy360;  // Use for anything you like.<br>double dummy360d; </font><font color="#663300"><font color="#663300"> // Use for anything you like.</font>
double epsilon360; // A small number, used for tolerance in some floating-point comparisons.<br></font></pre>
</blockquote>
For floating-point operations, native C formats and arithmetical 
operators are used.&nbsp; Conversion from/to IBM hexadecimal format 
occurs only when floating-point values are read from the memory array or
 written into the memory array.&nbsp; This is why the CPU's 
floating-point registers are modeled as the C <font color="#663300"><code>double</code></font> type.&nbsp; The alternative would have been to model them as pairs of <font color="#663300"><code>uint32_t</code></font>
 values, and to provide C functions that directly implemented exact IBM 
360 arithmetic (like addition, subtraction, and so on) directly upon 
such pairs.&nbsp; I admit that wisdom of my decision is arguable, but 
have no present plans to change the implementation.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Actually, there is one 
case in which this decision causes problems, and that involves the IBM 
360 instructions which perform "unnormalized" floating-point 
arithmetic.&nbsp; Recall that floating-point numbers have two parts, the
 <i>exponent</i> and the <i>significand</i>.&nbsp; For example, in 3.14156×<sup><super>10</super></sup>,
 the exponent is 10 and the significand is 3.14156. &nbsp; Almost all 
floating-point arithmetic on the IBM 360 is in "normalized" form, which 
means that the exponent and significant are adjusted so as to produce 
the maximum precision (number of bits) in the significand, given the 
number of bytes of storage allocated for the number in memory and the 
nature of the format used for storage.&nbsp; Thus in principle, 3.14156×<sup><super>10</super></sup> is more precise than 0.03142×<sup><super>12</super></sup>, and is less precise than 314.15654×<sup><super>8</super></sup>.&nbsp;
 In the case of IBM hexadecimal floating-point, the exponent field is 7 
bits wide and represents a power of 64 (rather than 10), and is offset 
by 64.&nbsp; I.e., if the exponent is (say) E, then the powers 
represented are 64<sup>-64</sup> through 64<sup>+63</sup>.&nbsp; The 
significand, meanwhile, is 56 bits wide and always positive, since 
there's a separate sign bit&nbsp; So in principle, an IBM hexadecimal 
double-precision floating-point number could represent exact positive or
 negative 56-bit integers.&nbsp; That'll be important in a minute.<br>
    <br>
Supplementing the instructions for normalized arithmetic, the IBM 360 includes instructions for both <i>unnormalized</i>
 addition and subtraction as well, which means they perform the 
indicated operations, but the results are taken as-is, without any 
normalization.&nbsp; Whereas the choice to use C <font color="#663300"><code>double</code></font> for all arithmetic in the <b>XCOM-I</b> framework means that all arithmetical results have maximum precision all the time.<br>
    <br>
Doesn't sound like a problem to you?&nbsp; Well, in practice <font color="#663300"><code>CALL INLINE</code></font>
 code uses a single unnormalized instruction, namely AW, which adds two 
floating-point numbers (normalized or unnormalized), producing an 
unnormalized result.&nbsp; It always does so in precisely the same 
manner, in order to perform the trick of converting a positive 
floating-point number (in IBM hexadeximal format) to a binary 
integer.&nbsp; In assembly language, that trick works as follows:<br>
  </font>
  <ul>
    <li><font size="-1">Somewhere — in <b>HAL/S-FC</b>, it's in the floating-point working area <font color="#663300"><code>DW(6)</code></font> and <font color="#663300"><code>DW(7)</code></font>, pointed to by the variable <font color="#663300"><code>ADDR_FIXER</code></font>
  — a representation of the number 0.0 is stored as the pair of words 
0x4E000000,0x00000000.&nbsp; (Note that there's no unique representation
 of 0.0 in IBM hexadecimal floating point, because the exponent is 
indeterminate when the signifcand is 0, but this particular choice of 
exponent is important.)</font></li>
    <li><font size="-1">AW is used to perform an unnormalized addition of the </font><font size="-1"><font size="-1"><font color="#663300"><code>ADDR_FIXER</code></font></font> representation 0.0 with a non-negative floating-point number that represents an integer.</font></li>
    <li><font size="-1">The unnormalized result of the addition has an 
exponent field that's 0x4E and a significand that's a non-negative 
56-bit binary integer.&nbsp; Specifically, the least-significant word is
 the least-significant 32 bits of the integer.<br>
      </font></li>
    <li><font size="-1">The least-significant word, being the desired <font color="#663300"><code>FIXED</code></font>
 data, is immediately stored someplace via the IBM 360 instruction STD 
for whatever further use the program has for that integer.<br>
      </font></li>
  </ul>
  <p><font size="-1">You probably don't care, but the reason this trick 
works is that IBM floating-point addition functions by unnormalizing the
 operand with the smaller exponent to match the exponent of the other 
operand, and then performing a binary addition of the 
significands.&nbsp; But no 56-bit integer can have an exponent in IBM 
hexadecimal format that's larger than 0x4E, so the representation of 0.0
 to have an exponent of 0x4E guarantees that it's the other operand that
 becomes unnormalized, and the way in which it's unnormalized is to be 
shifted rightward by exactly the right number of bits to turn into a 
binary representation of the integer.<br>
    </font></p>
  <p><font size="-1">Regardless of how it works, the reason this causes 
us a problem is that the native-C arithmetic we perform doesn't track 
any of this, so the AW is wasted, and <i>doesn't</i> produce an integer 
usable by the STD instructions that succeed the AW instructions.&nbsp; 
In other words, after the AW occurs, the <font color="#663300"><code>CALL INLINE</code></font> for the STD instruction that's supposed to store the 2's-complement integer has no 2's-complement integer to store!<br>
    </font></p>
  <p><font size="-1">The workaround for this in the <b>XCOM-I</b> 
runtime library, is that the floating-point registers are supplemented 
by an additional array that tracks whether the register should be 
treated as normalized or unnormalized, and then interprets the value 
stored in that floating-point register accordingly when an STD 
instruction is performed that stores the value in the register to 
memory:<br>
    </font></p>
  <blockquote>
    <pre><font size="-1" color="#663300">double FR[16];<br>uint8_t unnormFR[16]; // 0 to treat FRn as normalized, 1 as unnormalized.<br></font></pre>
  </blockquote>
  <p><font size="-1">Thus an AW instruction on <font color="#663300"><code>FR[<i>n</i>]</code></font> sets <font color="#663300"><code>unnormFR[<i>n</i>]</code></font>, while an STD instruction storing </font><font size="-1"><font size="-1"><font color="#663300"><code>FR[<i>n</i>]</code></font></font> resets </font><font size="-1"><font size="-1"><font color="#663300"><code>unnormFR[<i>n</i>]</code></font></font>.<br>
&nbsp;<br>
Yes, it's a bit of a hack, and if you were writing new <font color="#663300"><code>CALL INLINE</code></font> statements you could easily defeat it, but <i>for right now</i>
 it seems more economical than reworking the entire floating-point 
arithemetic system for a handful (less than 10) of uses of AW.&nbsp; My 
advice to you is this:&nbsp; If you're writing new XPL code, <i>don't</i> try to subvert my hack with perverted usage of the AW instruction in </font><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font></font> statements; AW (and </font><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font></font>, for that matter) is perverted enough already, and doesn't need <i>your</i> help.</font><br>
  </p>
</blockquote>
Let's get the question of IBM 360 
calling conventions out of the way.&nbsp; The conventional usage of the 
IBM 360 CPU's 
general registers in calling subroutines, as I understand it, is 
summarized in the bullet list below.&nbsp; But I've added a couple of 
apparently non-traditional extensions or differences (highlighted in <font color="#006600">green</font>) that I've inferred from some of the <font color="#663300"><code>CALL INLINE</code></font> statements I've encountered in the legacy code; take them with a grain of salt!<br>
<ul>
  <li>GR0 — Upon exit holds the return value.</li>
  <li>GR1 — Upon entry, holds the parameter (if there's only one) or else a pointer to a list of parameters.</li>
  <li><font color="#006600">GR3 — Upon exit holds the return value (<i>rather</i> than GR0).</font></li>
  <li><font color="#006600">GR12 </font><font color="#006600">— Upon 
entry holds the address at the end of the procedure's explicit code 
(prior to whatever linkage executes the actual return).<br>
    </font></li>
  <li>GR13 — Upon entry and exit, holds the address of an 18-word save 
area which holds the state (i.e., the general registers and other 
information) of the calling code. A procedure doesn't modify the 
contents of this save area, and must provide a different save area 
address to any procedures it calls itself<br>
  </li>
  <li>GR14 — Upon entry, holds the return address.</li>
  <li>GR15 — Upon entry, holds the beginning address of the procedure itself.<br>
  </li>
</ul>


<p>As for how a translation from IBM 360 machine code to C uses the 
various concepts described above, consider the very common statement <font color="#663300"><code>CALL INLINE("58", <i>n</i>, <i>v</i>)</code></font>, where <i><font color="#663300"><code>n</code></font></i> is a an integer 0-15 and <i><font color="#663300"><code>v</code></font></i>
 is the name of an XPL variable.&nbsp; This inline has IBM 360 opcode 
0x58, which has the assembly-language mnemonic L, and means to load 
register <font color="#663300"><code>GR[<i>n</i>]</code></font> with the contents of variable <i><font color="#663300"><code>v</code></font></i>.&nbsp; Such an inline can be translated into C as:<br>
</p>
<blockquote>
  <pre><font color="#663300">GR[<i>n</i>] = COREWORD(ADDR(<i>v</i>));</font><br></pre>
</blockquote>

Or consider <font color="#663300"><code>CALL INLINE("41", <i>n</i>, <i>v</i>)</code><font color="#000000">, which has the mnemonic LA, to store the address of the variable into the register:</font></font><br>
<blockquote>
  <pre><font color="#663300">GR[<i>n</i>] = ADDR(<i>v</i>);</font><br></pre>
</blockquote>


<font color="#663300"><font color="#000000">Or </font></font><font color="#663300"><font color="#000000"><font color="#663300"><code>CALL INLINE("50", <i>n</i>, <i>v</i>)</code><font color="#000000">, mnemonic ST, </font></font>to store the value of a register into a variable:<br>
  </font></font>
<blockquote>
  <pre><font color="#663300">COREWORD2(ADDR(<i>v</i>), GR[<i>n</i>]);</font><br></pre>
</blockquote>
In the 19-instruction patch used in the preceding section as an example,
 6 of the instructions used are already of one or the other of these 
three types.&nbsp; Other instructions may have much-more-complex 
implementations in C than these, of course.<br>
<br>
Recognizing that the majority of all <font color="#663300"><code>CALL INLINE</code></font> statements — though unfortunately not <i>all</i> of them — can be handled using these simple maneuvers, <b>XCOM-I</b> has a built-in tool that can create guessed versions of patch-files for you, in which most of the <font color="#663300"><code>INLINE</code></font>s have been translated, but with the ones that were too difficult for <b>XCOM-I</b> to handle left in the draft files for you to manually perfect.<br>
<br>
To use this tool, simply run <b>XCOM-I</b> as normal, using either or neither of the <font color="#663300"><code>--cond=P</code></font> or <font color="#663300"><code>--cond=B</code></font> options, <i>plus</i> the <font color="#663300"><code>--guess=...</code></font> switch as I summarized it earlier.&nbsp; When doing so, in addition to the normal compilation outputs, files named guess<i>N</i>.c, guess<i>N</i>p.c, or guess<i>N</i>b.c
 are output as well.&nbsp; You can then make manual changes to the 
guess-files and rename them as patch-files when you're satisfied.<br>
<br>
Regarding the effectiveness of the procedure, in the combined source code for the XPL programs <b>XCOM3</b>, <b>XCOM45</b>, and <b>HAL/S-FC</b>, there's a total of 81 blocks of <font color="#663300"><code>CALL INLINE</code></font>s, and thus in principle a total of 81 patch files.&nbsp; In generating guess-files for these programs, <b>XCOM-I</b> flags 11 of those guess-files with the comment <font color="#663300"><code>***FIXME***</code></font>, which you can easily search for in order to fix the associated issue.&nbsp; Problems <i>not</i> detectable by <font color="#663300"><code>--guess</code></font>, though rare, unfortunately are neither marked nor easy to find or fix.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Regarding the process of manually fixing up the EX instructions not supported by <b>XCOM-I</b> <font color="#663300"><code>--guess</code></font>, it's actually not that hard once you understand the trick involved.&nbsp; Admittedly, <i>right now</i> it will seem simpler to me than to you, given our relative positions on this particular learning curve.<br>
    <br>
An EX instruction is syntactically of the form<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">EX	R1,D2(X2,B2)</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1">where R1 is the number of a CPU general register, and 
D2(X2,B2) points to an IBM 360 machine code instruction.&nbsp; While it 
looks confusing, it's always easy to figure out which instruction is 
targeted, because in the XPL source code it will be set off by itself 
and there will be no way to reach it in C to execute it directly.&nbsp; 
Sometimes, the XPL source code will contain a binary representation of 
that target instruction, which makes the task a lot harder for you, but 
in the XPL I've seen it will almost always be represented as a <font color="#663300"><code>CALL INLINE</code></font>, which makes it much easier.&nbsp; The reason it's easy is because <b>XCOM-I</b> <font color="#663300"><code>--guess</code></font>
 will have made a guessed patch file for it, and will have printed the 
assembly-language syntax and the proposed C translation of it for you in
 the patch file.&nbsp; <br>
    <br>
To make what I'm saying concrete, consider an example taken from <b>PASS1</b> of <b>HAL/S-FC</b>.&nbsp; Here's a small excerpt of the XPL source-code file HALINCL/VMEM.xpl:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">         ELSE DO;                                                               00102100<br>            ADDRTEMP = ADDR(MOVECHAR);                                          00102200<br>            CALL INLINE("18",0,4);           /* LR 0,4                        */00102300<br>            CALL INLINE("58",2,0,INTO);      /* L  2,INTO                     */00102400<br>            CALL INLINE("58",3,0,FROM);      /* L   3,FROM                    */00102500<br>            CALL INLINE("48",1,0,LEGNTH);    /* LH 1,LEGNTH                   */00102600<br>            CALL INLINE("06",1,0);           /* BCTR 1,0                      */00102700<br>            CALL INLINE("58",4,0,ADDRTEMP);  /* L 4,ADDRTEMP                  */00102800<br>            CALL INLINE("44",1,0,4,0);       /* EX 1,0(0,4)                   */00102900<br>            CALL INLINE("18",4,0);           /* LR 4,0                        */00103000<br>            RETURN;                                                             00103100<br>         END;                                                                   00103200<br>      END;                                                                      00103300<br>MOVECHAR:                                                                       00103400<br>      CALL INLINE("D2",0,0,2,0,3,0);  /* MVC 0(0,2),0(3)                      */00103500</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1"><font size="-1">Those blocks of <font color="#663300"><code>CALL INLINE</code></font> statements correspond to patches 25 and 32 respectively.&nbsp; Thus <b>XCOM-I</b> <font color="#663300"><code>--guess</code></font></font>
 produces guessed patch files guess25p.c for lines 00102300-00103000 and
 guess32p.c for line 00103500.&nbsp; The latter is the target 
instruction for the EX instruction at line 00102900.&nbsp; It's visually
 obvious (since it's separated!), but you can tell it from reading the 
code too:&nbsp; Line 00102200 puts the address of the label <font color="#663300"><code>MOVECHAR</code></font> into the variable <font color="#663300"><code>ADDRTEMP</code></font>,
 while line 00102800 it moves it into the CPU general register GR4, and 
then at line 00102900 the EX instruction says that the base register GR4
 holds the address of the target instruction.&nbsp; Here's how <b>XCOM-I</b> has done its best in guess25p.c to translate the EX instruction,<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#009900">p25_24: ;<br>  // (31)       CALL INLINE("44", 2, 0, 3, 0);        /* EX  2,0(0,3)          */         <br>  address360B = GR[3] + 0;<br>  // Type RX, p. 7-74:		EX	2,0(0,3)<br>    // ***FIXME*** Unsupported opcode EX</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1">and in guess32p.c the target instruction,<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">p32_0: ;<br>  // (32)       CALL INLINE("D2", 0, 0, 1, 1, 1, 0);  /* MVC 1(0,1),0(1)       */         <br>  address360A = GR[1] + 1;<br>  address360B = GR[1] + 0;<br>  // Type SS, p. 7-83:		MVC	1(0,1),0(1)<br>  mvc(address360A, address360B, 0);</font><font size="-1"><br></font></pre>
  </blockquote>
  <font size="-1">In fact, in my experience, most EX instructions have 
targeted MVC instructions, as this example does, so this is great for 
covering the typical case! <br>
    <br>
Now, the action of an EX instruction is to replace bits 8-15 of the 
target machine-code instruction by the contents of the general register 
the EX instruction specifies, and then to execute that modified target 
instruction (<i>without</i> actually jumping to it).&nbsp; All you have 
to figure out is what in the C translation of the target instruction 
corresponds to bits 8-15 of the machine code.&nbsp; It will usually be 
something simple.&nbsp; For a target MVC instruction, I can tell you 
that it's just the final parameter of the <font color="#663300"><code>mvc(...)</code></font>
 function in the C translation.&nbsp; Thus, the change needed to the 
guessed file guess25p.c, in which the "***FIXME***" is replaced by 
actually-executable code, is this:<br>
  </font>
  <blockquote><font size="-1">
  </font><pre><font color="#009900"><font size="-1">p25_24: ;<br>  // (31)       CALL INLINE("44", 2, 0, 3, 0);        /* EX  2,0(0,3)          */         <br>  address360B = GR[3] + 0;<br>  // Type RX, p. 7-74:		EX	2,0(0,3)<br>  address360A = GR[1] + 1;<br>  address360B = GR[1] + 0;<br>  // Type SS, p. 7-83:		MVC	1(0,1),0(1)<br>  mvc(address360A, address360B, GR[2]);</font>
</font></pre></blockquote>
</blockquote>

Not perfect, of course, but not bad either.&nbsp; By my reckoning, close
 to 90% of the guessed files seem to be perfect as-is.&nbsp;&nbsp;&nbsp;
 And of the files which are not perfect, probably around 90% of the <font color="#663300"><code>CALL INLINE</code></font>s translated in those files are still perfect.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; As an example where <b>XCOM-I</b> fails to produce a perfect guessed result <i>not</i> due to an EX instruction, I can point to the single block of <font color="#663300"><code>CALL INLINE</code></font>s in the legacy program <b>XCOM45</b>.&nbsp;
 A number of its instructions involve use of the seemingly-uninitialized
 register GR12, as well as usage of the register GR3, that make sense 
(to me!) only if registers GR3 and GR12 are viewed as having a 
non-traditional conventional role in the subroutine linkage for calling 
their parent procedure (namely, <font color="#663300"><code>SCAN_FINDS_END_OF</code></font>):&nbsp;
 i.e., GR3 contains the return value of the procedure (rather than GR0 
as documented by IBM), and GR12 contains the size of the procedure's 
code (other than the linkage code), in bytes.<br>
    <br>
  </font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1">As another example, I'd point to the one case I know of (in the <font color="#663300"><code>INTEGER_VALUED</code></font> procedure of program <b>HAL/S-FC</b>) in which a <code><font color="#663300">RETURN</font></code></font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code> INLINE</code></font> statement is used rather than a </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font> statement.&nbsp; The </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font></font></font></font></font></font></font></font></font></font></font></font></font> XPL built-in is not specified in such a way as to return a value, but the calling procedure (<font color="#663300"><code>INTEGER_VALUE</code></font>) does check the returned value. &nbsp; Moreover, the </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>INLINE</code></font></font>s in </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>INTEGER_VALUED</code></font></font></font></font></font></font></font>
 do in fact manipulate the GR3 register in such a way as to contain 
either a 0 or a 1, without there being any other evident reason to do 
so, so it's easy to suppose once again that GR3 is indeed the return 
value.&nbsp; </font></font></font></font></font></font><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><font size="-1"><br>
            </font></font></font></font></font></font></blockquote>
<br>


    
<hr style="width: 100%; height: 2px;">
    
<center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-07-01<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i></center>


    <br>


  

</body></html>