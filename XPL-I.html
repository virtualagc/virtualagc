<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>XPL and XPL/I Development Tools</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","XPL/I and XPL Development Toolchain").replace("@SUBTITLE@","Contemporary and Modern"))
</script><br>
    <h1>Table of Contents </h1>
    <ul>
      <li><a moz-do-not-send="true" href="#Introduction">Introduction</a></li>
      <li><a moz-do-not-send="true" href="#WhyXPLI">XPL/I Versus
          Standard XPL</a></li>
      <li><b><a moz-do-not-send="true" href="#XCOMI">XCOM-I</a></b></li>
      <li><a moz-do-not-send="true" href="#Installation">Installation of
          <b>XCOM-I</b><br>
        </a></li>
      <ul>
        <li><a moz-do-not-send="true" href="#Linux">Linux or Mac OS<br>
          </a></li>
        <li><a moz-do-not-send="true" href="#Windows">Windows Specific</a></li>
        <li><a moz-do-not-send="true" href="#testTheInstallation">Testing










            the Installation</a></li>
      </ul>
      <li><a moz-do-not-send="true" href="#sim360">Emulating the IBM
          System/360 CPU</a></li>
      <li><a moz-do-not-send="true" href="#compilingXCOM">Insane
          Bootstrapping!</a></li>
      <li><a moz-do-not-send="true" href="#halsfc">How to Build HAL/S-FC</a></li>
      <li><a moz-do-not-send="true" href="#xpli">The Peculiarities of
          Standard XPL and Intermetrics XPL/I</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#programOptions">Program
          Options</a></li>
      <li><a moz-do-not-send="true" href="#builtin">Built-In
          Runtime-Library Functions</a></li>
      <li><a moz-do-not-send="true" href="#monitor">The MONITOR Built-In
          Runtime-Library Function</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#debugging">Debugging XPL
          Programs </a><br>
      </li>
      <ul>
      </ul>
      <li><a moz-do-not-send="true" href="#hooks">Patches for Insertion
          of Inline Code</a></li>
      <li><a moz-do-not-send="true" href="inlines">More on IBM
          System/360 Inline Code</a></li>
      <li><a moz-do-not-send="true" href="#appendix">Appendix:&nbsp;
          Suitable C Compilers</a><br>
      </li>
    </ul>
    <h1><a name="Introduction"></a>Introduction<br>
    </h1>
    XPL was a computer language (<a moz-do-not-send="true"
      href="https://en.wikipedia.org/wiki/XPL">see the Wikipedia article</a>)
    in the 1960's and 1970's that was defined by a book called <i>A
      Compiler Generator</i>, by William M. McKeeman, James J. Horning,
    and David B. Wortman.&nbsp; (Incidentally, there will also be
    frequent references to Intermetrics document IR-182-1, <a
      moz-do-not-send="true" href="Shuttle/19760020796.pdf#page=822">"HAL/S-FC










      &amp; HAL/S-360 Compiler System Program Description"</a>, though
    the document is not about the XPL language as such; for brevity,
    I'll refer to it simply as IR-182-1.) <br>
    <br>
    I'm unaware of any continued use of the XPL language today, though I
    don't claim to be enough of an XPL scholar to know for sure.&nbsp;
    (Let me know, if you know differently!)&nbsp;&nbsp; As for why the
    language is dead, I'd speculate that some of the more-important
    reasons are:<br>
    <ul>
      <li>The book remains the principal source of information about the
        language, and it's mainly about relatively-abstract
        topics.&nbsp; There is no "user's manual" for XPL.&nbsp; No
        "programmer's guide".&nbsp; No tutorials as to how to get
        started with it.&nbsp; Indeed, there is not even a "Hello,
        world!" program.&nbsp; The closest thing to a sample program in
        XPL is the source code for a full-blown language compiler!&nbsp;
        In short, there's no convenient way for a programmer to get
        started with it, except for immediately jumping into the deep
        end of the pool.<br>
      </li>
      <li>The language was not designed for general-purpose
        applications.&nbsp; It was tailored for the specific purpose of
        writing compilers for other computer languages, and writing
        compilers is not an everyday activity of large numbers of
        people.&nbsp; For example, while there is an integer datatype,
        there's no floating-point datatype; so how could you easily
        write mathematically-intensive programs in it?<br>
      </li>
      <li>The definition of the language is highly dependent on the
        characteristics of IBM System/360 mainframe computers, to the
        extent that even writing an XPL compiler that could run on
        non-compatible computers is quite a chore.&nbsp; Indeed, the
        preface to the book explicitly states that they were creating a
        language specifically for the IBM 360. </li>
    </ul>
    So why bother with it?<br>
    <br>
    To be blunt, it's all about the Space Shuttle and its flight
    software.&nbsp; If you want to work with Space Shuttle flight
    software, you need a compiler for a computer language called HAL/S,
    and fortunately <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0">we










      do have XPL source code for such a HAL/S compiler</a>.&nbsp; But
    if you want to use that HAL/S compiler, you first need an XPL
    compiler.&nbsp; And preferably, both compilers should work on
    computers that the general public actually has access to, such as
    Windows, Mac OS, or Linux computers, rather than being confined to
    mainframe systems that are no longer common.<br>
    <br>
    This web page is devoted to such a modern XPL compiler, which I call
    <b>XCOM-I</b>.&nbsp; A corresponding web page devoted to the modern
    HAL/S compiler, <b>HAL/S-FC</b> (which I'll often refer to as <b>HALSFC</b>
    in order to avoid the issue of having the / character in filenames),
    can be found <a moz-do-not-send="true" href="HAL.html">here</a>.&nbsp;










    A corresponding web page devoted to the Space Shuttle flight
    software (<b>PASS</b> and <b>BFS</b>) — and to the Space Shuttle
    computing systems in general —, can be found <a
      moz-do-not-send="true" href="Shuttle.html">here</a>.&nbsp; <b>HALSFC</b>
    will be discussed <i>here</i> only to the extent of instructions
    for building it using <b>XCOM-I</b>.<br>
    <h1><a name="WhyXPLI"></a>XPL/I Versus Standard XPL<br>
    </h1>
    The Space Shuttle flight software and the HAL/S compiler used to
    compile it were originally written by a company called Intermetrics,
    Inc.<br>
    <br>
    When I said earlier that the HAL/S compiler was written in XPL, I
    was taking certain liberties with the truth.&nbsp; The standard XPL
    language as described in <i>A Compiler Generator</i> was not
    adequate in Intermetrics's view, so they extended the language in
    various ways, and slightly modified its behavior in others.&nbsp;
    Intermetrics continued to refer to the language as "XPL", but XPL
    compilers conforming to <i>A Compiler Generator</i>, or indeed any
    XPL compiler outside the premises of Intermetrics itself, could not
    have compiled any significant program written in the XPL variant
    that Intermetrics had created.&nbsp; The lack of distinction between
    standard XPL and this extended XPL didn't matter as long as Fortress
    Intermetrics operated its walled garden separately from the
    remainder of the computing world.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; For example, the
        previous attempt best-known to me of a modern XPL compiler is <a
          moz-do-not-send="true"
          href="https://sourceforge.net/projects/xpl-compiler/">Daniel
          Weaver's XPL-to-C translator</a>.&nbsp; Alas, it is incapable
        of compiling Intermetrics's extended form of XPL.</font><br>
    </blockquote>
    But times have changed.&nbsp; <i>We</i> sometimes will need to
    distinguish between the standard XPL language of <i>A Compiler
      Generator</i> and the extended XPL language of Intermetrics in our
    discussion.&nbsp; When we do need to distinguish, I'll call that
    extended Intermetrics language "XPL/I".<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;










        In case you're wondering, there is no known surviving copy of
        Intermetrics's own XPL/I compiler.&nbsp; In fact, there is
        reason to believe that it was intentionally destroyed.&nbsp;
        (Prove me wrong, please!)&nbsp; If it had survived, however, I
        presume it would have been written in standard XPL and itself
        compiled by a standard XPL compiler on an IBM 360 computer.</font><br>
    </blockquote>
    Inconveniently, the differences between the standard XPL language
    and XPL/I are not fully documented.&nbsp; Or perhaps more
    accurately, if they are fully documented, then that documentation
    has either not survived or else has not made its way into my
    hands.&nbsp; <a moz-do-not-send="true"
      href="Shuttle/19760020796.pdf#page=822">Section 13 of IR-182-1</a>,
    does describe some (but not all) of the known differences.&nbsp; It
    is also true that the specification of standard XPL in <i>A
      Compiler Generator</i>, is perhaps not 100% complete or perfect,
    and much that is unsaid (or underemphasized) in it relies on the
    tribal knowledge of the intended audience at the time of publication
    ... tribal knowledge from a tribe which has today essentially
    vanished.<br>
    <br>
    Thus developing an XPL/I compiler, or even a standard XPL compiler,
    is today more like scientific research than like computer
    programming.&nbsp; In computer programming, if you want to know how
    to do something, you look it up in the documentation or in a book or
    website that has predigested it for you, and then you exactly follow
    the instructions given there; or if you're lucky, you "google" it to
    find that somebody else had already done almost exactly what you
    wanted to do, and you just cut-and-paste what they had already
    done.&nbsp; Whereas in scientific research, you observe, you make
    hypotheses, you explore the consequences of those hypotheses ... and
    you start all over again if your hypotheses were found to be
    wrong!&nbsp; And in scientific research, even if you think you've
    found the perfect answer, you may still be wrong in the end, in ways
    you can't detect or understand.&nbsp; In fact, you probably will be.<br>
    <br>
    Or to put it differently, computer programming is like a game where
    you can look up all of the rules, whereas scientific research (or
    writing an XPL/I compiler) is like a game where you don't know all
    of the rules.<br>
    <br>
    The latter is my XPL/I world, and welcome to it!<br>
    <h1><a name="XCOMI"></a>XCOM-I</h1>
    The modern XPL/I compiler is known as <b>XCOM-I</b>.&nbsp; It is
    designed to compile both XPL/I programs and standard XPL programs.<br>
    <br>
    It is perhaps a misnomer to call it a "compiler", because it's
    really an XPL/I-to-C translator.&nbsp; There's a two-step process to
    compile an XPL or XPL/I program:&nbsp; You first translate your
    program into C via <b>XCOM-I</b>, and then you compile the C code
    to get a program that actually runs on your computer.<br>
    <blockquote><font size="-1"><b>Aside:&nbsp; XCOM-I</b> itself is
        written in the Python 3 language, and getting <b>XCOM-I</b> to
        run on your computer is dead simple:&nbsp; Just install Python
        3, copy <b>XCOM-I</b> onto your computer, add it to your PATH,
        and you're ready to go!&nbsp; Setting up your computer to
        compile the C code is something else, though.&nbsp; Once again
        it's dead simple, <i>if</i> you have the common C compiler
        known as <b>gcc</b>.&nbsp; But it's not so simple on (say)
        Microsoft Windows where most people use the far-less-compatible
        Visual Studio system.&nbsp; And that's a <i>lot</i> of
        people.&nbsp; So let's put the installation problem aside for a
        few minutes and come back to it a little later.</font><br>
    </blockquote>
    On a properly-set-up computer, compiling an XPL or XPL/I program is
    quite simple.&nbsp; Suppose we have an XPL program called HELLO.xpl
    whose contents are this:<br>
    <blockquote>
      <pre><font color="#663300">OUTPUT = 'Hello, world!';<br>EOF</font><br></pre>
    </blockquote>
    To compile it, we do this:<br>
    <blockquote>
      <pre><font color="#663300">XCOM-I.py --xpl HELLO.xpl<br>make -C HELLO.build<br></font></pre>
    </blockquote>
    To run the compiled program, you could do this:<br>
    <blockquote>
      <pre><font color="#663300">./HELLO</font><br></pre>
    </blockquote>
    giving output that looks like this:<br>
    <blockquote>
      <pre><font color="#663300">PAGE 1<br><br><br>Hello, world!</font><br></pre>
    </blockquote>
    Note, by the way, that on most platforms there won't be be a line
    feed after the final exclamation point, so when your command-line
    prompt reappears, it will immediately follow the ! rather than being
    on a separate line.<br>
    <br>
    Not quite what you expected, I bet, if you're a coder and have seen
    lots of Hello World programs in the past!&nbsp; Blame the 1960's-era
    computing environment.&nbsp; Back then, programmers weren't sitting
    in front of a display screen and a keyboard when they wrote or ran
    their programs, but were instead punching their programs into
    80-column computer cards, submitting computing jobs that would run
    at some later but undetermined time, and outputting the results of
    running their programs on physical printers, probably on fan-fold,
    tractor-feed paper.&nbsp; Probably that paper has horizontal
    green-and-white bars on it, or perhaps horizontal black lines
    between every few lines of print.&nbsp; Pages of printouts had
    headings printed on them, and those headings included page numbers.<br>
    <br>
    If you were to write a computer program today that printed a line of
    text, you'd probably expect it to move to the next line after each
    line was "printed" on your display screen.&nbsp; Not in the 1960's
    on IBM printers!&nbsp; In that environment, it was more similar to
    moving to the next line and <i>then</i> printing the text.&nbsp;
    That's why there's no line-feed at the end of our printout:&nbsp; It
    came <i>before</i> the line was printed, not after it.&nbsp; Not
    that this is a big deal, of course, merely that our own ingrained
    expectations no longer completely match those of 1960's-era IBM
    programmers. <br>
    <br>
    As for what the compilation process above did for us, the result of
    running <b>XCOM-I</b> was that a directory called HELLO.build was
    created, containing the translation into C of our XPL program.&nbsp;
    That new directory is completely self-contained, and no longer
    requires <b>XCOM-I</b> nor HELLO.xpl.&nbsp; You could move it to an
    entirely-different computer before compiling the C code, if you
    liked.&nbsp; Its contents look something like this:<br>
    <blockquote>
      <pre>-rw-rw-r-- 1 rburkey rburkey  11207 Aug 12 07:23 COMPACTIFY.c<br>-rw-rw-r-- 1 rburkey rburkey   1730 Aug 12 07:23 configuration.h<br>-rw-rw-r-- 1 rburkey rburkey  16921 Jul  7 10:50 debuggingAid.c<br>-rw-rw-r-- 1 rburkey rburkey   4269 Aug  5 09:01 inline360.c<br>-rw-rw-r-- 1 rburkey rburkey   1195 Aug  5 09:01 inline360.h<br>-rw-rw-r-- 1 rburkey rburkey   1835 Aug 12 07:23 main.c<br>-rw-rw-r-- 1 rburkey rburkey   4545 Aug 10 17:07 Makefile<br>-rw-rw-r-- 1 rburkey rburkey  24759 Aug 12 07:23 memory.c<br>-rw-rw-r-- 1 rburkey rburkey    883 Aug 12 07:23 procedures.h<br>-rw-rw-r-- 1 rburkey rburkey    161 Aug 12 07:23 resetAllReentryGuards.c<br>-rw-rw-r-- 1 rburkey rburkey 125864 Aug  9 13:52 runtimeC.c<br>-rw-rw-r-- 1 rburkey rburkey  18037 Jul 18 10:52 runtimeC.h<br></pre>
    </blockquote>
    The command "<font color="#663300"><code>make -C HELLO.build</code></font>"
    simply compiles the C code in HELLO.build, and moves the executable
    (also called "HELLO" or in Windows, "HELLO.exe") up into the current
    working directory after it builds it.&nbsp; But the executable
    doesn't <i>have</i> to be there; you can move it somewhere else
    before running it, and even delete the HELLO.build directory or the
    current working directory completely.<br>
    <br>
    The <b>XCOM-I</b> command line switch <font color="#663300"><code>--xpl</code></font>,
    incidentally, wasn't necessary for HELLO.xpl.&nbsp; You can see all
    of the available command-line switches with<br>
    <blockquote>
      <pre><font color="#663300">XCOM-I.py --help</font><br></pre>
    </blockquote>
    In particular, the switch <font color="#663300"><code>--xpl</code></font>
    simply informed the compiler that the source code was standard XPL
    rather than XPL/I.&nbsp; XPL/I is the default.&nbsp; But HELLO.xpl
    is a perfectly-valid XPL/I program too, so we could just have
    omitted <font color="#663300"><code>--xpl</code></font> with no
    problem.&nbsp; That doesn't mean that an identical result is
    produced, though!&nbsp; For example, if we left off the <font
      color="#663300"><code>--xpl</code></font> switch, we might see the
    following messages when we ran <b>XCOM-I</b>:<br>
    <blockquote>
      <pre>No code is generated for the following PROCEDURE(s):<br>	Not called:  DESCRIPTORuMONITOR<br>	Not called:  uRECORDuCONSTANT<br>	Not called:  uNEEDMOREuSPACE<br>	Not called:  uRECORDuSEAL<br>	Not called:  uRECORDuUNSEAL<br>	Not called:  uRECORDuGROUPHEAD<br>	Not called:  uRECORDuCOORDINATED<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uINCREASEuRECORD<br>	Not called:  uALLOCATEuSPACE<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uATTACHuRECORD<br>	Not called:  uGETuSPACE<br>	Not called:  uHOWuMUCH<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uFINDuFREE<br>No code is generated for the following PROCEDURE(s):<br>	Not called:  uSTEAL<br>	Not called:  uMOVEuRECS<br></pre>
    </blockquote>
    Those aren't errors or warnings, but are instead informative
    messages indicating that certain XPL/I procedures implicitly
    imported by the compiler hadn't been needed, and thus were being
    discarded.&nbsp; Whereas the compiler wouldn't have tried to import
    these procedures in the first place if compiling standard XPL.&nbsp;
    You'd also find that the contents of the HELLO.build directory were
    quite different as well:<br>
    <blockquote>
      <pre>-rw-rw-r-- 1 rburkey rburkey   2890 Aug 12 07:52 uACTIVEuDESCRIPTORS.c<br>-rw-rw-r-- 1 rburkey rburkey   2040 Aug 12 07:52 uATTACHuBLOCK.c<br>-rw-rw-r-- 1 rburkey rburkey   1485 Aug 12 07:52 uATTACHuBLOCKxJOIN.c<br>-rw-rw-r-- 1 rburkey rburkey   1086 Aug 12 07:52 uCHECKuFORuTHEFT.c<br>-rw-rw-r-- 1 rburkey rburkey  21641 Aug 12 07:52 COMPACTIFY.c<br>-rw-rw-r-- 1 rburkey rburkey   1747 Aug 12 07:52 COMPACTIFYxADDuDESC.c<br>-rw-rw-r-- 1 rburkey rburkey   1711 Aug 12 07:52 configuration.h<br>-rw-rw-r-- 1 rburkey rburkey  16921 Jul  7 10:50 debuggingAid.c<br>-rw-rw-r-- 1 rburkey rburkey   1330 Aug 12 07:52 uDETACHuRECORD.c<br>-rw-rw-r-- 1 rburkey rburkey  10136 Aug 12 07:52 uFREEBLOCKuCHECK.c<br>-rw-rw-r-- 1 rburkey rburkey   1157 Aug 12 07:52 uFREEBLOCKuCHECKxADDRESSuCHECK.c<br>-rw-rw-r-- 1 rburkey rburkey   4322 Aug 12 07:52 uFREEBLOCKuCHECKxBLKPROC.c<br>-rw-rw-r-- 1 rburkey rburkey   4269 Aug  5 09:01 inline360.c<br>-rw-rw-r-- 1 rburkey rburkey   1195 Aug  5 09:01 inline360.h<br>-rw-rw-r-- 1 rburkey rburkey   7047 Aug 12 07:52 main.c<br>-rw-rw-r-- 1 rburkey rburkey   4545 Aug 10 17:07 Makefile<br>-rw-rw-r-- 1 rburkey rburkey  31342 Aug 12 07:52 memory.c<br>-rw-rw-r-- 1 rburkey rburkey   1692 Aug 12 07:52 uMOVEuWORDS.c<br>-rw-rw-r-- 1 rburkey rburkey   1176 Aug 12 07:52 uPREVuFREEBLOCK.c<br>-rw-rw-r-- 1 rburkey rburkey   1142 Aug 12 07:52 uPREVuRECORD.c<br>-rw-rw-r-- 1 rburkey rburkey   5236 Aug 12 07:52 procedures.h<br>-rw-rw-r-- 1 rburkey rburkey   2419 Aug 12 07:52 uRECORDuFREE.c<br>-rw-rw-r-- 1 rburkey rburkey   1597 Aug 12 07:52 RECORDuLINK.c<br>-rw-rw-r-- 1 rburkey rburkey   3990 Aug 12 07:52 uREDUCEuBLOCK.c<br>-rw-rw-r-- 1 rburkey rburkey    652 Aug 12 07:52 resetAllReentryGuards.c<br>-rw-rw-r-- 1 rburkey rburkey   2362 Aug 12 07:52 uRETURNuTOuFREESTRING.c<br>-rw-rw-r-- 1 rburkey rburkey   6157 Aug 12 07:52 uRETURNuUNUSED.c<br>-rw-rw-r-- 1 rburkey rburkey 125864 Aug  9 13:52 runtimeC.c<br>-rw-rw-r-- 1 rburkey rburkey  18037 Jul 18 10:52 runtimeC.h<br>-rw-rw-r-- 1 rburkey rburkey    475 Aug 12 07:52 uSPACEuROUND.c<br>-rw-rw-r-- 1 rburkey rburkey   2023 Aug 12 07:52 uSPMANERR.c<br>-rw-rw-r-- 1 rburkey rburkey   7067 Aug 12 07:52 uSQUASHuRECORDS.c<br>-rw-rw-r-- 1 rburkey rburkey   4714 Aug 12 07:52 uTAKEuBACK.c<br>-rw-rw-r-- 1 rburkey rburkey   1466 Aug 12 07:52 uUNUSEDuBYTES.c<br></pre>
    </blockquote>
    The way <b>XCOM-I</b> operates, each XPL <font color="#663300"><code>PROCEDURE</code></font>,
    even if its definition is embedded in another <font color="#663300"><code>PROCEDURE</code></font>,
    is given its own dedicated C file.&nbsp; Our simple HELLO.xpl
    program didn't have even a single <font color="#663300"><code>PROCEDURE</code></font>
    in it, though the compiler did implicitly import a number of support
    procedures such as <font color="#663300"><code>COMPACTIFY</code></font>,
    so you can see that a COMPACTIFY.c file has been generated.&nbsp; <font
      color="#663300"><code>COMPACTIFY</code></font>, as it happens, has
    an embedded <font color="#663300"><code>PROCEDURE</code></font>
    called <font color="#663300"><code>ADD_DESC</code></font>.&nbsp;
    That's where the file COMPACTIFYxADD_DESC.c comes from; the little
    "x" indicates the embedding.<br>
    <br>
    Just for grins, let's take a look at the generated C code.&nbsp;
    When compiled with the <font color="#663300"><code>--xpl</code></font>
    switch, the C file that most-directly relates to HELLO.xpl is
    main.c, which looks like this:<br>
    <blockquote>
      <pre><font color="#663300">/*<br>  File main.c generated by XCOM-I, 2024-08-12 08:01:10.<br>  XPL/I source-code files used: XPL.LIBRARY.xpl HELLO.xpl.<br>  To build the program from the command line, using defaults:<br>          cd HELLO/<br>          make<br>  View the Makefile to see different options for the `make`<br>  command above.  To run the program:<br>          HELLO [OPTIONS]<br>  Use `HELLO --help` to see the available OPTIONS.<br>*/<br><br>#include "runtimeC.h"<br><br>// clang-format off<br>/*<br>            *** Memory Map ***<br>  Address (Hex)   Data Type   Variable<br>  -------------   ---------   --------<br>  1318 (000526)   BASED       userMemory<br>  1346 (000542)   BASED       privateMemory<br>  1376 (000560)   FIXED       COMPACTIFYxI<br>  1380 (000564)   FIXED       COMPACTIFYxJ<br>  1384 (000568)   FIXED       COMPACTIFYxK<br>  1388 (00056C)   FIXED       COMPACTIFYxL<br>  1392 (000570)   FIXED       COMPACTIFYxND<br>  1396 (000574)   FIXED       COMPACTIFYxTC<br>  1400 (000578)   FIXED       COMPACTIFYxBC<br>  1404 (00057C)   FIXED       COMPACTIFYxDELTA<br>  1408 (000580)   BIT(16)     COMPACTIFYxDX(500)<br>  2412 (00096C)   FIXED       COMPACTIFYxMASK<br>  2416 (000970)   FIXED       COMPACTIFYxLOWER_BOUND<br>  2420 (000974)   BIT(1)      COMPACTIFYxTRIED<br>*/<br>// clang-format on<br><br>int<br>main(int argc, char *argv[])<br>{<br><br>  // Setup for MONITOR(6), MONITOR(7), MONITOR(21).  Initially,<br>  // entire physical memory is a single pre-allocated block.<br>  MONITOR6a(USER_MEMORY, PHYSICAL_MEMORY_LIMIT, 0);<br>  MONITOR6a(PRIVATE_MEMORY, PRIVATE_MEMORY_SIZE, 0);<br><br>  if (parseCommandLine(argc, argv)) exit(0);<br><br>  static int reentryGuard = 0;<br>  reentryGuard = guardReentry(reentryGuard, "main");<br>  // OUTPUT = 'Hello, world!'; (0)<br>  {<br>    descriptor_t *stringRHS;<br><font color="#009900">    stringRHS = cToDescriptor(NULL, "Hello, world!");<br>    OUTPUT(0, stringRHS);<br></font>    stringRHS-&gt;inUse = 0;<br>  }</font><br></pre>
    </blockquote>
    The part I've highlighted in green is the only part that directly
    relates to HELLO.xpl.&nbsp; All of the rest is overhead related to
    modeling the IBM 360 computing environment in C.&nbsp; The functions
    <font color="#009900"><code>cToDescriptor</code></font> and <font
      color="#009900"><code>OUTPUT</code></font> are part of <b>XCOM-I</b>'s










    runtime library.<br>
    <h1><a name="installation"></a>Installation of XCOM-I<br>
    </h1>
    <h2><a name="Linux"></a>Linux or Mac OS<br>
    </h2>
    <p>On a Mac, you will need to install <b>Xcode</b> <i>command-line
        tools</i> before doing anything else.&nbsp; If you instead want
      to install the entirety of <b>Xcode</b>, I'm sure that's fine
      too, but the only thing you'll actually need is the much-smaller
      package of command-line tools.&nbsp; Note that my very old Mac (<b>Xcode</b>
      4.6) hasn't been updatable for a long time now, but apparently the
      instructions you'll find throughout this page do work on <b>Xcode</b>
      14.2 as well; whether they work on the current version of <b>Xcode</b>,
      I cannot say.<br>
    </p>
    <p>On Linux, you usually don't have to go out of your way to install
      a C compiler, but <b>gcc</b> or alternately <b>clang</b> will be
      available from your package repository if you do need to
      explicitly install either or both of them.<br>
    </p>
    <p> </p>
    <ol>
      <li><a moz-do-not-send="true"
          href="https://github.com/virtualagc/virtualagc">Download the
          entire Virtual AGC source tree</a>.&nbsp; For brevity, I'm
        going to assume that this ends up as a folder called <i>virtualagc</i>,
        but you need to substitute the actual name in the instructions
        below.&nbsp; My personal suggestion would be to get it via <b>git</b>,
        as in the following command, because that makes it easy to keep
        up-to-date later via "<font color="#663300"><code>git pull</code></font>":</li>
    </ol>
    <blockquote>
      <blockquote>
        <pre><font color="#663300"><code>git clone --depth=1 https://github.com/virtualagc/virtualagc.git</code></font></pre>
      </blockquote>
    </blockquote>
    <ol start="2">
      <li>Add the following folders to your PATH&nbsp; (Hint:&nbsp; In
        Linux, I usually do this by editing ~/.bashrc; in Mac OS, by
        editing /etc/paths.&nbsp; But Google it if you're unsure!)&nbsp;
        Afterward, you may need to close and reopen any terminal windows
        in order for the change to take effect.:&nbsp; <br>
      </li>
      <ul>
        <li><i>"virtualagc</i>/XCOM-I"</li>
        <li><i>"virtualagc</i>/yaShuttle/ported/PASS1.PROCS"</li>
        <li><i>"virtualagc</i>/ASM101S"</li>
        <li><i>virtualagc</i>/yaShuttle/Source Code/PASS.REL32V0"</li>
      </ul>
      <li>Install Python 3, if not already installed.</li>
      <li>Optionally, install <b>clang-format</b>.&nbsp; This allows
        you optionally to "pretty print" the C code that <b>XCOM-I</b>
        generates.&nbsp; <br>
      </li>
    </ol>
    <blockquote>
      <ul>
        <li>Installation is easy on Linux (at least on Linux Mint),
          because <b>clang-format</b> is in the official package
          repositories.&nbsp; <br>
        </li>
        <li>On Mac OS, <b>clang-format</b> is apparently not included
          in Xcode.&nbsp; You can do this:&nbsp; Install <a
            moz-do-not-send="true" href="https://brew.sh/">homebrew</a>,
          if you don't already have it.&nbsp; Then use the command "<font
            color="#663300"><code>brew install clang-format</code></font>".<br>
        </li>
      </ul>
    </blockquote>
    <ol start="2">
    </ol>
    <h3>Cross-compiling from Linux or Mac OS to Windows<br>
    </h3>
    <p>Cross-compiling XPL files on Linux or Mac OS to create EXE files
      for Windows seems like a niche option.&nbsp; In fact, probably
      nobody but me would be interested, and I'm only interested because
      it saves me the trouble of firing up a Windows virtual machine to
      make EXE files for the HAL/S compiler!&nbsp;&nbsp; But even if
      it's just for myself, I need to write down how to set it up, so
      here are the instructions.&nbsp; Basically, you just need to
      install a C cross-compiler (mingw-w64) and a Windows emulator
      (WINE).<br>
    </p>
    <p>First, you have to install <b>XCOM-I</b> as described in the
      preceding section.<br>
    </p>
    <p>In Linux (at least Linux Mint), you should install mingw-w64
      using your usual package manager.&nbsp; Even if WINE is available
      in your package manager, though, I might suggest installing it <a
        moz-do-not-send="true" href="https://www.winehq.org/">directly
        from the WineHQ.org</a>, in order to get a better outcome.&nbsp;
      (For me, for example, that's the difference between WINE 6 and
      WINE 9.)<br>
    </p>
    <p>For relatively-new Mac OS versions, though, this should
      work:&nbsp; First, install <a moz-do-not-send="true"
        href="https://www.macports.org/install.php/">macports</a>.&nbsp;
      Then do this:<br>
    </p>
    <blockquote>
      <pre>sudo port install mingw-w64 wine-stable<br></pre>
    </blockquote>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; </font><font
        size="-1"><font size="-1">As it turns out, m</font>y</font><font
        size="-1"><font size="-1"> mid-2007</font> Mac Mini (</font><font
        size="-1"><font size="-1">Mac OS Lion</font>) <i>isn't</i>
        "relatively new", and thus the steps just mentioned didn't work
        for me.&nbsp; Nor did the seemingly very-attractive alternative
        of <a moz-do-not-send="true"
          href="https://github.com/mstorsjo/llvm-mingw/releases">installing








          llvm-mingw</a> </font><font size="-1">in place of
        mingw-w64.&nbsp; And as for WINE, <a moz-do-not-send="true"
          href="https://wiki.winehq.org/MacOS">its wiki says</a>
        explicitly that it works only for Mac OS Catalina or
        later.&nbsp; Oh well, no great loss!&nbsp; I doubt that many Mac
        users want to build Windows EXE files anyway.<br>
      </font> </blockquote>
    <ol start="4">
    </ol>
    <p> </p>
    <h2><a name="Windows"></a>Windows Specific</h2>
    <p>The problem in Windows is not <b>XCOM-I</b> <i>per se</i>,
      which works as-is, but rather to set up some kind of
      reasonably-compliant environment for compiling the C files
      produced by <b>XCOM-I</b>.&nbsp; That's more effort in Windows
      than in Linux or Mac OS, since you generally don't have to do
      anything to achieve it in Linux or Mac OS anyway.<br>
    </p>
    <blockquote> <font size="-1"><b>Aside:</b>&nbsp; A choice that will
        likely be obvious to most people is to use the </font><font
        size="-1">Windows Subsystem for Linux (WSL).&nbsp; I have been
        unable to try it.&nbsp; I purchased Windows 11 to do so, but I'm
        running Windows 11 in a virtual machine myself, and it turns out
        that you cannot run WSL on Windows <i>inside</i> of a virtual
        machine.&nbsp; Too bad, though hardly surprising!&nbsp; If you
        try WSL on a physical machine and make it work, let me know.<br>
      </font></blockquote>
    At any rate, I'll be offering you two choices of how to
    install.&nbsp; My recommended choice is to work with something
    called MSYS2, which is a development environment that's very
    Linux-like, and includes many of the same development tools that
    Linux provides.&nbsp; I'll also offer a way to use Visual Studio
    instead, though you'll still have to end up installing so many
    Linux-like tools that it's not much (if any) saving of effort.&nbsp;
    But it's your choice.<br>
    <h3>Option 1: MSYS2</h3>
    <ol>
      <li>Install <a moz-do-not-send="true"
          href="https://www.msys2.org/">MSYS2</a>, which gives you a
        Linux/Mac-like command-line working environment for compiling
        stuff.&nbsp; <br>
      </li>
      <li>Run MSYS2.<br>
      </li>
      <li>Install various packages with this command:&nbsp;&nbsp;<font
          color="#663300"><code></code></font></li>
    </ol>
    <blockquote>
      <blockquote><font color="#663300"><code>pacman -S
            mingw-w64-ucrt-x86_64-gcc make grep diffutils python3 </code></font><font
          color="#663300"><code><font color="#663300"><code>python3-pip
              </code></font>git clang</code></font><br>
      </blockquote>
    </blockquote>
    <ol start="4">
      <li><a moz-do-not-send="true"
          href="https://github.com/virtualagc/virtualagc">Download the
          entire Virtual AGC source tree</a>.&nbsp; For brevity, I'm
        going to assume that this ends up as a folder called <i>virtualagc</i>,
        but you need to substitute the actual name in the instructions
        below.&nbsp; My personal suggestion would be to get it via <b>git</b>,
        as in the following command, because that makes it easy to keep
        up-to-date later via "<font color="#663300"><code>git pull</code></font>":</li>
    </ol>
    <blockquote>
      <blockquote>
        <pre><font color="#663300"><code>git clone --depth=1 https://github.com/virtualagc/virtualagc.git</code></font></pre>
      </blockquote>
    </blockquote>
    <ol start="5">
      <li>Add the following folders to your PATH:&nbsp; <i>"virtualagc</i>/XCOM-I",










        <i>"virtualagc</i>/yaShuttle/ported/PASS1.PROCS", and <i>"virtualagc</i>/yaShuttle/Source










        Code/PASS.REL32V0".&nbsp; In MSYS2, you'd do that by editing the
        file ~/.bashrc, which you can do with the command "<font
          color="#663300"><code>nano ~/.bashrc</code></font>".&nbsp;
        Google how to permanently change the PATH in Linux if you're
        unsure what to do.&nbsp; Afterward, you will need to exit MSYS2
        and rerun it to see the change take effect.</li>
    </ol>
    <p>It's worth noting that if you followed these instructions to the
      letter, then your "home directory" in MSYS2 will probably be
      something like C:\msys64\home\<i>USERNAME</i>, whereas your home
      directory for a normal command-line would be c:\users\<i>USERNAME</i>.&nbsp;










      That's good to keep in mind if you need to transfer any files in
      or out of there!<br>
    </p>
    <h3>Option 2: Visual Studio</h3>
    <blockquote><font size="-1"><b>Warning:</b>&nbsp; I have never used
        Visual Studio prior to this, or if I have then it was so long
        ago I no longer remember doing so.&nbsp; Besides which, for <b>XCOM-I</b>
        I'm only using Visual Studio's command-line tools rather than
        its Integrated Development Environment (IDE).&nbsp; The upshot
        of this that you shouldn't interpret my giving you Visual Studio
        instructions as meaning you're going to get the wonderful
        integration into Visual Studio that you might dream of.&nbsp;
        You <i>might</i>, but you'll have to work it out yourself!</font><br>
    </blockquote>
    <p>Note that almost everything I'm going to tell you to do, either
      here in the setup, or elsewhere on the page, is done from what's
      called the Developer Command Prompt for Visual Studio, which you
      can run from the Windows Start menu if you have Visual Studio
      installed.&nbsp; You won't be working from a normal
      (non-developer) command prompt most of the time.&nbsp; I think the
      main reason you have to do this is that the C compiler (<b>cl</b>)
      is in its PATH, but not in the PATH in a normal command
      prompt.&nbsp; You'll have to '<code>cd</code>' to some other
      directory, though, to get anything done, since you'll have no
      permissions to actually modify anything in the working directory
      this plunks you into.&nbsp; Isn't that a fun feature?&nbsp; It's
      your own choice, of course, but perhaps you could go to your
      normal command-line home directory.</p>
    <ul>
    </ul>
    Another thing worth knowing is that if Python programs such as <b>XCOM-I</b>
    are run from a command line in Windows, they open up in a new window
    in which all of their messages appear, but the window vanishes as
    soon as the Python program completes.&nbsp; That means that you have
    little or no time to ponder or capture the messages it may be
    showing you, particularly the error messages.&nbsp; You can work
    around this phenomenon, whenever I explicitly instruct you to run <b>XCOM-I</b>,
    by invoking <b>XCOM-I</b> as<br>
    <blockquote>
      <pre>python XCOM-I.py <i>... </i><br></pre>
    </blockquote>
    Any invocations of <b>make</b> I instruct you to use will already
    have taken care of this for you.<br>
    <br>
    Here's the setup:<br>
    <ul>
      <li>Get the entire <a moz-do-not-send="true"
          href="https://github.com/virtualagc/virtualagc">Virtual AGC
          source-code tree</a> from GitHub.&nbsp; <br>
      </li>
      <li>Add the following folders to your PATH:&nbsp; <i>"virtualagc</i>/XCOM-I",










        <i>"virtualagc</i>/yaShuttle/ported/PASS1.PROCS", and <i>"virtualagc</i>/yaShuttle/Source










        Code/PASS.REL32V0"..&nbsp; If you've already opened a VS
        developer command prompt, then close it and start a new one to
        see the effect of the changed PATH.</li>
      <li>Install Python 3, if it's not already installed.&nbsp; <br>
      </li>
      <li>Permanently set the environment variable <code>PYTHONUTF8=1</code>
        to enable Python's UTF-8 processing ability.&nbsp;&nbsp;</li>
      <li>Obtain <a moz-do-not-send="true"
          href="https://github.com/bmatzelle/gow">a zipfile of numerous
          UNIX-style utilities from here</a>.&nbsp; Extract the contents
        somewhere on your local computer, and add the subdirectory
        called "bin" to your PATH.&nbsp; (Remember to close and then
        reopen any developer command line you may have open, in order to
        see the effect of the change to the PATH.)&nbsp;&nbsp;</li>
      <li>The version of GNU <b>make</b> provided with these UNIX-style
        utilities is too out-of-date (version 3.81) to be fully
        satisfactory for use with <b>XCOM-I</b>.&nbsp; So you'll have
        to install a newer version.&nbsp; Here's a reasonably-easy way
        to do that:</li>
      <ul>
        <li>Download <a moz-do-not-send="true"
            href="https://www.gnu.org/software/make/#download">the
            latest source code from here</a> (version 4.4.1 as I'm
          writing this) and extract it.</li>
        <li>From a Visual Studio developer command line, 'cd' in to the
          source-code directory just created.</li>
        <li>Run the batch script called <font color="#663300"><code>build_w32.bat</code></font>.&nbsp;










          This creates the file gnumake.exe in the subdirectory called
          WinRel/.</li>
        <li>Rename gnumake.exe as just make.exe.<br>
        </li>
        <li>Get it into your PATH somewhere that precedes the older
          version of <b>make</b> found in the UNIX-style
          utilities.&nbsp; What I do is just copy it atop the older
          version in the UNIX-style utilities' bin/ folder.</li>
        <li>You can verify the version by running <code>make -v</code>.<br>
        </li>
      </ul>
    </ul>
    <blockquote> </blockquote>
    <h2><a name="testTheInstallation"></a>Testing the Installation</h2>
    <p>We can do a very quick test of your setup and of <b>XCOM-I</b>
      itself by compiling and running the HELLO.xpl program I <a
        moz-do-not-send="true" href="#XCOMI">used as an example earlier</a>.</p>
    Do the following:<br>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <tbody>
        <tr>
          <td valign="top">
            <h4>Linux</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:
            <blockquote>
              <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s -C HELLO.build<br>./HELLO</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:
            <blockquote>
              <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s CC=clang EXTRA=-w -C HELLO.build<br>./HELLO<br></pre>
            </blockquote>
            (Omit <code>--pp</code> if <b>clang-format</b> not
            installed.)<br>
            <br>
          </td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" valign="top">
            <h4>Build/Run Windows EXE File in Linux or Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s CC=x86_64-w64-mingw32-gcc EXT=.exe -C HELLO.build<br></pre>
            </blockquote>
            Copy HELLO.exe to Windows or run on Linux with WINE:<br>
            <blockquote>
              <pre>export WINEDEBUG=-all<br>wine ./HELLO.exe</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Windows</h4>
            Open an MSYS2 command line.&nbsp; Then:
            <blockquote>
              <pre>mkdir ~/temp<br>cd ~/temp<br>XCOM-I.py --pp --xpl ~/virtualagc/XCOM-I/Tests/HELLO.xpl<br>make -s RDYNAMIC= -C HELLO.build<br>HELLO<br></pre>
            </blockquote>
            Or from a Visual Studio developer command line,<br>
            <blockquote>
              <pre>md temp<br>cd temp<br>set PYTHONUTF8=1<br>XCOM-I.py --xpl ..\virtualagc\XCOM-I\Tests\HELLO.xpl<br>make CC=cl -C HELLO.build<br>HELLO</pre>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    By the way, you don't actually <i>need</i> to create an empty
    directory (~/temp) to work in, but why not?<br>
    <br>
    If you were alert enough — <i>I</i> wouldn't have been! —, you'll
    have noticed a few differences from when I gave this same example
    earlier:<br>
    <ul>
      <li>The <b>XCOM-I</b> <font color="#663300"><code>--pp</code></font>
        option:&nbsp; This "pretty prints" the C-language files produced
        by <b>XCOM-I</b>, so that the indentation is nicer, the code
        doesn't trail out of view past the right-hand margin, and so
        on.&nbsp; On the other hand, it may also mess up column
        alignment in comments.&nbsp; You pays your money and takes your
        chances!&nbsp; In terms of how the compiled program behaves, it
        makes no difference whatsoever.<br>
      </li>
      <li>The <font color="#663300"><code>-s</code></font> in the make
        command:&nbsp; Optional.&nbsp; It just prevents <b>make</b>
        from giving you a running commentary on whatever commands it
        happens to be running.&nbsp; No big deal! <br>
      </li>
      <li><font color="#663300"><code>CC=clang EXTRA=-w</code></font> in
        the Mac OS <b>make</b> command:&nbsp; Probably not
        necessary.&nbsp; The same <b>make</b> command as for Linux
        could have been used.&nbsp; And <b>clang</b> is the default
        anyway in Mac OS anyway, I think, so adding <font
          color="#663300"><code>CC=clang</code></font> just makes it
        explicit.&nbsp; In fact, to force it to use <b>gcc</b>, you'd
        have to use the command <font color="#663300"><code>make -s
            CC=gcc EXTRA="-w -std=c99" -C HELLO</code><code>.build</code></font>.&nbsp;










        In my experience, <b>clang</b> produces a lot of pointless (and
        incorrect) warning messages, which is why I disable all of the
        warnings by adding <font color="#663300"><code>EXTRA=-w</code></font>.&nbsp;










        <br>
      </li>
      <li><font color="#663300"><code>RDYNAMIC=</code></font> in the
        Windows make command:&nbsp; Disables a compiler command-line
        option that the Windows version of <b>gcc</b> doesn't support.<br>
      </li>
    </ul>
    Various other helpful options will show up in later examples.<br>
    <br>
    By the way, the Test/ directory from which we just retrieved
    HELLO.xpl has lots of other sample XPL and XPL/I files in it as
    well, which could be run in the same manner as HELLO.xpl.&nbsp; In
    fact, I've cobbled together a much-more-extensive test of <b>XCOM-I</b>
    by using them, and you can run that more-extensive test like so:<br>
    <br>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <tbody>
        <tr>
          <td valign="top">
            <h4>Linux</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make -f Makefile-regression<br></pre>
            </blockquote>
            or<br>
            <blockquote>
              <pre>make CC=clang EXTRA=-w -f Makefile-regression</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=clang EXTRA=-w -f Makefile-regression<br></pre>
            </blockquote>
            or<br>
            <blockquote>
              <pre>make CC=gcc EXTRA="-w -std=c99" -f Makefile-regression<br></pre>
            </blockquote>
            <blockquote> </blockquote>
            <blockquote> </blockquote>
          </td>
        </tr>
        <tr>
          <td valign="top">
            <h4>Build/Test Windows EXE Files in Linux or Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=x86_64-w64-mingw32-gcc EXT=.exe EXER=wine -f Makefile-regression</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Windows</h4>
            <a name="winRegression"></a>Open an MSYS2 command
            line.&nbsp; Then:
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make RDYNAMIC= -f Makefile-regression<br></pre>
            </blockquote>
            Or from a Visual Studio developer command line,<br>
            <blockquote>
              <pre>make CC=cl -f Makefile-regression</pre>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    What you should expect to see in any case is some messages like the
    following:<br>
    <blockquote>
      <pre>make -s -C Example-6.18.3.build<br>make -s -C Example-6.18.4.build<br>make -s -C Example-6.18.5.build<br>make -s -C Example-6.18.6.build<br>make -s -C breakCharactersDemo.build<br>make -s -C ANALYZER.build<br>make -s -C SKELETON.build<br>make -s -C bitsizeDemo.build<br>make -s -C bitsizeDemoCommon.build<br>make -s -C bitsizeDemoCommonIn.build<br>Files bitsizeDemo.build/out.txt and Tests/bitsizeDemo.regression are identical<br>Files bitsizeDemo.build/xxxxA and bitsizeDemoCommon.build/xxxxA are identical<br>Files bitsizeDemoCommon.build/xxxxA and bitsizeDemoCommonIn.build/xxxx are identical<br>Files bitsizeDemoCommon.build/COMMONa.out and bitsizeDemoCommonIn.build/COMMONa.out are identical<br>Files Example-6.18.3.build/out.txt and Tests/Example-6.18.3.regression are identical<br>Files Example-6.18.4.build/out.txt and Tests/Example-6.18.4.regression are identical<br>Files Example-6.18.5.build/out.txt and Tests/Example-6.18.5-and-6.regression are identical<br>Files breakCharactersDemo.build/out.txt and Tests/breakCharactersDemo.regression are identical<br>Files ANALYZER.build/out.txt and ANALYZER.build/out.regression are identical<br>======================== All regression tests passed! ========================<br></pre>
    </blockquote>
    These were "regression tests", in the sense that the various
    programs mentioned in the output messages had been performed at some
    time in the past, and these new runs of those same programs were
    compared against those earlier outputs.&nbsp; In other words, they
    test expectations rather than accuracy.&nbsp; By the way, several of
    the programs, including those label Example-xxxx and ANALYZER come
    straight out of <i>A Compiler Generator</i>.&nbsp; The ANALYZER.xpl
    program is itself quite a significant chunk of code, in that what it
    does is to accept a BNF grammar for a language and generate a
    table-driven parser for the language, in essence building a compiler
    for the language; in the regression test, it generates a parser for
    a simple language called SKELETON.<br>
    <br>
    If you want still more testing to convince yourself that <b>XCOM-I</b>
    actually works on your platform, I'm going to give it to you in a
    moment, in a section I call "Insane Bootstrapping!".&nbsp; But
    before that, we need to make a brief detour.
    <h1><a name="sim360"></a>Emulating the IBM System/360 CPU </h1>
    <p>XPL or XPL/I programs compiled by <b>XCOM-I</b> are native to
      your own local computer system, and if <b>XCOM-I</b> has done its
      job properly, there should be no lingering dependencies on the IBM
      System/360 in the compiled programs.<br>
    </p>
    <p>Nevertheless ... XPL was <i>designed</i> to be a program for
      generating compilers, so a lot of legacy XPL or XPL/I code is
      actually the source code of a compiler for one or another computer
      language, and those compilers invariably spit out IBM System/360
      object code. Suppose for example that we had an XPL program called
      <b>X</b> that was a compiler for a programming language called
      "X". It's true that if we compile the source code for <b>X</b>
      with <b>XCOM-I</b> that we'll get executable code for <b>X</b>
      that runs on our native Linux/Mac/Windows computer (rather than,
      say, an IBM 360). But it's also true that if we <i>use</i> that
      native-Linux, Mac, or Windows version of <b>X</b> to compile
      source-code in the X language, say for a program called <b>Y</b>,
      then the output of the compiler will still be an object file for
      the IBM System/360. So we still wouldn't be able to run program <b>Y</b>
      on our native computer, and would still need an IBM System/360 to
      run <b>Y</b>.<br>
    </p>
    <p>Which means that even with <b>XCOM-I</b> in hand, it's still
      very useful to have an IBM System/360 emulator in which to run not
      the programs <i>produced</i> by <b>XCOM-I</b>, but the programs
      produced by the compilers compiled by <b>XCOM-I</b>.&nbsp; Yes, I
      know that makes your head swim a bit.&nbsp; Well, wait until you
      get to the next section.<br>
    </p>
    <p>If you're already an IBM System/360 expert or even someone who
      wants to be an IBM System/360 user, then perhaps an IBM System/360
      emulator such as <a moz-do-not-send="true"
        href="http://www.hercules-390.org/">Hercules</a> might work well
      for you. As for myself, having tried to figure out without success
      how to use Hercules, I have to concede that I'm neither an expert
      nor want to be one, and thus I have no desire to confront that
      learning curve. I'd much prefer a <i>lightweight</i> IBM
      System/360 emulator, with essentially no learning curve at all.
      (And a lightweight emulator is far more in line with Virtual AGC's
      goal of integrating Space Shuttle computing support into
      spaceflight simulation programs than a full-blown mainframe
      emulator would be anyway.)<br>
    </p>
    <p>As it happens, there <i>is</i> an available lightweight IBM
      System/360 emulator. This emulator, called <b>sim360</b>, was
      written by the same Daniel Weaver who I've also mentioned earlier
      as the author of an earlier XPL-to-C translator for standard XPL.
      You can find the source code for <b>sim360</b> as slightly
      modified for my purposes here in <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/XCOM-I/sim360-source/simulate">the










        Virtual AGC software repository</a>, but <a
        moz-do-not-send="true"
        href="https://sourceforge.net/projects/suny-pascal/">the
        official place to get the most up-to-date version is Dan's own
        site</a>.&nbsp; If you follow the hyperlink to Dan's site,
      you'll find that it's disguised as a Pascal compiler, which it
      is.&nbsp; But don't be confused: There's an IBM System/360
      emulator in there!<br>
    </p>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;










        There is a limit, of course, to how "lightweight" an IBM 360
        emulator can be while still remaining useful.&nbsp; To run
        programs originally written in XPL or XPL/I, for example, just
        emulating the CPU's instruction set is not enough.&nbsp; Such
        XPL or XPL/I programs depend on there being an operating system
        in place to allow operations like inputting data (from a files
        or keyboards) or outputting data (to a displays, printers, or
        files) to occur.&nbsp; But an XPL program doesn't actually
        interact directly with the operating system.&nbsp; Instead, an
        XPL program expects that there's a separate program called the <i>submonitor</i>
        running along side of it, and the XPL program makes its
        low-level requests for input, output, allocation of memory, and
        so on, to this submonitor program.&nbsp; In fact, there will be
        <a moz-do-not-send="true" href="#builtin">a whole section later
          on</a> that describes XPL's built-in functions, some of which
        rely on the submonitor, as well as <a moz-do-not-send="true"
          href="#monitor">another section covering the <font
            color="#663300"><code>MONITOR</code></font> procedure</a>, <i>all</i>
        of whose functionality comes from the submonitor.&nbsp; But the
        point is that to be useful to us, a lightweight emulator like <b>sim360</b>
        must provide enough submonitor capability to respond correctly
        when the XPL program makes these requests of the submonitor,
        even though the IBM 360 operating system is entirely absent.</font><font
        size="-1">&nbsp; Fortunately, <b>sim360</b> does so.&nbsp;
        Thanks, Dan!<br>
        <br>
        By the way, if in place of <b>sim360</b> you were to use <a
          moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>,
        an emulation of the XPL or XPL/I submonitor would <i>not</i> be
        built into it.&nbsp; Rather, you would have to assemble the IBM
        System/360 Basic Assembly Language (BAL) source code for the
        submonitor, and presumably contrive the JCL needed to run the
        submonitor program along-side your compiled XPL program on the
        emulator.&nbsp; Fortunately, although we don't need it if we are
        using <b>sim360</b>, we <i>do</i> have source code for the
        submonitor:&nbsp; <br>
      </font>
      <ul>
        <li><font size="-1">For <i>A Compiler Generator</i>'s <b>XCOM</b>,
            it's <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/XPL-TWS-1969-03/XMON.bal">XMON.bal</a>.</font></li>
        <li><font size="-1">For SUNY's <b>XCOM</b> 4.5, which we've not
            discussed yet but which we'll get to in the next section,
            it's the slightly-different <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLSM4.5.bal">XPLSM.bal</a>.</font></li>
        <li><font size="-1">For Intermetrics's unavailable <b>XCOM</b>,
            it's the collection of BAL source-code files known as <a
              moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM">MONITOR.ASM</a>.&nbsp;










            <br>
          </font></li>
      </ul>
      <p><font size="-1">What we don't have in this scenario is a BAL
          assembler, nor an IBM System/360 linker program, so in spite
          of this wealth of source code for submonitors, in the end we
          still have no way to build the submonitor programs that I'm
          aware of.</font><br>
      </p>
    </blockquote>
    <p>Let's build <b>sim360</b>.&nbsp; Do this:<br>
    </p>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <tbody>
        <tr>
          <td valign="top">
            <h4>Linux</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make sim360<br></pre>
            </blockquote>
            Or:
            <blockquote>
              <pre>make CC=clang EXTRA=-w sim360</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:&nbsp;
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=clang EXTRA=-w sim360<br></pre>
            </blockquote>
            Or:
            <blockquote>
              <pre>make CC=gcc EXTRA="-w -std=c99" sim360</pre>
            </blockquote>
            <blockquote> </blockquote>
          </td>
        </tr>
        <tr>
          <td valign="top">
            <h4>Build Windows EXE File in Linux or Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=x86_64-w64-mingw32-gcc EXT=.exe sim360.exe<br></pre>
            </blockquote>
            Or:<br>
            <blockquote>
              <pre>make CC=i686-w64-mingw32-gcc EXT=.exe sim360.exe</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Windows</h4>
            Open an MSYS2 command line.&nbsp; Then:&nbsp;<strike> </strike>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make sim360<br></pre>
            </blockquote>
            Or:
            <blockquote>
              <pre>make CC=clang EXTRA=-w sim360<br></pre>
            </blockquote>
            Or from a Visual Studio developer command line,<br>
            <pre>make CC=cl sim360.exe</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    To try out <b>sim360</b>, you'll need an IBM System/360 <i>load
      file</i> for some actual program.&nbsp; In the next couple of
    sections, we'll produce a lot of such load files.&nbsp; For now,
    I'll just point out that the IBM System/360 load file for a simple
    Hello World program is available in our Tests folder, and that you
    can run it like so:<br>
    <blockquote>
      <pre><font color="#663300">sim360 -o0ET stdout -i0AT stdin Tests/HELLO.obj</font><br></pre>
    </blockquote>
    (If you're trying to run sim360.exe in Linux or Mac OS, try this
    instead: "<font color="#663300"><code>wine sim360.exe -o0ET stdout
        -i0AT stdin Tests/HELLO.obj</code></font>".)&nbsp; <br>
    <br>
    Which (surprise!) gives you this output:<br>
    <blockquote>
      <pre>Hello, world!<br></pre>
    </blockquote>
    The command-line switches for <b>sim360</b> probably look
    mysterious, but they're not so bad. You can see a full list of
    command-line options with the command "<font color="#663300"><code>sim360










        --help</code></font>", but what the mysterious switches in the
    example above mean is this:<br>
    <ul>
      <li><font color="#663300"><code>-o0ET stdout</code></font>: Causes
        any output to "device 0" from the IBM 360 program to be routed
        to <font color="#663300"><code>stdout</code></font>, and
        automatically translate it from EBCDIC to ASCII.<br>
      </li>
      <li><code><font color="#663300">-i0AT stdin</font></code>: Causes
        input from "device 0" into the IBM 360 program to be routed from
        <font color="#663300"><code>stdin</code></font>, and
        automatically to translate it from ASCII to EBCDIC.</li>
    </ul>
    The spectre of EBCDIC that looms over this entire enterprise will be
    discussed later.<br>
    <ul>
    </ul>
    <h1><a name="compilingXCOM"></a>Insane Bootstrapping!</h1>
    And I do mean <i>insane</i>.<br>
    <br>
    Earlier, I promised (threatened?) to give you some much heftier
    testing of <b>XCOM-I</b> on your computer, and now that we have <b>sim360</b>
    in hand, we're going to do that with a vengeance!&nbsp; We're going
    try <i>bootstrapping</i> some legacy standard-XPL compilers.&nbsp;
    By a "legacy" compiler, I mean an IBM 360 XPL compiler from the
    good-old 1960's or 1970's.&nbsp; We'll use our ability to do this to
    gauge the authenticity of <b>XCOM-I</b>'s behavior, at least in so
    far as standard XPL is concerned.&nbsp; We happen to have XPL source
    code <i>and</i> IBM 360 executables for <i>two</i> such legacy
    compilers.&nbsp; (And by "we", I mean that I copied them from Dan
    Weaver's website.)<br>
    <br>
    <table cellspacing="2" cellpadding="2" border="1">
      <caption><font size="+1"><b>Available Legacy IBM 360 XPL Compilers</b></font></caption>
      <tbody>
        <tr>
          <th valign="bottom" align="center">Designation<br>
          </th>
          <th valign="bottom" align="center">Notes<br>
          </th>
          <th valign="bottom" align="center">Where I Got it From<br>
          </th>
          <th valign="bottom" align="center">Legacy XPL Source Code for
            XCOM Proper<br>
          </th>
          <th valign="bottom" align="center">Legacy XPL Source Code for
            Library<br>
          </th>
          <th valign="bottom" align="center">Legacy IBM 360 Executable<br>
          </th>
          <th valign="bottom" align="center">"Modern" Patch(es) for use
            with XCOM-I<br>
          </th>
        </tr>
        <tr>
          <td valign="middle" align="center"><b>XCOM3</b><br>
          </td>
          <td valign="middle">This is the version of XCOM listed in the
            book <i>A Compiler Generator</i>.&nbsp; Printouts from it
            identify it as "XCOM III".<br>
            <br>
            In reality, there's no way to know if it's identical to the
            book without comparing it line by line, which I have not
            done.&nbsp;&nbsp; The notes in the download file state that
            the files were recovered from a legacy computer tape from
            the Stanford Computation Center, dated 1969-01-23. &nbsp;
            The contemporary notes on the tape itself hint that it is
            the source code from the book, but stop short of saying
            explicitly that it's the precise version that appears in the
            book.&nbsp; The contemporary notes further state that <br>
            <blockquote><font size="-1">"THE BINARY IMAGE OF THE XCOM
                COMPILER ... [is] THE RESULT OF USING XCOM TO COMPILE
                ITSELF FROM THE SOURCE CARDS"</font><br>
            </blockquote>
            However, if you run the binary executable (in <b>sim360</b>),










            its printout says that it was built on May 2, 2001, at
            13:40:40.19.&nbsp; I'd suggest it's rare to find files
            created in 2001 on tapes made in 1969.&nbsp; As a separate
            matter, if you compile the legacy <b>XCOM3</b> source code
            with the legacy <b>XCOM3</b> executable, you do <i>not</i>
            get an identical copy of the legacy <b>XCOM3</b>
            executable.&nbsp; I'm convinced that a <i>different</i>
            version of <b>XCOM</b> compiled it. How the resulting 2001
            executable made its way onto the 1969 tape, or at least into
            the download file, I cannot say.<br>
          </td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
              href="https://www.cs.toronto.edu/XPL/xpl.zip">University
              of Toronto XPL page</a><br>
          </td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM.xpl">XCOM.xpl</a></td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/XPL.LIBRARY.xpl">XPL.LIBRARY.xpl</a></td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM3-20010502.obj">XCOM3-20010502.obj</a><br>
          </td>
          <td valign="middle" align="center">n/a<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><b>XCOM45</b><br>
          </td>
          <td valign="top">The accompanying notes indicate that this is
            from a computer tape from the State University of New York,
            Stonybrook.&nbsp; The notes from the tape itself date it
            1977-05-22.<br>
            <br>
            No information is given about how the binary executable of
            the compiler was created.&nbsp; Its printout (when run in <b>sim360</b>)
            identifies itself as "XCOM 4.5", compiled on July 19, 1976,
            at 21:05:40.16.&nbsp; Fortunately, unlike <b>XCOM3</b>,
            that's consistent with the date of the tape itself.&nbsp;
            But as with <b>XCOM3</b>, and for the same reasons, I'm
            convinced that <b>XCOM45</b> had not itself been used to
            compile the <b>XCOM45</b> binary executable on the tape.<br>
          </td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://sourceforge.net/projects/suny-pascal/files/suny0005.tar.gz/download">Dan










              Weaver's XPL project</a><br>
          </td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/xcom4.xpl">XCOM4.5.xpl</a></td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLIB4.5.xpl">XPLIB4.5.xpl</a></td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/XCOM4-1976.obj">XCOM45-19760719.obj</a></td>
          <td valign="middle" align="center"><a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/patch0.c">patch0.c</a></td>
        </tr>
      </tbody>
    </table>
    <br>
    To avoid confusion, from now on I'll refer to these specific
    compilers as <b>XCOM3</b> or <b>XCOM45</b>, rather than via vague
    references like "<i>A Compiler Generator</i>'s XCOM" as I've been
    doing up to now.&nbsp; Also from now on, if I'm speaking generically
    about any of these old compilers, I'll simply refer to <b>XCOM<i>x</i></b>.&nbsp;










    (For the legacy binary executables, I'll generically call those <b>XCOM</b><b><i>x-YYYYMMDD</i></b>.)&nbsp;











    As for the "patches" mentioned in the rightmost column of the table
    above, this refers to the fact that XPL programs may contain inline
    IBM System/360 machine code inserted directly by the programmer.
    &nbsp; <a moz-do-not-send="true" href="#hooks"><b>XCOM-I</b> has a
      framework for providing C-language patch files to replace the
      functionality the original XPL source code implemented by such
      inline IBM System/360 machine code</a>.&nbsp; Fortunately, <b>XCOM3</b>
    has no such inlined IBM 360 code, and <b>XCOM45</b> has merely has
    a single block of 19 consecutive machine-code instructions.&nbsp;
    The patch file, of course, was <i>not</i> on the legacy computer
    tape; I wrote it myself.<br>
    <br>
    "Bootstrapping" is a process employed by folks who feel compelled to
    write computer-language compilers that can "self-compile"; in the
    case of XPL, that means that an <b>XCOM</b> executable can compile
    the XPL source code for <b>XCOM</b>, and get back an binary
    executable <i>identical</i> to itself when it does so.&nbsp; Its a
    chicken-and-egg problem, though.&nbsp; How could it have possibly
    worked the very first time back in the 1960's, when there was XPL
    source code but no <b>XCOM</b> executable yet to compile it
    with?&nbsp; Well, obviously the initial versions of <b>XCOM</b>
    must have been very cut-rate; and they must have been compiled with
    something <i>other</i> than <b>XCOM</b>, something presumably with
    very-constrained functionality itself and not written in XPL
    itself.&nbsp; But over time, as <b>XCOM</b> became more and more
    capable, <b>XCOM</b> was eventually able to compile itself.&nbsp;
    That process is called "bootstrapping", as in "hauling yourself up
    by your own bootstraps".&nbsp; We're now going to try doing that
    with <b>XCOM<i>x</i></b>.<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;










        To be clear, <b>XCOM-I</b> is not self-compiling.&nbsp; It's
        written in Python, not XPL.&nbsp; Rather, <b>XCOM3</b> and <b>XCOM45</b>
        are what I expect to be self-compiling once they're
        bootstrapped.&nbsp; In the bootstrapping scenario, <b>XCOM-I</b>
        is that <i>other</i> compiler used to compile the initial
        version of <b>XCOM<i>x</i></b> before an <b>XCOM<i>x</i></b>
        executable exists.&nbsp; Except that unlike the normal
        bootstrapping scenario, <b>XCOM-I</b>, <b>XCOM3</b>, and <b>XCOM45</b>
        are full-blown compilers rather than being the initial
        weak-and-feeble versions thereof.</font><br>
    </blockquote>
    Also to be clear, the use case for <b>XCOM-I</b> I'm personally
    interested in is building <b>HAL/S-FC</b> and then forgetting that
    XPL and <b>XCOM-I</b> even exist.&nbsp;&nbsp;<font size="-1"><img
        moz-do-not-send="true" src="smiley.png" alt="" width="16"
        height="16"></font>&nbsp; We don't need <i>a single one</i> of
    these <b>XCOM<i>x</i></b> programs to do that.&nbsp; But still,
    compiling <b>HAL/S-FC</b> is going to go much more smoothly if we
    can have confidence that <b>XCOM-I</b> works properly in the first
    place.&nbsp; And if we can use <b>XCOM-I</b> for bootstrapping <b>XCOM<i>x</i></b>,
    that will give us a certain degree of confidence that <b>XCOM-I</b>
    does in fact work as intended. And if in that process <b>XCOM-I</b>
    can be made useful for somebody who (unlike myself) actually wants
    to play around with XPL, then why not?<br>
    <br>
    Here's the bootstrapping game-plan as it applies to either or both
    of the legacy <b>XCOM<i>x</i></b> compilers:<br>
    <ol>
      <li>We'll use <b>XCOM-I</b> to compile the XPL source code for <b>XCOM<i>x</i></b>.
        That will give us an executable which I'll call <b><b>XCOM<i>x</i></b>-native</b>
        that runs natively on our Linux, Windows, or Mac computer. <br>
      </li>
      <li>We'll then use <b>XCOM<i>x</i></b><b>-native</b> to compile
        the XPL source code for <b>XCOM<i>x</i></b> <i>again</i>. That
        will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360</b>
        that's native to the IBM 360. I.e., it only runs on an IBM 360
        or a simulation thereof, producing IBM 360 object code as well.<br>
      </li>
      <li>Finally, we'll run&nbsp;<b><b>XCOM<i>x</i></b>-360</b> under <b>sim360</b>
        to compile the source code for <b>XCOM<i>x</i></b> one last
        time. That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360A</b>.&nbsp;










        If everything worked perfectly, <b><b>XCOM<i>x</i></b>-360A</b>
        should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b>.<br>
      </li>
      <li><i>Finally</i> <i>finally</i>, we'll run the legacy <b>XCOM<i>x</i></b><b>-<i>YYYYMMDD</i></b>
        executable under <b>sim360</b> to compile source code for <b>XCOM<i>x</i></b>
        one <i>really-truly</i> last time.&nbsp; That will give us an
        executable which I'll call <b>XCOM<i>x</i>-360C</b>.&nbsp; If
        everything worked perfectly, <b><b>XCOM<i>x</i></b>-360C</b>
        should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b>
        and <b><b>XCOM<i>x</i></b>-360A</b>.<br>
      </li>
    </ol>
    That's a <i>lot</i> of XPL compilers floating around to keep
    straight.&nbsp; Here's a synopsis of the <b>XCOM</b> variants
    relevant to the discussion, color coded for cuteness:<br>
    <br>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <caption><font size="+1"><b>Summary of XPL Compilers in
            Bootstrapping Process</b></font></caption> <tbody>
        <tr>
          <th valign="bottom" align="center">Compiler Variant<br>
          </th>
          <th valign="bottom" align="center">Compiler's Own<br>
            Source-Code Files<br>
          </th>
          <th valign="bottom" align="center">Compiler<br>
            Compiled With<br>
          </th>
          <th valign="bottom" align="center">Compiler<br>
            Runs on IBM 360?<br>
          </th>
          <th valign="bottom" align="center">Compiler<br>
            Runs on Linux/Mac/Windows<br>
          </th>
          <th valign="bottom" align="center">Source-Code Language<br>
            &nbsp;and Encoding Accepted<br>
            By Compiler<br>
          </th>
          <th valign="bottom" align="center">Object Files Directly <br>
            Output By Compiler<br>
          </th>
          <th valign="bottom" align="center">Encoding of <br>
            Textual I/O When<br>
            Running the <br>
            Output<br>
            Object Files <br>
          </th>
        </tr>
        <tr>
          <td valign="middle" align="center"><b>XCOM-I</b><b>.py<br>
            </b></td>
          <td valign="middle" align="center">XCOM-I.py <i>et al.</i><br>
          </td>
          <td valign="middle" align="center">n/a<br>
          </td>
          <td valign="middle" align="center">No<br>
          </td>
          <td valign="middle" align="center">Yes<br>
          </td>
          <td valign="middle" align="center">XPL or XPL/I, ASCII (or
            UTF-8) coding<br>
          </td>
          <td valign="middle" align="center">C-language files<br>
          </td>
          <td valign="middle" align="center">ASCII<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#009900"><b>XCOM3-native</b><b><br>
              </b></font></td>
          <td valign="middle" align="center"><font color="#009900">XCOM.xpl,










              XPL.LIBRARY.xpl<br>
            </font></td>
          <td valign="middle" align="center"><b>XCOM-I.py</b><b><br>
            </b></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#009900">No</font><font color="#009900"><br>
            </font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#009900">Yes</font><font color="#009900"><br>
            </font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#009900">XPL, ASCII coding</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#009900">IBM 360 load file</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#009900">EBCDIC</font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#009900"><b>XCOM45-native</b></font></td>
          <td valign="middle" align="center"><font color="#009900">XCOM4.5.xpl,










              XPLIB4.5.xpl<br>
            </font></td>
          <td valign="middle" align="center"><b>XCOM-I</b><b>.py<br>
            </b></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-360</b><b>.obj<br>
              </b></font></td>
          <td valign="middle" align="center"><font color="#cc9933">XCOM.xpl,










              XPL.LIBRARY.xpl</font></td>
          <td valign="middle" align="center"><font color="#009900"><b>XCOM3-native</b><b><br>
              </b></font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#cc9933">Yes</font><font color="#cc9933"><br>
            </font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#cc9933">Only under <b>sim360</b> or similar</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#cc9933">XPL, EBCDIC coding</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#cc9933">IBM 360 load file</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#cc9933">EBCDIC</font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-360.obj</b></font></td>
          <td valign="middle" align="center"><font color="#cc9933">XCOM4.5.xpl,










              XPLIB4.5.xpl</font></td>
          <td valign="middle" align="center"><font color="#009900"><b>XCOM45-native</b></font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360A</b><b>.obj</b><br>
            </font></td>
          <td valign="middle" align="center"><font color="#000099">XCOM.xpl,










              XPL.LIBRARY.xpl</font></td>
          <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-360</b><b>.obj<br>
              </b></font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#000099">Yes<br>
            </font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#000099">Only under <b>sim360</b> or similar</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#000099">XPL, EBCDIC coding</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#000099">IBM 360 load file</font></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#000099">EBCDIC</font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360A.obj</b></font></td>
          <td valign="middle" align="center"><font color="#000099">XCOM4.5.xpl,










              XPLIB4.5.xpl</font></td>
          <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-360.obj</b></font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><b>XCOM3-20010502.obj</b><b><br>
            </b> </td>
          <td valign="middle" align="center">XCOM.xpl, XPL.LIBRARY.xpl</td>
          <td valign="middle" align="center">n/a</td>
          <td rowspan="2" colspan="1" valign="middle" align="center">Yes</td>
          <td rowspan="2" colspan="1" valign="middle" align="center">Only










            under <b>sim360</b> or similar</td>
          <td rowspan="2" colspan="1" valign="middle" align="center">XPL,










            EBCDIC coding</td>
          <td rowspan="2" colspan="1" valign="middle" align="center">IBM
            360 load file</td>
          <td rowspan="2" colspan="1" valign="middle" align="center">EBCDIC<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><b>XCOM45-19760719.obj</b><b><br>
            </b> </td>
          <td valign="middle" align="center">XCOM4.5.xpl, XPLIB4.5.xpl</td>
          <td valign="middle" align="center">n/a<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><b><font color="#ff0000">XCOM3-360C.obj<br>
              </font></b> </td>
          <td valign="middle" align="center"><font color="#ff0000">XCOM.xpl,










              XPL.LIBRARY.xpl</font></td>
          <td valign="middle" align="center"><b>XCOM3-20010502.obj</b></td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#ff0000">Yes<br>
            </font> </td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#ff0000">Only under <b>sim360</b> or similar<br>
            </font> </td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#ff0000">XPL, EBCDIC coding<br>
            </font> </td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#ff0000">IBM 360 load file</font><br>
          </td>
          <td rowspan="2" colspan="1" valign="middle" align="center"><font
              color="#ff0000">EBCDIC</font><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><b><font color="#ff0000">XCOM45-360C.obj<br>
              </font></b> </td>
          <td valign="middle" align="center"><font color="#ff0000">XCOM4.5.xpl,










              XPLIB4.5.xpl</font></td>
          <td valign="middle" align="center"><b>XCOM45-19760719.obj</b></td>
        </tr>
      </tbody>
    </table>
    <br>
    There are other possible scenarios the table doesn't cover for
    compiling stuff with other stuff.&nbsp; Those are left as an
    exercise for the reader, though I don't think they have any
    relevance <i>vis-à-vis</i> bootstrapping.<br>
    <br>
    Rather than tediously walking you through all of the steps required
    to carry out this complicated bootstrapping scheme, a Makefile has
    provided so that you can carry it out in one easy step.&nbsp; If you
    want to see the gory details, just look into the Makefile itself.<br>
    <br>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <tbody>
        <tr>
          <td valign="top">
            <h4>Linux</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make<br></pre>
            </blockquote>
            Or:
            <blockquote>
              <pre>make CC=clang EXTRA=-w</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=clang EXTRA=-w<br></pre>
            </blockquote>
            Or:
            <blockquote>
              <pre>make CC=gcc EXTRA="-w -std=c99"</pre>
            </blockquote>
            <blockquote> </blockquote>
          </td>
        </tr>
        <tr>
          <td valign="top">
            <h4>Build/Test Windows EXE Files in Linux or Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote>
              <pre>cd <i>virtualagc</i>/XCOM-I<br>make CC=x86_64-w64-mingw32-gcc EXT=.exe EXER=wine</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Windows</h4>
            <a name="winInsane"></a>Open an MSYS2 command line.&nbsp;
            Then: &nbsp;<code> </code>
            <blockquote>
              <pre><code>cd </code><code><i>virtualagc</i>/XCOM-I</code><code><br></code><code>make RDYNAMIC= EXTRA=-w</code><code> EXT=.exe<br></code></pre>
            </blockquote>
            <code>or<br>
            </code>
            <blockquote>
              <pre><code>make CC=clang EXTRA="-w" EXT=.exe<br></code><code></code><br></pre>
            </blockquote>
            Or from a Visual Studio developer command line,<br>
            <pre>make CC=cl</pre>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    Having done this, you should see that all of the XPL compilers in
    the table of XPL compilers have now been created, such as
    XCOM3-360A.obj, and if all of the tests comparing them have been
    passed, you'll see messages similar to these:<br>
    <blockquote>
      <pre>Bootstrapping XCOM3 -----------------------------------------<br>Files XCOM3-360.obj and XCOM3-360C.obj match within tolerance (2 &lt;= 4 mismatches)<br>Cross-comparison to output of legacy compiler successful<br>Files XCOM3-360.obj and XCOM3-360A.obj match within tolerance (1 &lt;= 4 mismatches)<br>Bootstrap of XCOM3 successful<br>Bootstrapping XCOM45 -----------------------------------------<br>Files XCOM45-360.obj and XCOM45-360C.obj match within tolerance (1 &lt;= 4 mismatches)<br>Cross-comparison to output of legacy compiler successful<br>Files XCOM45-360.obj and XCOM45-360A.obj match within tolerance (1 &lt;= 4 mismatches)<br>Bootstrap of XCOM45 successful<br></pre>
    </blockquote>
    You may wonder about the messages that some of the files were
    "within tolerance" for the IBM 360 object files.&nbsp; The object
    files are, of course, not text files, but rather are
    non-human-readable binary files.&nbsp; A perfect match would be if
    the files were the same length, and each byte of one file were
    identical to the corresponding byte of the other file.&nbsp; So why
    would it be okay if 1 or 2 bytes (as in the printout above) were
    different?<br>
    <br>
    Consider the following selection from the report the XPL compiler
    printed when generating the object file XCOM45-360C.obj:<br>
    <blockquote>
      <pre> XPL COMPILATION---SUNY STONYBROOK---XCOM4.5 VERSION OF  <font color="#ff0000">JULY 19, 1976</font>.  CLOCK TIME = <font color="#ff0000">21:5:40.16</font>.<br><br>TODAY IS AUGUST 12, 2024.  CLOCK TIME = 15:6:40.38.<br><br>   1 I   /*  FIRST WE INITIALIZE THE GLOBAL CONSTANTS THAT DEPEND UPON THE INPUT      I  1286<br>   2 I      GRAMMAR.  THE FOLLOWING CARDS ARE PUNCHED BY THE SYNTAX PRE-PROCESSOR  */ I  1286<br>   3 I                                                                                I  1286<br>   4 I   /*  XPL PARSING TABLES  */                                                   I  1286<br>   5 I                                                                                I  1286<br>   6 I   DECLARE MAXTL LITERALLY '12' ;                                               I  1286<br>   7 I   DECLARE MAXNTL LITERALLY '26' ;                                              I  1286<br>   8 I   DECLARE STARTSTATE LITERALLY '112' ;                                         I  1286<br>   9 I   DECLARE NT LITERALLY '42' ;                                                  I  1286<br>  10 I   DECLARE NSY LITERALLY '92' ;                                                 I  1286<br>  11 I   DECLARE NSTATES LITERALLY '228' ;                                            I  1286<br>  12 I   DECLARE V(92) CHARACTER INITIAL ( '&lt; DUMMY &gt;', '&lt;', '(', '+', '|',           I  1286<br>⋮<br><br>TOTAL TIME IN COMPILER   0:0:1.51.<br>SET UP TIME              0:0:0.03.<br>ACTUAL COMPILATION TIME  0:0:1.33.<br>POST-COMPILATION TIME    0:0:0.15.<br>COMPILATION RATE: 198451 CARDS PER MINUTE.<br></pre>
    </blockquote>
    Notice the part I've highlighted in <font color="#ff0000">red</font>.&nbsp;











    The compilation report includes the date and time on which <i>the
      compiler generating the report</i> was compiled, which means that
    the compilation date and time must themselves be embedded in the
    executable of the XPL compiler ... which means that the same XPL
    compiler, if compiled on two different occasions, would have
    different timestamps embedded in its two object files.&nbsp; Since a
    timestamp requires 3 bytes for the time and 3 bytes for the date,
    that means that up to 6 bytes may differ simply due to an embedded
    timestamp.<br>
    <br>
    That's fine theory, all right, but can we see it happening in
    practice?&nbsp; I.e., were the bytes that were different really part
    of a timestamp?&nbsp; Here's a spot check:&nbsp; I've made
    hexadecimal dumps of the two of the object files that we want to be
    identical, and then used a file-comparison utility to compare the
    hex dumps side-by-side.&nbsp; Here's a screenshot of the <i>only</i>
    difference found between the two files, with <b>XCOM45-360.obj</b>
    on the left and <b>XCOM45-360A.obj</b> on the right:<br>
    <br>
    <img moz-do-not-send="true" src="XCOM45-360-meld.png" alt=""
      width="1580" height="89"><br>
    <br>
    In this case, only 3 bytes are different.&nbsp; <b>XCOM45-360.obj</b>
    was built (according to the report it printed out when I made the
    screenshot above) at time 19:53.37.27, while <b> XCOM45-360A.obj</b>
    was built at 17:5:6.24 on the same date.&nbsp; <b>XCOM</b> gets the
    compile time using <a moz-do-not-send="true"
      href="XPL-I.html#builtin">the XPL built-in function <font
        color="#663300"><code>TIME_OF_GENERATION</code></font></a>,
    which returns the number of centiseconds since midnight.&nbsp; For <b>XCOM45-360.obj</b>,
    that computes to 100*(19*3600+60*53+37.27)=7161727=0x6D477F.&nbsp;
    Similarly, for <b>XCOM45-360A.obj</b>,
    100*(17*3600+5*60+6.24)=6150624=0x5DD9E0.&nbsp; Both perfectly match
    the screenshot above.&nbsp; (Incidentally, IBM 360 programs all
    store their integer data in <i>big-endian</i> form, so that the
    most-significant bytes come first in memory.)&nbsp; Q.E.D.<br>
    <blockquote> <font size="-1"><b>Aside:</b>&nbsp; By the way, <b>XCOM3</b>
        has plenty of quirks specific to it, quite aside from any quirks
        XPL more-generally may have as a computer language.&nbsp; <b>XCOM3-native</b>
        and <b>XCOM3-360</b> inherit these quirks.&nbsp; I mention this
        just in case you become excited about using <b>XCOM3-native</b>
        and start writing new XPL programs for it!&nbsp; Here are a few
        quirks I've noticed:</font><br>
      <font size="-1"> </font>
      <ul>
        <li><font size="-1">It only accepts upper-case for identifiers
            and keywords ... in spite of the fact that XPL is case-<i>in</i>sensitive










            and that every speck of XPL source code in <i>A Compiler
              Generator</i> is printed in lower case! <br>
          </font></li>
        <li><font size="-1">It requires an <font color="#663300"><code>EOF</code></font>
            token at the end of the source code. </font><font size="-1"><br>
          </font></li>
        <li><font size="-1">It won't allow you to have two division
            operations (including <font color="#663300"><code>MOD</code></font>
            as a division) in the same statement, instead emitting an
            error message saying that it requires a "busy register".</font></li>
      </ul>
    </blockquote>
    <blockquote> </blockquote>
    <blockquote> </blockquote>
    <h1><a name="halsfc"></a>How to Build HAL/S-FC<br>
    </h1>
    Hopefully you're now convinced that <b>XCOM-I</b> works somewhat
    correctly, at least in so far as compiling <i>standard</i> XPL
    programs is concerned.&nbsp; But we'll do one last test, and it's a
    big one! <br>
    <br>
    Recall that our motivation in creating <b>XCOM-I</b> was to compile
    XPL/I programs, and in particular to be able to compile the original
    HAL/S compiler for Space Shuttle flight software, which was known as
    <b>HAL/S-FC</b> back in the day, or <b>HALSFC</b> in its modern
    incarnation.&nbsp; While usage of <b>HALSFC</b> is the subject of <a
      moz-do-not-send="true" href="HAL.html">a different web page</a>,
    we'll talk about how to compile <b>HALSFC</b> itself here.<br>
    <br>
    Once again, a Makefile has been provided that performs the entire
    build of <b>HALSFC</b>, as well as using the newly-built <b>HALSFC</b>
    to compile a short HAL/S test file, and then doing a regression test
    of <b>HALSFC</b>'s outputs (i.e., object files, reports, and so on)
    vs an earlier build of the same test file on my own Linux box.&nbsp;
    Admittedly, this regression test only compiles a very simple HAL/S
    test program, HELLO.hal, which looks like this:<br>
    <blockquote style="background-color:lightgray">
      <pre><font color="#663300"><code>DEBUG ¢0¢3¢4¢5¢6¢8¢9¢C¢D¢E¢F H(202)</code><code><br></code><code> </code><code><br></code><code> HELLO: PROGRAM;</code><code><br></code><code>    DECLARE I INTEGER;</code><code><br></code><code>    DECLARE MY_NAME CHARACTER(20) INITIAL('RON BURKEY');</code><code><br></code><code>    DECLARE INTEGER, J;</code><code><br></code><code>    REPLACE PRINTER BY "6";</code><code><br></code><code>    WRITE(PRINTER) 'THE BEGINNING';</code><code><br></code><code>    DO FOR I = 1 TO 5;</code><code><br></code><code>       WRITE(PRINTER) I, 'HELLO, WORLD!';</code><code><br></code><code>       DO FOR J = 2 TO 8 BY 2;</code><code><br></code><code>          WRITE(PRINTER) J, MY_NAME, 'SAYS ISN''T THIS FUN?';</code><code><br></code><code>       END;</code><code><br></code><code>    END;</code><code><br></code><code>    WRITE(6) 'THE END';</code><code><br></code><code> CLOSE HELLO;</code></font><br></pre>
    </blockquote>
    But a test is a test, right?&nbsp; You may notice that HAL/S bears a
    creepy similarity to XPL/I.&nbsp; The similarity is superficial, and
    the two languages are quite different in reality.&nbsp; (But it
    fooled <i>me</i> at first!)&nbsp; Here are the instructions:<br>
    <br>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <tbody>
        <tr>
          <td valign="top">
            <h4>Linux<br>
            </h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote> </blockquote>
            <blockquote>
              <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet regression<br></pre>
            </blockquote>
            Or:<br>
            <blockquote>
              <pre>make -s XEXTRA=--quiet CC=clang EXTRA=-w regression</pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:
            <blockquote> </blockquote>
            <blockquote>
              <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet CC=clang EXTRA=-w regression<br></pre>
            </blockquote>
            Or:
            <blockquote>
              <pre>make -s XEXTRA=--quiet CC=gcc EXTRA="-w -std=c99" regression
</pre>
            </blockquote>
            <blockquote> </blockquote>
          </td>
        </tr>
        <tr>
          <td valign="top">
            <h4>Build/Test Windows EXE Files in Linux or Mac OS</h4>
            Open a "terminal" (i.e., a command line).&nbsp; Then:<br>
            <blockquote> </blockquote>
            <blockquote>
              <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet CC=x86_64-w64-mingw32-gcc EXT=.exe EXER=wine regression<br></pre>
            </blockquote>
          </td>
          <td valign="top">
            <h4>Windows</h4>
            Open an MSYS2 command line.&nbsp; Then:
            <blockquote> </blockquote>
            <blockquote>
              <pre>cd <i>virtualagc</i>/yaShuttle/"Source Code"/PASS.REL32V0<br>make -s XEXTRA=--quiet RDYNAMIC= regression<strike><br></strike></pre>
            </blockquote>
            Or from a Visual Studio developer command line,<br>
            <blockquote>
              <pre>make -s XEXTRA=--quiet CC=cl regression<strike><br></strike></pre>
            </blockquote>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <blockquote> <font size="-1"><b>Aside:</b>&nbsp; By the way, <code>XEXTRA</code>
        is something you can use on a make command line to pass extra
        options to <b>XCOM-I</b>, while <code>EXTRA</code> can be used
        to pass extra options to the C compiler.&nbsp; In particular,
        the <code>--quiet</code> in <code>XEXTRA</code> is a way to
        eliminate certain informative messages from <b>XCOM-I</b> that
        (after seeing them a hundred times) I personally no longer find
        quite so informative and would rather not see any longer. </font><br>
    </blockquote>
    If everything was found to be successful, you should see messages
    that terminate with lines similar to these:<br>
    <blockquote>
      <pre>⋮<br>Processing regression/HELLO ==========================================<br>Comparing ...<br>Files cA.rpt and pyA.rpt are identical<br>Files FILE1.bin and halmat.bin are identical<br>Files LISTING2.txt and listing2.txt are identical<br>Files pass1-new.rpt and pass1-old.rpt are identical<br>Files halmat.bin and regression/halmat.bin are identical<br>Files litfile.bin and regression/litfile.bin are identical<br>Files listing2.txt and regression/listing2.txt are identical<br>Files COMMON-PASS1-new.out and COMMON-PASS1-old.out are identical<br>Files optmato.bin and regression/optmato.bin are identical<br>Files auxmata.bin and regression/auxmata.bin are identical<br>Files pass2-new.rpt and pass2-old.rpt are identical<br>Files cards2.bin and regression/cards2.bin match within tolerance (17 &lt;= 18 mismatches)<br>Files cards2.bin and regression/cards2.bin match<br>Files COMMON-PASS2-new.out and COMMON-PASS2-old.out are identical<br>Regression test passed.<br></pre>
      <b><font size="-1">Warning:</font></b><font size="-1">&nbsp; Yes,
        this means that the regression test has passed, which is very
        comforting!&nbsp; But at least as of this writing, in <i>spite</i>
        of all this testing, there are still <i>some</i> cases in which
        <b>HALSFC</b>'s behavior is not entirely correct, which probably
        implies that <b>XCOM-I</b> is still not perfect either.&nbsp;
        Alas!&nbsp; A work in progress is a work in progress is a work
        in progress ... by which I mean <b>XCOM-I</b>.&nbsp; You pays
        your money and you takes your chances.&nbsp; When I think <b>XCOM-I</b>
        is fully perfected, at least insofar as <b>HALSFC</b> is
        concerned, I'll let you know.<br>
      </font></blockquote>
    You should also find 5 new executable files:<br>
    <ol>
      <li><b>PASS1[.exe]</b></li>
      <li><b>FLO</b><b>[.exe]</b></li>
      <li><b>OPT</b><b>[.exe]</b></li>
      <li><b>AUXP</b><b>[.exe]</b></li>
      <li><b>PASS2</b><b>[.exe]</b></li>
    </ol>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; This isn't actually
        a full build of <b>HAL/S-FC</b>, but merely of the compiler
        passes needed to run the regression test.&nbsp; You could have
        gotten the additional passes <b>PASS3</b> and <b>PASS4</b>,
        along with the BFS versions of the passes (discussed
        later),&nbsp; namely <b>PASS1B[.exe]</b>, <b>OPTB[.exe]</b>, <b>PASS2B[.exe]</b>,
        and <b>PASS3B[.exe]</b>, by using the <b>make</b> targets "<font
          color="#663300"><code>all regression</code></font>" rather
        than just "<font color="#663300"><code>regression</code></font>"
        in the instructions above.</font><br>
    </blockquote>
    These passes of <b>HAL/S-FC</b> are chained together to perform a
    full compilation of a HAL/S program.&nbsp; For those passes having <i>two</i>
    programs listed, (<b>xxxx</b> and <b>xxxxB</b>), the B version is
    used when compiling Backup Flight Software, whereas the non-<b>B</b>
    version is used for compiling the Primary Flight Software; if
    there's no <b>B</b> version, then the non-<b>B</b> version is used
    for both primary and backup.&nbsp; I'd note that there're something
    like 700K lines of XPL/I code in this compilation, so it's a
    non-negligible test of the XPL/I compiler ... assuming of course,
    that the HAL/S compiler actually works correctly once installed.<br>
    <br>
    But again, there's a dedicated <b>HALSFC</b> page covering these
    topics in more detail, so I'll not discuss them further here.<br>
    <br>
    Alas, I can't show you the results of <i>running</i> the compiled
    form of the HELLO program, since it would only run on an AP-101
    computer, and even then only in theory since we've made no effort to
    insure that the program employs i/o devices that are actually
    available to the computer!&nbsp; <img moz-do-not-send="true"
      src="smiley.png" alt="" width="16" height="16"><br>
    <h1><a name="xpli"></a>The Peculiarities of Standard XPL and
      Intermetrics XPL/I</h1>
    <p>It is a truth universally acknowledged that there is no
      satisfactory introductory information available concerning
      programming in XPL.&nbsp; Or at least, it <i>would</i> be
      universally acknowledged if anybody had ever heard of XPL and
      wanted to create new XPL programs.<br>
    </p>
    <p>The best you can do, generally speaking, is to purchase an
      out-of-print, used copy of the book <i>A Compiler Generator</i>.&nbsp;











      If you do, you'll find a book that's densely packed with
      information, but that that information is the source code for an
      XPL compiler (written in XPL), lots of BNF descriptions of the
      language, lots of theory on how to write a compiler-generator
      program, and very little of direct interest to a programmer who
      wants to come up to speed quickly on how to write or understand a
      program written in XPL. Not to mention the fact — though I <i>am</i>
      mentioning it! — that some of the most-critical counter-intuitive
      information is buried in easy-to-miss, easy-to-misunderstand
      comments made in passing, rather than as big, bold-face warnings.
      &nbsp; As a bonus, the book provides an index of almost no use at
      all to a newby XPL programmer.&nbsp; Beyond the book itself, most
      <i>online</i> information about XPL, in my experience, is simple
      condensing or other rehashing of <i>A Compiler Generator</i>, and
      adds little extra of value in a tutorial sense, since it's almost
      never written by anybody actually working with XPL.&nbsp; With
      that said, you may find some useful online information in a couple
      of places:<br>
    </p>
    <ul>
      <li><a moz-do-not-send="true"
          href="https://sourceforge.net/projects/xpl-compiler/">Daniel
          Weaver provides some documentation (in particular, his
          xpl.pdf) with his XPL-to-C translator program</a>.</li>
      <li>The <a moz-do-not-send="true"
          href="https://www.cs.toronto.edu/XPL/ldindex.html">University
          of Toronto XPL website has a page</a> with a small but useful
        transcription of some material from <i>A Compiler Generator</i>
        — albeit with unfortunate HTML formatting that make some of it
        almost unreadable.</li>
    </ul>
    <p>And as for Intermetrics XPL/I ... well, from a tutorial
      perspective, it's orders of magnitude worse. From the standpoint
      of <i>surviving</i> documentation, XPL/I may as well never have
      existed at all.<br>
    </p>
    <p>Taking all of that into account, I wish I could provide a full
      tutorial here how to write XPL or XPL/I programs, similar in
      nature to Michael Ryer's book <i>Programming in HAL/S</i>.&nbsp;
      But there's so little to do, and so much time.&nbsp; No, scratch
      that, the other way around!&nbsp; There's just not enough time,
      and maybe not enough skill.&nbsp; So for now, I'll just cover some
      of the quirks of the language(s) that might be unexpected to
      programmers already skilled in other programming languages. Send
      in suggestions for improvement, if you like; I'm sure I can use
      them somehow to make the discussion even worse. </p>
    <h2>Character Set and Modern Character Substitutions<br>
    </h2>
    <p>The most basic characteristic of a language is the character set
      in which the language is expressed.&nbsp; Above all else, we need
      to recognize that IBM 360 computers encoded textual information
      using so-called EBCDIC coding, which defined somewhat-different
      characters than the ASCII coding common today, as well as entirely
      different numerical codes for the characters it did include.<br>
    </p>
    <p>Neither <i>A Compiler Generator</i> nor Intermetrics specifies
      the character set.&nbsp; I've given it a lot of thought, and my
      conclusion is that the originally-supported character set was: </p>
    <p align="center">&lt;space&gt;<br>
      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>
      a b c d e f g h i j k l m n o p q r s t u v w x y z<br>
      0 1 2 3 4 5 6 7 8 9<br>
      _ % + - * . / | &amp; = &lt; &gt; # @ $ , ; : ( ) ' " ! ? [ ] { }<br>
      ¢ ¬ &lt;eof&gt;<br>
    </p>
    <p>Here, by &lt;space&gt; I mean a space character, and by
      &lt;eof&gt; I mean an end-of-file character.<br>
    </p>
    <p>You'll notice that several characters common today were not
      originally supported, including:</p>
    <p align="center">` ~ ^ \<br>
    </p>
    <p>Contrariwise, there are three characters (¢, ¬, and &lt;eof&gt;)
      that don't exist at all in the 7-bit ASCII character set that's
      the common core for the character sets typically used today when
      writing software source code.&nbsp; The first two are EBCDIC
      characters, while the third isn't even EBCDIC, but merely
      something (a Hollerith code, I guess) which could be encoded on
      punchcards.&nbsp; <b>HAL/S-FC</b> somewhat arbitrarily assigned
      the &lt;eof&gt; character the numerical code 0xFE, which I believe
      was otherwise unused in the then-available version of EBCDIC.</p>
    <p>Therefore, when working with <b>XCOM-I</b>, we can use the
      fortunately otherwise-unused ASCII characters in place of the
      three unsupported characters:<br>
    </p>
    <ul>
      <li>The ASCII characters ~ and ^ are used interchangeably with ¬,
        but <b>XCOM-I</b> prefers (and transparently replaces them by)
        ~.&nbsp; <br>
      </li>
      <li>Similarly, we use the ASCII character ` in preference to
        ¢.&nbsp; </li>
      <li>Finally, the ASCII \ character is now used in place of
        &lt;eof&gt;, which was a character that could be punched on the
        punch cards, but had no printable representation. <br>
      </li>
    </ul>
    <blockquote>
      <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; The
          &lt;eof&gt; <i>character</i> — not to be confused with the <font
            color="#663300"><code>EOF</code></font> <i>token</i> that
          appears at the end of the source code in an XPL or XPL/I
          program — is an unusual case.&nbsp; It is not a special
          character in XPL programs.&nbsp; However, it is used as a
          bookkeeping device by HAL/S compilers, or at least by <b>HAL/S-FC</b>,
          in padding that the HAL/S compiler automatically appends to a
          stream of input HAL/S source code.&nbsp; Thus we have to have
          a way of representing it in the <b>XCOM-I</b> framework, even
          though it's not a character anyone would ever have occasion to
          use in either an XPL or HAL/S source-code file, unless that
          file was itself part of a HAL/S compiler!&nbsp; To the best of
          my knowledge, &lt;eof&gt; appears only within a single string
          variable, <font color="#663300"><code>INPUT_PAD</code></font>,
          that occurs in the <b>HAL/S-FC</b> source-code file
          STREAM.xpl.&nbsp; See the comments for </font><font size="-1"><font
            size="-1"><font color="#663300"><code>INPUT_PAD</code></font></font>
          in STREAM.xpl.</font><br>
      </p>
    </blockquote>
    <p>These substitutions allow us to completely translate the original
      XPL or XPL/I source code back-and-forth between the original
      EBCDIC and ACII without any loss of information, and without
      insisting that you adopt any specific "locale" like ISO-8859-15 or
      UTF-8 for your computer that's not optimal for your other
      (non-XPL'ing) activities.&nbsp; With that said, I suspect that in
      most of today's common computer setups, you can probably use ¢ and
      ¬ in your XPL/I source code if you insist on doing so, but I
      neither recommend nor guarantee it. <br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b> All previously-existing XPL or
          XPL/I source code files I've found, or HAL/S source code for
          that matter, has already substituted ~ or ^ for ¬ anyway. And
          indeed, some early HAL/S documentation suggests the former
          substitution. I suspect that's because some IBM printers at
          the time printed ~ in place of </font><font size="-1"><font
            size="-1">¬</font>. But whatever the explanation, the
          substitutions I'm suggesting are not exactly daring in their
          originality. As far as the </font><font size="-1">¢ symbol is
          concerned, it's not actually used in XPL or XPL/I code, as far
          as I know, but it is used in HAL/S, so we still need to have a
          reliable way of dealing with it.<br>
        </font></p>
    </blockquote>
    <h2>Case Sensitivity</h2>
    <p>XPL programs are <i>not</i> case-sensitive, except in so far as
      the contents of quoted strings are concerned.&nbsp; E.g.,
      lower-case or mixed-case symbols are treated as being identical to
      their upper-case correspondents, but quoted strings are
      case-sensitive.<br>
    </p>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Case-insensitive <i>in




          principle</i>, though as I mentioned earlier, the early <b>XCOM3</b>
        compiler ended up being case-sensitive anyway for some reason,
        at least insofar as XPL keywords were concerned.</font><br>
    </blockquote>
    <p> </p>
    <h2>Source-Code Formatting<br>
    </h2>
    <p>Input to an XPL or XPL/I program (via the <font color="#663300"><code>INPUT</code></font>
      built-in function) is expected to conform to computer
      punch-card-like conventions. I.e., input lines are always exactly
      80 characters long, and <b>XCOM-I</b> enforces this by truncating
      or right-padding input lines as necessary. If the input lines are
      longer than 80 columns physically — say, because they have
      punch-card sequence numbers in columns 81-88 — the extra columns
      are stripped off.<br>
    </p>
    <p>As for the source-code proper, other than being confined to
      columns 1-80, it is entirely free-form. I.e., line breaks are
      ignored; several statements may exist on the same input card, or
      conversely, a single statement may be split across multiple cards.
      Even though XPL <font color="#663300"><code>CHARACTER</code></font>
      strings are limited to 256 characters, there is seemingly no limit
      to the length of an XPL statement.<br>
    </p>
    <p>There are hints in the error messages of <b>XCOM3</b> (and I
      believe, in <i>A Compiler Generator</i> text) that <i>some</i>
      contemporary computer systems may have treated column 1 specially,
      perhaps accepting some kind of non-blank control characters there.
      If so, it was a issue outside <b>XCOM<i>x</i></b> proper and is
      irrelevant to <b>XCOM-I</b>. However, you do find that legacy XPL
      source code does often begin in column 2 rather than column 1, and
      I suspect that this hypothetical column-sensitivity is the reason
      for it.<br>
    </p>
    <p>Regarding this column-1 ambiguity, however, there is the
      practical question of what to do when a long quoted string is
      split across multiple cards. (Yes, that <i>does</i>
      happen.)&nbsp; Does column 1 belong to the string or not? In <b>XCOM-I</b>,
      I take my cue from <b>XCOM3</b> source code in this matter: In
      spite of the fact that <b>XCOM<i>x</i></b>'s source code
      generally avoids column 1 in all other cases, column 1 <i>does</i>
      belong to any multi-line quoted strings.<br>
    </p>
    <h2>Identifiers</h2>
    <p>Identifiers cannot begin with a digit, but otherwise consist of
      any sequence of upper- or lower-case alphanumeric characters, <i>or</i>
      any of the characters @ _ # $.&nbsp; For example, @_26$8ab# is a
      legal name for a variable. </p>
    <p>Identifiers cannot exceed 256 characters in length. </p>
    <h2><a name="datatypes"></a>The Basic XPL Datatypes</h2>
    <p>There are only three basic datatypes:<br>
    </p>
    <ul>
      <li><font color="#663333"><code>FIXED</code></font> is a 32-bit
        signed integer.&nbsp; (Stored as 2's-complement, in big-endian
        byte order, vs the little-endian byte order used in most
        personal computers today.)<br>
      </li>
      <li><font color="#663333"><code>CHARACTER</code></font> is a
        variable-width character string, with a string-length limited to
        256 or less.&nbsp; Strings are stored as a 32-bit unsigned
        integer known as a <i>descriptor</i>, paired with a separate
        area from 1 to 256 bytes containing the individual characters of
        the string, encoded in EBCDIC.&nbsp; The descriptor has 8 bits
        specifying the string length (minus 1) and 24-bits providing the
        starting memory-address of the character data.&nbsp; The string
        descriptor 0x00000000 is a special case, and indicates an empty
        string.<br>
      </li>
      <li><font color="#663333"><code>BIT(<i>n</i>)</code></font>, where
        <i><font color="#663333"><code>n</code></font></i> is from 1 to
        2048, is an <i><font color="#663333"><code>n</code></font></i>-bit





        object.&nbsp; The amount of storage varies by the precision:</li>
      <ul>
        <li><font color="#663333"><code>BIT(1)</code></font> through <font
            color="#663333"><code>B(8)</code></font> are stored in
          memory as single bytes.</li>
        <li><font color="#663333"><code>BIT(9)</code></font> through <font
            color="#663333"><code>BIT(16)</code></font> are stored as
          2-byte "half-words".</li>
        <li><font color="#663333"><code>BIT(17)</code></font> through <font
            color="#663333"><code>BIT(32)</code></font> are stored as
          32-bit words.</li>
        <li><font color="#663300"><code>BIT(33)</code></font> through <font
            color="#663300"><code>BIT(2048)</code></font> are stored
          similarly to <font color="#663300"><code>CHARACTER</code></font>
          variables: There's a 32-bit "descriptor", of which 8 bits is
          the number of bytes needed to store all of the bits, minus 1,
          and 24 bits area pointer to elsewhere in memory, where the
          bytes themselves are stored. Thus, a long <font
            color="#663300"><code>BIT(<i>n</i>)</code></font> like this
          uses up 4 bytes for the descriptor, plus ⌊(<i>n</i>+7)/8⌋
          bytes (5 for <i>n</i>=33 through 256 for <i>n</i>=2048) for
          the data. </li>
      </ul>
    </ul>
    Regarding the <font color="#663300"><code>BIT(<i>n</i>)</code></font>
    datatypes, you might suppose that since one has gone to all the
    trouble to define separate datatypes like <font color="#663300"><code>BIT(1)</code></font>,
    <font color="#663300"><code>BIT(2)</code></font>, ..., <font
      color="#663300"><code>BIT(8)</code></font>, that there is some
    distinction between them.&nbsp; That they behave differently in some
    way.&nbsp; That there's some <i>reason</i> for making such a
    distinction.&nbsp; You would be cruelly mistaken, as I was.&nbsp;
    There is literally no difference between these 8 datatypes.&nbsp;
    Nor is there any distinction between the 8 datatypes <font
      color="#663300"><code>BIT(9)</code></font> through <font
      color="#663300"><code>BIT(16)</code></font>.&nbsp; Nor is there
    any distinction between the 16 datatypes <font color="#663300"><code>BIT(17)</code></font>
    through <font color="#663300"><code>BIT(32)</code></font>.&nbsp;
    The distinctions between the <font color="#663300"><code>BIT(<i>n</i>)
      </code></font>datatypes for <font color="#663300"><code><i>n</i>&gt;32</code></font>
    are left as a thought experiment for the reader.&nbsp; Thus we're
    left with seemingly ridiculous code, like the following from <b>PASS1</b>
    of <b>HAL/S-FC</b>:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE COMPILING BIT(1);
...<br>IF (COMPILING&amp;"80")^=0 THEN<br>    ...</font><br></pre>
    </blockquote>
    <p>Or in other words, first you declare <font color="#663300"><code>COMPILING</code></font>
      to have a single bit, and then later you check it to see what the
      value of its 8th bit is!&nbsp; This particular morsel of hilarity
      caused me months worth of trouble.<br>
    </p>
    <p>The storage formats in memory duplicate those that would have
      been expected on an IBM System/360 computer.&nbsp; While the
      storage formats are not significant in abstract terms, they'll be
      seen to be <i>quite</i> significant in dealing with certain
      aspects of <b>HAL/S-FC</b>'s source code, such as its so-called
      "virtual memory" system, and indeed I think it would be impossible
      to run <b>HAL/S-FC</b> unless these underlying IBM 360 storage
      formats were used.<br>
    </p>
    You'll notice that there is no floating-point datatype, a fact which
    will be discussed in some detail later. <br>
    <br>
    The three basic datatypes can also be incorporated into
    single-dimension arrays. Multi-dimensional arrays are not
    allowed.&nbsp; There is no maximum array length beyond that dictated
    by IBM 360 memory-addressing peculiarities.&nbsp; Array indices
    start at 0.&nbsp; Indices (or "subscripts") are enclosed in
    parentheses, as in <font color="#663300"><code>A(3)</code></font>
    or <font color="#663300"><code>B(N)</code></font>.&nbsp; <br>
    <blockquote><font size="-1"><b>Aside:</b> It's easy to become
        confused and to imagine (incorrectly!) that you can treat a <font
          color="#663333"><code>CHARACTER</code></font> variable (as
        opposed to an array of <font color="#663333"><code>CHARACTER</code></font>
        variables) as an array itself, in order to access its individual
        characters.&nbsp; You cannot!&nbsp; In fact, the XPL language
        does not provide <i>any</i> syntactical means to access
        individual characters of a string.&nbsp; For that, you must rely
        on built-in functions provided by the runtime library to
        directly manipulate memory.&nbsp; The most-direct method is to
        use the <font color="#663300"><code>BYTE</code></font>
        function, which can either retrieve the EBCDIC numerical
        encoding of an individual character in a <font color="#663333"><code>CHARACTER</code></font>
        variable, or else to store a new EBCDIC numerical value at a
        given position in a <font color="#663333"><code>CHARACTER</code></font>
        variable.&nbsp; Thus if we had a <font color="#663333"><code>CHARACTER</code></font>
        variable <font color="#663300"><code>C</code></font> which held
        the value 'HELLO!', then <font color="#663300"><code>BYTE(C, 3)</code></font>
        would return 211 (the EBCDIC encoding for the letter 'L'), while
        the assignment statement "<font color="#663300"><code>BYTE(C, 3)
            = 198;</code></font>" would change the contents of <font
          color="#663300"><code>C</code></font> to 'HELFO' since 198 is
        the EBCDIC code for the letter 'F'.&nbsp; That sounds
        cumbersome, since very few of us have memorized the EBCDIC
        table, but it's really not.&nbsp; You generally don't have to
        look up the EBCDIC encoding for anything, because you would
        actually have programmed operations such as this as "<font
          color="#663300"><code>BYTE(C, 3) = BYTE('F');</code></font>".&nbsp;










        Another, less-generally-useful method would be to use the
        built-in <font color="#663300"><code>SUBSTR</code></font>
        function to retrieve a specific character position as a new <font
          color="#663300"><code>CHARACTER</code></font> object of length
        1.<br>
      </font></blockquote>
    <font size="-1"> </font>The <font color="#663333"><code>BIT(N)</code></font>
    datatype is actually quite problematic.&nbsp; It would be reasonable
    to assume that since <font color="#663333"><code>BIT(N)</code></font>
    seems to represent support for collections of bits, then XPL should
    provide some syntactical sugar for reading the values of these bits
    or modifying them.&nbsp; For <font color="#663333"><code>BIT(1)</code></font>
    through <font color="#663333"><code>BIT(32)</code></font>, you'd be
    somewhat correct, in that XPL largely treats these as being
    interchangeable with integers (i.e., <font color="#663333"><code>FIXED</code></font>),










    and automatically converts them back and forth between <font
      color="#663333"><code>FIXED</code></font>.&nbsp; The runtime
    library's built-in logical-shift-left and logical-shift-right
    functions (<font color="#663300"><code>SHL</code></font> and <font
      color="#663300"><code>SHR</code></font>) work just as easily with
    them as with the <font color="#663333"><code>FIXED</code></font>,
    as do the logical operators <font color="#663300"><code>&amp;</code></font>,
    <font color="#663300"><code>|</code></font>, and <font
      color="#663300"><code>¬</code></font> (<font color="#663300"><code>~</code></font>),










    and the relational operators <font color="#663300"><code>&lt;</code></font>,
    <font color="#663300"><code>&gt;</code></font>, <font
      color="#663300"><code>=</code></font>, <font color="#663300"><code>!=</code></font>,
    <font color="#663300"><code>&gt;=</code></font>, and <font
      color="#663300"><code>&lt;=</code></font>.&nbsp; Swell!<br>
    <br>
    But once you advance to <font color="#663333"><code>BIT(32)</code></font>
    through <font color="#663333"><code>BIT(2048)</code></font>, you
    are cruelly disappointed. &nbsp; XPL provides <i>no</i> built-in
    methods of working with this data <i>qua</i> bits, beyond the
    ability to initialize <font color="#663333"><code>BIT(N)</code></font>
    variables with data when they're declared.&nbsp; (More on that
    later.)&nbsp; As far as actually using this data for anything, there
    are no built-in means to do anything at all with that data.&nbsp;
    While you <i>can</i> manipulate the data by cobbling together
    various runtime-library memory-access functions, <i>A Compiler
      Generator</i> gives none of the technical information about the
    storage format that would allow you to do so, in so far as I was
    able to discover.<b>&nbsp; </b>What do I mean about cobbling
    together memory-access functions?&nbsp; Well, suppose that you want
    to access bit 43 of a <font color="#663300"><code>BIT(86)</code></font>
    variable called <font color="#663300"><code>B</code></font>.&nbsp;
    First, you must know where the data for <font color="#663300"><code>B</code></font>
    is located in memory.&nbsp; There's a function that can tell you
    that.&nbsp; Then you must know which byte in that block contains bit
    43.&nbsp; There's no function that tells you that, but if you <i>do</i>
    know it somehow then there's a function that gives you the value of
    a byte at that address.&nbsp; Then you must know which bit in the
    byte corresponds to bit 43.&nbsp; Again, there's no function for
    that, but if you know it, then you can use library functions like <font
      color="#663300"><code>SHL</code></font> or <font color="#663300"><code>SHR</code></font>,
    probably in conjunction with a logical operator like <font
      color="#663300"><code>&amp;</code></font>, to isolate the value of
    that bit.&nbsp; If you wanted to change the value of that bit,
    different but similar awfulness is involved.<br>
    <br>
    But doing any of that requires that you have intimate knowledge of
    how such <font color="#663333"><code>BIT</code></font> data is
    packed into memory.&nbsp; It's hard to write unambiguously about
    these matters, but I'll try to do so using the following
    concepts:&nbsp; An <i>n</i>-bit value, when written out in
    human-readable form has a <i>leftmost</i> bit and a <i>rightmost</i>
    bit; meanwhile, a block of <i>m</i> bytes in memory has a byte
    that's at the <i>lowest</i> address, a byte at the <i>highest</i>
    address, and within each byte has a <i>most-significant</i> bit and
    a <i>least-significant</i> bit.&nbsp; With those ideas in mind,
    here's how XPL packs the various <font color="#663333"><code>BIT</code></font>
    datatypes into memory:<br>
    <ul>
      <li><font color="#663333"><code>BIT(1)</code></font> through <font
          color="#663333"><code>BIT(32)</code></font>: The rightmost bit
        corresponds to the least-significant bit in the byte at the
        highest address.</li>
      <li><font color="#663333"><code>BIT(32)</code></font> through <font
          color="#663333"><code>BIT(2048)</code></font>: The leftmost
        bit corresponds to the most-significant bit in the byte at the
        lowest address.</li>
    </ul>
    Or to put it concisely if ambiguously, short bit strings are right
    justified, while long bit strings are left justified.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Since I say that the
        bit-packing is undocumented, what's my justification for
        claiming that what I said just above is true?&nbsp; The short
        answer is trial-and-error!&nbsp; The longer answer is that one
        of the intermediate milestones in trying to get <b>XCOM-I</b>
        to the point of being able to compile the original source code
        for <b>HAL/S-FC</b> was first to be able to compile <b>XCOM3</b>
        and run it with a verifiably correct result.&nbsp; (Recall
        "insane bootstrapping" from earlier.)&nbsp; But I couldn't get
        it to work!&nbsp; After messing with it for days on end, I
        eventually got the answer in a dream, and then experimented with
        a couple of different bit-packing schemes before finally getting
        <b>XCOM3</b> to run properly.&nbsp; The packing scheme I
        describe above is the one that worked.</font><br>
    </blockquote>
    <blockquote><font size="-1"> <b>Aside:</b> If all that wasn't bad
        enough, there's also a trap waiting for you if you're already
        used to doing bit manipulations with logical operators and
        shifts in other computer languages.&nbsp; This trap is in the
        behavior of conditional tests in XPL's <font color="#663300"><code>IF</code></font>
        and <font color="#663300"><code>DO WHILE</code></font>
        statements.&nbsp; Conditional tests in these statements depend
        only on the <i>least significant</i> bit; i.e., it as if any
        conditional test involves an extra "<font color="#663300"><code>&amp;










            1</code></font>" operation that you can't see.&nbsp; Thus if
        you wanted to detect (say) that bit 3 of the <font
          color="#663300"><code>BIT(5)</code></font> variable <font
          color="#663300"><code>A</code></font> was set, a statement
        like "<code><font color="#663300">IF A &amp; 8 THEN ...;</font></code>"
        wouldn't help you at all, since the implicit </font><font
        size="-1"> "<font color="#663300"><code>&amp; 1</code></font>"
        in the conditional would cause the test always to fail!&nbsp;
        You would instead need to use a shift-right operation, such as </font><font
        size="-1"><font size="-1">"<code><font color="#663300">IF SHR(A,
              3) THEN ...;</font></code>". </font></font><font
        size="-1"><font size="-1"><br>
        </font></font></blockquote>
    But enough of these measly <font color="#663333"><code>BIT</code></font>-based










    frustrations!<br>
    <br>
    Variables in general are <i>supposedly</i> strictly typed, and
    every variable used must have an associated declaration
    statement.&nbsp; This is a particularly comical assertion when you
    consider the effect that I call <i>subscripting sloppiness</i>.&nbsp;










    Suppose you had the following brief example of a program:<br>
    <blockquote>
      <pre><font color="#663333">declare x fixed, y fixed, z fixed;<br>x(0) = 1;<br>x(1) = 2;<br>x(2) = 3;<br>output = x(0) || ' ' || x(1) || ' ' || x(2);<br></font><font color="#663333">output = x || ' ' || y || ' ' || z;</font><br></pre>
    </blockquote>
    What is this little example supposed to do?&nbsp; First, it declares
    3 variables of the <font color="#663333"><code>fixed</code></font>
    datatype; <font color="#663333"><code>fixed</code></font> means
    that <font color="#663333"><code>x</code></font>, <font
      color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font>
    are 32-bit signed integers.&nbsp; It then proceeds to use <font
      color="#663333"><code>x</code></font> <i>as if</i> it were a
    three-element array, though <font color="#663333"><code>x</code></font>
    wasn't declared that way, assigning values to each of its
    elements.&nbsp; The program simply assumes that <font
      color="#663333"><code>x(0)</code></font> corresponds to <font
      color="#663333"><code>x</code></font>, <font color="#663333"><code>x(1)</code></font>
    corresponds to <font color="#663333"><code>y</code></font>, and <font
      color="#663333"><code>x(2)</code></font> corresponds to <font
      color="#663333"><code>z</code></font>.&nbsp; Finally, the program
    "prints out" both the elements of <font color="#663333"><code>x</code></font>
    (as an array) and the values of <font color="#663333"><code>x</code></font>
    (as a non-array), <font color="#663333"><code>y</code></font>, and
    <font color="#663333"><code>z</code></font>.&nbsp; Naturally, those
    two lines of printout are identical.&nbsp; In case you're wondering,
    we <i>could</i> have used <font color="#663300"><code>z(-1)</code></font>
    as an equivalent to <font color="#663300"><code>y</code></font>, or
    <font color="#663300"><code>z(-2)</code></font> as <font
      color="#663300"><code>x</code></font>.&nbsp; For that matter, we
    could have used this feature to read or write areas of memory in
    which no variables at all had been declared.&nbsp; Or to a certain
    extent, if we had declared variables of some other datatype than <font
      color="#663333"><code>FIXED</code></font>, we could have used this
    same trick to access them as if they were <font color="#663333"><code>FIXED</code></font>.<br>
    <br>
    Subscripting sloppiness indeed!<br>
    <br>
    Here are a few examples of declarations of variables, both scalar
    and array:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE F FIXED, C CHARACTER, B BIT(5);<br>DECLARE FS(10) FIXED, CS(10) CHARACTER, BS(10) BIT(5);</font><br></pre>
    </blockquote>
    These are pretty self-explanatory in most ways, so I won't dissect
    them for you in detail.&nbsp; What's perhaps most confusing is that
    the three arrays declared here (<font color="#663300"><code>FS</code></font>,
    <font color="#663300"><code>CS</code></font>, and <font
      color="#663300"><code>BS</code></font>) each have <i>eleven</i>
    elements in them, because the number 10 in their declarations is not
    the number of elements, but rather the highest legal index.&nbsp; As
    mentioned above, indices start at 0, so the total number of elements
    in each is 11. <br>
    <blockquote><font size="-1"><b>Aside:</b> Standard XPL, as in <i>A
          Compiler Generator</i>, doesn't allow expressions when
        expressing array sizes, whereas XPL/I does allow them.&nbsp; For
        example, the following is fine in XPL/I but is a no-no in XPL:<br>
      </font>
      <blockquote>
        <pre><font size="-1">DECLARE BUFFER(3600-1) BIT(8);<br></font></pre>
      </blockquote>
      <font size="-1">This example will be continued in the next
        section, where it will make a little more sense.</font><br>
    </blockquote>
    There are additional attributes which can be applied to such
    declarations, of which the most important is probably <code><font
        color="#663300">INITIAL</font></code>.&nbsp; This attribute
    allows you to supply an initial value for the variable, such as:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE F FIXED INITIAL(22), F2 FIXED INITIAL("22"), F3 FIXED INITIAL("(8) 22");<br>DECLARE C CHARACTER INITIAL('Hello!');<br>DECLARE B BIT(5) INITIAL("(1) 10100");<br>DECLARE FS(10) FIXED INITIAL(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);</font><br></pre>
    </blockquote>
    It's important to understand that the initializer has its affect
    only at compile-time, and is not applied at run-time.&nbsp; That
    means that if you declare variables within a <font color="#663300"><code>PROCEDURE</code></font>,
    they're <i>not reinitialized</i> each time the <font
      color="#663300"><code>PROCEDURE</code></font> is executed.<br>
    <br>
    You may have been confused by the initializers shown above for the
    variables <font color="#663300"><code>F2</code></font>, <font
      color="#663300"><code>F3</code></font>, and <font color="#663300"><code>B</code></font>,
    since they naively appear to be strings instead of numbers; but the
    naive interpretation is wrong.&nbsp; Which brings up the nature of <i>literals</i>
    in XPL:<br>
    <ul>
      <li><code><font color="#663300">CHARACTER</font></code> literals —
        i.e., text strings — are enclosed in single-quote (')
        characters. If a single-quote itself must appear within the
        string, you use two single-quotes in succession. For example: <font
          color="#663300"><code>'I am the ''king'' of the world!'</code></font>.</li>
      <li>Integer literals for <font color="#663300"><code>FIXED</code></font>
        or <font color="#663300"><code>BIT(N)</code></font> have one of
        several forms:</li>
      <ul>
        <li>A sequence of decimal digits is interpreted as a
          non-negative number in base-10 in the usual way. Note that a
          leading minus sign (-) or plus sign (+) is <i>not</i> part of
          a numeric literal! In XPL, minus signs are only <i>operators</i>,
          and thus something like <font color="#663300"><code>-10</code></font>
          is not a literal for the number -10, but is instead the
          unary-minus operator followed by the literal for the number
          10. In most cases this is a distinction without significance,
          because <b>XCOM-I</b> (or the original <b>XCOM<i>x</i></b>)
          automatically tries to perform all computations that are
          possible at compile time. Nevertheless, this distinction does
          cause some arithmetically-satisfactory expressions to be
          syntactically illegal in XPL. For example, the expression <font
            color="#663300"><code>5 + -5</code></font> isn't legal in
          XPL, and would need to be <font color="#663300"><code>5 +
              (-5)</code></font> instead.&nbsp; The plus sign is also
          only an operator, but unlike the minus sign (which can be
          either a binary or a unary operator), the plus sign is only a
          binary operator.&nbsp; So even an expression like "<font
            color="#663300"><code>(+5)</code></font>" would be illegal.<br>
        </li>
        <li>A sequence of hexadecimal digits enclosed in double-quote
          (") characters represents a hexadecimal number. Spaces are
          ignored within literals like this, and hence can be added at
          will for improved human readability.</li>
        <li>If a double-quoted string is preceded (within the quotes) by
          a parenthesized decimal number, then that number indicates the
          number of bits represented by each digit. <b>XCOM-I</b>
          supports only the following cases:</li>
        <ul>
          <li>"(1) ..." (with digits 0-1 and spaces) is a binary number.</li>
          <li>"(2) ..." (with digits 0-3 and spaces) is a base-4 number.</li>
          <li>"(3) ..." (with digits 0-7 and spaces) is an octal number.</li>
        </ul>
      </ul>
    </ul>
    These numeric literals are the only syntactical reason that the
    double-quote character (") appears in XPL source code.<br>
    <br>
    Another important attribute is <font color="#663300"><code>LITERALLY</code></font>.
    It's not strictly related to declaration of variables, even though
    appearing in <font color="#663300"><code>DECLARE</code></font>
    statements and so it's discussed later on.<br>
    <h2>Automatic Datatype Conversions</h2>
    <p>To a limited extent, XPL will convert one datatype to another
      when appropriate.&nbsp; Table 6.8.2 in <i>A Compiler Generator</i>
      supposedly covers all conversions, if you can understand what it's
      telling you.&nbsp; Here's the way <i>I</i> think it works:<br>
    </p>
    <ul>
      <li><font color="#663300"><code>BIT(1)</code></font> through <font
          color="#663300"><code>BIT(15)</code></font> are automatically
        up-converted to <font color="#663300"><code>FIXED</code></font>
        when the context calls for it.&nbsp; After conversion, all of
        the converted values will be positive integers.</li>
      <li><font color="#663300"><code>BIT(16)</code></font> is
        automatically up-converted to <font color="#663300"><code>FIXED</code></font>,
        with sign-extension of the most-significant bit.&nbsp; I.e., the
        converted value may be either positive or negative.</li>
      <li><font color="#663300"><code>BIT(17)</code></font> through <font
          color="#663300"><code>BIT(31)</code></font> is automatically
        up-converted to <font color="#663300"><code>FIXED</code></font>,
        but <i>A Compiler Generator</i> is not clear on the handling of
        the sign.&nbsp; <b>XCOM-I</b> assumes, highly dubiously, that
        the most-significant bit is extended as if it were a sign.&nbsp;
        In practice, <font color="#663300"><code>BIT(17)</code></font>
        through <font color="#663300"><code>BIT(31)</code></font> are
        seldom if ever used.</li>
      <li>The storage format of <font color="#663300"><code>BIT(32)</code></font>
        is identical to <font color="#663300"><code>FIXED</code></font>,
        so no conversion is needed.</li>
      <li><font color="#663300"><code>FIXED</code></font> is
        automatically down-converted to <font color="#663300"><code>BIT(1)</code></font>
        through <font color="#663300"><code>BIT(31)</code></font> by
        truncating the most-significant 0, 16, or 24 bits.<br>
      </li>
      <li><font color="#663300"><code>FIXED</code></font> (or <font
          color="#663300"><code>BIT</code></font> up-converted to <font
          color="#663300"><code>FIXED</code></font>) can be
        automatically converted to a <font color="#663300"><code>CHARACTER</code></font>
        representation of a decimal number.&nbsp; For example, 12345 →
        '12345'.&nbsp; (Note that there is no automated conversion in
        the reverse direction.)</li>
    </ul>
    <p>The final conversion just mentioned, conversion of integer
      datatypes to decimal-string representations, is quite problematic,
      because it is entirely ambiguous as to what the appropriate
      conversion may be.&nbsp; The usual usages are something like the
      following:<br>
    </p>
    <blockquote>
      <pre>DECLARE I INTEGER, C CHARACTER;<br>⋮<br>C = I;<br>OUTPUT = 'THE VALUE IS' || I;<br></pre>
    </blockquote>
    <p>I.e., assigning an integer value to a string variable, or
      concatenating an integer value with a string value.&nbsp;
      Autoconversion seems logical and sensible at first glance,
      particularly in string concatenation.<br>
    </p>
    <p>Looking deeper, however, <a moz-do-not-send="true"
        href="#datatypes">recall</a> that <font color="#663300"><code>CHARACTER</code></font>
      values are passed around in the form of so-called <i>string
        descriptors</i>, which are themselves indistinguishable from <font
        color="#663300"><code>FIXED</code></font>.&nbsp; Thus in <font
        color="#663300"><code>C=I</code></font>, should the integer <font
        color="#663300"><code>I</code></font> be converted to a string
      and assigned to <font color="#663300"><code>C</code></font>, or
      should it be treated as a string descriptor and the string it
      points to be assigned to <font color="#663300"><code>C</code></font>
      instead?&nbsp; There's literally no way for the compiler to know
      for sure what was intended by the programmer.&nbsp; <b>XCOM-I</b>
      makes an attempt to guess which is appropriate, and I assume so
      did the original XPL/I compiler.&nbsp; But the rules to be used
      are undocumented, and the two compilers <i>sometimes</i>
      disagree.<br>
    </p>
    <p>In cases of disagreement between the intention of the programmer
      and the guess of the compiler, there's a built-in function (<font
        color="#663300"><code>STRING</code></font>) that can be used to
      communicate the programmer's intention to the compiler.&nbsp; As
      near as I can tell (with <i>A Compiler Generator</i>, perhaps no
      longer shockingly to us, being unclear about it), <font
        color="#663300"><code>STRING(I)</code></font> would tell the
      compiler to treat <font color="#663300"><code>I</code></font> as
      a string descriptor, while <font color="#663300"><code>STRING(C)</code></font>
      might tell it to treat the string descriptor of <font
        color="#663300"><code>C</code></font> as if it were an
      integer.&nbsp; Thus judicious use of <font color="#663300"><code>STRING</code></font>
      can be used to override the compiler's guesses as to where
      automatic conversions are needed.&nbsp; Unfortunately, at present,
      there are some (though fortunately very few) cases in which <b>XCOM-I</b>
      would require the use of <font color="#663300"><code>STRING</code></font>
      while the original XPL/I compiler did not, or vice-versa.&nbsp; In
      these cases, the only recourse at present is to insert and extra <font
        color="#663300"><code>STRING</code></font> (or to remove one)
      from XPL source code, which in my world-view is a very undesirable
      thing to do in legacy XPL source code such as that of HAL/S-FC.<br>
    </p>
    <h2> <a name="basedManagement"></a>XPL/I ARRAY and BASED Data ...
      and an Exception<br>
    </h2>
    XPL/I provides a separate kind of statement which can declare
    arrays, which syntactically differs only in that the keyword <font
      color="#663300"><code>ARRAY</code></font> is used in place of the
    keyword <font color="#663300"><code>DECLARE</code></font>, and in
    that it can only be used for arrays of <font color="#663300"><code>FIXED</code></font>
    or <font color="#663300"><code>BIT</code></font>, and not for <font
      color="#663300"><code>CHARACTER</code></font>.<br>
    <blockquote><font size="-1"><b>Aside:</b> For the original XPL/I
        compiler, there was a distinction in the way <font
          color="#663300"><code>ARRAY</code></font> variables were
        stored in memory vs <font color="#663300"><code>DECLARE</code></font>
        array variables.&nbsp; The distinction was that a pointer was
        stored in the variable and the data for the array was stored
        elsewhere, much as a string descriptor is used for character
        values.&nbsp; That was apparently a trick get around limitations
        on IBM 360 memory-segment sizes.&nbsp; At the present time, I
        don't see this distinction as being operationally significant,
        so <b>XCOM-I</b> treats the two keywords identically.&nbsp;
        This is subject to change, if I discover my thinking was in
        error.&nbsp; As, unfortunately, I often do. </font><br>
    </blockquote>
    More significantly, XPL/I adds an additional kind of datatype that
    it calls a <font color="#663300"><code>BASED</code></font>
    variable.&nbsp; These are basically <i>pointers</i> to arrays of <font
      color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>,
    or <font color="#663300"><code>CHARACTER</code></font>.&nbsp; Note
    that I said "pointers to arrays" rather than "arrays of
    pointers".&nbsp; By changing the address stored in the <font
      color="#663300"><code>BASED</code></font> variable's pointer, you
    can instantly interpret an entirely different chunk of memory as the
    array.&nbsp; Moreover, besides the basic types just mentioned, the <font
      color="#663300"><code>BASED</code></font> variable can point to an
    array of "records", where each "record" is a collection of the basic
    datatypes.&nbsp; I.e., a record can hold any combination of <font
      color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>,
    or <font color="#663300"><code>CHARACTER</code></font> fields, or
    arrays thereof.&nbsp; Using the <font color="#663300"><code>BASED</code></font>
    mechanism, XPL/I can thus mimic both pointers <i>and</i> primitive
    types of structures, neither of which is available in XPL
    proper.&nbsp; I say that the structures are "primitive", because <font
      color="#663300"><code>BASED</code></font> variables cannot
    themselves be fields of <font color="#663300"><code>BASED</code></font>
    variables, hence only structures that are a single-level deep are
    available.&nbsp; <br>
    <br>
    Here are a couple of examples of declarations of <font
      color="#663300"><code>BASED</code></font> variables:<br>
    <blockquote>
      <pre><font color="#663300">BASED FB FIXED;<br>BASED RB RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(10) BIT(5),<br>END;</font><br></pre>
    </blockquote>
    Although <font color="#663300"><code>BASED</code></font> variables
    are always (or almost always) arrays, you'll note that the
    declarations of <font color="#663300"><code>FB</code></font> and <font
      color="#663300"><code>RB</code></font> don't indicate any
    dimensional information.&nbsp; That's because no memory for them,
    other than for the pointer, is allocated at compile-time.&nbsp;
    Space is instead explicitly allocated at runtime by user code.&nbsp;
    Thus <b>XCOM-I</b> has knowledge of the <i>size</i> of each array
    entry, but not of the <i>number of elements</i> in the array.&nbsp;
    <br>
    <blockquote>
      <div align="center"><b> <font size="-1"><a name="DopeVectors"></a>"Dope










            Vectors"<br>
            <br>
          </font></b></div>
      <font size="-1">When I said that a <font color="#663300"><code>BASED</code></font>
        is a "pointer to an array", I was glossing over the fact that to
        be useful a <font color="#663300"><code>BASED</code></font>
        must track a lot more information about the <font
          color="#663300"><code>BASED</code></font> than just its data's
        location in memory.&nbsp; In fact, a <font color="#663300"><code>BASED</code></font>
        is stored as a 28-byte structure <i>plus</i> the
        separately-positioned data for the array.&nbsp; The 28-byte
        structure is referred to as a "dope vector". &nbsp; In other
        words, if you had a <font color="#663300"><code>BASED</code></font>
        called (say) <font color="#663300"><code>MYBASED</code></font>
        and you executed the built-in function <font color="#663300"><code>ADDR(MYBASED)</code></font>,
        it would return the address of the dope vector for <font
          color="#663300"><code>MYBASED</code></font>.&nbsp; As usual,
        the <b>HAL/S-FC</b> documentation and source code do not
        actually provide any useful facts about this setup, but various
        factoids can be inferred from <b>HAL/S-FC</b> source code, to a
        greater or lesser degree of confidence, and here are my feeble
        inferences about the fields of dope vectors.&nbsp; The fields
        with <font color="#009900">green</font> highlighting are those
        of conceivable interest to an application programmer, though all
        of them are managed entirely transparently in most cases.<br>
      </font>
      <ol>
      </ol>
      <ul>
        <li><font size="-1" color="#009900"><font color="#663300"><font
                color="#000000">Offset 0:&nbsp; </font><code>FIXED</code></font>
            pointer giving the address of the actual data.</font></li>
        <li><font size="-1" color="#009900"><font color="#663300"><font
                size="-1" color="#009900"><font color="#663300"><font
                    color="#000000">Offset 4:&nbsp; </font></font></font><code>BIT(16)</code></font>
            giving the size in bytes of each record.</font></li>
        <li><font size="-1" color="#009900"><font color="#663300"><font
                size="-1" color="#009900"><font color="#663300"><font
                    size="-1" color="#009900"><font color="#663300"><font
                        color="#000000">Offset 6:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font
            size="-1"> <font color="#009900">gives the number of <font
                color="#663300"><code>CHARACTER</code></font> or <font
                color="#663300"><code>BIT(≥32)</code></font> fields in
              each <font color="#663300"><code>BASED RECORD</code></font>,
              or 1 if it's a <font color="#663300"><code>BASED
                  CHARACTER</code></font> or <font color="#663300"><code>BASED










                </code><code>BIT(≥32)</code></font>, or 0 otherwise. The
              point is that it's the number of "string descriptors"
              associated with each element of the <font color="#663300"><code>BASED</code></font>
              array. This information is used by </font><font
              color="#663300"><code>COMPACTIFY</code></font>. (<a
              moz-do-not-send="true" href="#compactify">See below</a>.)
            While I don't fully understand the calculations being
            performed, I'd venture the opinion that for <font
              color="#663300"><code>COMPACTIFY</code></font> to use this
            information efficiently, it's necessary for the XPL/I
            compiler to rearrange the fields of <font color="#009900"><font
                color="#663300"><code>BASED RECORD</code></font></font>
            from their declared order in such a way that all of
            string-descriptor fields come first in the record. <b>XCOM-I</b>
            does indeed perform this rearrangement.<br>
          </font></li>
        <li><font size="-1" color="#009900"><font color="#009900"><font
                color="#663300"><font size="-1" color="#009900"><font
                    color="#663300"><font size="-1" color="#009900"><font
                        color="#663300"><font color="#000000">Offset
                          8:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font>
            giving the total number of array entries for which space has
            been <i>allocated</i>.</font></li>
        <li><font size="-1" color="#009900"><font color="#009900"><font
                color="#663300"><font size="-1" color="#009900"><font
                    color="#663300"><font size="-1" color="#009900"><font
                        color="#663300"><font color="#000000">Offset
                          12:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font>
            giving the total number of array entries actually <i>used</i>
            so far.</font></li>
        <li><font size="-1" color="#009900"><font color="#009900"><font
                color="#663300"><font size="-1" color="#009900"><font
                    color="#663300"><font size="-1" color="#009900"><font
                        color="#663300"><font color="#000000">Offset
                          16:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font></font><font
            size="-1">.&nbsp; The dope vectors for all <font
              color="#663300"><code>BASED</code></font> variables for
            which memory has been allocated form a linked list.&nbsp;
            The global variable <font color="#663300"><code>FIRSTRECORD</code></font>
            gives the address of the first dope vector on the list, and
            this field at offset 16 in the dope vector points to the
            next dope vector, or 0 if there is no next one (or if space
            hasn't been allocated).&nbsp; The ordering is TBD, since I
            haven't traced through the code in all of its gory detail,
            but I believe they are ordered according to <i>decreasing</i>
            address fields (i.e., the field at offset 0), which at least
            initially is also the order in which the <font
              color="#663300"><code>RECORD_CONST</code></font> or <font
              color="#663300"><code>ALLOCATE_SPACE</code></font> macros
            (see below) were executed to allocate memory for them.<br>
          </font></li>
        <li><font size="-1" color="#009900"><font color="#663300"><font
                size="-1" color="#009900"><font color="#663300"><font
                    size="-1" color="#009900"><font color="#663300"><font
                        color="#000000">Offset 20:&nbsp; </font></font></font></font></font><code>FIXED</code></font></font><font
            size="-1">. It appears to me that this field supplies some
            properties of the <font color="#663300"><code>BASED</code></font>
            in the form of bit fields. It is laid out as follows:</font></li>
        <ul>
          <li><font size="-1">Bit 24 indicates the <font
                color="#663300"><code>BASED</code></font> is "constant",
              which appears to mean that you cannot incrementally grow
              it. (The macro <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font>
              is used to increase the size of the specified <font
                color="#663300"><code><i>based</i></code></font> by 1
              record, an operation which fails if the <font
                color="#663300"><code><i>based</i></code></font> is
              "constant".)</font></li>
          <li><font size="-1">Bit 25 indicates the <font
                color="#663300"><code>BASED</code></font> is
              "unmoveable". If a <font color="#663300"><code><i>based</i></code></font>
              is "unmovable", it means that an operation like <font
                color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font>
              (see above) will succeed only if there is enough free
              space immediately following the allocated memory that can
              be "stolen". Whereas if it's not unmovable, then the <font
                color="#663300"><code><i>based</i></code></font> may
              migrate in its entirety to a newly-allocated block
              elsewhere and the space it originally occupied may thus be
              freed.</font></li>
        </ul>
        <li><font size="-1" color="#009900"><font color="#663300"><font
                size="-1" color="#009900"><font color="#663300"><font
                    size="-1" color="#009900"><font color="#663300"><font
                        color="#000000">Offset 24:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font
            size="-1"> of purpose TBD. It is referred to as "global
            factor".</font></li>
        <li><font size="-1" color="#009900"><font color="#663300"><font
                size="-1" color="#009900"><font color="#663300"><font
                    size="-1" color="#009900"><font color="#663300"><font
                        color="#000000">Offset 26:&nbsp; </font></font></font></font></font><code>BIT(16)</code></font></font><font
            size="-1"> is referred to as "group factor". As far as I can
            see, all uses of this are commented out in <b>HAL/S-FC</b>,
            so perhaps it ended up being unused.<br>
          </font></li>
      </ul>
      <ol>
      </ol>
      <font size="-1"> The <b>XCOM-I</b> implementation mimics this
        dope-vector structure, though only the fields I've highlighted
        in <font color="#009900">green</font> are significant in <b>XCOM-I</b>
        ... which is fortunate, since they're the only ones I imagine I
        understand somewhat.<br>
        <br>
        With that discussion in mind, in understanding some of the
        things that need to happen with <font color="#663300"><code>BASED</code></font>
        variables in actual XPL/I source code (and in particular, in <b>HAL/S-FC</b>),










        let's consider various space-management macros and/or procedures
        used:<br>
      </font>
      <ul>
        <li><font size="-1" color="#663300"><code>RECORD_ALLOC(<i>based</i>)</code></font><font
            size="-1">, used in expressions, returns the number of
            records allocated in <font color="#663300"><code>BASED</code></font>
            variable <font color="#663300"><code><i>based</i></code></font>.</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_USED(<i>based</i>)</code></font><font
            size="-1">, normally used on the left-hand-side in
            assignments, sets the number of records used so far in
            based. Its most-common usage is <font color="#663300"><code>RECORD_USED(<i>based</i>)=RECORD_ALLOC(<i>based</i>)</code></font>,
            but it can also be used with something other than that on
            the right-hand side to truncate the array or to skip past
            the lowest indexes. And it can be used in expressions or
            conditionals, though that happens relatively seldom.</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_TOP(<i>based</i>)</code></font><font
            size="-1">, as you might expect, simply returns <font
              color="#663300"><code>RECORD_USED(<i>based</i>)-1</code></font>.&nbsp;








            I.e., the highest allowed index into the array.<br>
          </font></li>
        <li><font size="-1" color="#663300"><code>ALLOCATE_SPACE(<i>based</i>,
              <i>top</i>)</code></font><font size="-1"> allocates enough
            space for <i><font color="#663300"><code>based</code></font></i>
            to insure that it contains at least <font color="#663300"><code><i>top</i>+1</code></font>
            records in total. It will fail if we already have <font
              color="#663300"><code>RECORD_ALLOC(<i>based</i>)&gt;0</code></font>.</font></li>
        <li><font size="-1" color="#663300"><code>NEXT_ELEMENT(based)</code></font><font
            size="-1"> increments <font color="#663300"><code>RECORD_USED(<i>based</i>)</code></font>
            by 1, stealing the space from adjacent free memory or else
            reallocating and moving the entire array if necessary to do
            so. This can only be used if space for <font
              color="#663300"><code><i>based</i></code></font> had been
            allocated by <font color="#663300"><code>ALLOCATE_SPACE</code></font>,
            and will instead cause an abend if <font color="#663300"><code><i>based</i></code></font>
            had been allocated by <font color="#663300"><code>RECORD_CONSTANT</code></font>
            (see below).</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_FREE(based)</code></font><font
            size="-1"> frees the data for <i><font color="#663300"><code>based</code></font></i>,
            returning the allocated space to the free pool.</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_SEAL(<i>based</i>)</code>,
            <code>RECORD_UNSEAL(<i>based</i>)</code></font><font
            size="-1">: Enables or disables the "constant" attribute of
            the <i><font color="#663300"><code>based</code></font></i>.</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_CONSTANT(<i>based</i>,
              <i>top</i>, <i>moveable</i>)</code></font><font size="-1">
            Like <font color="#663300"><code>ALLOCATE_SPACE(<i>based</i>,
                <i>top</i>)</code></font>, but additionally enables the
            "constant" property, and optionally enables the "unmovable"
            property.</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_WIDTH(based)</code></font><font
            size="-1"> returns the record width of the <i><font
                color="#663300"><code>based</code></font></i>.</font></li>
        <li><font size="-1" color="#663300"><code>RECORD_LINK()</code></font><font
            size="-1"> prepares the data for transferring <font
              color="#663300"><code>COMMON</code></font> memory to the
            next program loaded.</font></li>
      </ul>
      <font size="-1"> </font> </blockquote>
    User code that initially allocates free memory — let's say 25
    records to start with — for a <font color="#663300"><code>BASED</code></font>
    variable is <i>typically</i> a two-step process that looks
    something like this:<br>
    <blockquote>
      <pre><font color="#663300">BASED MYVARIABLE FIXED;<br>...<br>RECORD_CONSTANT(MYVARIABLE, 25, MOVEABLE); /* OR UNMOVEABLE */<br>RECORD_USED(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>) = RECORD_ALLOC(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>);</font><br></pre>
    </blockquote>
    Or, if you knew that you were going to need more elements later, you
    might allocate a bit extra, for example:<br>
    <blockquote>
      <pre><font color="#663300">BASED MYBASED FIXED;<br>...<br>ALLOCATE_SPACE(</font><font color="#663300"><font color="#663300">MYBASED</font>, 30);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYBASED</font></font>) = 25;</font></pre>
    </blockquote>
    Having allocated the space for it, you can now use <font
      color="#663300"><code>MYBASED</code></font> just like any other
    array of <font color="#663300"><code>FIXED</code></font>, such as
    in assignments like "<font color="#663300"><code><font
          color="#663300"><code>MYBASED</code></font>(27) = 6;</code></font>"
    or "<font color="#663300"><code>X = </code></font><font
      color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(N)










        + 12;</code></font>".&nbsp; <br>
    <br>
    To actually increase the number of elements later, you'd do
    something like this:<br>
    <blockquote>
      <pre><font color="#663300">NEXT_RECORD(MYBASED);</font><br></pre>
    </blockquote>
    This will increment <font color="#663300"><code>RECORD_USED(MYBASED)</code></font>
    by 1 — if possible while still keeping it below <font
      color="#663300"><code>RECORD_ALLOC(MYBASED)</code></font> — or
    else will reallocate and possibly move <font color="#663300"><code>MYBASED</code></font>
    into a larger space, if possible.<br>
    <br>
    In a more-complex case, we might have a <font color="#663300"><code>BASED










        RECORD</code></font> variable:<br>
    <blockquote>
      <pre><font color="#663300">BASED MYNEWBASED RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(9) FIXED,<br>END;<br>...<br>RECORD_CONSTANT(</font><font color="#663300"><font color="#663300">MYNEWBASED</font>, 30, MOVEABLE);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYNEWBASED</font></font>) = 25;</font></pre>
    </blockquote>
    Accessing <font color="#663300"><code>MYNEWBASE</code></font>
    requires the dotted style often used these days for accessing fields
    of structures or classes.&nbsp; Some examples include:<br>
    <blockquote>
      <pre><font color="#663300">MYNEWBASED(6).F = 12;<br>MYNEWBASED(10).C = 'XPL is where it is at!';<br>MYNEWBASED(20).A(6) = 15;<br>X = MYNEWBASED(6).F;</font><br></pre>
    </blockquote>
    and so on.<br>
    <div align="center"><b><font size="-1">The Exception<br>
        </font></b></div>
    <blockquote><font size="-1">There is one — count 'em, <i>one</i>! —
        exception I've found to the <i>somewhat-documented</i> behavior
        I've described above.&nbsp; This undocumented use is seen in the
        <font color="#663300"><code>IND_STACK</code></font> variable
        found in <b>PASS2</b> of <b>HAL/S-FC</b>.&nbsp; </font><font
        size="-1"><font size="-1"><font color="#663300"><code>IND_STACK</code></font></font>
        is declared using the following bastardized mash-up of a <font
          color="#663300"><code>DECLARE</code></font> statement and a <font
          color="#663300"><code>BASED</code></font> statement:<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#663300">   DECLARE IND_STACK(STACK_SIZE) RECORD:<br>         I_CONST        FIXED,<br>         I_INX_CON      FIXED, <br>         I_STRUCT_CON   FIXED,<br>         ...<br>         I_LIVREMT      BIT(8),<br>         I_NAMEVAR      BIT(8),<br>         I_STRUCT_WALK  BIT(8),<br>         I_AIADONE      BIT(8),<br>      END;</font><br></pre>
      </blockquote>
      <font size="-1">Unlike a </font><font size="-1"><font size="-1"><font
            color="#663300"><code>BASED</code></font></font>
        declaration, in which specifying an array size at compile time
        is illegal, or as IR-182-1 states, "ignored if present", the
        array size is indeed found in this declaration.&nbsp; Nor is
        there any runtime adjustment to the size, as would be expected
        with a </font><font size="-1"><font size="-1"><font size="-1"><font
              color="#663300"><code>BASED</code></font></font></font>.&nbsp;










        Nonetheless, </font><font size="-1"><font size="-1"><font
            size="-1"><font color="#663300"><code>IND_STACK</code></font></font></font>
        is subsequently accessed by the dotted, structure-type notation
        used only by </font><font size="-1"><font size="-1"><font
            color="#663300"><code>BASED</code></font></font> variables.
        <br>
        <br>
        Rather than implement an entirely new but undocumented class of
        structure objects to handle this single instance, <b>XCOM-I</b>
        implements this case as if it were a </font><font size="-1"><font
          size="-1"><font color="#663300"><code>BASED</code></font></font>
        declaration followed by an appropriate <font color="#663300"><code>RECORD_CONSTANT</code></font>
        operation.&nbsp; </font><font size="-1"><font size="-1"><font
            color="#663300"><code>IND_STACK</code></font></font> is one
        of the very few objects stored in <a moz-do-not-send="true"
          href="#MemoryModel">region 7 of the XPL memory model</a>, and
        by far the largest of them.<br>
      </font></blockquote>
    <h2>LITERALLY and Macros</h2>
    Another attribute that can appear in <font color="#663300"><code>DECLARE</code></font>
    statements is the <font color="#663300"><code>LITERALLY</code></font>
    attribute.&nbsp; Here's an example:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE ARRAYTOP LITERALLY '255';<br>DECLARE MYARRAY(ARRAYTOP) FIXED;</font><br></pre>
    </blockquote>
    Notice that <font color="#663300"><code>ARRAYTOP</code></font> has
    no datatype assigned to it.&nbsp; That's because its declaration is
    not actually the declaration of a variable called "ARRAYTOP", but
    rather of a macro of that name.&nbsp; Wherever the identifier <font
      color="#663300"><code>ARRAYTOP</code></font> is encountered
    subsequently, it's simply replaced literally by the string <font
      color="#663300"><code>255</code></font>, now unquoted:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE MYARRAY(255) FIXED;</font><br></pre>
    </blockquote>
    This clarifies an example of a commonly-desirable declaration I
    mentioned earlier, which in this section would be expressed as:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE RECSIZE LITERALLY '3600';<br>DECLARE BUFFER(RECSIZE-1) BIT(8);</font><br></pre>
    </blockquote>
    As noted earlier, <i>standard</i> XPL's grammar wouldn't allow an
    expression (like <font color="#663300"><code>RECSIZE-1</code></font>)
    in the context of an array declaration, so the convenience of
    (compile-time computable) expressions in declarations is only
    available in XPL/I.<br>
    <br>
    Macro expansions — not macro <i>declarations</i> (I hope!) — can be
    nested, so you can do things like this if you want:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE DEVICE LITERALLY '6', OUT LITERALLY 'OUTPUT(DEVICE)';<br>OUT = 'My message';</font><br></pre>
    </blockquote>
    This expands to<br>
    <blockquote>
      <pre><font color="#663300">OUTPUT(6) = 'My message';</font><br></pre>
    </blockquote>
    Macros can expand to portions of statements, as the ones above have,
    or to multiple statements, such as<br>
    <blockquote>
      <pre><font color="#663300">DECLARE MYBLOCK LITERALLY 'DO; X=1; Y=X+3; END';<br>...<br>IF X=7 THEN;<br>    MYBLOCK;</font><br></pre>
    </blockquote>
    which expands to:<br>
    <blockquote>
      <pre><font color="#663300">IF X=7 THEN;<br>    DO; X=1; Y=X+3; END;</font><br></pre>
    </blockquote>
    Macros can also have arguments.&nbsp; Consider the following:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE MYMAC(2) LITERALLY '%1% = %2%';</font><br></pre>
    </blockquote>
    This declaration means that <font color="#663300"><code>MYMAC</code></font>
    has 2 arguments, and that when the macro is expanded, the first
    argument will replace <font color="#663300"><code>%1%</code></font>
    and the second argument will replace <font color="#663300"><code>%2%</code></font>.&nbsp;










    Thus "<font color="#663300"><code>MYMAC(X, 3 * Y)</code></font>"
    expands to "<font color="#663300"><code>X = 3 * Y</code></font>".<br>
    <blockquote><font size="-1"><b>Warning:</b>&nbsp; As with macros in
        any other computer language, this can quickly get out of
        hand.&nbsp; <b>XCOM-I</b>, for example, won't detect recursive,
        endlessly-expanding macros.&nbsp; There's also no guarantee when
        multiple macros are in play that <b>XCOM-I</b> will necessarily
        expand macros in the same order that <b>XCOM<i>x</i></b> would
        have.&nbsp; Neither <i>A Compiler Generator</i> nor
        Intermetrics documentation makes any mention of what that
        ordering should be.<br>
        <br>
        <b>Warning:</b>&nbsp; The scope of macro definitions is also
        different in XPL vs XPL/I.&nbsp; In XPL, macro definitions don't
        respect any nested scopes they appear in; i.e., any macro
        definition will simply remain in effect until the end of the
        source code.&nbsp; In XPL/I, macro definitions remain in effect
        only until the end of the procedure in which they're defined,
        including embedded procedures.&nbsp; In neither case does a
        macro definition have any effect on source code prior to
        it.&nbsp; <b>XCOM-I</b> uses the XPL/I scoping convention, even
        when the command-line switch --xpl is used, and thus is not
        compatible with standard XPL in this respect.&nbsp; I've so far
        found no instance in legacy XPL code in which this caused any
        problem.<br>
      </font></blockquote>
    <h2>Perplexing Multiple Assignments</h2>
    <p>XPL allows multiple variables to be assigned the same value in a
      single assignment statement, with a syntax like:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">X1, X2, ..., XN = Y;</font><br></pre>
    </blockquote>
    <p>According to <i>A Compiler Generator</i> (p. 137), these
      assignments are performed in right-to-left order.&nbsp; In other
      words, it <i>should</i> be equivalent to:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">XN = Y;<br>.<br>.<br>.<br>X1 = Y;</font><br></pre>
    </blockquote>
    <p>In most cases, the ordering of these assignments is of no
      significance, and in fact I've found no legacy <i>standard</i>
      XPL programs in which the ordering matters.&nbsp; However, there
      are instances in XPL/I code, specifically in <b>PASS1</b> of <b>HAL/S-FC</b>
      in which the order matters a lot.&nbsp; That's when you have
      assignments of the form:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">Y(I), I = J;</font><br></pre>
    </blockquote>
    <p>because obviously<br>
    </p>
    <blockquote>
      <pre><font color="#663300">I = J;<br>Y(I) = J;</font><br></pre>
    </blockquote>
    <p>is a lot different than<br>
    </p>
    <blockquote>
      <pre><font color="#663300">Y(I) = J;<br>I = J;</font><br></pre>
    </blockquote>
    <p><i>Unfortunately</i>, in the cases I've encountered, the XPL/I
      code seems to rely on the latter interpretation.&nbsp; I.e., it
      seems to believe that the assignments are performed in
      left-to-right order, in direct contradiction to <i>A Compiler
        Generator</i>.&nbsp; What's going on here?<br>
    </p>
    <p>Of course, we have no way of knowing what Intermetrics <b>XCOM</b>
      did with this, but as far as <i>A Compiler Generator</i>'s <b>XCOM3</b>,
      it appears (thanks to Dan Weaver for this explanation) that while
      the assignments are indeed performed in a right-to-left manner as
      documented, the peculiarities of the IBM 360 object-code
      generation in <b>XCOM3</b>, shove the index <font
        color="#663300"><code>I</code></font> into a CPU register and
      reuse it without change throughout both assignments.&nbsp; So
      seemingly by accident, the net result is that the assignments <i>appear</i>
      to have been done in a left-to-right order.&nbsp; I would also
      note that there is an example in <i>A Compiler Generator</i>
      (Fig. 6.18.1) that shows assembly code generated for the XPL
      expression<br>
    </p>
    <blockquote>
      <pre><font color="#663300">I, J, K = 2;</font><br></pre>
    </blockquote>
    <p> </p>
    <p>which supports the documented right-to-left order, namely,<br>
    </p>
    <blockquote>
      <pre><font color="#663300">LA	1,2(0,0)	[This gets a 2]<br>STC	1,1346(0,11)	[This sticks it into K]<br>STH	1,1344(0,11)	[This sticks it into J]<br>ST	1,1340(0,11)	[This sticks it into I]</font><br></pre>
    </blockquote>
    <p><i>Vis-à-vis</i> Dan's explanation, it doesn't appear to me to be
      a reliable design choice in <b>XCOM<i>x</i></b>:&nbsp; what if
      there are more than 2 assignments on the left-hand side, and if
      they don't all use the same index <font color="#663300"><code>I</code></font>?&nbsp;










      What would the order appear to be then?&nbsp; Well, perhaps <b>XCOM<i>x</i></b>
      does something else in that situation.<br>
    </p>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; When I wrote this,
        perhaps I didn't have a working <b>XCOM3</b> yet, or perhaps it
        did not occur to me that I could just use <b>XCOM3</b> and
        compile any test cases I like, so that I could see what the
        assembly code did.&nbsp; Well, I realize it now.&nbsp; I still
        haven't done it, but perhaps I should.&nbsp; Some day.</font><br>
    </blockquote>
    <p> </p>
    <p>To sum it all up:<br>
    </p>
    <blockquote><font size="-1"><b>Important Note</b>:&nbsp; <b>XCOM-I</b>
        <i>ignores</i> the statement in <i>A Compiler Generator</i>
        that assignments are performed in a right-to-left manner.&nbsp;
        Rather, it performs them in a left-to-right manner, and any
        indices of arrays are computed at the moment the assignment is
        performed.&nbsp; I'm keeping my fingers crossed that this
        doesn't explode in my face.&nbsp; If it does, I would be tempted
        to just fix the XPL source code that was doing it, rather than
        to fix <b>XCOM-I</b>.&nbsp; We'll see.</font><br>
    </blockquote>
    <h2>Logical Expressions</h2>
    <p>XPL's logical operators are <font color="#663300"><code>&amp;</code></font>,
      <font color="#663300"><code>|</code></font>, and <font
        color="#663300"><code>~</code></font> (<font color="#663300"><code>¬</code></font>,
      <font color="#663300"><code>^</code></font>), for "and", "or", and
      "not", respectively. The documentation in <i>A Compiler Generator</i>
      is maddeningly unclear as to what these operators do. True, table
      6.8.1 calls them "logical and", "logical or", and "logical
      complement", but the word "logical" isn't defined ... just as my
      sloppy usage of the word "logical" at the beginning of this
      paragraph makes no distinction. Which leaves open a few loopholes
      that have to be closed up. The issues which we must understand
      are:<br>
    </p>
    <ul>
      <li>Are these operations bitwise or narrowly "logical". I.e., do
        they operate in parallel on each bit position in a numerical
        value, or do they simply produce bipolar results of 1 (true) or
        0 (false)?</li>
      <li>Do these operations short circuit? E.g., if we have an
        expression of the form (say) <font color="#663300"><code><i>expression1</i>&amp;<i>expression2</i></code></font>,
        and <i><font color="#663300"><code>expression1</code></font></i>
        evaluates to 0, is <i><font color="#663300"><code>expression2</code></font></i>
        even evaluated?</li>
    </ul>
    <p>In case you're not in the mood for a technical discussion of the
      matter, I'll give you the short answer up front, and having read
      that, you can either bypass or proceed to the long discussion
      according to your desires:<br>
    </p>
    <ul>
      <li>The logical operations are indeed bitwise.</li>
      <li>The preponderance of evidence is that <b>XCOM<i>x</i></b> did
        not short circuit. <b>XCOM-I</b> does not at present attempt
        any short-circuiting.<br>
      </li>
    </ul>
    <p>As for how I came up with this "information", there are several
      places we can look for guidance in guessing the answers. For one
      thing, according to <i>A Compiler Generator</i>'s account, the
      XPL language was derived from the PL/I language, so we can look at
      PL/I documentation and hope that it applies to XPL. Of course, we
      can look at the source code for <i>A Compiler Generator</i>'s XPL
      compiler (<b>XCOM3</b>) as listed in the book, and see if there
      are any hints there. Or we can even examine the IBM 360 object
      code that <b>XCOM<i>x</i></b> generates for these operators. (All
      the while wondering how things came to this, that we have to
      resort to lame measures like consulting object code to figure out
      the basic features of the language?)<br>
    </p>
    <p>As far as PL/I is concerned, <a moz-do-not-send="true"
href="https://www.ibm.com/docs/en/SSY2V3_5.1.0/com.ibm.ent.pl1.zos.doc/lrm.pdf">IBM's










        PL/I Language Reference</a> (2017) tells us on p. 66 that for
      the <font color="#663300"><code>&amp;</code></font>, <font
        color="#663300"><code>|</code></font>, and <font
        color="#663300"><code>¬</code></font> operators, "bit operations
      are performed on a bit-by-bit basis". As far as object code
      produced by <b>XCOM</b> is concerned, <i>A Compiler Generator</i>
      (p. 150) shows an example in which object code for the expression
      "<font color="#663300"><code>SHL(K,1) &amp; SHR(I,J)</code></font>"
      is produced, and we do find that it simply uses the IBM 360 <font
        color="#663300"><code>NR</code></font> ("And Logical")
      instruction:<br>
    </p>
    <blockquote>
      <p align="left"><img moz-do-not-send="true" src="shortCircuit.jpg"
          alt="" width="768" height="123"></p>
    </blockquote>
    <p>Although I had to consult more than one IBM assembly-language
      manual to find the answer to the seemingly-simple question of what
      <font color="#663300"><code>NR</code></font> does, <a
        moz-do-not-send="true"
href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf">IBM's










        z/Architecture Principles of Operation</a> (p. A-8) does tell us
      that the <font color="#663300"><code>NR</code></font> (and its
      cousins <font color="#663300"><code>N</code></font>, <font
        color="#663300"><code>NC</code></font>, and <font
        color="#663300"><code>NI</code></font>) are indeed bitwise
      operations.<br>
    </p>
    <blockquote><font size="-1"><b>Aside:</b> <a moz-do-not-send="true"
href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf#page=940">Figure










          B-2, "Instructions Arranged by Mnemonic"</a> of the latter
        document is very helpful in trying to decipher such listings of
        IBM 360 object code.<br>
      </font></blockquote>
    <p>Short-circuiting is a natural consideration for strictly bipolar
      operands and operators, but is a bit trickier to consider once
      we've concluded that the logical operators operate bitwise rather
      than in a bipolar fashion. Certainly the object-code example from
      <i>A Compiler Generator</i> that was mentioned in the preceding
      paragraph shows no signs at all of short circuiting: Both of the
      operands of the <font color="#663300"><code>&amp;</code></font>
      operator in that example are evaluated, with no attempt at
      checking the value of the first operation before proceeding to the
      second one. On the other hand, that example of object-code
      generation by <b>XCOM<i>x</i></b> happens to be for an assignment
      statement rather than for the conditional expression of an <font
        color="#663300"><code>IF</code></font>, <font color="#663300"><code>DO










          WHILE</code></font>, or <font color="#663300"><code>DO UNTIL</code></font>.
      Perhaps the evaluation of a conditional expression might be very
      different in those contexts. One reason to believe that it might
      be different is that the final result of a conditional expression
      is masked to just the least-significant bit, and thus (eventually)
      is indeed a bipolar value; i.e., even if all of the bits were
      involved in the computation, all but one of them is discarded in
      the end, so perhaps the extra bits are discarded at the beginning
      rather than at the end of the computation, even though it's more
      work to do so. Moreover, the PL/I Language Reference document
      mentioned earlier does cover short-circuit evaluation (see p.
      245), and it says that short-circuiting is <i>only</i> in the
      context of the conditional of an <font color="#663300"><code>IF</code></font>
      statement (versus assignment statements). Plus, even then the
      short-circuiting occurs only in certain special circumstances,
      such as the leading operand being a <font color="#663300"><code>BIT(1)</code></font>
      literal or constant variable, which leads one to believe that the
      value of the leading operand has to be determined to be 0 or 1 at
      compile-time rather than at run-time for the short-circuiting to
      occur.<br>
    </p>
    <p>Unfortunately, the example of object-code generation in <i>A
        Compiler Generator</i> doesn't show us how an <font
        color="#663300"><code>IF</code></font> statement would compile.
      But <a moz-do-not-send="true" href="#compilingXCOM">as we saw
        earlier</a>, we have been able to use <b>XCOM-I</b> to create a
      working copy of <i>A Compiler Generators</i>'s <b>XCOM3</b>, so
      we can make our own example of <font color="#663300"><code>IF</code></font>,
      compile it with <b>XCOM3</b> and see! Imagine we have the
      following ridiculous little XPL program:<br>
    </p>
    <blockquote>
      <pre><font color="#663300"> DECLARE I FIXED;<br> DO I = 1 TO 10;<br>     IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br> DO I = 1 TO 10;<br>     IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br>EOF<br></font></pre>
    </blockquote>
    Compiling this silly program with <b>XCOM3</b>, and pulling just
    the relevant portion of the <b>XCOM3</b>'s report gives us the
    following IBM 360 object code for the conditional expressions of the
    <font color="#663300"><code>IF</code></font> statements:<br>
    <pre><font color="#663300">  20 |    IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';                           |  1314 C7 = 10.<br>                                                                      1314: CODE = L    1,1340(0,11)<br>                                                                      1318: CODE = M    0,1340(0,11)<br>                                                                      1322: CODE = L    2,1340(0,11)<br>                                                                      1326: CODE = L    3,1340(0,11)<br>                                                                      1330: CODE = MR   2,2<br>                                                                      1332: CODE = LA   2,100(0,0)<br>                                                                      1336: CODE = SR   2,3<br>                                                                      1338: CODE = NR   1,2<br>                                                                      1340: CODE = N    1,164(0,11)<br>                                                                      ...<br> 24 |    IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';                                 |  1400<br>                                                                      1400: CODE = L    1,1340(0,11)<br>                                                                      1404: CODE = M    0,1340(0,11)<br>                                                                      1408: CODE = LA   2,100(0,0)<br>                                                                      1412: CODE = SR   2,1<br>                                                                      1414: CODE = N    2,1300(0,1048571)<br>                                                                      1418: CODE = N    2,164(0,11)<br>                                                                      ...<br><br></font></pre>
    <p>Not shown above is that the symbol table tells us variable <font
        color="#663300"><code>I</code></font> is stored at address
      1340(11), which is why all of the 1340(0,11)'s appear above. I
      don't understand IBM 360 assembly language too well, but what I <i>think</i>
      the code probably does is:<br>
    </p>
    <ul>
      <li>The first <font color="#663300"><code>IF</code></font>:</li>
      <ul>
        <li>1314 through 1318: Compute the left-hand operand of the <font
            color="#663300"><code>&amp;</code></font> operator; i.e., <font
            color="#663300"><code>I*I</code></font>.</li>
        <li>1322 through 1336: Compute the right-hand operand of the <font
            color="#663300"><code>&amp;</code></font> operator; i.e., <font
            color="#663300"><code>100-I**</code></font>. </li>
        <li>1338: Perform a bitwise-AND of the two operands.</li>
        <li>1340: Mask off all but the least-significant bit.<br>
        </li>
      </ul>
      <li>The second <font color="#663300"><code>IF</code></font>:</li>
      <ul>
        <li>1400-1412: Compute the <i>right</i>-hand operand of the <font
            color="#663300"><code>&amp;</code></font> operator; i.e., <font
            color="#663300"><code>I*I</code></font>.</li>
        <li>1414: Perform a bitwise-AND with 0. Admittedly, I'm not
          quite sure <i>why</i> it would be 0 it's AND'ing with, but
          it's certainly AND'ing with something.</li>
        <li>1418: Mask off all but the least-significant bit.</li>
      </ul>
    </ul>
    <p>But whether or not my interpretation is 100% correct, at least in
      this example there's no evidence of short-circuiting. The 2nd <font
        color="#663300"><code>IF</code></font> in particular is pretty
      shocking. Perhaps there's supposed to be some subsequent
      optimization I'm not aware of that would have cleaned it up.<br>
    </p>
    <h2><a name="common"></a>COMMON Memory</h2>
    XPL/I also introduces the notion of <font color="#663300"><code>COMMON</code></font>
    memory, not present in XPL.&nbsp; The notion behind <font
      color="#663300"><code>COMMON</code></font> memory is that a very
    large application program like <b>HAL/S-FC</b> won't be loaded
    entirely in memory at once, but will instead be run as a sequence of
    "passes".&nbsp; Since <font color="#663300"><code>COMMON</code></font>
    memory is not supported in standard XPL, compiling a program with <b>XCOM-I</b>'s










    <font color="#663300"><code>--xpl</code></font> switch will disable
    the <font color="#663300"><code>COMMON</code></font> memory
    features described in this sections.<br>
    <br>
    Thus, a program like <b>HAL/S-FC</b> isn't a single application
    program, but rather a set of them:&nbsp; <b>PASS1</b>, <b>FLO</b>,
    <b>OPT</b>, <b>AUX</b>, <b>PASS2</b>, <b>PASS3</b>, and <b>PASS4</b>.&nbsp;










    Each of these applications is loaded, run, and unloaded from memory,
    in succession.<br>
    <br>
    But!&nbsp; Each of these application programs may receive some kind
    of input data or state data from the preceding application program,
    and transmit output data or state data to the next application
    program in succession.&nbsp; In XPL/I's visualization, <i>some</i>
    of that data is passed in files.&nbsp; But other data is instead
    just assumed to remain in computer memory, unchanged from whatever
    the preceding application has left behind.&nbsp; The term XPL/I
    applies to this leftover memory is <font color="#663300"><code>COMMON</code></font>
    memory.&nbsp; It's formalized when you explicitly declare variables
    as being in <font color="#663300"><code>COMMON</code></font>.&nbsp;
    Variables declared to be in <font color="#663300"><code>COMMON</code></font>
    are not initialized by an XPL/I program, except for the very first
    program in a chain of programs, but are simply assumed to already
    contain the data needed.&nbsp; On the other hand, variables <i>not</i>
    declared <font color="#663300"><code>COMMON</code></font> are up
    for grabs, and no assumption can be made about their initial
    contents other than whatever initialization their declarations
    explicitly provide.<br>
    <br>
    Syntactically, <font color="#663300"><code>COMMON</code></font>
    data is declared in XPL/I by three methods:<br>
    <ul>
      <li>Using the keyword <font color="#663300"><code>COMMON</code></font>
        in place of the keyword <font color="#663300"><code>DECLARE</code></font>.</li>
      <li>Using the keyword-pair <font color="#663300"><code>COMMON
            ARRAY</code></font> in place of the keyword <font
          color="#663300"><code>ARRAY</code></font>.</li>
      <li>Using the keyword-pair <font color="#663300"><code>COMMON
            BASED</code></font> in place of the keyword <font
          color="#663300"><code>BASED</code></font>.</li>
    </ul>
    <p>Another distinction is that <font color="#663300"><code>CHARACTER</code></font>
      variables cannot declared in <font color="#663300"><code>COMMON</code></font>,
      though <font color="#663300"><code>CHARACTER</code></font>
      variables can appear as fields in <font color="#663300"><code>COMMON










          BASED RECORD</code></font> variables. <br>
    </p>
    <p>Each cooperating application running in succession needs to
      declare <font color="#663300"><code>COMMON</code></font> in
      exactly the same way, using exactly the same ordering of variables
      and the same datatypes, at the same addresses.&nbsp; When <a
        moz-do-not-send="true" href="#basedManagement">"dope vectors" of
        <b>BASED</b> variables</a> were discussed earlier, it was
      mentioned that <b>BASED</b> variables could be set as "constant"
      or "unmoveable", and this necessity for remaining at the same
      location when successor programs are executed is part of the
      reason for this feature.<br>
    </p>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;










        If <b>BASED</b> variables were always manipulated by an XPL/I
        program as intended by the original compiler design — i.e.,
        allowing SPACELIB to manipulate them via their dope vectors —
        there would be no reason for these restrictions on
        moveability.&nbsp; However, the "virtual memory" system employed
        by <b>HAL/S-FC</b>, as implemented by the files HALINCL/VMEM<i>x</i>.xpl,











        bypasses the dope-vector system.&nbsp; Specifically, "pages" of
        memory managed by the virtual-memory system are tracked only by
        an array of addresses (rather than dope vectors).&nbsp; But
        SPACELIB manages dope vectors, and has no cognizance of arrays
        of addresses whose interpretation exists only in the mind of a
        programmer.&nbsp; It is therefore necessary to make sure that
        the virtual-memory system's pages of memory never move.&nbsp;
        One might ask the programmer why they didn't use arrays of dope
        vectors rather than arrays of addresses?&nbsp; But that might be
        interpreted as being rude.&nbsp; On the other hand, I've known
        enough engineers to be pretty sure they'd think that since it
        worked for them, it was good enough.</font><br>
    </blockquote>
    <blockquote>
      <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;
          Speaking of the relationship between <font color="#663300"><code>BASED</code></font>
          variables and <font color="#663300"><code>COMMON</code></font>
          memory, it's important to note the following points:<br>
        </font></p>
      <ul>
        <li><font size="-1">For </font><font size="-1"><font size="-1"><font
                color="#663300"><code>BASED</code></font></font>
            variables appearing in </font><font size="-1"><font
              size="-1"><font color="#663300"><code>COMMON</code></font></font>,
            space is allocated for them via <font color="#663300"><code>RECORD_CONSTANT</code></font>
            or <font color="#663300"><code>ALLOCATE_SPACE</code></font>
            <i>only</i> in the first of the chained programs that needs
            to use them.&nbsp; Subsequent programs in the chain use them
            as-is, without allocation.</font></li>
        <li><font size="-1">Memory for </font><font size="-1"><font
              size="-1"><font color="#663300"><code>BASED</code></font></font>
            variables <i>not</i> appearing in </font><font size="-1"><font
              size="-1"><font color="#663300"><code>COMMON</code></font></font>
            must be explicitly freed via <font color="#663300"><code>RECORD_FREE</code></font>
            prior to exiting whatever program of the chain allocated
            their memory.&nbsp; If this is not done, then the
            memory-management system (Intermetrics SPACELIB) will abort
            the program with an error and fail to prepare the <font
              color="#663300"><code>COMMON</code></font> data for use by
            the next program in the chain.<br>
          </font></li>
      </ul>
    </blockquote>
    <p>Of course, <b>XCOM-I</b> makes no effort at all to pass <font
        color="#663300"><code>COMMON</code></font> data from one
      application to another using actual memory. Rather, each XPL/I
      application program compiled by <b>XCOM-I</b> can optionally
      (depending on its command-line options) load a <i>file</i>
      containing data into its <font color="#663300"><code>COMMON</code></font>
      areas of memory; and similarly, it automatically writes out its <font
        color="#663300"><code>COMMON</code></font> areas of memory into
      a file upon termination. By using the <font color="#663300"><code>--commoni</code></font>
      and <font color="#663300"><code>--commono</code></font>
      command-line switches of the application, a close degree of
      control can be exercised over which previously-saved <font
        color="#663300"><code>COMMON</code></font> blocks, if any, are
      passed to which application programs.&nbsp; The command-line
      options are needed because by <i>default</i>, an executable
      produced by <b>XCOM-I</b> does not read in a <font
        color="#663300"><code>COMMON</code></font> file at startup, and
      outputs a file literally called "COMMON.out" upon
      termination.&nbsp; The command-line options override either or
      both of those defaults.<br>
    </p>
    <p><font color="#663300"><code>COMMON</code></font> files are in a
      human-readable format.&nbsp; See the comments for the <font
        color="#663300"><code>writeEntryCommon</code></font> function in
      the runtime-library file runtimeC.c if you have any interest in
      the file format.&nbsp; It's actually pretty useful for debugging
      certain kinds of problems.<br>
    </p>
    <blockquote> </blockquote>
    <h2><a name="MemoryModel"></a>Memory Model for a Compiled XPL
      Program<br>
    </h2>
    <table width="100%" cellspacing="10" cellpadding="0">
      <tbody>
        <tr>
          <td valign="top">
            <p>The theoretical memory space available at runtime for a
              compiled XPL program is 2<sup>24</sup>=16,777,216 bytes in
              size, although the Wikipedia article on IBM System/360
              tells us that the actual physical maximum was only 8
              MB.&nbsp; In the C object code generated by XCOM-I, this
              is represented by the byte array called <font
                color="#663300"><code>memory</code></font>.</p>
            <p> For the original XPL and XPL/I compilers, the lowest
              portion and highest portion of this (theoretical) 16 MB
              space was dedicated to the executable code for the program
              and the data used by it.&nbsp; The middle of the area was
              used for the program's data.&nbsp; But in the <b>XCOM-I</b>
              framework, all of the program code is stored elsewhere,
              thus the entire 16MB space can be dedicated just for the
              variables actually <font color="#663300"><code>DECLARE</code></font>'d











              in the XPL source code ... plus those few elements of data
              which the operating system needs to communicate to the
              program, such as run-time program options, and a few other
              items I'll talk about in a moment.<br>
            </p>
            <p>The memory nevertheless still needs to be partitioned
              into blocks dedicated to specific types of data, in order
              to facilitate management of dynamic data like <font
                color="#663300"><code>CHARACTER</code></font> or <font
                color="#663300"><code>BIT</code></font><font
                color="#663300"><code>(n&gt;32)</code></font> strings
              and <font color="#663300"><code>BASED</code></font>
              variables.&nbsp; I try to follow the same partitioning
              scheme as used by the original compilers, at least
              roughly.&nbsp; The broad outline of this partitioning
              scheme is seen in the diagram to the right.<b>&nbsp; <br>
              </b></p>
            <p>Regions 4 and 6 naturally did not exist in XPL, since <font
                color="#663300"><code>BASED</code></font> variables are
              an XPL/I extension to standard XPL.&nbsp; So when <b>XCOM-I</b>
              is run with the <font color="#663300"><code>--xpl</code></font>
              command-line switch, those regions both have fixed sizes
              of 0.<br>
            </p>
            <p>Mostly, the boundaries of these memory regions are
              established at compile-time, by which I mean they're
              established by <b>XCOM-I</b> and don't change thereafter.
              The exceptions are the boundaries between regions 5, 6,
              and 7. As you may recall, at program startup, <font
                color="#663300"><code>BASED</code></font> variables have
              already been <font color="#663300"><code>DECLARE</code></font>'d










              and <b>XCOM-I</b> has thus made space for their dope
              vectors (region 4), but considered as arrays their sizes
              are 0. At program start, region 6 is empty. But memory
              region 6 grows <i>downward</i> when <font
                color="#663300"><code>BASED</code></font> variables are
              allocated memory at runtime, simultaneously shrinking the
              free-string memory region 5. String data meanwhile
              occupies the space from <font color="#663300"><code>FREEBASE</code></font>
              to <font color="#663300"><code>FREEPOINT</code></font> in
              region 5, which means that the space between <font
                color="#663300"><code>FREEPOINT</code></font> and <font
                color="#663300"><code>FREELIMIT</code></font> is
              available both for growing the string data upward (thus
              increasing <font color="#663300"><code>FREEPOINT</code></font>)
              or growing the <font color="#663300"><code>BASED</code></font>
              data downward (thus decreasing <font color="#663300"><code>FREELIMIT</code></font>).<br>
            </p>
            <blockquote><b><font size="-1">Aside:</font></b><font
                size="-1">&nbsp; It would seem reasonable, at least to
                me, that if </font><font size="-1"><font
                  color="#663300"><code>BASED</code></font> allocations
                proceed downward in memory, then the indices of the </font><font
                size="-1"><font color="#663300"><code>BASED</code></font>
                should also proceed downward as well.&nbsp; I mean that
                if we had a decoration such as <font color="#663300"><code>BASED










                    MYBASED</code></font>, then <font color="#663300"><code>MYBASED(0)</code></font>
                would be at a higher address than </font><font
                size="-1"><font size="-1"><font color="#663300"><code>MYBASED(1)</code></font></font>,
                which would be at a higher address than </font><font
                size="-1"><font size="-1"><font size="-1"><font
                      color="#663300"><code>MYBASED(2)</code></font></font></font>,
                and so on.&nbsp; If that were the case, then growing </font><font
                size="-1"><font size="-1"><font size="-1"><font
                      color="#663300"><code>MYBASED</code></font></font></font>
                after its initial allocation would be more efficient (if
                it happened to border on unallocated space), since it
                just involves snatching an unallocate chunk of memory
                rather than moving the entire array.&nbsp; However, if I
                am reading the code in SPACELIB correctly this does not
                appear to be the case:&nbsp; Indices of </font><font
                size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font>
                variables seem to increase upward in memory, just as
                they do in any other XPL/I array.&nbsp; </font><br>
            </blockquote>
            Region 7 is a bit trickier to explain.&nbsp; It is an area
            dedicated to data which <b>XCOM-I</b> wants to use for XPL
            objects it creates at compile time that need to be
            accessible to the XPL program as normal XPL variables, but
            that need to be exempt from the normal memory-management
            procedures applied to regions 5 and 6.&nbsp; These are items
            which the original XPL compilers would have stored in
            regions 1 through 6, but that the different implementation
            of <b>XCOM-I</b> would have made difficult.&nbsp; <b>XCOM-I</b>
            allocates this area and the objects in it at
            compile-time.&nbsp; Though shown as beginning at <font
              color="#663300"><code>0xFFE000</code></font>, that's
            misleading.&nbsp; The <font color="#663300"><code>0xFFE000</code></font>
            limit is the default, and is appropriate for compiling <b>HAL/S-FC</b>,
            but in fact is controlled by <b>XCOM-I</b>'s <font
              color="#663300"><code>--reserved=<i>N</i></code></font>
            (default 8192) command-line option.&nbsp; There will be
            compile-time messages if the size of the reserved memory
            needs to be increased.&nbsp; It's important to note that all
            XPL programs sharing the same <font color="#663300"><code>COMMON</code></font>
            memory need to have the same size for region 7.&nbsp;
            Specifically, all passes of <b>HAL/S-FC</b> need to have
            the same size of reserved memory, and that's why this
            particular default value for it was chosen.<br>
            <blockquote><font size="-1"><b>Aside:</b>&nbsp; In fact, the
                use of reserved memory has proven to be extremely
                rare.&nbsp; The only instances of use, to date, have
                been in <b>PASS2</b> and <b>PASS4</b> of <b>HAL/S-FC</b>,
                each of which stores a single object declared in a
                previously-unencountered, idiosyncratic way.</font><br>
            </blockquote>
            <br>
            <blockquote> </blockquote>
          </td>
          <td valign="middle">
            <table width="100%" cellspacing="2" cellpadding="2"
              border="1">
              <caption><font size="+1"><b>Memory Layout</b></font></caption>
              <tbody>
                <tr>
                  <th valign="bottom"><font size="-1">Addresses<br>
                    </font></th>
                  <th valign="bottom"><font size="-1">Description<br>
                    </font></th>
                  <th valign="bottom"><font size="-1">Region Number<br>
                    </font></th>
                </tr>
                <tr>
                  <td valign="top" align="right"><font color="#663300"><code><font
                          size="-1">0xFFFFFF<br>
                          <br>
                          <br>
                          0xFFE000<br>
                        </font></code></font></td>
                  <td valign="middle" align="center"><font size="-1"><br>
                      Reserved memory<br>
                      <br>
                    </font></td>
                  <td valign="middle" align="center">7<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="right"><br>
                    <br>
                    <br>
                    <br>
                    <br>
                    <br>
                    <br>
                    <font color="#663300"><code></code></font></td>
                  <td valign="middle" align="center"><font size="-1"><br>
                      <br>
                      Data pointed to by "dope vectors" of </font><font
                      size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font><br>
                      <br>
                      <br>
                    </font></td>
                  <td valign="middle" align="center">6<br>
                  </td>
                </tr>
                <tr>
                  <td valign="bottom" align="right"><font
                      color="#663300"><code><font size="-1">FREELIMIT</font></code></font></td>
                  <td valign="middle" align="center"><font size="-1"><br>
                      512-byte zone<br>
                      <br>
                    </font></td>
                  <td valign="middle" align="center"><font size="-1">5z</font><br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="right"><font color="#663300"><code><font
                          size="-1"><br>
                          <br>
                          <br>
                          <br>
                          FREEPOINT<br>
                          <br>
                          <br>
                          <br>
                          FREEBASE</font><br>
                      </code></font></td>
                  <td valign="middle" align="center"><br>
                    <font size="-1"><font size="-1">Data pointed to by
                        "string descriptors" of <font color="#663300"><code>CHARACTER</code></font>
                        or <font color="#663300"><code>BIT(&gt;32)</code></font><br>
                        <br>
                      </font></font> </td>
                  <td valign="middle" align="center">5<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center"><font size="-1"><br>
                    </font></td>
                  <td valign="middle" align="center"><font size="-1"><font
                        size="-1"><font color="#663300"><code><br>
                            BASED</code></font></font> dope vectors for
                      non-<font color="#663300"><code>COMMON</code></font><br>
                      <br>
                    </font></td>
                  <td valign="middle" align="center">4<br>
                  </td>
                </tr>
                <tr>
                  <td valign="bottom" align="right"><font size="-1"><font
                        color="#663300"><code>DESCRIPTOR</code></font><br>
                    </font></td>
                  <td valign="middle" align="center"><font size="-1"><font
                        size="-1"><font color="#663300"><code><br>
                            CHARACTER</code></font> or <font
                          color="#663300"><code>BIT(&gt;32)</code><font
                            color="#000000"> string descriptors<br>
                            <br>
                          </font></font></font></font></td>
                  <td valign="middle" align="center">3<br>
                  </td>
                </tr>
                <tr>
                  <td valign="bottom" align="right"><br>
                  </td>
                  <td valign="middle" align="center"><font size="-1"><br>
                    </font><font color="#663300"><font size="-1"
                        color="#000000"><font size="-1"><font
                            color="#663300"><font color="#000000"><font
                                color="#663300"><code>FIXED</code></font>,
                              <font color="#663300"><code>BIT(</code><code>≤32)</code></font>
                              , and <font color="#663300"><code>BASED</code></font>
                              dope vectors for</font></font></font></font></font><font
                      size="-1"><font color="#663300"><font
                          color="#000000"> non-<font color="#663300"><code>COMMON</code></font></font></font></font><font
                      size="-1"><br>
                      <br>
                    </font> </td>
                  <td valign="middle" align="center">2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top"><br>
                  </td>
                  <td valign="middle" align="center"><font
                      color="#663300"><code><br>
                      </code></font><font color="#663300"><font
                        size="-1" color="#000000"><font size="-1"><font
                            color="#663300"><font color="#000000"><font
                                color="#663300"><code>FIXED</code></font>,
                              <font color="#663300"><code>BIT(</code><code>≤32)</code></font>
                              , and <font color="#663300"><code>BASED</code></font>
                              dope vectors for </font><code>COMMON</code></font></font><font
                          color="#663300"><code></code></font></font><code><br>
                        <br>
                      </code></font></td>
                  <td valign="middle" align="center">1<br>
                  </td>
                </tr>
                <tr>
                  <td valign="bottom" align="right"><font
                      color="#663300"><code><font size="-1">0x000000</font></code></font></td>
                  <td valign="middle" align="center"><br>
                    <font size="-1"><font color="#663300"><code><font
                            color="#663300"><font size="-1"
                              color="#000000">Data supplied by <font
                                color="#663300"><code>MONITOR(13)</code></font>
                              and <font color="#663300"><code>MONITOR(23)<br>
                                  <br>
                                </code></font></font></font> </code></font>
                    </font> </td>
                  <td valign="middle" align="center">0<br>
                  </td>
                </tr>
              </tbody>
            </table>
          </td>
        </tr>
      </tbody>
    </table>
    <h2><a name="compactify"></a>Understanding COMPACTIFY</h2>
    <p>At runtime, changes to sizes of <font color="#663300"><code>BASED</code></font>
      arrays may cause those arrays to move around within memory region
      6 (see the preceding section). Depending on the type of changes,
      this can cause "holes" of unused memory to develop in memory
      region 6. Similarly, operations on <font color="#663300"><code>CHARACTER</code></font>
      variables such as <font color="#663300"><code>INPUT</code></font>
      or string concatenation (<font color="#663300"><code>||</code></font>)
      can cause holes of unused memory to develop in memory region 5. As
      long as <font color="#663300"><code>FREEPOINT</code></font> is
      comfortably less than <font color="#663300"><code>FREELIMIT</code></font>,
      these holes don't cause any problem and can just be ignored.
      However, it may eventually become necessary to repack these memory
      regions to consolidate the free space and eliminate the holes. <br>
    </p>
    <p>As far as memory region 6 is concerned, that's handled
      transparently by the tools already discussed in <a
        moz-do-not-send="true" href="#basedManagement">the section on <font
          color="#663300"><code>BASED</code></font> variables</a>
      earlier, and won't be discussed here. The <font color="#663333"><code>COMPACTIFY</code></font>
      procedure which handles this for memory region 5, unfortunately,
      does require some clarification, even though you typically don't
      need to explicitly call <font color="#663300"><code></code></font><font
        color="#663333"><code>COMPACTIFY</code></font> yourself, and can
      assume it will just be called automatically whenever needed.<br>
    </p>
    <p>Most importantly, while <font color="#663333"><code>COMPACTIFY</code></font>
      doesn't handle memory management of <font color="#663300"><code>BASED</code></font>
      variables, the existence of based variables <i>does</i> affect
      how <font color="#663333"><code>COMPACTIFY</code></font>
      operates, with the result that different versions of <font
        color="#663333"><code>COMPACTIFY</code></font> must be used for
      XPL code than for XPL/I code. But there's a quirk in XPL's
      implementation: While <font color="#663333"><code>COMPACTIFY</code></font>
      is considered a "built-in" function of the XPL runtime library, in
      point of fact it's <i>not</i> present in the XPL (or XPL/I)
      runtime library, and must instead be explicitly provided in the
      form of XPL source code.<br>
    </p>
    <p>Fortunately, that doesn't entail any effort on your part, since <b>XCOM-I</b>
      can usually figure out what to do on its own. But still, it may be
      helpful to understand what's going one behind the scenes, for
      those cases in which you need to intervene. The <b>XCOM-I</b>
      approach to the inclusion of <font color="#663333"><code>COMPACTIFY</code></font>
      is that prior to loading any of the XPL or XPL/I source-code files
      you explicitly specify, it automatically preloads a "library
      file", which is an XPL or XPL/I source-code file containing <i>at
        least</i> the source code for <font color="#663333"><code>COMPACTIFY</code></font>.
      The library file it chooses is governed by the following rules:<br>
    </p>
    <ol>
      <li>By default, it chooses SPACELIB.xpl, which is a duplicate of
        the Intermetrics file of the same name provided with the XPL/I
        source code for the <b>HAL/S-FC</b> program. It should be good
        for compiling all XPL/I source code.</li>
      <li>But if the <b>XCOM-I</b> command-line switch <font
          color="#663300"><code>--xpl</code></font> is used, the default
        library changes to XPL.LIBRARY.xpl. This a duplicate of the
        library of the same name provided with the source code of <b>XCOM3</b>
        program. It should be good for compiling all standard XPL source
        code.</li>
      <li>But if the <b>XCOM-I</b> command-line switch <font
          color="#663300"><code>--lib-file=<i>FILENAME</i></code></font>
        is used, then <font color="#663300"><code><i>FILENAME</i></code></font>
        is used in place of the default library file. This gives you the
        option of using some other version of <font color="#663333"><code>COMPACTIFY</code></font>,
        perhaps experimenting with it yourself. If used along with an <font
          color="#663300"><code>--xpl</code></font> switch, then <font
          color="#663300"><code>--lib-file</code></font> must <i>follow</i>
        <font color="#663300"><code>--xpl</code></font> on the command
        line.<br>
      </li>
    </ol>
    That's all you really <i>need</i> to know, and perhaps more than
    you needed.&nbsp; Unfortunately, <i>I</i> need to know more about
    it, in order to make it work in <b>XCOM-I</b>, and here's as good a
    place as any to write down some of that need-to-know info!<br>
    <br>
    The principal difficulty is that while XPL.LIBRARY.xpl works
    immediately for XPL programs, as-is, as long as the memory
    partitioning described in the preceding section is compatible <i>enough</i>
    with <i>A Compiler Generator</i>, the same cannot be said of
    SPACELIB.xpl for XPL/I programs.<br>
    <br>
    In brief, here's how the XPL <font color="#663333"><code>COMPACTIFY</code></font>
    of XPL.LIBRARY.xpl works.&nbsp; All of the "string descriptors"
    (providing the addresses and sizes of the character strings in
    region 5 which need to be repacked) are found, contiguously, in
    memory region 3, which they completely fill.&nbsp; Because of this
    convenient arrangement, all of the string descriptors can all be
    accessed as if they were a single <font color="#663300"><code>FIXED</code></font>
    array.&nbsp; Standard XPL's built-in <font color="#663300"><code>DESCRIPTOR</code></font>
    and <font color="#663300"><code>NDESCRIPT</code></font>
    respectively give the location and size of this array of string
    descriptors.&nbsp; Repacking region 5 is a relatively-simple matter
    of sorting <font color="#663300"><code>DESCRIPTOR</code></font>
    array by address, using the sorted array to find the "holes", then
    moving the string data downward in region 5 to eliminate the holes,
    and finally updating the original descriptors in the <font
      color="#663300"><code>DESCRIPTOR</code></font> array to preserve
    the strings but to change the addresses.<br>
    <br>
    The only mild complication in the description above is that the <font
      color="#663300"><code>DESCRIPTOR</code></font> array can't be
    sorted <i>in place</i>.&nbsp; Rather, a separate scratch array is
    needed to help out the process:<br>
    <blockquote>
      <pre><font color="#663300">DECLARE DX_SIZE LITERALLY '500', DX(DX_SIZE) BIT(16);</font><br></pre>
    </blockquote>
    This <font color="#663300"><code>DX</code></font> array is set up
    to contain the indices into the <font color="#663300"><code>DESCRIPTOR</code></font>
    array, and it's <font color="#663300"><code>DX</code></font> that's
    sorted rather than <font color="#663300"><code>DESCRIPTOR</code></font>.&nbsp;










    This is undoubtedly a good strategy, although it limits the total
    number of <font color="#663300"><code>DECLARE</code></font>'d <font
      color="#663300"><code>CHARACTER</code></font> variables to
    500.&nbsp; On the other hand, the limit of 500 is completely
    arbitrary, and if you have enough memory (we do!) there's no reason
    it couldn't be increased as high as 64K.&nbsp; And by the simple
    expedient of declaring <font color="#663300"><code>DX</code></font>
    as <font color="#663300"><code>FIXED</code></font> rather than <font
      color="#663300"><code>BIT(16)</code></font>, the limit could be
    made much higher.<br>
    <br>
    Unfortunately, the relatively-simple processing fails for XPL/I code
    — or at least, for any XPL/I code having <font color="#663300"><code>BASED</code></font>
    variables containing <font color="#663300"><code>CHARACTER</code></font>
    data or <font color="#663300"><code>BIT(≥32)</code></font> data —
    because no longer are all of the string descriptors nicely lined up
    for us in memory region 3.&nbsp; Rather, many of them are smeared
    all over memory region 6.&nbsp; Nor is a limit of 500 strings
    remotely adequate for compiling programs like <b>HAL/S-FC</b>.&nbsp;










    Here is what I understand of the differences between how the XPL/I <font
      color="#663333"><code>COMPACTIFY</code></font> has to operate, as
    compared to the description I just gave of the XPL <font
      color="#663333"><code>COMPACTIFY</code></font>:<br>
    <ul>
      <li>While the built-ins called <font color="#663300"><code>DESCRIPTOR</code></font>
        and <font color="#663300"><code>NDESCRIPT</code></font> still
        exist, and still provide exactly the same info about memory
        region 3, they are no longer relevant to <font color="#663333"><code>COMPACTIFY</code></font>.</li>
      <li><font color="#663300"><code>DX</code></font> is now a <font
          color="#663300"><code>BASED FIXED</code></font>, because it
        contains pointers to the string descriptors (i.e. it contains
        memory addresses of the string descriptors) rather than just
        indices into region 3.</li>
      <li><font color="#663300"><code>DX_SIZE</code></font> gives the
        number of elements of <font color="#663300"><code>DX</code></font>,
        but as it's nowhere <font color="#663300"><code>DECLARE</code></font>'d










        in the library, I suppose it must be an undocumented XPL/I
        built-in.</li>
    </ul>
    <blockquote>
      <p><b><font size="-1">Aside:</font></b><font size="-1"> I'd
          venture the guess that </font><font size="-1"><font
            color="#663300"><code>DX_SIZE</code></font> is initially set
          and space for </font><font size="-1"><font color="#663300"><code>DX</code></font>
          is initially allocate by the XPL/I compiler to handle the
          string descriptors which are </font><font size="-1"><font
            color="#663300"><code>DECLARE</code></font>'d and therefore
          known at compile time. At runtime, SPACELIB would then take
          over the task of maintaining </font><font size="-1"><font
            color="#663300"><code>DX</code></font> and </font><font
          size="-1"><font color="#663300"><code>DX_SIZE</code></font> to
          handle additional string descriptors that come into existence
          (or leave it) when </font><font size="-1"><font
            color="#663300"><code>BASED</code></font> variables
          containing them grow (or shrink).</font><br>
      </p>
    </blockquote>
    More TBD<br>
    <h2>Structure of an XPL Program vs XPL/I<br>
    </h2>
    <p>An XPL program consists of any sequence of XPL <i>statements</i>,
      followed by the token <font color="#663333"><code>EOF</code></font>.&nbsp;










      In particular:<br>
    </p>
    <ul>
      <li>Declarations of variables can be intermixed with active
        statements such as assignments.</li>
      <li>Active code can exist at the global level, outside of any <font
          color="#663300"><code>PROCEDURE</code></font>s. <br>
      </li>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Note:</b>&nbsp; The original XPL compiler, <b>XCOM3</b>,
          performed a single pass.&nbsp; It required that the
          declaration of any particular identifier as an object (such as
          a variable) had to precede the use of that identifier,
          although there were provisions for making a forward
          declaration for a </font><font size="-1"><font
            color="#663333"><code>PROCEDURE</code></font>, so that the </font><font
          size="-1"><font color="#663333"><code>PROCEDURE</code></font>
          could be used before it was defined.&nbsp; <b>XCOM-I</b>
          relaxes this requirement.<br>
        </font></p>
    </blockquote>
    <p>Each of the sample programs I've encountered in standard XPL so
      far has been contained in a single <i>relatively</i>-small file.
      For example, <b>ANALYZER</b> has a little over 1500 lines of
      source code, while <b>XCOM</b> has a little over 4200 lines. <br>
    </p>
    <p>In contrast, the XPL/I source code for Intermetrics's HAL/S
      compiler <b>HAL/S-FC</b> has over 120,000 lines of source code
      spread across over 600 files, though any individual pass of the
      compiler has no more than around 35,000 lines. This necessitated
      different methods for managing that source-code base in XPL/I vs
      XPL, and some of those methods are reflected by compiler
      directives embedded within the source code. Insofar as <b>HAL/S-FC</b>
      and its related applications are concerned, the top-level
      source-code file (##DRIVER.xpl) for each application always
      contains all of the necessary directives for compiling the other
      source-code files needed, in the correct order, so in using <b>XCOM-I</b>
      to compile these applications you don't need to worry about any
      file other than ##DRIVER.xpl itself.<br>
    </p>
    <blockquote>
      <p><font size="-1"><b>Aside:</b> Well, the comment about
          ##DRIVER.xpl isn't exactly right. Any XPL or XPL/I program
          will expect that there's a separate "library file" containing
          source code for the <font color="#663300"><code>COMPACTIFY</code></font>
          procedure, but the XPL/I source code for the program won't
          explicitly include the library file. That's the compiler's
          responsibility.<br>
        </font></p>
      <p><font size="-1"><b>Aside:</b> Due to the lack of relevant
          Intermetrics documentation, what I'm about to describe is not
          only speculative on my part, but also represents certain
          pragmatic compromises that I don't believe literally existed
          in Intermetrics's XPL compiler or development procedures. But
          if it will work for us using <b>XCOM-I</b> on <b>HAL/S-FC</b>
          and if there are no other lurking XPL/I programs that we need
          to worry about, why complain?</font><br>
      </p>
    </blockquote>
    Compiler directives in XPL/I are comments or comment-like
    constructions which aren't documented in <i>A Compiler Generator</i>
    and have no other obvious purpose.&nbsp; The specifics are covered
    by the subsections below.<br>
    <h4><a name="conditional"></a>Compiler Directive Type:&nbsp; <font
        color="#663300"><code>/?<i>c</i> ... XPL/I source code ... ?/</code></font></h4>
    This type of compiler directive is a conditional inclusion of source
    code, similar to the C language's <font color="#663300"><code>#if <i>c</i></code></font>.&nbsp;










    Here, <font color="#663300"><i><code>c</code></i></font> is
    supposed to be an upper-case alphabetical letter that represents the
    particular condition that needs to be "true".&nbsp; All conditions,
    <font color="#663300"><code>A</code></font> through <font
      color="#663300"><code>Z</code></font>, are by default
    "false".&nbsp; You make condition <font color="#663300"><i><code>c</code></i></font>
    "true" by using <b>XCOM-I</b>'s <font color="#663300"><code>--cond=<i>c</i></code></font>
    command-line switch.<br>
    <br>
    Interpretations of the possible conditions are entirely at the
    user's disposal; i.e., they vary by the particular source-code being
    compiled by <b>XCOM-I</b>.&nbsp; In the particular case of the
    XPL/I source code for the <b>HAL/S-FC</b> program, there are 4
    possible conditions <font color="#663300"><i><code>c</code></i></font>,
    plus 2 additional ones I invented personally:<br>
    <br>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <caption><font size="+1"><b>Preprocessor Conditionals</b></font></caption>
      <tbody>
        <tr>
          <th valign="bottom" align="center">XCOM-I Command-Line Switch<br>
          </th>
          <th valign="top">Interpretation<br>
          </th>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>--cond=P</code></font><br>
          </td>
          <td valign="top"><b>HAL/S-FC</b> will be specialized for
            compiling the Space Shuttle's Primary Flight Software
            (PASS).</td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>--cond=B</code></font>
          </td>
          <td valign="top"><b>HAL/S-FC</b> will be specialized for
            compiling the Space Shuttle's Backup Flight Software (BFS).<br>
            <b>Note:</b>&nbsp; Either <font color="#663300"><code>--cond=P</code></font>
            or <font color="#663300"><code>--cond=B</code></font> must
            be used, but not both at the same time.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>--cond=A</code></font></td>
          <td valign="top">Produce debugging output related to memory
            management of <font color="#663300"><code>BASED</code></font>
            variables.</td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>--cond=C</code></font></td>
          <td valign="top">Produces debugging output related to actions
            by the <font color="#663300"><code>COMPACTIFY</code></font>
            procedure.</td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>--cond=V</code></font><br>
          </td>
          <td valign="top">For code specific to the Virtual AGC
            Project.&nbsp; This is my own innovation, and of course was
            not used in any legacy code.&nbsp; It is used in those few
            cases (2 at the present count) in which legacy code XPL[/I]
            code is not fully appropriate for modern usage, or <b>XCOM-I</b>
            has some bug which cannot be overcome, and thus the legacy
            code needs to be replaced to make the program that's being
            compiled usable.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>--cond=W</code></font><br>
          </td>
          <td valign="top">The opposite of <font color="#663300"><code>--cond=V</code></font>.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <ul>
    </ul>
    <blockquote>
      <p><font size="-1"><b>Aside:</b> This implies that you don't just
          compile <b>HAL/S-FC</b> <i>once</i> to get a HAL/S compiler
          that works for all HAL/S programs. Rather, you compile <b>HAL/S-FC</b>
          <i>twice</i>, once to get a version of the HAL/S compiler that
          works for the primary flight software, and once to get a
          version of the compiler that works for the backup flight
          software.</font></p>
    </blockquote>
    <h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/%INCLUDE










          <i>module</i> %/</code></font></h4>
    This type of compiler directive inserts an entire XPL/I source-code
    file, <i>module</i>.xpl, at the current point.&nbsp; It is used for
    importing <font color="#663300"><code>COMMON</code></font>-block
    declarations or macros which are used identically by all source-code
    files.&nbsp; By default, the included module is taken from the
    folder ../HALINCL/.&nbsp; As far as I know this covers every use in
    <b>HAL/S-FC</b> source code.&nbsp; However, if necessary, <b>XCOM-I</b>
    has a command-line option (<font color="#663300"><code>--include=<i>folder</i></code></font>)
    which can be used to change the folder containing the modules.<br>
    <h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/*
          ...comment... <i>$%module</i> */</code></font></h4>
    This is a variant of the<font color="#663300"><code> /%INCLUDE <i>module</i>
        ...comment... %/</code></font> directive, which acts the same
    way, and for which my comments are otherwise the same.<br>
    <h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/**MERGE










          <i>module</i> <i>procedure</i> */</code></font></h4>
    This is yet another directive for including an XPL/I source-code
    file in the current XPL/I source-code file, but it differs from the
    other include-directives described above in that instead of
    importing definitions used in common by multiple source-code files,
    it instead is typically used for importing the source code for a
    single <font color="#663300"><code>PROCEDURE</code></font>.&nbsp;
    As above, <i>module</i>.xpl is the source-code file to include,
    while <i>procedure</i> is the name of the <font color="#663300"><code>PROCEDURE</code></font>
    contained in that file.&nbsp; In point of fact, <b>XCOM-I</b>
    simply ignores the procedure name.<br>
    <blockquote><font size="-1"><b>Aside:</b> Procedure names don't
        match the filenames, usually, because the naming conventions for
        System/360 files were severely limited vs identifiers in
        XPL.&nbsp; Thus the filenames were normalized, truncated forms
        of the procedure names.</font><br>
    </blockquote>
    Also, <i>module</i>.xpl is expected to be within the same folder as
    the source-code file being compiled; no other folders are searched
    for it, and there are no command-line switches to alter this
    behavior.<br>
    <blockquote> </blockquote>
    <h2>PROCEDUREs, RETURNs, and Their Peculiarities<br>
    </h2>
    <p>In a view from a height, an XPL program consists of <font
        color="#663333"><code>PROCEDURE</code></font> definitions and of
      code that uses those definitions.<br>
    </p>
    <p>A procedure definition looks something like this:<br>
    </p>
    <blockquote>
      <pre><font color="#663300"><i>label</i>:<br>PROCEDURE(... <i>parameter list</i> ...) <i>ReturnType</i>;<br>	DECLARE ... <i>for the parameters</i> ...;<br>	DECLARE ... <i>for local variables</i> ...;<br><br>	... <i>code</i> ...;<br>END <i>label</i>;</font><br></pre>
    </blockquote>
    <p><font color="#663333"><font color="#000000">A lot of this is
          optional. Thus while the initial <font color="#663300"><code><i>label</i>:</code></font>
          is required (since it's the name of the procedure), the </font></font><font
        color="#663333"><font color="#000000"><font color="#663333"><font
              color="#000000"><font color="#663300"><code><i>label</i></code></font></font></font>
          at the end of the definition is optional, and is really there
          only for readability purposes. If the procedure needs no
          parameters, then the <font color="#663300"><i><code>parameter
                list</code></i></font>, <i>including</i> its enclosing
          parentheses, is omitted. If the procedure returns no value,
          then <font color="#663300"><i><code>ReturnType</code></i></font>
          is omitted; if present, it is one of the basic non-subscripted
          datatypes <font color="#663300"><code>FIXED</code></font>, <font
            color="#663300"><code>BIT(<i>n</i>)</code></font>, or <font
            color="#663300"><code>CHARACTER</code></font>. Each
          parameter in the </font></font><font color="#663333"><font
          color="#000000"><font color="#663333"><font color="#000000"><font
                color="#663300"><i><code>parameter list</code></i></font></font></font>
          must have a declaration within the body of the procedure, and
          while those declarations don't technically have to precede the
          declarations of the local variables as shown above, it was
          apparently customary to do so.</font></font></p>
    <font color="#663333"><code>PROCEDURE</code></font> definitions in
    the source code can be nested, to any desired depth. <font
      color="#663333"><code>PROCEDURE</code></font> definitions and <font
      color="#663300"><code>DO...END</code></font> blocks provide the
    program with a hierarchical structure of "scopes".&nbsp; The
    hierarchical structure is provided by the parent/child relationships
    among the scopes. Variables are accessible within the scope in which
    they're declared, along with any descendant scopes. If a variable is
    declared in more than one scope of the hierarchy, the one in the
    innermost enclosing scope is the one that is applicable. <br>
    <br>
    In standard XPL, variables can be declared only at the global level
    or in a <font color="#663300"><code>PROCEDURE</code></font>, and
    not within <font color="#663300"><code>DO...END</code></font>
    blocks.&nbsp; <br>
    <br>
    In XPL/I, variable (and <font color="#663300"><code>PROCEDURE</code></font>)
    definitions can be declared anywhere, even within <font
      color="#663300"><code>DO...END</code></font> blocks.&nbsp; <b>XCOM-I</b>
    mimics the XPL/I usage, since it's compatible with standard
    XPL.&nbsp; But there's a trap!&nbsp; Or at least, it's a trap for <i>me</i>,
    and by projection, I assume it's a trap for you as well.&nbsp; The
    trap is that you'd suppose the scope of a variable or <font
      color="#663300"><code>PROCEDURE</code></font> was the <font
      color="#663300"><code>DO...END</code></font> block in which it was
    declared.&nbsp; Not so!&nbsp; The scope is the entire enclosing <font
      color="#663300"><code>PROCEDURE</code></font> and its
    descendants.&nbsp; So beware.&nbsp; Fortunately, such abominations
    are very rare, and only a handful appear in the entire <b>HAL/S-FC</b>
    source-code base.&nbsp; Here's an example from the <font
      color="#663300"><code>DUMP_SDF PROCEDURE</code></font> of <b>PASS4</b>
    of the compiler, cleaned up a little for readability.&nbsp; Observe
    the declaration and usage of the variable <font color="#663300"><code>SYM_DATA_CELL_ADDR</code></font>
    within the two distinct <font color="#663300"><code>DO...END</code></font>
    blocks:<br>
    <blockquote>
      <pre>            IF NODE_B(3) &gt; 0 THEN <font color="#009900">DO; <br> 	       /* IN CASE OF SYMBOL XREF EXTENSION CELL, SAVE ADDR OF SYM DATA CELL */<br>               DECLARE <font color="#ff0000">SYM_DATA_CELL_ADDR</font> FIXED; <br>               <font color="#ff0000">SYM_DATA_CELL_ADDR</font>= COREWORD(ADDR(NODE_F)); <br>               CALL PRINT_XREF_DATA(SHR(NODE_B(3),1));<br>            END</font>; <br><br>            IF ASIP_FLAG &amp; (SCLASS=1 | SCLASS=2 &amp; NAME_FLAG) THEN <font color="#3333ff">DO;<br> 	       /* RESTORE NODE_F TO SYM_DATA_CELL_ADDR BEFORE GETTING AUXILIARY INFO. */<br>               COREWORD(ADDR(NODE_F))  = <font color="#ff0000">SYM_DATA_CELL_ADDR</font>;<br>               IF STYPE=16 &amp; ^NAME_FLAG THEN<br>                  CALL FORMAT_NAME_TERM_CELLS(I,NODE_F(-2));<br>               ELSE OUTPUT = X10||'INITIAL(NAME('|| <br>                  FORMAT_VAR_REF_CELL(NODE_F(-2)) || '))';<br>            END</font>; <br></pre>
    </blockquote>
    A <font color="#663333"><code>PROCEDURE</code></font> may be
    invoked in two different ways.&nbsp; If it returns a value via a <font
      color="#663300"><code>RETURN</code></font> statement, it can be
    used in an arithmetical expression or a string expression.&nbsp; If
    it doesn't return a value, or if it does return a value and you
    simply want to ignore the value, a <font color="#663333"><code>CALL</code></font>
    statement can be used to invoke the <font color="#663333"><code>PROCEDURE</code></font>
    but to discard any returned value.&nbsp; But don't be
    deceived!&nbsp; Cases in which these rules are simply ignored exist
    in legacy code, and we'll talk a little bit more about that below.<br>
    <p><b>Important:</b>&nbsp; All variables local to a <font
        color="#663333"><code>PROCEDURE</code></font> definition retain
      their values after the <font color="#663333"><code>PROCEDURE</code></font>
      returns.&nbsp; If the <font color="#663333"><code>PROCEDURE</code></font>
      is re-executed, those local variables retain the values they
      previously had in the prior invocation of the <font
        color="#663333"><code>PROCEDURE</code></font>.&nbsp; The values
      of those local variables, though retained, are inaccessible to
      code outside of the <font color="#663333"><code>PROCEDURE</code></font>,
      because the namespaces of the local variables prevent it. (In C
      code, this would be the same thing as saying that every local
      variable of every function is automatically declared as <font
        color="#663333"><code>static</code></font>.) </p>
    <p><b><i>Very</i> important:</b> Any (or even all) <i>parameter</i>s
      at the trailing end of the calling list of a <font
        color="#663333"><code>PROCEDURE</code></font> can be omitted
      from when calling the <font color="#663333"><code>PROCEDURE</code></font>,
      and if omitted, they too retain the same values as the last time
      the <font color="#663333"><code>PROCEDURE</code></font> was
      invoked <i>or</i> the values previously assigned to those
      parameters from within the <font color="#663333"><code>PROCEDURE</code></font>
      itself!&nbsp; (In essence, this is like saying that parameters of
      a <font color="#663333"><code>PROCEDURE</code></font> are not
      passed to the <font color="#663333"><code>PROCEDURE</code></font>,
      but rather that they are just aliases for some set of global
      variables dedicated to the <font color="#663333"><code>PROCEDURE</code></font>.)&nbsp;










      That's so weird that we need to see an example.&nbsp; Consider the
      following XPL <font color="#663333"><code>PROCEDURE</code></font>
      definition, and <font color="#663333"><code>CALL</code></font>s
      to it: </p>
    <blockquote>
      <pre><font color="#663333">weirdo: <br>procedure(x, y, z);<br>    declare (x, y, z) fixed;		/* Declare x,y,z as integers */<br>    output = x || ' ' || y || ' ' || z; /* Print out x,y,z */<br>    x = 29;<br>    y = y + 1;<br>end weirdo;<br><br>call weirdo(1, 2, 3);<br>call weirdo(4, 5);<br>call weirdo(6);<br>call weirdo();<br>call weirdo;</font><br></pre>
    </blockquote>
    <p>The five calls successively print out the following: </p>
    <blockquote>
      <pre>1 2 3<br>4 5 3<br>6 6 3<br>29 7 3<br>29 8 3<br></pre>
    </blockquote>
    <p><font color="#663333"><code>PROCEDURE</code></font>s cannot be
      recursive, either directly or indirectly.<br>
    </p>
    <p>Taking these facts altogether, <b>XCOM-I</b> implements both
      parameters and local variables of <font color="#663333"><code>PROCEDURE</code></font>s
      essentially as global variables in they way they are stored:&nbsp;
      i.e., each parameter and each local variable of each <font
        color="#663333"><code>PROCEDURE</code></font> has its own <i>static</i>
      address (in the global memory model), assigned at compile time and
      unchanging thereafter.&nbsp; The compiler enforces the logical
      scoping of these variables by means of their namespace.&nbsp;
      There will be more on this when the concept of "mangling" of
      identifiers is discussed.<br>
    </p>
    <p>Regarding the <font color="#663300"><code>RETURN</code></font>
      statement, <i>A Compiler Generator</i> explains that it is used
      to exit from a <font color="#663333"><code>PROCEDURE</code></font>
      and optionally to return a value. Furthermore, the calling code
      can either use that return value or else ignore it. Which makes
      perfect sense. But as usual, there are some documented and
      undocumented peculiarities to the <font color="#663300"><code>RETURN</code></font>
      statement as well:<br>
    </p>
    <ul>
      <li><i>A Compiler Generator</i> explains (p. 146) that calling
        code can <i>use</i> returned values from <font color="#663300"><code>PROCEDURE</code></font>s
        even if the <font color="#663300"><code>PROCEDURE</code></font>
        has no <font color="#663300"><code>RETURN</code></font>
        statement, or the <font color="#663300"><code>RETURN</code></font>
        statement specifies no value. In this case, we are told, the
        return value is simply some unpredictable value from some
        unspecified System/360 register. Which is rotten, of course, but
        so what? This is never going to happen, right? Wrong! Actual XPL
        code does this from time to time. <b>XCOM-I</b>, on the other
        hand, <i>always</i> returns a well-defined value from a <font
          color="#663300"><code>PROCEDURE</code></font>, whether or not
        there are any <font color="#663300"><code>RETURN</code></font>
        statements specifying a return value; the returned value in this
        case is 0 if <font color="#663300"><code>FIXED</code></font>, a
        <font color="#663300"><code>BIT</code></font> value of the
        appropriate width evaluating to 0, or else the empty string for
        a <font color="#663300"><code>CHARACTER</code></font>.</li>
      <li><i>A Compiler Generator</i> (probably!) does not mention that
        <font color="#663300"><code>RETURN</code></font> statements may
        exist at the global level, outside of the scope of any
        procedure, and may return a value when they do. But they can. <b>XCOM-I</b>
        treats these as exits from the program back to the operating
        system, with the returned value being the program's exit code.
        It thus expects the return value to be a program status code.</li>
    </ul>
    <h2>Blocks and Loops</h2>
    <p>Compound statements in XPL are groupings of simple statements
      (such as assignments or if-then-else statements) enclosed within a
      <font color="#663300"><code>DO ... END</code></font> block:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">DO ...;<br>    ... simple statements ...<br>END;</font><br></pre>
    </blockquote>
    <p>There are five different kinds of <font color="#663300"><code>DO
          ... END</code></font> blocks. First, there is a stand-alone
      simple grouping as shown above.<br>
    </p>
    <p>Then there are 3 different kinds of loops:</p>
    <pre><font color="#663300">DO <i>COUNTER</i> = <i>START</i> TO <i>END</i> [BY <i>STEP</i>];<br>    ... simple statements ...<br>END;<br><br></font><font color="#663300">DO WHILE <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
<br><font color="#663300">DO UNTIL <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
</pre>
    <p>Note that <font color="#663300"><code>DO UNTIL</code></font> is
      new in XPL/I and is not present in standard XPL.<br>
    </p>
    <p>In these loops, <i><font color="#663300"><code>COUNTER</code></font></i>,
      <i><font color="#663300"><code>START</code></font></i>, <i><font
          color="#663300"><code>END</code></font></i>, and the optional
      <i><font color="#663300"><code>STEP</code></font></i> are all
      integers. <i><font color="#663300"><code>STEP</code></font></i>
      defaults to 1, but must be <i>positive</i>. <i><font
          color="#663300"><code>START</code></font></i>, <i><font
          color="#663300"><code>END</code></font></i>, and <i><font
          color="#663300"><code>STEP</code></font></i> may be
      expressions, but if so they are evaluated only a single time, at
      the start of the loop, and are not reevaluated thereafter. <i><font
          color="#663300"><code>CONDITION</code></font></i>, on the
      other hand, is an expression evaluated on each loop; it is treated
      as "true" if its least-significant bit is 1, or "false" if its
      least-significant bit is 0.&nbsp; When I say they are "integers",
      I don't mean that they are necessarily <font color="#663300"><code>FIXED</code></font>;
      they could also be <font color="#663300"><code>BIT(</code><code>≤32)</code></font>,
      which evaluate to integers.<br>
    </p>
    <p>The fifth kind of <font color="#663300"><code>DO ... END</code></font>
      block is:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">DO CASE EXPRESSION;<br>    STATEMENT0;<br>    STATEMENT1;<br>    STATEMENT2;<br>    ...<br>END;</font><br></pre>
    </blockquote>
    <p>The <i><font color="#663300"><code>EXPRESSION</code></font></i>
      must also evaluate to an integer. If 0, then <i><font
          color="#663300"><code>STATEMENT0</code></font></i> is
      executed; if 1, then <i><font color="#663300"><code>STATEMENT1</code></font></i>
      is executed; and so on. At most, a single statement is executed,
      and there is no "fall through" from one statement to the next. If
      the <i><font color="#663300"><code>EXPRESSION</code></font></i>
      is negative or beyond the number of available statements, <i>A
        Compiler Generator</i> tells us that "a random jump is
      executed". In <b>XCOM-I</b>, no statement is executed under those
      circumstances, and control passes to the next statement after the
      <font color="#663300"><code>END</code></font>.<br>
    </p>
    <h2><font size="+3"><code>ESCAPE</code></font> and <font size="+3"><code>REPEAT</code></font><br>
    </h2>
    <p>The <font color="#663300"><code>ESCAPE</code></font> and <font
        color="#663300"><code>REPEAT</code></font> keywords appear to be
      undocumented XPL/I features not present in standard XPL.
      Unfortunately, from the available material I can't think of any
      way to be <i>sure</i> what they do, so I can only speculate.<br>
    </p>
    <p><font color="#663300"><code>ESCAPE</code></font> appears in two
      different forms:<br>
    </p>
    <ul>
      <li><font color="#663300"><code><font color="#663300"><code>ESCAPE;</code></font>
            <br>
          </code></font></li>
      <li><font color="#663300"><code>ESCAPE <i>LABEL</i>;</code></font>
        <font color="#663300"><code></code></font></li>
    </ul>
    <p>It should be noted that the HAL/S language has the keyword <code><font
          color="#663300">EXIT</font></code>, which also has these two
      forms. (<a moz-do-not-send="true"
href="https://www.ibiblio.org/apollo/Shuttle/Programming%20in%20HAL_S%20Sept%201978.pdf#page=96">See










        Ryer, p. 5-12</a>.) <code><font color="#663300">EXIT</font></code>
      has the following behavior in HAL/S:<br>
    </p>
    <ul>
      <li><font color="#663300"><code><font color="#663300"><code>EXIT</code></font>;</code></font>
        — Exits from the innermost enclosing <font color="#663300"><code>DO










            ... END</code></font> block. I.e., it's essentially a <font
          color="#663300"><code>GO TO</code></font> to just after the
        closest enclosing <font color="#663300"><code>END</code></font>.</li>
      <li><font color="#663300"><code>EXIT <i>LABEL</i>;</code></font>
        — Exits from an enclosing <font color="#663300"><code>DO ...
            END</code></font> that isn't necessarily the innermost one,
        but rather the one which instead has the specified <i><font
            color="#663300"><code>LABEL</code></font></i> attached to
        it. By "attached to it", I mean that they're directly adjacent,
        as in "<font color="#663300"><code><i>LABEL</i>: DO ...</code></font>".<font
          color="#663300"><code></code></font></li>
    </ul>
    <p>Until a more-plausible explanation comes along, my assumption is
      that <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font>
      in XPL/I has the same behavior as HAL/S's <font color="#663300"><code>EXIT</code></font>.<br>
    </p>
    <p>For example, consider the following XPL/I code:<br>
    </p>
    <blockquote><font color="#663300"><code>...</code><code></code></font><br>
      <font color="#663300"><code></code><code>MYBLOCK: </code><code></code></font><br>
      <font color="#663300"><code></code><code>DO ...</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; DO ...</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;










          ...</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;










          ESCAPE; /* Escape #1 */</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;










          ...</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;










          ESCAPE MYBLOCK; /* Escape #2 */</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;










          ...</code><code></code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; END;</code><code></code></font><br>
      <font color="#cc0000"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;










          /* Escape #1 comes here! */</code></font><br>
      <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code></font><br>
      <font color="#663300"><code>END;</code></font><br>
      <font color="#cc0000"><code></code><code>/* Escape #2 comes here!
          */</code></font><br>
      <font color="#663300"><code>...</code></font><br>
      <font color="#663300"><code></code></font></blockquote>
    <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
    also appears in those same two forms:<br>
    <ul>
      <li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font>
            <br>
          </code></font></li>
      <li><font color="#663300"><code><font color="#663300"><code><font
                  color="#663300"><code>REPEAT</code></font></code></font>
            <i>LABEL</i>;</code></font> </li>
    </ul>
    And again, there's a <font color="#663300"><code><font
          color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font></code></font>
    keyword in HAL/S as well.&nbsp; In this case, though, from examining
    the actual usage in HAL/S-FC source code, I believe that while the
    keyword has a <i>similar</i> behavior in HAL/S and XPL/I, there is
    nevertheless a distinction between them.&nbsp; Here's what I believe
    the behavior is in XPL/I:<br>
    <ul>
      <li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font></code><font
            color="#000000"> </font></font>— "Repeats" the smallest
        enclosing <font color="#663300"><code>DO ... END</code></font>.
        In case the smallest enclosing <font color="#663300"><code>DO
            ... END </code></font>is a loop — <font color="#663300"><code>DO










            WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font>
        or <font color="#663300"><code>DO I = X TO Y</code></font> —
        saying that it "repeats" has a pretty clear meaning: XPL/I <font
          color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
        is like a Python or C <font color="#663300"><code>continue</code></font>
        statement. On the other hand, if the immediately-enclosing <font
          color="#663300"><code>DO ... END</code></font> is <i>not</i>
        a loop, the expected behavior is less clear; nor are there any
        instances of <font color="#663300"><code>REPEAT</code></font>
        in non-loops in legacy XPL/I code from which we might get a
        clue.&nbsp; <b>XCOM-I</b> implements <font color="#663300"><code><font
              color="#663300"><code>REPEAT</code></font></code></font>
        without a label simply as a jump to the beginning of the block,
        which means that you could form an infinite loop if there were
        no other code (like <font color="#663300"><code>ESCAPE</code></font>
        or <font color="#663300"><code>GO TO</code></font>) to exit the
        loop.</li>
      <li><font color="#663300"><code><font color="#663300"><code><font
                  color="#663300"><code>REPEAT</code></font></code></font>
            <i>LABEL</i>;</code></font> — Breaks out of inner loops as
        needed, until reaching an enclosing <font color="#663300"><code>DO










            ... END</code></font> loop that has the attached <i><font
            color="#663300"><code>LABEL</code></font></i>. <i>That's</i>
        the block that it repeats.</li>
    </ul>
    <ul>
    </ul>
    <blockquote> <font size="-1"><b>Aside:</b>&nbsp; The way my XPL/I
        implementation is different from HAL/S is that in HAL/S, <font
          color="#663300"><code>REPEAT</code></font> (without a label)
        goes to the beginning of the innermost enclosing <i>loop</i> (<font
          color="#663300"><code>DO WHILE</code></font> or <font
          color="#663300"><code>DO UNTIL</code></font> or <font
          color="#663300"><code>DO I = X TO Y</code></font>) rather than
        the innermost enclosing <font color="#663300"><code>DO ... END</code></font>.&nbsp;










        Which makes sense, since that's what you'd normally want.<br>
      </font></blockquote>
    <b>Note:</b>&nbsp; Neither <font color="#663300"><code>ESCAPE</code></font>
    nor <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
    accepts a label attached to an arbitrary statement.&nbsp; It must be
    a label attached to a <font color="#663300"><code>DO ... END</code></font>
    block, and it must at some level enclose the <font color="#663300"><code>ESCAPE</code></font>
    or <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
    statement itself.<br>
    <h2>Counter Value After Normal Loop Termination<br>
    </h2>
    <font color="#663300"><code></code></font>For XPL code such as<br>
    <blockquote>
      <pre><font color="#663300">DO I = 1 to 100;<br>    ...<br>END;</font><br></pre>
    </blockquote>
    it appears to be undocumented what value <font color="#663300"><code>I</code></font>
    holds after the loop ends.&nbsp; Not all computer languages handle
    this in the same way.&nbsp; My considered opinion is that the loop
    counter holds the value at which the condition for continuation
    fails: in this example, 101.&nbsp; Or, if the loop is broken
    prematurely (as with <font color="#663300"><code><font
          color="#663300"><code>ESCAPE</code></font></code></font> from
    the preceding section), then the value the counter held when the <font
      color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font>
    occurred is retained.<br>
    <blockquote><font size="-1"><b>Aside:</b></font>&nbsp; This would
      match the behavior of C.&nbsp; Whereas in Python, for example, the
      counter for an equivalent loop would have the value 100 rather
      than 101 after normal termination of the loop.<br>
    </blockquote>
    <h2>Order of Evaluation of Procedure Operands</h2>
    <p>In an XPL string-concatenation expression like this one,<br>
    </p>
    <blockquote>
      <pre>EXPRESSION1 || EXPRESSION2<br></pre>
    </blockquote>
    <p>while I've found no documentation concerning it, XPL/I expects
      the operands to be evaluated in left-to-right order.&nbsp; I.e., <code>EXPRESSION1</code>
      is evaluated first, then <code>EXPRESSION2</code> is evaluated,
      and then they are concatenated.&nbsp; Normally this ordering
      doesn't matter, but it matters if as a side-effect of <code>EXPRESSION1</code>
      some values needed to compute <code>EXPRESSION2</code> are
      altered, or vice-versa.&nbsp; I know that this is the expectation
      because I have found code in <b>PASS2</b> of <b>HAL/S-FC</b>
      that does not work as needed if a right-to-left order of
      evaluation is used.<br>
    </p>
    <p><i>Presumably,</i> the left-to-right ordering should be enforced
      on <i>all</i> calls to procedures, and possibly all operator
      expressions, rather than just this string-concatenation
      example.&nbsp; <b>XCOM-I</b> already enforces left-to-right order
      in calls to all XPL procedures, but prior to this finding it did
      not enforce an ordering on parameter evaluation in calls to
      runtime-library functions.&nbsp; Frankly, it had never occurred to
      me that a C compiler might evaluate such arguments in
      right-to-left order.&nbsp; But some do, under some circumstances,
      and can do so because the C standard apparently does not specify
      the ordering.<br>
    </p>
    <p>As it stands presently:<br>
    </p>
    <ul>
      <li><b>XCOM-I</b> enforces left-to-right evaluation of arguments
        of XPL procedures.</li>
      <li><b>XCOM-I</b> enforces left-to-right evaluation of operands
        for operator expressions (such as <code>op1||op2</code> or <code>op1+op2</code>).</li>
      <li><b>XCOM-I</b> does not presently enforce any particular order
        of evaluation on other runtime-library functions (such as <code>SUBSTR</code>
        or <code>SHL</code>), but may be changed to do so in the future
        if problems become apparent.<br>
      </li>
    </ul>
    <p>In <i>A Compiler Generator</i>, Fig. 6.18.1 depicts the assembly
      code generated for a sample XPL program having several
      library-function calls with 2 or 3 parameters.&nbsp; In those
      examples, the code for the arguments is always in left-to-right
      order.<br>
    </p>
    <blockquote><font size="-1"><b>The example:</b>&nbsp; Look at this
        line in <b>HAL/S-FC</b>'s PASS2.PROCS/OBJECTGE.xpl:<br>
      </font>
      <blockquote>
        <pre><font size="-1">S2=GENERATE_OPERANDS || TAG_NAME;                                07411000<br></font></pre>
      </blockquote>
    </blockquote>
    <blockquote>
      <p><font size="-1">Here, <code>GENERATE_OPERANDS</code> is a <code>PROCEDURE</code>,
          and calling it has the side-effect of setting the <code>TAG_NAME</code>
          appropriately.&nbsp; </font><font size="-1"><font size="-1"><code>GENERATE_OPERANDS</code></font>
          therefore must be executed before <code>TAG_NAME</code> is
          used.&nbsp; (And it does no good to argue that </font><font
          size="-1"><font size="-1"><code>TAG_NAME</code></font> is
          merely string descriptor rather than a string so that it
          doesn't "evaluate" anything, since when </font><font
          size="-1"><font size="-1"><font size="-1"><code>GENERATE_OPERANDS</code></font></font>
          modifies the string it modifies the string descriptor
          too.)&nbsp; In <b>XCOM-I</b>, the string-concatenation
          operator<code></code> is implemented as a function, <code>xsCat</code>,
          so the two string operands are the two function
          parameters.&nbsp; I found that <b>clang</b> evaluated the
          function parameters left-to-right in a test program I created,
          while <b>gcc</b> evaluated them right-to-left.&nbsp; Whether
          they do that consistently or not, I don't know, but if they <i>ever</i>
          do it right-to-left it's a problem!&nbsp; If the ordering were
          not forced by <b>XCOM-I</b> to be correct, <b>clang</b>
          would print assembly code in <b>PASS2</b> correctly, such as<br>
        </font></p>
      <blockquote>
        <pre><font size="-1">00000 E8F3 0000                              LHI    R0,0()              TIME: 0.25; @0HELLO<br></font></pre>
      </blockquote>
      <p><font size="-1">while <b>gcc</b> would print it incorrectly,
          such as<br>
        </font></p>
      <blockquote>
        <pre><font size="-1">00000 E8F3 0000                              LHI    R0,0()              @0HELLO<br></font></pre>
      </blockquote>
      <font size="-1">The printout that includes the <code>TIME</code>
        must be the correct one, because otherwise the elaborate XPL
        procedure that constructs the time (<code>EXECUTION_TIME</code>)
        would have no effect at all.<br>
      </font></blockquote>
    <blockquote> </blockquote>
    <h1><a name="programOptions"></a>Program Options</h1>
    <p>As far as I've been able to determine, the standard XPL of <i>A
        Compiler Generator</i> did not support program options presented
      at program-start time.&nbsp; The submonitor program provided with
      <b>XCOM3</b> did have some such program options, but they were
      consumed only by the submonitor and were not passed to the XPL
      program.<br>
    </p>
    <p>In XPL/I, on the other hand, the XPL program could indeed accept
      a rich set of options, from a JCL object known as the "PARM
      field".&nbsp; One of the XPL built-in functions, the <font
        color="#663300"><code>MONITOR</code></font> function, was
      provided to access submonitor services, but <i>A Compiler
        Generator</i> left it basically undefined, presumably since any
      functionality it provided would be highly program-specific.&nbsp;
      In XPL/I, on the other hand, the <font color="#663300"><code>MONITOR</code></font>
      function is indeed defined with a rich set of features, and in
      particular, <font color="#663300"><code>MONITOR(13)</code></font>
      passes the submonitor the name of an "options processor", and the
      submonitor returns a set of program options (as interpreted by the
      selected options processor) back to the XPL/I program.<br>
    </p>
    <p>In <b>HAL/S-FC</b>, there are three different options processors
      defined, "COMPOPT" for pass 1 of the compiler, "LISTOPT" for pass
      4 of the compiler, and "MONOPT" for the submonitor.&nbsp; At the
      present time, the <b>XCOM-I</b> runtime library supports these
      three options processors, and none other.&nbsp; Since the
      particular program options supported are specific to <b>HAL/S-FC</b>,
      they won't be covered here, but are covered in great detail on <a
        moz-do-not-send="true" href="HAL.html">the <b>HALSFC</b> page</a>.<br>
    </p>
    Besides the program options passed to the XPL program at startup,
    there were position-dependent options ("control toggles") which
    could be inserted directly into the XPL program within its
    comments.&nbsp; <a moz-do-not-send="true"
      href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=830">Early










      documentation</a> indicates that control toggles could appear also
    appear in the PARM field.&nbsp; <i><b>XCOM-I</b></i><i> does not
      support either of these features.</i>&nbsp; But <b>XCOM</b><b><i>x</i></b>
    as compiled by <b>XCOM-I</b> does support these features, and
    they're encountered in legacy XPL code, which is why I'm covering
    them here.<br>
    <br>
    Control toggles are two-character strings which normally would be
    embedded in program comments.&nbsp; Generally speaking, program
    comments are ignored by compilers.&nbsp; But when these particular
    two-character strings are found within a program comment of an XPL
    program, they are used to enable certain program features from the
    point they appear until a countermanding control toggle is
    found.&nbsp; The control toggles I'm aware of that were supported by
    one or another version of <b>XCOM<i>x</i></b> are listed
    below.&nbsp; Not all of them are necessarily suitable for
    command-line usage anyway; for example, the action of "<font
      color="#663300"><code>$|</code></font>" depends on its particular
    punch-card column in which it appears.&nbsp; The list below has been
    merged from <i>A Compiler Generator</i> (p. 148), IR-182-1 (section
    13.4), and <b>XCOM45 </b> source code:<br>
    <ul>
      <li><font color="#663300"><code>$B</code></font> — Interlist code
        bytes in hexadecimal.</li>
      <li><font color="#663300"><code>$D</code></font> — Print
        compilation statistics and symbol table at the end of
        compilation (initially enabled).</li>
      <li><font color="#663300"><code>$E</code></font> — Interlist
        emitted code (assembly format) and data.</li>
      <li><font color="#663300"><code>$I</code></font> — Print Impact
        summary, indicating variables outside the scope of any procedure
        which were referenced, plus procedures called.&nbsp; (Default =
        Off.)<br>
      </li>
      <li><font color="#663300"><code>$L</code></font> — List the
        compiled program (listing is initially enabled).</li>
      <li><font color="#663300"><code>$M</code></font> — List program
        without auxiliary information (speeds compilation by minimizing
        string storage usage).</li>
      <li><font color="#663300"><code>$N</code></font> — Produce a
        warning message if a procedure is called with fewer actual than
        formal parameters.</li>
      <li><font color="#663300"><code>$Q</code></font> — This toggle
        seems to have been available for a while and then
        discontinued.&nbsp; It <i>may</i> have caused compilation to
        terminate after processing the library file.<br>
      </li>
      <li><font color="#663300"><code>$R</code></font> — Collect
        cross-reference data for each symbol (based on statement
        numbers) and print with symbol table. (Default = On.)<br>
      </li>
      <li><font color="#663300"><code>$S</code></font> — Dump symbol
        table at the end of each procedure, if any local data is
        declared. (Default = Off.)<br>
      </li>
      <li><font color="#663300"><code>$T</code></font> — Begin tracing
        execution of XCOM at this point, during compilation.</li>
      <li><font color="#663300"><code>$U</code></font> — Terminate
        tracing of XCOM.</li>
      <li><font color="#663300"><code>$V</code></font> — Expand variable
        cross reference to include names of procedures referencing data
        and names of procedures calling other procedures.&nbsp; (Default
        = Off.)</li>
      <li><font color="#663300"><code>$X</code></font> — Do not abort
        compilation when ceiling on count of severe errors has been
        exceeded.<br>
      </li>
      <li><font color="#663300"><code>$Y</code></font> — Use <font
          color="#663300"><code>'|'</code></font> as margin marker
        rather than <font color="#663300"><code>'I'</code></font>.<br>
      </li>
      <li><font color="#663300"><code>$Z</code></font> — Allow the
        compiled program to execute in spite of severe errors.</li>
      <li><font color="#663300"><code>$|</code></font> — Set
        margin.&nbsp; The portion of succeeding cards starting from the
        column containing the | will be ignored.&nbsp; Note that this
        can only be used to make the card width <i>shorter</i> than 80
        columns.<br>
      </li>
    </ul>
    Although <b>XCOM-I</b> doesn't support control toggles in the PARM
    field, there is a command-line option that can be made to serve the
    same purpose:&nbsp; The <font color="#663300"><code>--extra=<i>N</i>,'<i>STRING</i>'</code></font>
    option causes the <font color="#663300"><code><i>STRING</i></code></font>
    to be returned to the XPL program upon the first invocation of <font
      color="#663300"><code>INPUT(<i>N</i>)</code></font>; subsequent
    invocations of <font color="#663300"><code>INPUT(<i>N</i>)</code></font>
    get data from the file attached to input <font color="#663300"><code><i>N</i></code></font>.&nbsp;










    So for example, if you wanted to use the control toggle <font
      color="#663300"><code>$E</code></font>, but didn't want to modify
    your XPL source code to add it into a comment, you could use the
    command-line option <font color="#663300"><code>--extra=0,'/* $E
        */'</code></font>.<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;










      </font><font size="-1">Again, just to be clear, <b>XCOM-I</b> <i>itself</i>
        has no cognizance whatever of control toggles.&nbsp; Control
        toggles, if available, are provided to and used by legacy
        versions of <b>XCOM<i>x</i></b> which <b>XCOM-I</b> may have
        compiled for you!</font> </blockquote>
    If you're writing <i>new</i> XPL or XPL/I programs, of course, then
    you still may want your own custom command-line options for
    it.&nbsp; <a moz-do-not-send="true" href="#builtin">The built-in
      library function</a> <font color="#663300"><code>PARM_FIELD</code></font>
    returns a string containing the value of the <font color="#663300"><code>--parm</code></font>
    command-line switch as-is. You can therefore just write XPL code to
    parse <font color="#663300"><code>PARM_FIELD</code></font>. <br>
    <blockquote> </blockquote>
    <font color="#663300"><code></code></font>
    <ul>
    </ul>
    <h1><a name="builtin"></a>Built-In Runtime-Library Functions</h1>
    <p>Standard XPL has a variety of so-called "built-ins", comprising
      runtime-library functions callable from XPL code. Some of these
      bullt-ins can appear on either the right-hand or left-hand side of
      assignments, and some have to be <font color="#663300"><code>CALL</code></font>'d










      like user-defined <font color="#663300"><code>PROCEDURE</code></font>s.











      XPL/I has roughly the same built-ins, plus-or-minus a few, mostly
      (but not entirely) defined to have the same functionality. The
      compiler recognizes these built-ins, and there is no need for them
      to be declared in any way prior to use. Since these built-ins were
      mostly written originally in IBM System/360 basic assembly
      language, the runtime library supplied with <b>XCOM-I</b> has
      been entirely written in C, without any reference to the original
      runtime-library source code.<br>
    </p>
    <p>The list below is from <i>A Compiler Generator</i> (p. 140-142),
      with some alterations due to XPL/I, and some hopefully-helpful
      notes from me. The parameter descriptions in the list below
      identify the datatypes of parameters by the following convention:<br>
    </p>
    <ul>
      <li><font color="#663300"><code>FIXED</code></font> — <code><font
            color="#663300">NE</font></code><font color="#663300"><code><sub>x</sub></code></font></li>
      <li><font color="#663300"><code>CHARACTER</code></font> descriptor
        — <font color="#663300"><code></code><code>DE<sub>x</sub></code></font></li>
      <li>Symbolic name of a variable, with or without a subscript — <font
          color="#663300"><code></code><code>V</code></font></li>
    </ul>
    <p>I suppose I should make it clear that the <b>XCOM-I</b>
      environment is not precisely like that envisaged in the original
      XPL language as confined to an IBM 360 runtime environment, and as
      such, built-in functions don't work exactly the same way either.
      What's described here is how <i>the </i><i><b>XCOM-I</b></i><i>
        runtime library's functions </i>corresponding to the original
      built-in functions work.<br>
    </p>
    <ul>
    </ul>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <caption><font size="+1"><b>Built-Ins</b></font></caption> <tbody>
        <tr>
          <th valign="bottom" align="center">Library Function<br>
          </th>
          <th valign="bottom">Description From Original Documentation<br>
          </th>
          <th valign="bottom">Additional Notes<br>
          </th>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>ABS(NE)</code><code><br>
              </code></font></td>
          <td valign="middle">This function returns the absolute value
            of <font color="#663300"><code>NE</code></font>.&nbsp;
            (Note: "80000000", the maximum negative number, has no
            representable absolute value and returns "7FFFFFFF", the
            maximum positive number.)<br>
          </td>
          <td valign="middle">(XPL/I only.)<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>ADDR(V)</code></font></td>
          <td valign="middle">A function with numeric value which is the
            (at most) 24-bit absolute address of the variable
            (subscripted or not) <font color="#663300"><code>V</code></font>.&nbsp;










            Mostly used in conjunction with <font color="#663300"><code>COREWORD</code></font>
            or <font color="#663300"><code>COREBYTE</code></font>.<br>
          </td>
          <td valign="middle">If the variable has a subscript, then the
            returned address is that of a specific array element, rather
            than of the beginning of the array.&nbsp; For a <font
              color="#663300"><code>CHARACTER</code></font> or long <code><font
                color="#663300">BIT</font></code> string (i.e., for <font
              color="#663300"><code>BIT(33)</code></font> through <font
              color="#663300"><code>BIT(2048)</code></font> datatypes),
            the returned address is that of the <i>descriptor</i> for
            the variable, and if you want to find the actual data, you
            then must first fetch the value of the descriptor and then
            massage it further.&nbsp; For XPL/I's <font color="#663300"><code>BASED</code></font>
            variables (see IR-182-1 p. 13-3), using the unsubscripted
            name of the variable for <code><font color="#663300">V</font></code><font
              color="#663300"><code></code></font> will return the
            address in memory where the pointer to the <font
              color="#663300"><code>BASED</code></font> variable's data
            is stored; whereas adding the subscript <font
              color="#663300"><code>(0)</code></font> to <code><font
                color="#663300">V</font></code><font color="#663300"><code></code></font>
            returns the address of the variable's data itself.<br>
            <br>
            There are two exceptional cases, due to the fact that unlike
            the original XPL compilers, program code in <b>XCOM-I</b>
            exists in a separate memory space outside of the simulated
            XPL memory in which variable exist.&nbsp; Therefore,
            attempts to use <font color="#663300"><code>ADDR(V)</code></font>
            to find addresses in code space, such as addresses of XPL
            built-ins or of program labels, have to be treated very
            differently than addresses of variables, if sensible results
            are to be obtained.<br>
            <br>
            Insofar as addresses of runtime-library functions are
            concerned, the only case I'm aware of is <font
              color="#663300"><code>ADDR(DESCRIPTOR)</code></font>.&nbsp;










            In this case, <font color="#663300"><code>ADDR</code></font>
            returns the address immediately following <a
              moz-do-not-send="true" href="#common"><font
                color="#663300"><code>COMMON</code></font> memory</a>.&nbsp;










            The reason for this <i>ad hoc</i> behavior is that the
            XPL/I memory-management system (SPACELIB) uses the location
            of the built-in variable <font color="#663300"><code>DESCRIPTOR</code></font>
            (see below) to determine the cutoff between <font
              color="#663300"><code>COMMON</code></font> (in low memory)
            and non-<font color="#663300"><code>COMMON</code></font> (in
            higher memory).&nbsp; But I realized this fact too late in
            the development process, after I had made decisions about
            implementation and memory layout that were incompatible with
            the interpretation of <font color="#663300"><code>DESCRIPTOR</code></font>
            as a normal variable with the desired properties.<br>
            <blockquote><font size="-1"><b>Aside:</b>&nbsp;&nbsp; It
                isn't <i>terribly</i> difficult to undo the
                incompatible design decisions I mentioned, and sometime
                in the future I may do so.&nbsp; Technically, I think
                it's mainly a matter of swapping <a
                  moz-do-not-send="true" href="#MemoryModel">memory
                  regions 2 and 3</a>.&nbsp; Again technically, it is
                necessary for <a moz-do-not-send="true"
                  href="#basedManagement">the dope vectors of all BASED
                  variables</a> to reside in the lowest 64K of memory,
                so it would have the effect of reducing the possible
                number of non-<font color="#663300"><code>COMMON BASED</code></font>
                variables; fortunately, if existing XPL/I code is any
                guide, that's a pretty-negligible problem.<br>
              </font></blockquote>
            Insofar as program labels are concerned, as far as I know,
            there's no mechanism in XPL itself for using the memory
            address of a program label.&nbsp; Consequently, the only
            reason for finding the address of an XPL program label is
            that assembly language (in a <font color="#663300"><code>CALL










                INLINE</code></font>) wants either to branch to that
            address, or else to somehow use the data in another <font
              color="#663300"><code>CALL INLINE</code></font> at that
            address.&nbsp; But this notion is based on various
            assumptions that are false in <b>XCOM-I</b>. &nbsp;
            Nevertheless, in spite of that fact, we still need some
            uniform method of handling such "addresses" that allows <font
              color="#663300"><code>ADDR</code></font> and <font
              color="#663300"><code>CALL INLINE</code></font> to
            interact smoothly.&nbsp; <br>
            <br>
            <b>XCOM-I</b> handles addresses of XPL labels as
            follows:&nbsp; The labels in any <font color="#663300"><code>PROCEDURE</code></font>
            are assigned a predictable sequence of unique <i>negative</i>
            addresses.&nbsp; Thus the first label encountered has the
            address -1, the second has address -2, and so on.&nbsp; The
            addresses are local to the <font color="#663300"><code>PROCEDURE</code></font>,
            and restart at -1 in each <font color="#663300"><code>PROCEDURE</code></font>.&nbsp;










            <font color="#663300"><code>ADDR</code></font> returns these
            negative addresses.&nbsp; C implementations of the branch
            instructions in <font color="#663300"><code>CALL INLINE</code></font>
            statements can exploit that by having a jump table of a form
            similar to:<br>
            <blockquote>
              <pre>switch (address) {<br>  case -1: goto LABEL1;<br>  case -2: goto LABEL2;<br>  ...<br>}<br></pre>
            </blockquote>
            Admittedly, this is not a terribly-efficient solution, but C
            has no practical computed-goto other than this, as far as
            I'm aware. <br>
            <blockquote><font size="-1"> </font></blockquote>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE,NE)<br>
              </code></font></td>
          <td valign="middle">A function with numeric value given by the
            <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font>
            8 bits of the string described <font color="#663300"><code>DE</code></font>.<br>
          </td>
          <td valign="middle">By "string", <i>A Compiler Generator</i>
            means either <font color="#663300"><code>CHARACTER</code></font>
            data or <font color="#663300"><code>BIT</code></font>
            data.&nbsp; As far as <font color="#663300"><code>BIT</code></font>
            data is concerned, this function works for any data-width;
            i.e., for <font color="#663300"><code>BIT(1)</code></font>
            through <font color="#663300"><code>BIT(2048)</code></font>,
            and not just for "long" <font color="#663300"><code>BIT</code></font>
            string.&nbsp; However, there's some difference between how <font
              color="#663300"><code>CHARACTER</code></font> and <font
              color="#663300"><code>BIT</code></font> data is
            treated.&nbsp; <font color="#663300"><code>BIT</code></font>
            data is retrieved from memory as-is, whereas <font
              color="#663300"><code>CHARACTER</code></font> data is
            transparently translated between EBCDIC encoding (in memory)
            vs ASCII encoding (for manipulation) by the software.&nbsp;
            The latter behavior is specific to <b>XCOM-I</b>, and
            wouldn't have been needed by the original <b>XCOM</b>,
            since back then, all <font color="#663300"><code>CHARACTER</code></font>
            data was encoded in EBCDIC all the time, whether or not it
            resided in "memory".&nbsp; Moreover, if you try to do so, it
            is possible to fool <b>XCOM-I</b>'s <font color="#663300"><code>BYTE</code></font>
            function into thinking an area of memory is a different
            datatype than it really is, thus defeating the translation
            mechanism ... so please don't try to do that.<br>
            <br>
            Note that <font color="#663300"><code>BYTE</code></font>
            can appear either in an expression (such as on the
            right-hand side of an assignment), in which case it returns
            a value as just described, or else on the left-hand side of
            an assignment, in which case it modifies the value stored in
            memory.&nbsp; <i>A Compiler Generator</i> recommends not
            using <font color="#663300"><code>BYTE</code></font> on the
            left-hand side of an assigment, due to the possibility of
            unintended consequences.<br>
            <br>
            The documentation does not explain what's supposed to happen
            if <font color="#663300"><code>NE</code><code>&lt;0</code></font>
            or <font color="#663300"><code>NE</code><code>&gt;=len(</code><code>DE</code><code>)</code></font>.&nbsp;










            Alas, that's not a theoretical question, because such uses
            of <font color="#663300"><code>BYTE</code></font> really
            appear in legacy XPL code.&nbsp; Given the sloppy
            subscripting accepted by XPL, my guess is that <font
              color="#663300"><code>BYTE</code></font> just grabs
            whatever happens to reside wherever <font color="#663300"><code>NE</code></font>
            leads it.&nbsp; Unlike the usual sloppy subscripting in XPL
            code, this would almost certainly be a mistake by the
            programmer, because the location of string data in memory is
            dynamically assigned and liable to change during the course
            of execution, so the programmer can't really know reliably
            what lies beyond the bounds of a string.&nbsp; Thus my guess
            is that when <font color="#663300"><code>NE</code></font>
            is out of bounds for the string size, it's probably a
            mistake on the part of the program that was never detected
            because it never produced any error messages.<br>
            <blockquote><font size="-1"><b>Aside:</b> For example, it
                happens in the <font color="#663300"><code>SCAN</code></font>
                procedure of <b>XCOM</b>, in the vicinity of line 835
                at this writing,<br>
              </font>
              <blockquote>
                <pre><font size="-1" color="#663300">CP = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>DO WHILE BYTE(TEXT, CP) = BYTE(' ') &amp; CP &lt;= TEXT_LIMIT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>   CP = CP + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>END;&nbsp;&nbsp;</font><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></pre>
              </blockquote>
              <font size="-1">where <font color="#663300"><code>TEXT</code></font>
                happens to be a string with <font color="#663300"><code>LEN(TEXT)=1</code></font>
                containing a single blank space, and <font
                  color="#663300"><code>TEXT_LIMIT=0</code></font>.&nbsp;










                Here, <font color="#663300"><code>BYTE(TEXT,CP)</code></font>
                is out of bounds on the very first iteration of the
                loop.&nbsp; In C, if the operands of the <font
                  color="#663300"><code>&amp;</code></font> operator
                were reversed, then <font color="#663300"><code>BYTE(TEXT,CP)</code></font>
                would never be executed, and the problem would be
                avoided.&nbsp; But <i>if</i> that kind of optimization
                of conditionals is a feature of XPL, it's not a feature
                that's mentioned anywhere to my knowledge, and <b>XCOM-I</b>
                does not attempt it.</font><br>
            </blockquote>
            Whether or not that's a true interpretation, in <b>XCOM-I</b>
            the <font color="#663300"><code>BYTE</code></font> function
            returns a value of 0 (corresponding to an EBCDIC <font
              color="#663300"><code>NUL</code></font>) if <font
              color="#663300"><code>NE</code></font> is out of bounds,
            or else silently does nothing at all if on the left-hand
            side of an assignment.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE)<br>
              </code></font></td>
          <td valign="middle">Same as <font color="#663300"><code>BYTE(DE,0)</code></font></td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>CLOCK_TRAP<br>
              </code></font></td>
          <td valign="middle">Not supported in <b>XCOM</b>.</td>
          <td valign="middle">And it's not supported in <b>XCOM-I</b>
            either.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>COMPACTIFY<br>
              </code></font></td>
          <td valign="middle">A procedure called automatically to repack
            the free storage area for string data when it is exhausted.
            Calls can be triggered by <font color="#663300"><code>||</code></font>,
            <font color="#663300"><code>INPUT</code></font>,
            number-to-string conversions, or an explicit call:<br>
            <blockquote><font color="#663300"><code>CALL COMPACTIFY;<br>
                </code></font></blockquote>
            <font color="#663300"><code></code></font>The variables <font
              color="#663300"><code>FREEBASE</code></font>, <font
              color="#663300"><code>FREELIMIT</code></font>, <font
              color="#663300"><code>FREEPOINT</code></font>, <font
              color="#663300"><code>DESCRIPTOR</code></font>, and <font
              color="#663300"><code>NDESCRIPT</code></font> are used by
            <font color="#663300"><code>COMPACTIFY</code></font>.<br>
            <font color="#663300"><code></code></font></td>
          <td valign="middle">The "free-storage area" is where the data
            for <font color="#663300"><code>CHARACTER</code></font> and
            long <font color="#663300"><code>BIT</code></font>-string
            variables is stored.&nbsp; As a program which involves
            string variables executes, the strings tend to change size
            and move around in the free-storage area, thus causing
            unused "holes" in memory to develop.&nbsp; <font
              color="#663300"><code>COMPACTIFY</code></font> repacks the
            area so as to remove the holes.<br>
            <blockquote> <font size="-1"><b>Aside:</b>&nbsp; While long
                <font color="#663300"><code>BIT</code></font>-strings
                (&gt;32 bits) are technically similar to <font
                  color="#663300"><code>CHARACTER</code></font> strings,
                they differ in the fact that the amount of storage they
                require is determined at compile-time and does not
                change after that.&nbsp; The original </font><font
                size="-1"><i>A Compiler Generator</i> and Intermetrics
                compilers therefore stored them outside of the
                free-storage area — or at least in the very lowest
                addresses of the free-string area </font><font
                size="-1"><font size="-1">—</font> in order to save any
                execution time that would otherwise have been wasted
                during allocation of memory or garbage allocation.&nbsp;
                <b>XCOM-I</b> is not so picky, since even the most
                feeble modern computer will be approximately 14.3926
                gazillion times faster than an IBM 360 was.&nbsp; <b>XCOM-I</b>
                thus saves (me) a little effort by grouping the long bit
                strings with the character strings in memory, at an
                immeasurably-small cost in execution time.</font><br>
            </blockquote>
            XPL/I's <font color="#663300"><code>BASED</code></font>
            variables are stored in a separate memory region and do not
            participate in garbage collection by <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp;










            <a moz-do-not-send="true" href="#MemoryModel">See the
              earlier discussion of this</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>COREBYTE(NE)<br>
              </code></font></td>
          <td valign="middle">A byte array identical to the IBM
            System/360 memory.&nbsp; The subscript is the absolute byte
            address of the byte selected.&nbsp; <font color="#663300"><code>COREBYTE</code></font>
            may be used on either side of the replacement operator
            (i.e., <font color="#663300"><code>=</code></font>).<br>
          </td>
          <td valign="middle">The function returns a <font
              color="#663300"><code>FIXED</code></font> value, if used
            in an expression, but only the least-significant 8 bits
            contain the value.&nbsp; Similarly, if used on the left-hand
            side of an assignment, it receives a <font color="#663300"><code>FIXED</code></font>
            value from the right-hand side, but only stores the
            least-significant 8 bits at the specified memory
            address.&nbsp; The <b>XCOM-I</b> version of this function
            performs no EBCDIC translation as <font color="#663300"><code>BYTE</code></font>
            (see above) does, so it does not expect the data in memory
            to be <font color="#663300"><code>CHARACTER</code></font>
            data.&nbsp; Whether this will turn out to be an issue
            remains to be seen.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>COREWORD(NE)<br>
              </code></font></td>
          <td valign="middle">Like <font color="#663300"><code>COREBYTE</code></font>,
            except the subscript corresponds to the word address in
            memory.&nbsp; Thus an assignment to <font color="#663300"><code>COREBYTE(4)</code></font>
            can change <font color="#663300"><code>COREWORD(1)</code></font>.<br>
          </td>
          <td valign="middle">Since XPL has only a 24-bit address space,
            only the least-significant 3 bytes of the "4-byte word
            address" <font color="#663300"><code>NE</code></font> are
            used.&nbsp; According to IR-182-1 (p. 13-3), this function <i>differs</i>
            in XPL/I as follows:<br>
            <blockquote><font size="-1">According to "<i>A COMPILER
                  GENERATOR</i>", <font color="#663300"><code>NE</code></font>
                is a word index, or word-aligned address. However, in
                the Intermetrics version, <font color="#663300"><code>NE</code></font>
                must be a byte address, and the user must himself
                guarantee that the lower-most two bits are 0's (full
                word aligned).</font><br>
            </blockquote>
            I <i>think</i> that what's being implied by this cryptic
            comment is that <i>A Compiler Generator</i>'s <font
              color="#663300"><code>COREWORD</code></font> in XPL worked
            like this:<br>
            <ul>
              <li><font color="#663300"><code>COREWORD(0)</code></font>
                consists of <font color="#663300"><code>COREBYTE(0)</code></font>
                through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
              <li><font color="#663300"><code>COREWORD(1)</code></font>
                consists of <font color="#663300"><code>COREBYTE(4)</code></font>
                through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
              <li><font color="#663300"><code>COREWORD(2) </code></font>consists










                of <font color="#663300"><code>COREBYTE(8)</code></font>
                through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
              <li>and so on.</li>
            </ul>
            <p>whereas Intermetrics's <font color="#663300"><code>COREWORD</code></font>
              in XPL/I worked like this:<br>
            </p>
            <ul>
              <li><font color="#663300"><code>COREWORD(0)</code></font>
                consists of <font color="#663300"><code>COREBYTE(0)</code></font>
                through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
              <li><font color="#663300"><code>COREWORD(1)</code></font>
                is illegal.</li>
              <li><font color="#663300"><code>COREWORD(2)</code></font>
                is illegal.</li>
              <li><font color="#663300"><code>COREWORD(3)</code></font>
                is illegal.</li>
              <li><font color="#663300"><code>COREWORD(4)</code></font>
                consists of <font color="#663300"><code>COREBYTE(4)</code></font>
                through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
              <li><font color="#663300"><code>COREWORD(5)</code></font>
                is illegal.</li>
              <li><font color="#663300"><code>COREWORD(6)</code></font>
                is illegal.</li>
              <li><font color="#663300"><code>COREWORD(7)</code></font>
                is illegal.</li>
              <li><font color="#663300"><code>COREWORD(8) </code></font>consists










                of <font color="#663300"><code>COREBYTE(8)</code></font>
                through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
              <li><font color="#663300"><code>COREWORD(9)</code></font>
                is illegal.</li>
              <li>and so on.</li>
            </ul>
            <p>To my way of thinking, <i>A Compiler Generator</i>'s
              description doesn't say what IR-182-1 says it says, and
              unfortunately, <i>A Compiler Generator</i>'s
              clarification that "an assignment to <font
                color="#663300"><code>COREBYTE(4)</code></font> can
              change <font color="#663300"><code>COREWORD(1)</code><font
                  color="#000000">", does not in fact clarify it very
                  much either.<br>
                </font></font></p>
            <p><font color="#663300"><font color="#000000"><b>XCOM-I</b>
                  conforms to the latter (Intermetrics) usage, with the
                  exception that addresses like 1, 2, 3, 5, 6, 7, 9, ...
                  are perfectly fine: </font></font><font
                color="#663300"><code>COREWORD(1)</code></font> consists
              of <font color="#663300"><code>COREBYTE(1)</code></font>
              through <font color="#663300"><code>COREBYTE(4)</code></font>,
              and so on. Which conforms just fine to the description in
              <i>A Compiler Generator</i> as well, if not necessarily to
              <i>A Compiler Generator</i>'s actual usage.<br>
            </p>
            <blockquote><font size="-1"><b>Aside:</b>&nbsp; In point of
                fact, </font><font size="-1"><font color="#663300"><code>COREWORD</code></font>
                is not used in any software written in standard XPL
                that's available to me, so I cannot determine
                empirically which of these choices (if either) is
                correct.&nbsp; If it is somehow discovered later that <b>XCOM3</b>
                really does need to behave in the manner Intermetrics
                claimed that it did, then <b>XCOM-I</b>'s <font
                  color="#663300"><code>--xpl</code></font> command-line
                switch will be extended to select between the two
                behaviors.&nbsp; But I don't intend to waste any effort
                implementing that until/unless I have enough evidence to
                justify it.&nbsp; For now, it's a moot point.</font><br>
            </blockquote>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>DATE<br>
              </code></font></td>
          <td valign="middle">A function with the numeric value of the
            date, coded as<br>
            <blockquote>(day of year) + 1000 * (year - 1900)<br>
            </blockquote>
          </td>
          <td valign="middle"><i>A Compiler Generator</i> doesn't inform
            us of anything so mundane as the time zone to which the <font
              color="#663300"><code>DATE</code></font> and <font
              color="#663300"><code>TIME</code></font> built-ins relate,
            at least not in the text of the book.&nbsp; <b><br>
            </b><br>
            I have been told that <i>A Compiler Generator</i> would
            have used local time here.&nbsp; The submonitor function
            supplying this value would appear to be called <font
              color="#663300"><code>GETIME</code></font>, and identical
            versions of <font color="#663300"><code>GETIME</code></font>
            are used by the <b>XCOM3</b>, <b>XCOM45</b>, and <b>HAL/S-FC</b>
            submonitors, so if <i>A Compiler Generator</i> used local
            time, then all other legacy compilers available at present
            did so as well.&nbsp; Exactly how <font color="#663300"><code>GETIME</code></font>
            works isn't clear to me.&nbsp; But if what I understand from
            looking at the <i>IBM System/360 Operating System MFT
              Supervisor</i> manual is correct, the IBM 360 seems to
            have had no conception of UTC at all, or for that matter, of
            local timezones either; it simply knew whatever time and
            date the operator&nbsp; manually input into the system at
            each power-up, and what the operator was supposed to input
            was the <i>local</i> time and date.<br>
            <br>
            Consequently, the <font color="#663300"><code>DATE</code></font>
            and <font color="#663300"><code>TIME</code></font>
            built-ins return the local date and time, according to
            whatever locale your computer is set for.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>DATE_OF_GENERATION<br>
              </code></font></td>
          <td valign="middle">A word variable initialized with the value
            of <font color="#663300"><code>DATE</code></font> during
            compilation of the program being run.<br>
          </td>
          <td valign="middle">See <font color="#663300"><code>DATE</code></font>
            above. </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>DESCRIPTOR(NE)<br>
              </code></font></td>
          <td valign="middle">The description of the <font
              color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font>
            string as a numeric value.<br>
          </td>
          <td valign="middle">This cryptic description is referring to
            the fact that in the way memory is allocated for the
            variables declared by <b>XCOM</b>, the 32-bit string
            descriptors for all <font color="#663300"><code>CHARACTER</code></font>
            and <font color="#663300"><code>BIT(n)</code></font> (<font
              color="#663300"><code>n</code></font>&gt;32) variables
            appear consecutively in memory.&nbsp; By symbolically
            labeling the very first of those descriptors as <font
              color="#663300"><code>DESCRIPTOR</code></font>, and
            treating <font color="#663300"><code>DESCRIPTOR</code></font>
            as of the <font color="#663300"><code>FIXED</code></font>
            datatype, <font color="#663300"><code>DESCRIPTOR</code></font>
            becomes an easily-accessible array of all the string
            descriptors.&nbsp; This is useful, for example, for
            memory-management procedures like <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp;










            The number of elements of the array is given by the built-in
            <font color="#663300"><code>NDESCRIPT</code></font> (see
            below).<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>EXIT</code><code><br>
              </code></font></td>
          <td valign="middle">A procedure<br>
            <blockquote><font color="#663300"><code>CALL EXIT;</code></font><br>
            </blockquote>
            which causes an abnormal exit form XPL execution. <br>
          </td>
          <td valign="middle">In fact, <b>XCOM-I</b> models this a
            C-language <font color="#663300"><code>exit(1)</code></font>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>FILE(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
              </code></font></td>
          <td valign="middle">An array-valued pseudovariable for
            manipulation of random-access bulk storage.&nbsp; Examples
            of its use are<br>
            <blockquote><font color="#663300"><code>DECLARE BUFF(3600)
                  BIT(8);</code><code><br>
                </code><code>BUFF = FILE(I, J);</code><code><br>
                </code><code>FILE(I-1, J) = BUFF;</code></font><br>
            </blockquote>
            One record is transferred into or out of the buffer array by
            the assignments shown above.&nbsp; FILE cannot appear on
            both sides of the same assignment.&nbsp; <br>
          </td>
          <td valign="middle"><a name="file"></a>I've actually truncated
            <i>A Compiler Generator</i>'s description of <font
              color="#663300"><code>FILE</code></font>, because it is so
            long and so much of it is specific to IBM System/360, while
            being quite irrelevant to us.&nbsp; The key facts are these:<br>
            <ul>
              <li>"Random access files" may be attached to the running
                program.&nbsp; <br>
              </li>
              <li>Once attached, they are identified by a "device
                number" that ranges from 1 to 9.&nbsp; <br>
              </li>
              <li>Each attached random-access file may be for
                input-only, output-only, or both.&nbsp; <br>
              </li>
              <li>Each of the attached files consists of records of a
                fixed size.</li>
              <li>Different files may have different record sizes.</li>
              <li>These random-access files, and the associated <font
                  color="#663300"><code>FILE</code></font> operations,
                are <i>completely distinct</i> from the "sequential
                files" (numbered 0 through 9) accessed via the <font
                  color="#663300"><code>INPUT</code></font> and <font
                  color="#663300"><code>OUTPUT</code></font> functions
                (see below).</li>
              <li>Record sizes <i>typically</i> do not change during
                program execution. (But see the continued comments
                below.)</li>
            </ul>
            By default, no random-access files are attached to
            programs.&nbsp; Originally (back in 1970), they were
            attached at runtime via Job Control Language (JCL) <font
              color="#663300"><code>DD</code></font> cards.&nbsp; But
            with programs compiled via <b>XCOM-I</b>, files are
            attached at program startup by using the program's
            command-line switches.&nbsp; The relevant switch is <font
              color="#663300"><code>--raf</code></font>, and multiple
            instances can be used on the same command line.<br>
            <blockquote><font color="#663300"><code>--raf=<i>I,R,N,F</i></code></font><br>
            </blockquote>
            The parameters of the <font color="#663300"><code>--raf</code></font>
            switch are:<br>
            <ul>
              <li><font color="#663300"><code>I</code></font> is either
                a literal I (for "input"), a literal O (for "output"),
                or a literal B (for "both input and output"). Note that
                for O, an empty file will always be created by the
                program; for B, if there's an existing file of the
                specified name, then it will be used, but an empty file
                will be created otherwise.</li>
              <li><font color="#663300"><code>R</code></font> is the
                record size associated with the file. 3600 and 7200 are
                typical values, but not the only ones in use. They must
                match the expectations of the program's XPL code for
                using the data.</li>
              <li><font color="#663300"><code>N</code></font> is the
                device number, from 1 through 9, to which the file
                should be attached.</li>
              <li><font color="#663300"><code>F</code></font> is the
                relative or absolute path to the file.</li>
            </ul>
            <p>In spite of what I said above, the XPL/I documentation
              (IR-182-1, p. 13-5) does describe one way to change the
              record size of a random-access file once the program has
              begun operation, and that is via a call to <font
                color="#663300"><code>MONITOR(4,R,N)</code></font> (see
              below), where <font color="#663300"><code>R</code></font>
              and <font color="#663300"><code>N</code></font> have the
              same meanings as for <font color="#663300"><code>--raf</code></font>.
              It also tells us that such a call must precede the first
              use of <font color="#663300"><code>FILE(N)</code></font>.
              <b>XCOM-I</b> relaxes this restriction, though it seems
              that the original restriction should be treated as very
              good advice to follow. Note, by the way, that the call to
              <font color="#663300"><code>MONITOR(4,R,N)</code></font>
              has no way to distinguish between input files and output
              files, so its record-size manipulation is applied
              simultaneously to input file <font color="#663300"><code>N</code></font>
              and output file <font color="#663300"><code>N</code></font>,
              if they differ.<br>
            </p>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>FREEBASE</code><code><br>
              </code></font></td>
          <td valign="middle">A word variable containing the absolute
            address of the top of constant strings and thus the bottom
            of the repackable area.<br>
          </td>
          <td valign="middle">In <b>XCOM-I</b>, this is implemented as
            a function rather than a variable, and is not directly
            modifiable by user code.&nbsp; <br>
            <br>
            What the description from the original documentation is
            trying to say is that most kinds of variables — such as <font
              color="#663300"><code>FIXED</code></font> or <font
              color="#663300"><code>BIT(1)</code></font> types, or
            descriptors for <font color="#663300"><code>CHARACTER</code></font>
            or long <font color="#663300"><code>BIT</code></font>-string










            types, or arrays thereof, or pointers to <font
              color="#663300"><code>BASED</code></font> variables — are
            stored in memory at low addresses determined at compile
            time, and remain unchanged in address thereafter.&nbsp; In
            contrast, data for <font color="#663300"><code>CHARACTER</code></font>
            variables can grow or shrink or move at runtime.&nbsp; <font
              color="#663300"><code>FREEBASE </code></font>is the
            boundary between those regions of memory.<br>
            <br>
            In <b>XCOM-I</b>, data allocated at runtime via the <font
              color="#663300"><code>MONITOR(6,...)</code></font> or <font
              color="#663300"><code>MONITOR(19,...)</code></font>
            function (see below), sometimes for storing data of for <font
              color="#663300"><code>BASED</code></font> variables, also
            appears above the <font color="#663300"><code>FREEBASE</code></font>
            boundary.<font color="#663300"><code></code></font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>FREELIMIT</code><code><br>
              </code></font></td>
          <td valign="middle">A word variable containing the absolute
            address of the last usable byte in the string-data area. <br>
          </td>
          <td valign="middle">I believe that the description lies, and
            that <font color="#663300"><code>FREELIMIT</code></font> is
            the first unusable byte beyond the string-data area, rather
            than the last usable byte in it.<br>
            <br>
            In XPL, all memory beyond <font color="#663300"><code>FREELIMIT</code></font>
            is unused by the program.&nbsp; In XPL/I, the data for <font
              color="#663300"><code>BASED</code></font> variables is
            stored at <font color="#663300"><code>FREELIMIT</code></font>
            and above.&nbsp; However, the memory-management technique
            for is to push <font color="#663300"><code>FREELIMIT</code></font>
            <i>downward</i> in order to make room for <font
              color="#663300"><code>BASED</code></font> variables.&nbsp;
            So for either XPL or XPL/I, the <i>initial</i> value of <font
              color="#663300"><code>FREELIMIT</code></font> is the
            highest memory location used by the program.&nbsp; <b>XCOM-I</b>
            sets the initial value of <font color="#663300"><code>FREELIMIT</code></font>
            at <font color="#663300"><code>"FFFC00"</code></font>
            (i.e., 1024 bytes below the top of physical memory), in
            order to leave a small amount of space for <font
              color="#663300"><code>COMPACTIFY</code></font> to use as
            scratch memory.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>FREEPOINT</code><code><br>
              </code></font></td>
          <td valign="middle">A word variable containing the absolute
            address of the next free byte in the string-data area.&nbsp;
            When <font color="#663300"><code>FREEPOINT</code></font>
            passes <font color="#663300"><code>FREELIMIT</code></font>,
            <font color="#663300"><code>COMPACTIFY</code></font> must be
            called.<br>
          </td>
          <td valign="middle">In other words, at any given time, only
            the memory region between <font color="#663300"><code>FREEPOINT</code></font>
            and <font color="#663300"><code>FREELIMIT</code></font> is
            available for dynamically-allocating new free memory for <font
              color="#663300"><code>BASED</code></font> variables or <font
              color="#663300"><code>CHARACTER</code></font>
            variables.&nbsp; As the program continues to execute,
            dynamic memory allocation and subsequent memory-freeing may
            cause <font color="#663300"><code>FREEPOINT</code></font>
            to steadily creep upward, and the area from <font
              color="#663300"><code>FREEBASE</code></font> to <font
              color="#663300"><code>FREEPOINT</code></font> to become
            increasingly fully of unusable holes.&nbsp; Eventually, <font
              color="#663300"><code>COMPACTIFY</code></font> will be <i>automatically</i>
            called, repacking the data to eliminate the holes, and
            moving <font color="#663300"><code>FREEPOINT</code></font>
            downward in memory once again.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>INLINE(NE<sub>1</sub>,...)<br>
              </code></font></td>
          <td valign="middle">Inserts arbitrary IBM System/360 machine
            code directly into the instruction stream.<br>
          </td>
          <td valign="middle">The applicability of the original
            functionality has changed drastically in the 55+ years (as
            of this writing) since <i>A Compiler Generator</i> was
            written.&nbsp; <b>XCOM-I</b> provides three different
            mechanisms for supporting direct insertion of inline non-XPL
            code, none of which are identical to those in <i>A Compiler
              Generator</i>.&nbsp; Thankfully, no available legacy <i>standard</i>
            XPL program I've encountered contains any <font
              color="#663300"><code>CALL INLINE</code></font>
            statements, so the difficulties presented by them are
            limited to XPL/I code such as <b>HAL/S-FC</b>.<br>
            <br>
            <b>Support mechanism 1:&nbsp; insertion of C code</b><br>
            <br>
            You can use <br>
            <blockquote><font color="#663300"><code>CALL INLINE('<i>C-language










                    source code</i>');</code></font><br>
            </blockquote>
            to insert an arbitrary string of C-language source code
            directly into the instruction stream.&nbsp; If the string
            contains newline characters (<font color="#663300"><code>'\n'</code></font>),










            then a single <font color="#663300"><code>INLINE</code></font>
            can insert multiple lines of C code.&nbsp; But recall that
            an XPL string can be no longer than 256 characters, so the
            inserted C code can be no longer than 256 characters in any
            one <font color="#663300"><code>CALL INLINE</code></font>
            statement.<br>
            <br>
            <b>Support mechanism 2:&nbsp; insertion of IBM 360 machine
              code</b><br>
            <br>
            <b>XCOM-I</b> will automatically translate IBM 360 machine
            code to C.&nbsp; Full-blown IBM 360 emulation is not
            provided, but support is available for those IBM 360
            instructions used in XPL code I have personally encountered,
            which includes the entire source-code base of <b>HAL/S-FC</b>.&nbsp;










            Instructions that are not (yet) supported cause compilation
            to abort.<br>
            <br>
            This feature is not normally enabled.&nbsp; You must use the
            <b>XCOM-I</b> command-line switch <font color="#663300"><code>--auto-inline</code></font>
            to enable it.&nbsp; That's because while it sounds
            wonderful, this feature must be regarded with great
            suspicion.&nbsp; A better way to think of it is that it will
            give you an initial guess of an appropriate C translation
            that you would be wise to carefully inspect and refine.<br>
            <br>
            <b>Support mechanism 3:&nbsp; other</b><br>
            <br>
            If <font color="#663300"><code>--auto-inline</code></font>
            is not enabled (see support mechanism 2 above), any CALL
            INLINE statements not caught by support mechanism 1 are
            commented out by default, but "patched" with C code if a
            "patch file" is available.&nbsp; &nbsp; <a
              moz-do-not-send="true" href="#hooks">This important but
              far from automatic mechanism is the topic of a later
              section</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>INPUT(NE)</code><code><br>
              </code></font></td>
          <td valign="middle">A function with descriptor value
            specifying the next record on input file <font
              color="#663300"><code>NE</code></font>.<br>
          </td>
          <td valign="middle">I've truncated <i>A Compiler Generator</i>'s










            rather roundabout description, because I don't find it very
            informative as-is to more-modern readers.<br>
            <br>
            What <i>A Compiler Generator</i> is trying to say is that
            any given program can have several files attached to it for
            so-called <i>sequential</i> input.&nbsp; You can think of
            these files as consisting of lines of text, and you can read
            them, one text-line at a time, by using the <font
              color="#663300"><code>INPUT</code></font> built-in
            function.&nbsp; For the original <i>A Compiler Generator</i>
            <b>XCOM</b> (or the Intermetrics version of <b>XCOM</b>),
            the text in the sequential files would have been encoded in
            EBCDIC, but for use with <b>XCOM-I</b> they are encoded in
            ASCII.<br>
            <br>
            Because XPL comes from the era and computing environment it
            did, it expects input to be supplied on computer punch
            cards.&nbsp; As such, it expects lines of input to actually
            be 80 columns wide, even if they need to be padded by spaces
            to do so.&nbsp; Not all XPL programs have problems with
            lines of a different length, but some do.&nbsp; Notably, the
            original <b>XCOM</b> is one of the programs that behaves
            incorrectly unless it gets its way.&nbsp; Because of that, <b>XCOM-I</b>'s





            built-in <font color="#663300"><code>INPUT</code></font>
            function transparently truncates lines to 80 columns or pads
            them to 80 columns as necessary.<br>
            <br>
            There are up to 9 INPUT files attached to the program,
            numbered 0 through 9 — yes, I <i>know</i> that's 10 files,
            but just keep reading — and you access them via those
            "device numbers".&nbsp; For example,<br>
            <blockquote><font color="#663300"><code>DECLARE CHARACTER C;</code><code><br>
                </code><code>C = INPUT(5);</code></font><br>
            </blockquote>
            reads a single line from sequential file number 5 into the
            variable <font color="#663300"><code>C</code></font>.<br>
            <blockquote><font size="-1"><b>Important:</b> These
                "sequential files" and the <font color="#663300"><code>INPUT</code></font>
                mechanism are completely separate from the
                "random-access files" described in <font
                  color="#663300"><code>FILE</code></font>'s notes
                earlier!</font><br>
            </blockquote>
            By default, there is a single sequential file attached to
            the program, though it is attached to <i>both</i> device
            number 0 and device number 1.&nbsp; The default attached
            file is <font color="#663300"><code>stdin</code></font>,
            and thus any text piped into the program via a redirector (<font
              color="#663300"><code>&lt;</code></font>) on the program's
            command line will be available on both <font
              color="#663300"><code>INPUT(0)</code></font> and <font
              color="#663300"><code>INPUT(1)</code></font>.<br>
            <blockquote><font size="-1"><b>Aside:</b>&nbsp; In case
                you're wondering, I don't think that the reason two
                separate devices are associated with <font
                  color="#663300"><code>stdin</code></font> is very deep
                or interesting.&nbsp; I imagine it's just kind of
                symmetric to the fact that <font color="#663300"><code>OUTPUT(0)</code></font>
                and <font color="#663300"><code>OUTPUT(1)</code></font>
                (see below) are both attached by default to <font
                  color="#663300"><code>stdout</code></font>.&nbsp; In
                situations like this I'm tempted to quote Emerson</font>
              <font size="-1">— "a foolish consistency is the hobgoblin
                of little minds" — but I suspect the decision was
                pragmatic rather than foolish.</font><br>
            </blockquote>
            There's no explanation or obvious provision in the
            documentation for what happens when an end-of-file is
            reached, and <b>XCOM-I</b> makes no particular provision
            for it either.&nbsp; I suppose it must depend on the
            particular program.&nbsp; For example, some XPL programs
            assume that a blank line terminates a file.&nbsp; Other
            programs may look for special patterns, such as the string
            "EOF".&nbsp; <b>XCOM-I</b> returns an empty string for
            reads past the end of the file.<br>
            <br>
            Additional input files can be attached via the program's
            command-line switch <font color="#663300"><code>--ddi</code></font>:<br>
            <blockquote><font color="#663300"><code>--ddi=<i>N,F</i></code></font><br>
            </blockquote>
            Here, <font color="#663300"><code><i>F</i></code></font> is
            the pathname to the file, and <font color="#663300"><i><code>N</code></i></font>
            is the device number to which it should be attached.&nbsp;
            By the way, if you want to debug your program once it has
            been translated by <b>XCOM-I</b> to C and then the C has
            been compiled to an exectuable, I've sometimes found piping
            input into the program via a command-line redirector (<font
              color="#663300"><code>&lt;</code></font>) to be somewhat
            problematic.&nbsp; It's handy in those situations to
            override the default attachment of stdin to device 0 by
            using <font color="#663300"><code>--ddi=0,<i>F</i></code></font>
            instead of piping.&nbsp; <br>
            <br>
            There is no way to change the attachments once the program
            is running, although there are <font color="#663300"><code>MONITOR</code></font>
            calls (see below) which can close attached files at runtime.<br>
            <br>
            In XPL/I, there's an additional alternative, in which <i>Partioned










              Data Set</i> (PDS) files can be attached for use by <font
              color="#663300"><code>INPUT</code></font> instead of
            sequential files. A PDS is partitioned into sections, each
            with its own 8-character identifying name (right-padded with
            blanks if necessary).&nbsp; An attempted read past the end
            of a partition returns an empty string.<br>
            <br>
            Only one partition of the PDS is available via <font
              color="#663300"><code>INPUT</code></font> at any given
            time, but <br>
            <blockquote><font color="#663300"><code><i>F</i> =
                  MONITOR(2, <i>N</i>, <i>NAME</i>);</code></font><br>
            </blockquote>
            (see below) can be used at any time to switch device <font
              color="#663300"><code><i>N</i></code></font> to the
            partition whose name is contained in the string called <font
              color="#663300"><code><i>NAME</i></code></font>.&nbsp; The
            value returned, <font color="#663300"><code><i>F</i></code></font>,
            is 0 if the switch was successful, or 1 if there was no such
            partition.<br>
            <br>
            A PDS is thus similar to a <i>folder</i> of sequential
            files, with the partition names corresponding to filenames
            within the folder.&nbsp; <br>
            <br>
            By default, no there is no PDS attached to programs.&nbsp;
            However, a PDS can be attached for input via the program's
            command-line switch <font color="#663300"><code>--pdsi</code></font>:<br>
            <blockquote><font color="#663300"><code>--pdsi=<i>N</i>,<i>F</i></code></font><br>
            </blockquote>
            Because of PDS similarity to folders, that's how they're
            implemented in <b>XCOM-I</b>. So <font color="#663300"><code><i>F</i></code></font>
            should be the pathname of a folder, and the partitions
            should be ASCII text files within the folder.&nbsp; <font
              color="#663300"><code><i>N</i></code></font>, of course,
            is the device number on which the attachment is to be
            made.&nbsp; However, no specific partition is selected for
            reading until the necessary <font color="#663300"><code>MONITOR(2,










                <i>N</i>, <i>NAME</i>)</code></font> call has been
            made.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>INPUT</code><code><br>
              </code></font></td>
          <td valign="middle">Same as <font color="#663300"><code>INPUT(0)</code></font><br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>INTERRUPT_TRAP</code><code><br>
              </code></font></td>
          <td valign="middle">Not supported in <b>XCOM</b>.<br>
          </td>
          <td valign="middle">Not supported in <b>XCOM-I</b>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>LENGTH(DE)</code><code><br>
              </code></font></td>
          <td valign="middle">A function with the numeric value equal to
            the number of characters in the string denoted by the
            parameter.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>LINE_COUNT</code><code><br>
              </code></font></td>
          <td valign="middle">This function returns the number of lines
            which have been printed on the SYSPRINT file since the last
            page eject.<br>
          </td>
          <td valign="middle">(XPL/I only.)&nbsp; "SYSPRINT" refers to <font
              color="#663300"><code>OUTPUT(0)</code></font> and <font
              color="#663300"><code>OUTPUT(1)</code></font> (see below).<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>LINK</code><code><br>
              </code></font></td>
          <td valign="middle">This procedure performs the functions
            necessary to exit the current program phase and pass control
            to the next phase on the <font color="#663300"><code>PROGRAM










                DD</code></font> sequence, preserving <font
              color="#663300"><code>COMMON</code></font> data and any
            other dynamically allocated space which has not been
            deallocated.<br>
          </td>
          <td valign="middle">(XPL/I only.)&nbsp; This refers to the
            notion that a sequence of XPL/I programs is being run via
            Job Control Language (JCL), with each program passing data
            to the next program in sequence.&nbsp; However, this <font
              color="#663300"><code>LINK</code></font> built-in is
            specific to the original computing environment, and performs
            no function in <b>XCOM-I</b>, which has a different
            mechanism sharing data between program passes.&nbsp; <a
              moz-do-not-send="true" href="#common">Refer to the
              extensive discussion concerning <font color="#663300"><code>COMMON</code></font>
              memory</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>MONITOR(NE<sub>1</sub>,...)</code><code><br>
              </code></font></td>
          <td valign="middle">Calls the "submonitor".<br>
          </td>
          <td valign="middle">The "submonitor" is a separate program
            from whatever XPL or XPL/I program is being compiled and
            run, providing some kind of system-specific
            functionality.&nbsp; In so far as <i>A Compiler Generator</i>
            is concerned, the submonitor's functionality and even its
            calling sequence was unknowable, and thus the <i>A Compiler
              Generator</i> <b>XCOM</b> system simply discarded all
            calls to the submonitor.<br>
            <br>
            Not so with XPL/I: There is an extensive set of functions
            provided by the submonitor, and the XPL/I program <b>HAL/S-FC</b>
            uses them extensively as well, so <b>XCOM-I</b> needs to
            support them.&nbsp; Most (I hope!) but not all submonitor
            functions are known from their descriptions in section 13.3
            of IR-182-1.&nbsp; Besides which, <b>HAL/S-FC</b> source
            code contains the source code for <font color="#663300"><code>MONITOR</code></font>
            (written in IBM 360 Basic Assembly Language), from which
            additional information can be obtained.<br>
            <br>
            Because of the complexity of <font color="#663300"><code>MONITOR</code></font>,
            <a moz-do-not-send="true" href="#monitor">an entire separate
              section is devoted to explaining it</a>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>MONITOR_LINK</code><code><br>
              </code></font></td>
          <td valign="middle">A fixed array which can be used for
            transmission of information between a program and the
            submonitor.<br>
          </td>
          <td valign="middle">(See Table 8.4.6 in <i>A Compiler
              Generator</i>.)&nbsp; I'm not presently aware of any need
            to implement this in <b>XCOM-I</b>.&nbsp; However, there
            are <font color="#663300"><code>MONITOR</code></font>
            functions (see above) whose operations remain a mystery, so
            there's a possibility that that could change.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>NDESCRIPT(NE)</code><code><br>
              </code></font></td>
          <td valign="middle">A word variable containing the upper bound
            in the array <font color="#663300"><code>DESCRIPTOR</code></font>
            (see above) of the descriptions.<br>
          </td>
          <td valign="middle">See <font color="#663300"><code>DESCRIPTOR</code></font>
            above.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>OUTPUT(NE)</code><code><br>
              </code></font></td>
          <td valign="middle">This is the analog of <font
              color="#663300"><code>INPUT</code></font> (see above) but
            for outputting textual data rather than inputting it.<br>
          </td>
          <td valign="middle">Most of the comments concerning <font
              color="#663300"><code>INPUT</code></font> (see above) are
            directly applicable to <font color="#663300"><code>OUTPUT</code></font>,
            or else are analogous in a very obvious way, so I'll try to
            confine my remarks to the clear differences between the two.<br>
            <br>
            The most common use of <font color="#663300"><code>OUTPUT</code></font>
            is to "print" to the "SYSPRINT" device.&nbsp; Unlike the
            original <b>XCOM</b> computing environment, in which
            SYSPRINT was an actual printer, in <b>XCOM-I</b> SYSPRINT
            by default refers to <font color="#663300"><code>stdout</code></font>.&nbsp;










            And by default, <font color="#663300"><code>stdout</code></font>
            is attached to both <font color="#663300"><code>OUTPUT(0)</code></font>
            and <font color="#663300"><code>OUTPUT(1)</code></font>.
            But there are differences between the two!&nbsp; Use of <font
              color="#663300"><code>OUTPUT(0)</code></font> is simpler,
            and therefore more common, but <font color="#663300"><code>OUTPUT(1)</code></font>
            is more flexible.&nbsp; Let's start with <font
              color="#663300"><code>OUTPUT(0)</code></font>.<br>
            <br>
            Output statements via <font color="#663300"><code>OUTPUT(0)</code></font>
            might look something like this:<br>
            <blockquote><font color="#663300"><code>OUTPUT(0) = 'Hello,
                  world!';</code><code><br>
                </code><code>OUTPUT(0) = 'Hello' || ',' || ' ' ||
                  'world' || '!';</code><code><br>
                </code><code>OUTPUT(0) = 'This is OUTPUT statement
                  number ' || 3;</code><code><br>
                </code><code>OUTPUT(0) = 25;</code></font><br>
            </blockquote>
            Thus we can print any character strings or numbers we like,
            and can concatenate them using the string-concatenation
            operator (<font color="#663300"><code>||</code></font>),
            with <b>XCOM-I</b> doing the work of automatically
            converting numbers to strings where necessary.<br>
            <br>
            Each use of <font color="#663300"><code>OUTPUT(0)</code></font>
            results in another physical line being printed.&nbsp; When
            printing messages with <font color="#663300"><code>OUTPUT</code></font>,
            since it is expected that the lines are being output to a
            physical printer, the system keeps track of the number of
            lines being printed, and automatically inserts page breaks
            in the output once a page has been filled up.&nbsp; At the
            tops of pages, a page number and optional headings and
            subheadings are also printed.&nbsp; The headings and
            subheadings, though, are simply whatever has been previously
            set up, and you can't change them or otherwise influence
            them using <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
            <br>
            With <font color="#663300"><code>OUTPUT(1)</code></font>,
            on the other hand, there's quite a bit of additional
            functionality.&nbsp; For example, it isn't necessarily true
            that each use of <font color="#663300"><code>OUTPUT(1)</code></font>
            prints another line.&nbsp; The <i>first</i> character of
            each <font color="#663300"><code>OUTPUT(1)</code></font>
            isn't directly printed, but instead is a "carriage-control
            character" (or "ANSI control character"), as follows:<br>
            <ul>
              <li>'<font color="#663300"><code> </code></font>' (i.e.,
                a space) — Single-space the line and print. This is the
                same behavior as <font color="#663300"><code>OUTPUT(0)</code></font>:
                i.e., any line you print to <font color="#663300"><code>OUTPUT(0)</code></font>,
                you could instead prefix it with a space character and
                send it to <font color="#663300"><code>OUTPUT(1)</code></font>
                instead.</li>
              <li>'<font color="#663300"><code>0</code></font>' —
                Double-space the line and print.</li>
              <li>'<font color="#663300"><code>-</code></font>' —
                Triple-space the line and print.</li>
              <li>'<font color="#663300"><code>+</code></font>' —
                Overstrike the preceding line. In other words, go back
                to column 1, without advancing to the next line, and
                then print the remainder of the string. Unfortunately,
                that's behavior suitable for a physical printer, but not
                really for outputting text to <font color="#663300"><code>stdout</code></font>
                on most computers today.&nbsp; Yes, we may be able to
                emulate it using strange maneuvers which most computers
                aren't set up for, but not in any universal,
                easily-set-up way.&nbsp; So in <b>XCOM-I</b>, the
                string is instead printed on a new line, almost as if
                the ANSI control character had been '<font
                  color="#663300"><code> </code></font>'&nbsp; (see
                above) rather than '<font color="#663300"><code>+</code></font>'.&nbsp;










                Almost!&nbsp; You see, what these overstruck lines are
                mostly used for is underlining text.&nbsp; In <b>HAL/S-FC</b>,
                for example, text which has undergone replacement via
                macro expansion is underlined in compiler reports.&nbsp;
                The temptation is to mimic underlining by using
                underscore characters (_), but when underscore
                characters are printed on a separate line from the text
                they're underlining, they don't really look like
                underlining, but rather like overlining on the
                succeeding line ... which while it may be better than
                nothing, is absolutely <i>not</i> what you want it to
                look like!&nbsp; <b>XCOM-I</b> thus takes a
                slightly-different approach:&nbsp; It replaces such
                underscores by carats (^), which in my opinion are
                more-effective visually.&nbsp; For example, where one
                would have gotten something like <br>
              </li>
            </ul>
            <blockquote>
              <blockquote>
                <pre><font color="#663300">... <code><u>MYTEXT</u> ...</code></font> </pre>
              </blockquote>
            </blockquote>
            <blockquote>on a line printer back in the olden times, today
              with <b>XCOM-I</b> you'll instead see the uglier but
              still effective<br>
            </blockquote>
            <blockquote>
              <blockquote>
                <pre><font color="#663300">... MYTEXT ...<br>    ^^^^^^</font><br></pre>
              </blockquote>
            </blockquote>
            <ul>
              <li>'<font color="#663300"><code>1</code></font>' — Form
                feed. I.e., advance to the top of the next page,
                regardless of how many left-over lines remain on the
                current page. In <b>XCOM-I</b>, this is accomplished by
                embedding the ASCII form-feed character (<font
                  color="#663300"><code>'\l'</code></font>) in the
                output.</li>
              <li>'<font color="#663300"><code>H</code></font>' —
                Heading line. This doesn't print anything, but takes the
                remainder of the line and sets it as the heading for
                subsequent pages.</li>
              <li>'<font color="#663300"><code>2</code></font>' —
                Subheading line. This doesn't print anything, but takes
                the remainder of the line and sets it as the subheading
                for subsequent pages.</li>
            </ul>
            <blockquote><b><font size="-1">Note:</font></b><font
                size="-1">&nbsp; What this explanation of </font><font
                size="-1"><font color="#663300"><code>OUTPUT(1)</code></font>
                fails to explain is what happens if the string <i>doesn't










                  have</i> a first character; i.e., what if it's
                empty?&nbsp; Well, the obvious response would be that
                that would be an illegal use.&nbsp; Unfortunately for
                us, that obvious fact didn't stop some of the coders of
                <b>HAL/S-FC</b> from strewing their code — perhaps an
                exaggeration — with assignments <font color="#663300"><code>OUTPUT(1)










                    = ''</code></font>, thus forcing us to deal with
                it.&nbsp; Lacking any particular rationale for what such
                a thing might mean, <b>XCOM-I</b> treats it as <font
                  color="#663300"><code>OUTPUT(0) = ''</code></font>;
                i.e., it prints a newline.<br>
              </font></blockquote>
            If you experiment with <font color="#663300"><code>OUTPUT(1)</code></font>,
            and even to a certain extent with <font color="#663300"><code>OUTPUT(0)</code></font>,
            you may become very confused, because various things won't
            work as you expect.&nbsp; Or at least, <i>I</i> was very
            confused at first.&nbsp; To get past this confusion, you
            need to grasp the following<br>
            <blockquote><font size="-1"><b>Very important point</b>:&nbsp;




                For the computer systems most people are familiar with
                today, when we print a line of text, we expect that line
                of text to end with an implicit advance to the next
                line; i.e., with a "newline" character, often signified
                in programming languages by <font color="#663300"><code>'\n'</code></font>.&nbsp;










                Whereas in System/360 (and therefore in XPL or XPL/I),
                the implicit newline occurs <i>prior</i> to the text
                being printed by the <font color="#663300"><code>OUTPUT</code></font>
                command.&nbsp; I.e., today we typically ask ourselves
                "what happens at the <i>end</i> of the line"", whereas
                for XPL you need to ask "what happens at the <i>beginning</i>
                of the line?".</font><br>
            </blockquote>
            Similarly to <font color="#663300"><code>INPUT</code></font>,
            you can attach additional sequential output files (<font
              color="#663300"><code><i>F</i></code></font>) on device
            numbers (<font color="#663300"><code><i>N</i></code></font>),<br>
            <blockquote><font color="#663300"><code>--ddo=<i>N,F</i></code></font><br>
            </blockquote>
            Or for Partitioned Data Sets,<br>
            <blockquote><font color="#663300"><code>--pdso=<i>N</i>,<i>F</i></code></font><br>
            </blockquote>
            For selecting partitions of a PDS, you don't use the same <font
              color="#663300"><code>MONITOR</code></font> call as for <font
              color="#663300"><code>INPUT</code></font>, but instead
            use: <br>
            <blockquote><font color="#663300"><code><i>F</i> =
                  MONITOR(1, <i>N</i>, <i>NAME</i>);</code></font><br>
            </blockquote>
            <font color="#663300"><code>OUTPUT</code></font> commands
            targetting a PDS don't immediately write data to the
            physical PDS.&nbsp; Rather, the data being output is
            buffered in memory until the <font color="#663300"><code>MONITOR(1,










                <i>N</i>, <i>NAME</i>)</code></font> call occurs, and
            the data is then written out to the selected partition in
            its entirety.&nbsp; The return value (<font color="#663300"><code><i>F</i></code></font>)
            is 0 if the partition is new (i.e., if it didn't previously
            exist in the PDS), while it is 1 if the partion previously
            existed but has now been overwritten with entirely new
            contents.</td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>OUTPUT</code><code><br>
              </code></font></td>
          <td valign="middle">The same as <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>PARM_FIELD</code><code><br>
              </code></font></td>
          <td valign="middle">This function returns a character string
            which contains the entire parameter specification coded on
            the <font color="#663300"><code>PARM=</code></font> option
            on the <font color="#663300"><code>EXEC</code></font>
            card.&nbsp; If no <font color="#663300"><code>PARM</code></font>
            is specified, a null string will be returned.<br>
          </td>
          <td valign="middle">(XPL/I only.)&nbsp; A program of any
            complexity generally has a number of options selectable at
            runtime.&nbsp; For XPL/I programs like <b>HAL/S-FC</b>, the
            mechanism for selecting such options was originally a Job
            Control Language (JCL) card such as:<br>
            <blockquote><font color="#663300"><code>PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font><br>
            </blockquote>
            Thus, <font color="#663300"><code>PARM_FIELD</code><code> </code></font>would










            have had the value <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font>
            in such a case.<br>
            <br>
            In <b>XCOM-I</b>, <font color="#663300"><code>PARM_FIELD</code></font>
            is implemented as a function rather than a variable, but
            nevertheless returns data of the kind described.&nbsp; Of
            course, there is no JCL supplying such parameters, but the
            compiled program nevertheless has a command-line option that
            does the same job:<br>
            <blockquote><font color="#663300"><code>--parm='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'<br>
                </code></font></blockquote>
            <blockquote><b><font color="#663300"><code></code></font></b><font
                size="-1"><b>Aside:</b> Depending on your operating
                system, some trickery may be involved in correctly
                forming such a command-line option.&nbsp; In Linux or (I
                suppose) Mac OS, the command shell expects the dollar
                sign (<font color="#663300"><code>$</code></font>) to
                indicate that the value of an environment variable is
                desired.&nbsp; In other words, if the string in the
                command-line option shown above had no quotes, then (for
                example) <font color="#663300"><code>$I</code></font>
                would be replaced by the value of the
                environment-variable <font color="#663300"><code>I</code></font>
                ... probably a blank!&nbsp; And the same thing would
                happen if the option were enclosed in
                double-quotes.&nbsp; But by using single-quotes, we
                defeat that substitution, and <font color="#663300"><code>$I</code></font>
                is reported in </font><font size="-1"><font
                  color="#663300"><code>PARM_FIELD</code></font>
                literally as <font color="#663300"><code>$I</code></font>.&nbsp;










                Alternate tricks to defeating substitution could include
                using the backslash (<font color="#663300"><code>'\'</code></font>)
                escape character in front of all dollar signs (<font
                  color="#663300"><code>$</code></font>).&nbsp; <br>
                <br>
                <b>Aside:</b> It has been decades since I used Windows
                in any serious way, so I don't really know whether
                there's any similar problem with it.&nbsp; Probably not.</font><br>
            </blockquote>
            <font color="#663300"><code></code></font></td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>RECORD_WIDTH(V)</code></font><br>
          </td>
          <td valign="top"><br>
          </td>
          <td valign="middle">(XPL/I only.)&nbsp; IR-182-1 doesn't
            mention it, but it appears to me that <font color="#663300"><code>RECORD_WIDTH</code></font>
            is a new built-in in XPL/I which when given the symbolic
            name of a <font color="#663300"><code>BASED</code></font>
            variable returns the variable's record size (in
            bytes).&nbsp; In <b>HAL/S-FC</b>'s XPL/I source code (the
            only available example of use of <font color="#663300"><code>RECORD_WIDTH</code></font>),










            I find it used only for a couple of <font color="#663300"><code>BASED










                RECORD</code></font> variables, which makes sense
            according to the naming, but I have no way to tell just from
            those few examples what the actual applicability was.&nbsp;
            In <b>XCOM-I</b>, it will work for any <font
              color="#663300"><code>BASED</code></font> variable, <font
              color="#663300"><code>RECORD</code></font> or not.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>SET_LINELIM(NE)</code><code><br>
              </code></font></td>
          <td valign="middle">This procedure establishes the number of
            lines which will be printed on the SYSPRINT file before an
            automatic page eject and header line will be printed.<br>
          </td>
          <td valign="middle">(XPL/I only.)&nbsp; See <font
              color="#663300"><code>OUTPUT(NE)</code></font>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>SHL(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
              </code></font></td>
          <td valign="middle">A function with the numeric value given by
            shifting the value of <font color="#663300"><code>NE<sub>1</sub></code></font>
            left (logical shift, zeroes appear in the least significant
            bit position) the number of positions indicated by the value
            of <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
          </td>
          <td valign="middle">One point I found confusing for quite a
            while is that you'd suppose that logical shifts would
            operate on <font color="#663300"><code>BIT</code></font>
            variables, and particularly on long-<font color="#663300"><code>BIT</code></font>
            variables, for which XPL provides no conveniences at all for
            accessing individual bits.&nbsp; Not so!&nbsp; <font
              color="#663300"><code>SHL</code></font> operates only on <font
              color="#663300"><code>FIXED</code></font> values, and can
            only shift by up to 32 positions.&nbsp; <font
              color="#663300"><code>BIT</code></font> variables are
            converted to <font color="#663300"><code>FIXED</code></font>
            if shift operations on them are needed.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>SHR(</code></font><font
              color="#663300"><code><font color="#663300"><code>NE<sub>1</sub>,NE<sub>2</sub></code></font>)</code><code><br>
              </code></font></td>
          <td valign="middle">Logical shift right.&nbsp; <font
              color="#663300"><code>SHL</code></font> and <font
              color="#663300"><code>SHR</code></font> are used in
            conjunction with <font color="#663300"><code>&amp;</code></font>,
            <font color="#663300"><code>|</code></font>, and <font
              color="#663300"><code>¬</code></font> for masking and data
            packing.<br>
          </td>
          <td valign="middle">But recall that it is preferable to use <font
              color="#663300"><code>~</code></font> rather than <font
              color="#663300"><code>¬</code></font> with <b>XCOM-I</b>.
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>STRING(<i>IDENTIFIER</i>)<br>
                STRING(<i>INTEGER</i>)</code><code><br>
              </code></font></td>
          <td valign="middle">This function transforms the variable <font
              color="#663300"><code>NE</code></font> (which should be <font
              color="#663300"><code>FIXED</code></font> for proper
            usage) into a <font color="#663300"><code>CHARACTER</code></font>
            descriptor.&nbsp; <font color="#663300"><code>NE</code></font>
            should have the form:<br>
            <br>
            <table cellspacing="2" cellpadding="2" align="center"
              border="1">
              <tbody>
                <tr>
                  <th valign="middle" align="center">Length - 1<br>
                  </th>
                  <th valign="middle" align="center">&nbsp;Data Address<br>
                  </th>
                </tr>
                <tr>
                  <td valign="middle" align="center">8 bits<br>
                  </td>
                  <td valign="middle" align="center">24 bits<br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
          </td>
          <td valign="middle">(XPL/I only.) I admit that the description
            at left is confusing.&nbsp; The whole concept is
            confusing.&nbsp; Here's my take on it:&nbsp; I believe that
            <font color="#663300"><code>STRING</code></font> is used in
            one of two situations:<br>
            <ul>
              <li>You have an <font color="#663300"><code><i>IDENTIFIER</i></code></font>
                for a <font color="#663300"><code>CHARACTER</code></font>
                variable, and you want the string descriptor for the
                string contained in that variable; or</li>
              <li>By some kind of arithmetical process, a <font
                  color="#663300"><code><i>INTEGER</i></code></font>
                value has been created that you want to treat as a
                string descriptor.<br>
              </li>
            </ul>
            These are respectively equivalent to<br>
            <ul>
              <li><font color="#663300"><code>COREWORD(ADDR(IDENTIFIER))</code></font></li>
              <li><font color="#663300"><code>INTEGER</code></font></li>
            </ul>
            <p><b>XCOM-I</b> implements <font color="#663300"><code>STRING</code></font>
              using these equivalences, and there is no runtime library
              function as such that's called <font color="#663300"><code>STRING</code></font>.<br>
            </p>
            <p>To make things a bit more confusing, <font
                color="#663300"><code>STRING</code></font> is the one
              built-in I'm aware of that is <i>also</i> commonly used
              as a name for a variable. If names of built-ins are
              declared as variables (or procedures), the user's
              declaration overrides the built-in for the scope of the
              declaration.<br>
            </p>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>STRING_GT(DE<sub>1</sub>,DE<sub>2</sub>)</code><code><br>
              </code></font></td>
          <td valign="middle">This function returns a <font
              color="#663300"><code>TRUE</code></font> value if the
            contents of string <font color="#663300"><code>DE<sub>1</sub></code></font>
            is greater than the contents of string <font
              color="#663300"><code>DE<sub>2</sub></code></font>, based
            on the collating sequence of the characters, irrespective of
            the lengths of <font color="#663300"><code>DE<sub>1</sub></code></font>
            and <font color="#663300"><code>DE<sub>2</sub></code></font>.
            Otherwise, the value is <font color="#663300"><code>FALSE</code></font>.
            This is functionally equivalent to padding the shorter of <font
              color="#663300"><code>DE<sub>1</sub></code></font> or <font
              color="#663300"><code>DE<sub>2</sub></code></font> with
            blanks and then comparing the strings.<br>
          </td>
          <td valign="middle"><a name="STRING_GT"></a>(XPL/I
            only.)&nbsp; If this seems confusing, it may be helpful to
            recall that when the XPL relational operators <font
              color="#663300"><code>&lt;</code></font>, <font
              color="#663300"><code>&gt;</code></font>, <font
              color="#663300"><code>&lt;=</code></font>, and <font
              color="#663300"><code>&gt;=</code></font> compare two <font
              color="#663300"><code>CHARACTER</code></font> values, they
            look first at the lengths of the values, and only if the
            lengths are equal do they compare the actual character
            data.&nbsp; For example,<br>
            <blockquote><font color="#663300"><code>'ZZZ' &lt; 'AAAA'</code></font><br>
            </blockquote>
            because <font color="#663300"><code>'ZZZ'</code></font> has
            only 3 characters, while <font color="#663300"><code>'AAAA'</code></font>
            has 4.&nbsp; Presumably <font color="#663300"><code>STRING_GT</code></font>
            was introduced because somebody at Intermetrics didn't think
            that kind of behavior was great, and thus <font
              color="#663300"><code>STRING_GT('ZZZ', 'AAAA')</code></font>
            will report instead that <font color="#663300"><code>'ZZZ'</code></font>
            is greater than <font color="#663300"><code>'AAAA'</code></font>.<br>
            <br>
            The collating sequence in either case is EBCDIC rather than
            the more-usual ASCII.&nbsp; The primary visually-obvious
            consequence of this is that digits come after letters rather
            than before them.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
              </code></font></td>
          <td valign="middle">A function with descriptor value
            specifying the substring of the string specified by <font
              color="#663300"><code>DE</code></font>, starting at
            position with <font color="#663300"><code>NE<sub>1</sub></code></font>
            with length <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
          </td>
          <td valign="middle">I.e., it allocates and returns a new
            string created by taking a substring of length <font
              color="#663300"><code>NE<sub>2</sub></code></font>,
            starting at position <font color="#663300"><code>NE<sub>1</sub></code></font>
            in string <font color="#663300"><code>DE</code></font>.<sub><code></code></sub><sub><code></code></sub><font
              color="#663300"><code></code></font> </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE)</code><code><br>
              </code></font></td>
          <td valign="middle">Like the above except that all characters
            from <font color="#663300"><code>NE</code></font> to the
            end of the string are taken.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>TIME</code><code><br>
              </code></font></td>
          <td valign="middle">A function with numeric value given by the
            time-of-day coded as centiseconds since midnight.<br>
          </td>
          <td valign="middle">See the notes for the <font
              color="#663300"><code>DATE</code></font> function above.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>TIME_OF_GENERATION<br>
              </code></font></td>
          <td valign="middle">A word variable initialized with the value
            of <font color="#663300"><code>TIME</code></font> during
            compilation of the program.<br>
          </td>
          <td valign="middle"><font color="#663300"><code>TIME</code></font>
            (see above) isn't literally available during
            compilation.&nbsp; Moreover, <b>XCOM-I</b> implements this
            as a function rather than as a variable, which should be
            transparent to the programmer.&nbsp; <br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>TRACE<br>
              </code></font></td>
          <td valign="middle">A procedure,<br>
            <blockquote><font color="#663300"><code>CALL TRACE;</code></font><br>
            </blockquote>
            which causes activation of the instruction-by-instruction
            trace at runtime.<br>
          </td>
          <td valign="middle">This is described in quite a lot of detail
            in <i>A Compiler Generator</i>'s Appendix 2.&nbsp; At
            present, it is accepted during compilation but does nothing
            at runtime in code generated by <b>XCOM-I</b>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>UNTRACE<br>
              </code></font></td>
          <td valign="middle">A procedure,<br>
            <blockquote><font color="#663300"><code>CALL UNTRACE;</code></font><br>
            </blockquote>
            which turns off run-time trace.<br>
          </td>
          <td valign="middle">See <font color="#663300"><code>TRACE</code></font>.<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center"><font color="#663300"><code>XPL_COMPILER_VERSION</code></font><br>
          </td>
          <td valign="middle"><code></code><code></code><font
              color="#663300"><code></code></font> An array of length 2
            — actually a function in the <b>XCOM-I</b> runtime library
            — in which the first element is the major version of the XPL
            compiler (<b>XCOM-I</b> in this case), and the second
            element is the minor version, both in the range 0-99.<br>
          </td>
          <td valign="middle">This is just speculation on my part, based
            on how an undeclared variable with this name is used when it
            appears a couple of times in <b>PASS2</b> of <b>HAL/S-FC</b>.&nbsp;










            Nearby code also provides the interesting information that
            the XPL version <i>name</i> is "TITAN--XPL".&nbsp; You may
            recall my <a moz-do-not-send="true" href="#titan">earlier
              observation</a> that Intermetrics merged with Titan
            Corporation in March 2000, which is obviously the origin of
            the "TITAN" portion of the name.&nbsp; The other
            interesting&nbsp; point is that no effort is made to
            distinguish it in any way from <i>standard</i> XPL.<br>
            <br>
            Of course, I have no inkling whatever of how the versions
            for the Intermetrics/Titan XPL compiler were numbered.&nbsp;
            I was tempted to set the major version to 32 and the minor
            version to 0, but that would only serve to obscure the fact
            that <b>XCOM-I</b> is in fact <i>not</i> TITAN--XPL, nor
            even related to it other than that I've tried to imitate
            it.&nbsp; Instead, <b>XCOM-I</b> will always return a major
            and minor versions appropriate to itself:&nbsp; major = 0
            preliminary versions, 1 for first release, and so on.<br>
            <br>
            As an <i>ad hoc</i> measure, <b>XCOM-I</b> also
            transparently performs string substitions replacing
            'TITAN--XPL', wherever it may be found, by 'RSB-XCOM-I'.<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h1><a name="monitor"></a>The MONITOR Built-In Runtime-Library
      Function</h1>
    <p>As mentioned before, an XPL/I program obtained various services
      outside what the XPL/I language proper or runtime library could
      provide, by instead making requests to the separate "submonitor"
      program. The mechanism was a call of the <font color="#663300"><code>MONITOR</code></font>
      procedure. For <b>XCOM-I</b>, on the other hand, there is no
      separate submonitor program, and we may as well think of <font
        color="#663300"><code>MONITOR</code></font> as being just
      another built-in runtime-library function. Well, not just <i>any</i>
      runtime-library function. A big difference is that it provides a
      very large number of functions, each one of which can require its
      own unique syntax, thus necessitating a somewhat more-flexible
      discussion of how to use it.</p>
    <p>The only uniform feature among the many aspects of <font
        color="#663300"><code>MONITOR</code></font> usage is that each
      separate function it provides is identified by a number, and such
      a function number is passed to <font color="#663300"><code>MONITOR</code></font>
      as its first parameter. My explanations in the table below are
      mostly pulled from Chapter 13 of IR-182-1, and then altered
      according to my understanding (or lack thereof). Functions 24
      through 32 are deduced, poorly, from the <b>HAL/S-FC</b> BAL
      source-code file for the submonitor program (which happens to be
      called "MONITOR").<br>
    </p>
    <p>A number of the <font color="#663300"><code>MONITOR(...)</code></font>
      functions work with what's called "IBM hexadecimal floating-point"
      format, and specifically to the 64-bit (double-precision) version
      of that format, as opposed to the 32-bit (single-precision)
      version of it. To make the discussion more concise, I'll just
      refer to it as "DP floating point". <br>
    </p>
    <p>To be perfectly clear, there is <i>no</i> floating-point
      datatype in XPL/I, there are no floating-point literal constants,
      and there is no provision whatever to make it convenient for you
      (the programmer!) to hard-code such constants into your XPL source
      code, nor to interpret any such hexadecimal constants you find
      within legacy source code. Rather, you must somehow obtain the
      hexadecimal equivalents for whatever floating-point constants you
      wish to use, and then hard-code those hexadecimals into your code.
      For your convenience — or more accurately, for <i>mine</i> — I've
      included a little utility called ibmHex.py that you can use to
      convert back-and-forth between human-readable floating-point
      numbers and DP floating point. Just run <font color="#663300"><code>ibmHex.py










          --help</code></font> for instructions. This little utility can
      either be run in a stand-alone fashion, or else you can <font
        color="#663300"><code>import</code></font> it as a Python
      module. But I digress!<br>
    </p>
    <p>To understand DP floating point, imagine 8 groups of 8 bits each:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">SEEEEEEE FFFFFFFF FFFFFFFF ... FFFFFFFF</font></pre>
    </blockquote>
    <p>where <font color="#663300"><code>S</code></font> is the sign, <font
        color="#663300"><code>E</code></font> is the exponent, and <font
        color="#663300"><code>F</code></font> is the fraction. (SP
      floating point is the same, but with 3 <font color="#663300"><code>FFFFFFFF</code></font>-groups










      rather than 7 of them.) The exponent is a power of 16, biased by
      64, and thus represents 16<sup>-64</sup> through 16<sup>63</sup>.
      The fraction is an unsigned number, of which the leftmost bit
      represents 1/2, the next bit represents 1/4, and so on. As a
      special case, 0 is encoded as all zeroes.<br>
      <br>
      For example, the 64-bit hexadecimal pair 0x42640000 0x00000000
      parses as:<br>
    </p>
    <ul>
      <li>Sign = 0 (i.e., positive)</li>
      <li>Exponent = 16<sup>0x42-0x40</sup> = 16<sup>2</sup> = 2<sup>8</sup>.</li>
      <li>Fraction = 0.0110 0100 ...</li>
    </ul>
    <p>or in total, 1100100 (binary), or 100 decimal.<br>
    </p>
    <p>As in the preceding section, I want to make it clear that the
      descriptions given here are how the <b>XCOM-I</b> runtime
      library's <font color="#663300"><code>MONITOR</code></font>
      functions work, and not how the original <font color="#663300"><code>MONITOR</code></font>
      functions as confined to an IBM 360 runtime environment worked!</p>
    <table cellspacing="2" cellpadding="2" align="center" border="1">
      <caption><font size="+1"><b>MONITOR Functions</b></font></caption>
      <tbody>
        <tr>
          <th nowrap="nowrap" valign="bottom" align="center">MONITOR
            Call<br>
          </th>
          <th valign="bottom">Description From Original Documentation<br>
          </th>
          <th valign="bottom">Additional Notes<br>
          </th>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(0,<i>n</i>);<br>
              </font></code></td>
          <td valign="middle">Closes output file <i><font
                color="#663300"><code>n</code></font></i>.<br>
          </td>
          <td valign="middle">I believe this refers to the sequential
            file or PDS attached for use with <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font>,
            and <i>not</i> the random-access file (if any) attached for
            use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(1,<i>n</i>,<i>name</i>);<br>
              </font></code></td>
          <td valign="middle">Assumes that a PDS is attached to output
            device <font color="#663300"><code><i>n</i></code></font>.&nbsp;










            Physically writes any data previously buffered in memory by
            <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font>
            operations into the PDS's member named <code><font
                color="#663300"><i>name</i></font></code>.&nbsp; The <code><font
                color="#663300"><i>name</i></font></code> parameter is a
            string 8 characters long, padded with blanks as
            necessary.&nbsp; Returns 0 if the member hadn't existed
            previously in the PDS, or 1 if the contents of an existing
            member of that name was replaced.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(2,<i>n</i>,<i>name</i>);<br>
              </font></code></td>
          <td valign="middle">Assumes that a PDS is attached to input
            device <font color="#663300"><code><i>n</i></code></font>.&nbsp;










            Sets future <font color="#663300"><code>INPUT(n)</code></font>
            operations to pull data from the PDS's member named <code><font
                color="#663300"><i>name</i></font></code>.&nbsp; The <code><font
                color="#663300"><i>name</i></font></code> parameter is a
            string 8 characters long, padded with blanks as
            necessary.&nbsp; Returns 0 if the member was found, or 1 if
            it was not found.<br>
          </td>
          <td valign="middle">The end-of-data for the member is detected
            when an input string of 0 length is encountered.<br>
            <br>
            IR-182-1 asserts that devices 4 and 7 have the following
            abnormal <i>ad hoc</i> behavior very specific to <b>HAL/S-FC</b>.&nbsp;











            A PDS called "INCLUDE" is normally attached to input device
            4, while either "INCLUDE" or "OUTPUT6" is normally attached
            to input device 7.&nbsp; But member <code><font
                color="#663300"><i>name</i></font></code>&nbsp; is
            sought in device 4 or 7, then <code><font color="#663300"><i>name</i></font></code>
            is first sought in "INCLUDE" but upon failure is then sought
            in "OUTPUT6".<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(3,<i>n</i>);<br>
              </font></code></td>
          <td valign="middle">Closes input file <i><font
                color="#663300"><code>n</code></font></i>.</td>
          <td valign="middle">I believe this refers to the sequential
            file or PDS attached for use with <font color="#663300"><code>INPUT(<i>n</i>)</code></font>,
            and <i>not</i> the random-access file (if any) attached for
            use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.</td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(4,<i>n</i>,<i>b</i>);<br>
              </font></code></td>
          <td valign="middle">Changes the record size of random-access
            file <code><font color="#663300"><i>n</i></font></code> to
            <code><font color="#663300"><i>b</i></font></code>.&nbsp;
            Must precede the first use of <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(5,ADDR(DW));<br>
              </font></code></td>
          <td valign="middle">Sets the location of the double-word work
            area (<font color="#663300"><code>DW</code></font>) for
            subsequent use by <font color="#663300"><code>MONITOR(9,...)</code></font>
            and <font color="#663300"><code>MONITOR(10,...)</code></font>.<br>
          </td>
          <td valign="middle"><code><font color="#663300">DW</font></code>
            is meant to be literal here, at least for <b>HAL/S-FC</b>,
            and should not be replaced by anything else.<br>
            <br>
            <code><font color="#663300">DW</font></code> refers to an
            array of <font color="#663300"><code>FIXED</code></font>
            variables used in pairs, to hold 64-bit values. In
            particular, these pairs are often used to hold
            double-precision floating-point numbers in IBM System/360
            format.&nbsp;&nbsp; <code><font color="#663300">MONITOR(9,<i>op</i>)</font></code>
            <font color="#663300"><font color="#000000">(see below) is
                then capable of performing various arithmetical
                operations on those numbers.&nbsp; Since XPL/I itself
                has no facilities for floating-point variables or
                operations on them, this workaround is the only
                available way to employ floating-point numbers in XPL/I
                programs.<br>
                <br>
                In legacy HAL/S code, I've found that at least 14 words
                of memory are needed for this work area.&nbsp; In the <b>
                  XCOM-I</b> implementation, the </font></font><font
              color="#663300"><font color="#000000"><code><font
                    color="#663300">MONITOR(5)</font></code> call is
                rejected within 14 words of the end of memory.</font></font><code><font
                color="#663300"><br>
              </font></code></td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
              </font></code></td>
          <td valign="middle">Allocates <font color="#663300"><i>n</i></font>
            bytes of storage in free memory, clearing that memory to 0,
            and assigns the pointer of the <font color="#663300"><code><i>basedVariable</i></code></font>
            to point to that newly-allocated space.&nbsp; Returns 0 upon
            success, or 1 upon failure.<br>
          </td>
          <td valign="middle">It would be natural to suppose that <code><font
                color="#663300">MONITOR(6)</font></code> is the
            mechanism used to allocate memory for <font color="#663300"><code>BASED</code></font>
            variables declared in the XPL/I code.&nbsp; In general, this
            is <i>not</i> true.&nbsp; Memory for <font color="#663300"><code>BASED</code></font>
            variables declared in user XPL code comes from a large
            pre-allocated contiguous block of memory, and the
            sub-allocations of individual <font color="#663300"><code>BASED</code></font>
            variables within that large block are managed using means
            other than <font color="#663300"><font color="#000000"><code><font
                    color="#663300">MONITOR(6)</font></code></font></font>
            and <font color="#663300"><font color="#000000"><code><font
                    color="#663300">MONITOR(7)</font></code></font></font>.<br>
            <blockquote> <b><font size="-1">Aside:</font></b><font
                size="-1">&nbsp; It appears to me that once upon a time,
                the intention may indeed have been for </font><font
                size="-1"><font color="#663300"><code>BASED</code></font>
                variables to be managed by </font><font size="-1"><code><font
                    color="#663300">MONITOR(6)</font></code>.&nbsp; The
                evidence for this is a procedure called <font
                  color="#663300"><code>DESCRIPTOR_MONITOR</code></font>
                in SPACELIB, which does try to allocate or deallocate
                space for </font><font size="-1"><font size="-1"><font
                    color="#663300"><code>BASED</code></font></font>
                variables in just that fashion.&nbsp; However, </font><font
                size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font>
                is never called, and some of the variables upon which it
                depends are never declared, making </font><font
                size="-1"><font size="-1"><font size="-1"><font
                      color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font></font>
                uncompilable.&nbsp; (<b>XCOM-I</b> transparently deletes
                it, and other functions which are never called.) &nbsp;
                But in spite of the historical evidence of </font><font
                size="-1"><font size="-1"><font color="#663300"><code>DESCRIPTOR_MONITOR</code></font></font>,
                I see no such behavior in any of the <i>active</i>
                code, with a single exception:&nbsp; The
                memory-management system itself (i.e., SPACELIB) does
                have a </font><font size="-1"><font color="#663300"><code>BASED</code></font>
                variable, <font color="#663300"><code>DX</code></font>,
                which it continues to manage using <font
                  color="#663300"><code>MONITOR(6)</code></font> and <font
                  color="#663300"><code>MONITOR(7)</code></font>.<br>
              </font></blockquote>
            My observation is that <font color="#663300"><font
                color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font>
            must update more of the <font color="#663300"><code><i>basedVariable</i></code></font>
            than just its pointer to its data.<font color="#663300"><font
                color="#000000">&nbsp;&nbsp; </font></font>Recall that
            a <font color="#663300"><code>BASED</code></font> variable
            is associated with a 28-byte structure known as a <a
              moz-do-not-send="true" href="#DopeVectors">"dope vector"</a>,
            of which the pointer to the data comprises only bytes
            0-3.&nbsp; Beyond that, bytes 4-5 give the sizes (in bytes)
            of each record, while bytes 8-11 give the total number of
            records allocated so far.&nbsp; (Not to be confused with the
            total number of records in use; for growth, more records may
            have been allocated than were strictly needed at that
            moment.)&nbsp; While <font color="#663300"><font
                color="#000000"><code><font color="#663300">MONITOR(6)</font></code></font></font>
            may not need an entire dope vector to be present at the
            address it has been given, it needs the first 12 bytes to be
            present, so that it can use/update the fields just
            mentioned.&nbsp; I don't see evidence of that in the
            submonitor source code, but then I don't fully understand
            that source code; at any rate, this is how <b>XCOM-I</b>
            treats it.<br>
            <br>
            Note that <font color="#663300"><code>MONITOR(6)</code></font>
            <i>increases</i> the size of <code><font color="#663300"><i>basedVariable</i></font></code>
            by <code><font color="#663300"><i>n</i></font></code>
            bytes; it does not <i>set</i> the size to <code><font
                color="#663300"><i>n</i></font></code> bytes.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(7,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
              </font></code></td>
          <td valign="middle">Frees memory previously allocated via <code><font
                color="#663300">MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>)</font></code>.&nbsp;










            However, <code><font color="#663300"><i>basedVariable</i></font></code>'s










            pointer is not changed, and thus will continue to point to
            the freed area until explicitly changed.<br>
          </td>
          <td valign="middle" bgcolor="transparent">See the comments for
            <code><font color="#663300">MONITOR(6)</font></code>.&nbsp;
            <br>
            <br>
            If <code><font color="#663300"><i>n</i></font></code> is
            less than the total number of bytes allocated for <code><font
                color="#663300"><i>basedVariable</i></font></code>, then
            the number of records available in <code><font
                color="#663300"><i>basedVariable</i></font></code> has
            shrunk, but <code><font color="#663300"><i>basedVariable</i></font></code>
            continues to be usable, with a reduced number f records.<br>
            <br>
            Although described as having the address of a <font
              color="#663300"><code>BASED</code></font> variable as a
            parameter, this isn't entirely true.&nbsp; It is also
            sometimes the address of a <font color="#663300"><code>FIXED</code></font>
            variable.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(8, <i>dev</i>, <i>filenum</i>);<br>
              </font></code></td>
          <td valign="middle">Set PDS DDNAME.<br>
          </td>
          <td valign="middle" bgcolor="transparent">Apparently, the use
            of <code><font color="#663300">MONITOR(8)</font></code>
            changed after the only documentation of it (in IR-182-1) was
            produced, leaving us to try to infer its usage from context
            in the <b>HAL/S-FC</b> and <code><font color="#663300">MONITOR</font></code>'s










            source code.&nbsp; The purpose seems to be to change the
            association of files to device numbers, <i>à la</i> <font
              color="#663300"><code>DD</code></font>'s in JCL, but to do
            so dynamically during execution rather than statically at
            program startup.&nbsp; <br>
            <br>
            The <font color="#663300"><code><i>dev</i></code></font>
            parameter, an integer, would appear to be the logical device
            number as used in an <code>XPL <font color="#663300">INPUT(<i>dev</i>)</font></code>
            or <font color="#663300"><code>OUTPUT(<i>dev</i>)</code></font>
            (or in a HAL/S <font color="#663300"><code>READ(<i>dev</i>)</code></font>
            or <font color="#663300"><code>WRITE(<i>dev</i>)</code></font>).<br>
            <br>
            The <i><font color="#663300"><code>filenum</code></font></i>
            parameter is trickier for me to understand, because I'm
            unclear how <font color="#663300"><code>DD</code></font> in
            JCL associates a dataset name with a file number, so take
            what I say with a grain of salt.&nbsp; My inference, subject
            to change, is that if you have a dataset identified with the
            <font color="#663300"><code>DD</code></font> name "<font
              color="#663300"><code>INPUT<i>n</i></code></font>" (where
            <font color="#663300"><code><i>n</i></code></font> is a
            digit), then that is <font color="#663300"><code><i>filenum</i>=<i>n</i></code></font>;
            whereas a dataset named "<font color="#663300"><code>OUTPUT<i>n</i></code></font>"
            is associated with <font color="#663300"><code><i>filenum</i>="80000000"|<i>n</i></code></font>.&nbsp;










            Recall that <font color="#663300"><code>"80000000"</code></font>
            is XPL-speak for 0x80000000.&nbsp; So the <i><font
                color="#663300"><code>filenum</code></font></i> is
            implicit in the dataset name, and the most-significant bit
            is used to indicate the direction of data flow.<br>
            <br>
            For example, <font color="#663300"><code>INPUT(4)</code></font>
            invocations might normally input data from <font
              color="#663300"><code>INPUT4</code></font>, but you could
            associate it instead with <font color="#663300"><code>INPUT2</code></font>
            via<br>
            <blockquote>
              <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 2);</font><br></pre>
            </blockquote>
            and then reassociate it later with <font color="#663300"><code>INPUT4</code></font>
            via<br>
            <blockquote>
              <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 4);<br></font></pre>
            </blockquote>
            The description "Set PDS DDNAME" I've given as the
            description comes from the associated program comment in
            MONITOR.bal, the source-code for the <font color="#663300"><code>MONITOR</code></font>
            procedure.&nbsp; It would seem to imply that it has
            something specifically do with Partitioned Data Sets
            (PDS).&nbsp; It's difficult to see why that would be so; I
            think it merely reflects the specific usage in HAL/S-FC,
            which indeed relates to PDS.&nbsp; The <b>XCOM-I</b>
            runtime library allows it to be used for a PDS <i>or</i> a
            sequential dataset.&nbsp; It is not applicable to
            random-access files.<br>
            <br>
            Of course, there is no JCL, and consequently no DD
            statements, associated with an XPL or XPL/I file compiled
            with <b>XCOM-I</b>, nor with a HAL/S file compiled with <b>HAL/S-FC</b>.&nbsp;










            The description above has to be applied instead to
            command-line switches in a hopefully-obvious way.<br>
            <blockquote> </blockquote>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(9,<i>op</i>);<br>
              </font></code></td>
          <td valign="middle">Performs floating point evaluation as
            specified by value of <code><font color="#663300"><i>op</i></font></code>.&nbsp;










            Operands are obtained from work area whose address was set
            up via a <font color="#663300"><code>MONITOR(5)</code></font>
            call. The first operand is taken from the first double word
            of the work area and the second operand from the second
            double word. The result is placed in the first double word
            of the work area. The return code is 0 if the operation
            succeeds, or 1 if the operation fails (under or overflow).<br>
            <br>
            The values of <code><font color="#663300"><i>op</i></font></code>
            are:<br>
            <table cellspacing="2" cellpadding="2" align="center"
              border="1">
              <tbody>
                <tr>
                  <th valign="top">OP<br>
                  </th>
                  <th valign="top">Function<br>
                  </th>
                </tr>
                <tr>
                  <td valign="top" align="center">1<br>
                  </td>
                  <td valign="top" align="center">arg1 + arg2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">2<br>
                  </td>
                  <td valign="top" align="center">arg1 - arg2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">3<br>
                  </td>
                  <td valign="top" align="center">arg1 * arg2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">4<br>
                  </td>
                  <td valign="top" align="center">arg1 / arg2<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">5<br>
                  </td>
                  <td valign="top" align="center">arg1<sup>arg2</sup><br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">6<br>
                  </td>
                  <td valign="top" align="center">sin(arg1)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">7<br>
                  </td>
                  <td valign="top" align="center">cos(arg1)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">8<br>
                  </td>
                  <td valign="top" align="center">tan(arg1)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">9<br>
                  </td>
                  <td valign="top" align="center">exp(arg1)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">10<br>
                  </td>
                  <td valign="top" align="center">log(arg1)<br>
                  </td>
                </tr>
                <tr>
                  <td valign="top" align="center">11<br>
                  </td>
                  <td valign="top" align="center">sqrt(arg1)<br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
          </td>
          <td valign="middle">"arg1" refers to the DP floating-point
            number stored in the pair of work-area valued <font
              color="#663300"><code>DW(0),DW(1)</code></font>.<br>
            <br>
            "arg2" refers to the DP floating-point number stored in the
            pair of work-area valued <font color="#663300"><code>DW(2),DW(3)</code></font>.<br>
            <br>
            The DP floating-point result of the operation is stored back
            into <font color="#663300"><code>DW(0),DW(1)</code></font>,
            although not all of the operations can necessarily produce
            results of full DP accuracy from DP operands.<br>
            <br>
            The angular unit for trigonometric operations is the radian.<br>
            <br>
            Note that the values stored in these registers of the
            work-area are in the binary format of "IBM hexadecimal
            floating-point", which are not used anywhere else in XPL
            memory (unless copied from the working area).<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(10,<i>string</i>);<br>
              </font></code></td>
          <td valign="middle">Performs character to DP floating-point
            conversion upon characters in <code><font color="#663300"><i>string</i></font></code>.
            The return code is 0 if the result is valid, or 1 if
            conversion was not possible. The result is placed in the
            first double word of the work area provided by the <font
              color="#663300"><code>MONITOR(5)</code></font> call.<br>
          </td>
          <td valign="middle">In other words, <code><font
                color="#663300"><i>string</i></font></code> is
            interpreted as a DP floating-point number and stored in <font
              color="#663300"><code>DW(0),DW(1)</code></font>.&nbsp; Any
            of the usual representations for decimal numbers are
            accepted in the string, including the usual <font
              color="#663300"><code>E</code></font> notation for
            exponents.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(11);<br>
              </font></code></td>
          <td valign="middle">No-op.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>string</i>=MONITOR(12,<i>p</i>);<br>
              </font></code></td>
          <td valign="middle">Converts floating-point number in the
            first double word of the work area to standard HAL/S
            character form. Value of <code><font color="#663300"><i>p</i></font></code>
            indicates whether the operand is SP (<code><font
                color="#663300"><i>p</i></font></code>=0) or DP (<code><font
                color="#663300"><i>p</i></font></code>=8).<br>
          </td>
          <td valign="middle">In other words, this is the inverse of <code><font
                color="#663300">MONITOR(10,<i>string</i>)</font></code>
            (see above).<br>
            <br>
            As far as the "standard HAL/S character form" is concerned,
            it's described in HAL/S documentation (<i>Programming in
              HAL/S</i>, p. 3) as follows:<br>
            <ul>
              <li>0.0: Printed as " 0.0" (notice the leading space).</li>
              <li>Positive: Printed as " d.ddd...E±ee"</li>
              <li>Negative: Printed as "-d.ddd...E±ee"</li>
            </ul>
            Except for the special case 0.0, the number of printed
            fractional digits is always the same, although we're not
            told exactly how many that it is:&nbsp; merely that it is
            "implementation dependent".&nbsp; I believe, without any
            basis — and therefore <b>XCOM-I</b> implements — that the
            number of fractional digits is chosen to provide the maximum
            accuracy, which is 6 for single precision and 15 for double
            precision.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>address</i>=MONITOR(13,<i>name</i>);<br>
              </font></code></td>
          <td valign="middle">Performs DELETE of current option
            processor and then LOADs an option processor specified by <code><font
                color="#663300"><i>name</i></font></code>. The option
            processor loaded is called and passed a pointer to the PARM
            field in effect at the time of compiler invocation. The
            option processor passes the PARM field and establishes an
            options table (see Chapter 9 [of document IR-182-1]) whose
            address is passed back as a return value.&nbsp; If <code><font
                color="#663300"><i>name</i></font></code> is a null
            string, the pointer to the existing options table is
            returned.<br>
          </td>
          <td valign="middle"><a name="MONITOR13"></a><a
              moz-do-not-send="true" href="#programOptions">See the
              earlier discussion concerning program options</a>.&nbsp;
            In brief, each XPL or XPL/I program has some defined set of
            "Type 1" options and "Type 2" options.&nbsp; The former are
            binary (on/off) options, whereas the latter are options with
            integer or string values.<br>
            <br>
            <code><font color="#663300">MONITOR(13,<i>name</i>)</font></code>
            returns an address which is used by the XPL program to find
            options settings for it that have been set up by the
            run-time library.&nbsp; In C terms, it's the equivalent for
            <font color="#663300"><code>argv[]</code></font> but with
            more behind-the-scenes interpretation of the
            parameters.&nbsp; Those program options would originally
            have been provided by the Job Control Language (JCL) which
            initiated execution of the program, by means a "PARM field"
            given on one of the JCL cards.&nbsp; For example, in the JCL<br>
            <blockquote>
              <pre><font color="#663300">//XPL EXEC PGM=MONITOR,<br>//         PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</font><br></pre>
            </blockquote>
            the PARM field is the string <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font>,
            and the comma-delimited items are the individual options
            selected.&nbsp; Presumably, the operating system wouldn't
            have been able to directly interpret the meaning of this
            PARM field on its own, since the types of options would have
            been specific to the program being run.&nbsp; So an "option
            processor" specific to the allowed parameters must be loaded
            to perform that interpretation.&nbsp; In the case of the
            Intermetrics version of <b>HAL/S-FC</b>, the particular
            options processor for compiler pass 1 was <code><font
                color="#663300"><i>name</i></font></code><font
              color="#663300"><code>='COMPOPT '</code></font>, whereas
            it was an empty string for passes 2 and 3, and <font
              color="#663300"><code>'LISTOPT '</code></font> for pass
            4.&nbsp; (Note the trailing spaces to make the non-empty
            strings come out to 8 characters.&nbsp; These trailing
            spaces are not required in <b>XCOM-I</b>.)&nbsp; <br>
            <br>
            Again, just to be doubly clear, <code><font color="#663300">MONITOR(13)</font></code>
            provides access to options settings <i>not</i> for <b>XCOM</b>
            or <b>XCOM-I</b>, but rather for the XPL program being
            compiled by <b>XCOM-I</b>, and specifically for <b>HAL/S-FC</b>.
            <br>
            <br>
            <b>XCOM-I</b> supports the pre-existing built-in options
            processors 'COMPOPT', 'LISTOPT' and 'MONOPT'.&nbsp; (MONOPT
            provides the parameters described in <i>A Compiler
              Generator</i> but they are passed to the XPL/I program in
            the Intermetrics manner rather than being confined to the
            submonitor as in <i>A Compiler Generator</i>.)&nbsp; Plus,
            it is possible (as described in the discussion of program
            options) for the user to define their own custom options
            processor called 'USEROPT'.&nbsp; Whenever <code><font
                color="#663300">MONITOR(13)</font></code> is called, it
            saves the <code><font color="#663300"><i>name</i></font></code>
            and the PARM field to a file called "monitor13.parms".&nbsp;
            If called with an empty <code><font color="#663300"><i>name</i></font></code>,
            or more typically as <code><font color="#663300">MONITOR(13,0)</font></code>,
            it simply reloads the contents of monitor13.parms and reuses
            those.<br>
            <br>
            The <code><font color="#663300"><i>address</i></font></code>
            returned by <code><font color="#663300">MONITOR(13)</font></code>
            is a pointer in memory to the beginning of a block of 6
            consecutive <font color="#663300"><code>FIXED</code></font>
            values<font size="-1"><b>:</b></font><br>
            <ul>
              <li><font color="#663300"><font color="#000000">The<b> </b>first










                    is a <font color="#663300"><code>FIXED</code></font>
                    value (called </font></font><font color="#663300"><font
                    color="#000000"><font color="#663300"><code>OPTIONS_CODE</code></font>
                    or <font color="#663300"><code>OPTION_BITS</code></font>)
                    that collects</font></font> 32 bit flags, each of
                them (in principle) itself representing a type 1
                (on/off) option. Refer to the source-code files
                COMPOPT.bal, LISTOPT.bal, and MONOPT.bal (in the
                MONITOR.ASM folder of the <b>HAL/S-FC</b> source code)
                for the detailed list of which options correspond to
                which of the 32 bits.</li>
              <li><font color="#663300"><font color="#000000">The
                    remaining five values are the pointer addresses for
                    <font color="#663300"><code>BASED FIXED</code></font>
                    arrays: </font><code>CON</code></font>, <font
                  color="#663300"><code>PRO</code></font>, <font
                  color="#663300"><code>TYPE2</code></font>, <font
                  color="#663300"><code>VALS</code></font>, <font
                  color="#663300"><code>NPVALS</code></font> (or <font
                  color="#663300"><code>MONVALS</code></font>), each of
                which the options processor has already allocated memory
                for and equipped with data:</li>
              <ul>
                <li><font color="#663300"><code>CON</code></font>: This
                  is an array of string descriptors for the selected
                  type 1 options. <b>HAL/S-FC</b> uses it just for
                  printing a report in pass 1, while using <font
                    color="#663300"><code>OPTIONS_CODE</code></font> in
                  place of it for any more-significant purpose. <a
                    moz-do-not-send="true" href="#programOptions">Our
                    earlier section on program options</a> lists the
                  order in which the parameters appear in <font
                    color="#663300"><code>CON</code></font>.</li>
                <li><font color="#663300"><code>PRO</code></font>: In
                  principle, this is like <font color="#663300"><code>CON</code></font>,
                  but instead contains the opposites of the selected
                  options. For example, if "LISTING2" appears in <font
                    color="#663300"><code>CON</code></font>, then
                  "NOLISTING2" appears in <font color="#663300"><code>PRO</code></font>.</li>
                <li><font color="#663300"><code>TYPE2</code></font>:
                  This array contains the names (as string descriptors)
                  of options of type 2 (i.e., options which can be
                  assigned value other than on/off). They are presented
                  in the order listed in the discussion of program
                  options. <br>
                </li>
                <li><font color="#663300"><code>VALS</code></font>: This
                  array contains the values of the options of type 2, in
                  the same order as the names in the <font
                    color="#663300"><code>TYPE2</code></font> array.
                  Once again, see the discussion of program options.</li>
                <li><font color="#663300"><code>NPVALS/MONVALS</code></font>:
                  This is like <font color="#663300"><code>CON/PRO</code></font>,
                  except that in principle it contains values of options
                  which are <i>not</i> among the list printed by <b>HAL/S-FC</b>,
                  which roughly speaking, is half of them.</li>
              </ul>
            </ul>
            <ul>
            </ul>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(14,<i>n</i>,<i>a</i>);<br>
              </font></code></td>
          <td valign="middle">For creating Simulation Data Files.&nbsp;
            The value of <code><font color="#663300"><i>n</i></font></code>
            selects a function; the value of <code><font
                color="#663300"><i>a</i></font></code> supplies
            supplementary data:<br>
            <br>
            <table cellspacing="2" cellpadding="2" align="center"
              border="1">
              <tbody>
                <tr>
                  <th valign="top"><code><font color="#663300"><i>n</i></font></code></th>
                  <th valign="top">Function<br>
                  </th>
                  <th valign="top"><code><font color="#663300"><i>a</i></font></code></th>
                </tr>
                <tr>
                  <td valign="middle" align="center">0<br>
                  </td>
                  <td valign="middle" align="center">Open<br>
                  </td>
                  <td valign="middle" align="center">option flags<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">1<br>
                  </td>
                  <td valign="middle" align="center">Write<br>
                  </td>
                  <td valign="middle" align="center">area address<br>
                  </td>
                </tr>
                <tr>
                  <td valign="middle" align="center">2<br>
                  </td>
                  <td valign="middle" align="center">Stow &amp; Close<br>
                  </td>
                  <td valign="middle" align="center">member name<br>
                  </td>
                </tr>
              </tbody>
            </table>
            <br>
          </td>
          <td valign="middle">(Note that simulation data files are not
            presently supported; they relate to <b>PASS3</b> and <b>PASS4</b>
            of the HAL/S compiler, and those passes are not yet
            supported.)<br>
            <br>
            Unfortunately, the only documentation of this is from 1976,
            and it may be somewhat preliminary in nature.<br>
            <br>
            For example, from the source code of <b>HALS/FC</b> (see
            the <font color="#663300"><code>OUTPUT_SDF</code></font>
            procedure in <b>PASS3</b>), the function numbers (<code><font
                color="#663300"><i>n</i></font></code>) appear to be 0,
            4, and 8 (rather than 0, 1, and 2 as it says in the
            description to the neighboring column).<br>
            <br>
            It appears to me that it's used somewhat like this:&nbsp; <br>
            <ol>
              <li>First you "open" the SDF file.&nbsp; It apparently
                consists of "pages", numbered from 0 upward.&nbsp; The
                only "option" you can give it is the maximum page
                number.</li>
              <li>Then you "write" to the file a page at a time,
                starting at page 0.&nbsp; Each "write" transfers data
                from the "area address" you specify to the next higher
                page in the buffer.</li>
              <li>Finally, you "stow&amp;close" the SDF file.&nbsp; This
                is the step which writes the memory buffer out to the
                actual SDF file (if it hasn't been doing so already),
                which is a partitioned data set (PDS).&nbsp; The member
                name of the PDS is assigned at this point.&nbsp; Note
                that the member name can be one that already exists in
                the PDS, which will cause the existing member to be
                overwritten.<br>
              </li>
            </ol>
            <p>Thus you start with a presumably-empty PDS (which happens
              to be attached to output device 5), and end up with a PDS
              populated with lots of named members, each one of which
              consists of some integral number of "pages".<br>
            </p>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>I</i>=MONITOR(15);<br>
              </font></code></td>
          <td valign="middle">Returns Revision Level and Catenation
            Number from last <font color="#663300"><code>MONITOR(2)</code></font>
            call.&nbsp; Catenation number is obtained from PDS directory
            data and Revision Level from user data field as specified in
            the HAL/SDL ICD. The values are returned in the left and
            right halfwords of the result.<br>
          </td>
          <td valign="middle">The function always returns
            0xF0F00000.&nbsp; <br>
            <blockquote><font size="-1"><b>Aside:</b>&nbsp; That's not
                what it's <i>supposed</i> to return, but the
                description of what it's really supposed to do leaves me
                in the dark, so that's my compromise.</font><font
                size="-1"><font size="-1">&nbsp; How I came up with
                  0xF0F00000 is also now a mystery to me.&nbsp; Formerly
                  I had <code>MONITOR(15)</code> print "FYI" messages
                  in the PASS1 report as warnings to the programmer, but
                  those eventually became annoying to me, not to mention
                  useless in any practical sense, so the operation no
                  longer gives any warnings in the output report.</font>
                <br>
                <br>
                There's only one place in PASS/BFS source code where <code>MONITOR(15)</code>
                is explicitly used, I believe, and that's in the <code>INCLUDE_OK()</code>
                function of HALINCL/PATCHINC.xpl.&nbsp; If anyone wants
                to dig into it and figure it out, let me know the
                results.</font><br>
            </blockquote>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(16,<i>n</i>);<br>
              </font></code></td>
          <td valign="middle">Sets flags in byte to be returned as high
            order byte of return code at end of compilation. Flags are
            passed as right most byte of fullword <code><font
                color="#663300"><i>n</i></font></code>. If high order
            bit of <code><font color="#663300"><i>n</i></font></code>
            is zero, flags are OR'ed into existing flags. If high order
            bit of <code><font color="#663300"><i>n</i></font></code>
            is one, flags replace existing flags.<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(17,<i>name</i>);<br>
              </font></code></td>
          <td valign="middle">Causes <i><code><font color="#663300">name</font></code></i>
            to be copied to third parm field (if any) passed to <font
              color="#663300"><code>MONITOR</code></font> by the program
            that invoked the compiler. See HAL/SDL ICD.<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>T</i>=MONITOR(18);<br>
              </font></code></td>
          <td valign="middle">Returns elapsed CPU time since beginning
            of run in units of .01 seconds.<br>
          </td>
          <td valign="middle"><br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(19,<i>addressList</i>,<i>sizeList</i>);<br>
              </font></code></td>
          <td valign="middle">This is an extended form of <font
              color="#663300"><code>MONITOR(6)</code></font> (see
            above), accepting arrays of addresses of <font
              color="#663300"><code>BASED</code></font> variables and
            their block sizes.&nbsp; Unlike <font color="#663300"><code>MONITOR(6)</code></font>,
            the newly-allocated blocks of memory are not cleared to 0.<br>
          </td>
          <td valign="middle"><b>XCOM-I</b> does not implement this
            function.&nbsp; Besides, it's unclear how to represent a
            "list".<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(20,</font></code><code><font
                color="#663300"><code><font color="#663300"><i>addressList</i>,<i>sizeList</i></font></code>);<br>
              </font></code></td>
          <td valign="middle">This is an extended form of <font
              color="#663300"><code>MONITOR(7)</code></font> (see
            above), accepting arrays of addresses of <font
              color="#663300"><code>BASED</code></font> variables and
            their block sizes. <br>
          </td>
          <td valign="middle"><b>XCOM-I</b> does not implement this
            function. </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>I</i>=MONITOR(21);<br>
              </font></code></td>
          <td valign="middle">Returns remaining amount of memory (in
            bytes) that's free for allocation via <font color="#663300"><code>MONITOR(6)</code></font>.<br>
          </td>
          <td valign="middle">For Intermetrics <b>XCOM</b>, I believe,
            <font color="#663300"><code>MONITOR(6)</code></font> could
            use <i>any</i> contiguous block of free memory, including
            those that were candidates for garbage collection.&nbsp;
            Whereas <b>XCOM-I</b> only allocates memory within the
            contiguous block at the end of the free-memory space.&nbsp;
            Consequently, this function would originally have found the
            largest free block wherever it was located, whereas <b>XCOM-I</b>
            merely reports the size of the final block of free memory.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i><code><font color="#663300"><code><font
                          color="#663300"><i>F</i></font></code></font></code></i><code><font
                    color="#663300"><code><font color="#663300">=MONITOR(22,0,<i>n</i><i><sub>2</sub></i>);</font></code></font></code><i><code><font
                      color="#663300"><code><font color="#663300"><br>
                        </font></code></font></code>F</i>=MONITOR(22,<i>n<sub>1</sub></i>);</font></code><br>
            <code><font color="#663300"><code></code> </font></code></td>
          <td valign="middle">Calls SDF access package.<br>
          </td>
          <td valign="middle">(Note that simulation data files are not
            presently supported; they relate to <b>PASS3</b> and <b>PASS4</b>
            of the HAL/S compiler, and those passes are not yet
            supported.)<br>
            <br>
            SDF stands for Simulation Data File.&nbsp; The "SDF access
            package" (SDFPKG) was a separate program, similar to the
            submonitor itself, with which the XPL/I program could
            communicate via <font color="#663300"><code>MONITOR(22)</code></font>.&nbsp;










            And like the submonitor, in the <b>XCOM-I</b> framework,
            SDFPKG equivalents are built into the runtime library rather
            than being provided by a separate SDFPKG program.&nbsp; <br>
            <br>
            Documentation can be found in TBD.&nbsp; There is not space
            for a full description here, so I'm only giving a brief
            summary; the documentation should be consulted for more
            details.<br>
            <br>
            The first form, <code><font color="#663300"><code><font
                    color="#663300"><code><font color="#663300"><code><font
                            color="#663300"><i><code><font
                                  color="#663300"><code><font
                                      color="#663300"><i>F</i></font></code></font></code></i><code><font
                                color="#663300"><code><font
                                    color="#663300">=</font></code></font></code></font></code>MONITOR(22,0,<i>n</i><i><sub>2</sub></i>)</font></code></font></code></font></code>,
            initializes the SDFPKG functionality.&nbsp; The <code><font
                color="#663300"><code><font color="#663300"><code><font
                        color="#663300"><i>n</i><i><sub>2</sub></i></font></code></font></code></font></code>
            parameter points to an array of 30 <font color="#663300"><code>FIXED</code></font>
            values which serves as a "communications area" holding data
            for subsequent calls. <br>
            <br>
            For calls of the second form, <code><font color="#663300"><i>F</i>=MONITOR(22,<i>n<sub>1</sub></i>)</font></code>,
            the <code><font color="#663300"><i>n<sub>1</sub></i></font></code>
            parameter specifies a function number ("mode"):<br>
            <ol>
              <li>Terminate SDFPKG.</li>
              <li>Augment paging area.</li>
              <li>Rescind paging area augments.</li>
              <li>Select an SDF.</li>
              <li>Locate pointer.</li>
              <li>Set disposition parameters.</li>
              <li>Locate directory root cell.</li>
              <li>Locate block data cell given block number.</li>
              <li>Locate symbol data cell given symbol number.</li>
              <li>Locate statement data cell given statement number.</li>
              <li>Locate block data cell given block name.</li>
              <li>Locate symbol data cell given block name and symbol
                name.</li>
              <li>Locate symbol data cell given only symbol name.</li>
              <li>Locate statement data cell given SRN.</li>
              <li>Locate block node given block number.</li>
              <li>Locate symbol node given symbol number.</li>
              <li>Locate statement node given statement number.</li>
              <li>Locate initialization data given symbol number. <br>
              </li>
              <li>Deselect an SDF.<br>
              </li>
            </ol>
            There's some confusion in the available
            software/documentation, in that sometimes function #19 is
            missing; and when #19 is missing, #18 may either be as shown
            or else may be deselection of the SDF.&nbsp; I have no
            explanation for that discrepancy.&nbsp; However, the
            functional lineup listed above is consistent with the
            version of HAL/S-FC source code we have.<br>
            <br>
            Additionally, the function number <code><font
                color="#663300"><i>n<sub>1</sub></i></font></code> may
            have high-order bits set, such as 0x10000006 or
            0x80000007.&nbsp; The significance of that is TBD.<br>
            <br>
            The return code, <code><font color="#663300"><i><code><font
                      color="#663300"><code><font color="#663300"><i>F</i></font></code></font></code></i></font></code>,
            for all calls is 0 upon success, or non-zero for various
            failures.&nbsp; See section 11 of the documentation.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>descriptor</i>=MONITOR(23);<br>
              </font></code></td>
          <td valign="middle">Returns the <code><font color="#663300"><i>descriptor</i></font></code>
            of the 10-character string obtained from the ID field of the
            File Control Block of the first phase of the compiler.&nbsp;
            The ID field is maintained by the <b>XPLZAP</b> program and
            contains the identifying string printed on the header of
            each page of the HAL listing". </td>
          <td valign="middle">I think that what the original
            documentation was trying to get at is that <b>HAL/S-FC</b>'s










            version code, printed on each of the report pages printed by
            <b>XCOM</b> (or now, <b>XCOM-I</b>), is given by this ID
            string, and that the ID string is provided to each pass of <b>HAL/S-FC</b>
            via a call to <code><font color="#663300">MONITOR(23)</font></code>.&nbsp;










            Of course, in the modern reimplementation, there is no <b>XPLZAP</b>
            program, and it wouldn't be compatible with <b>XCOM-I</b>
            if there were one.&nbsp; In <b>XCOM-I</b>, the ID string
            itself is by default 'REL32V0&nbsp;&nbsp; ', but it can be
            changed via the <b>XCOM-I</b> command-line parameter <font
              color="#663300"><code>--identifier</code></font>.<br>
            <br>
            As for what a "descriptor" is, see <a
              moz-do-not-send="true" href="#datatypes">the description
              of the CHARACTER datatype</a>.&nbsp;&nbsp; In brief, the
            return value is not itself the ID string, but an integer
            value (i.e., of the <font color="#663300"><code>FIXED</code></font>
            datatype) that provides an index for finding the ID string
            in memory. <br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(24)<br>
              </font></code></td>
          <td valign="middle">Read a block of a load module.<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(25)<br>
              </font></code></td>
          <td valign="middle">Read a mass-memory load block.<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(26)<br>
              </font></code></td>
          <td valign="middle">Read a MAF (memory analysis file) block<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(27)<br>
              </font></code></td>
          <td valign="middle">Write a MAF block<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(28)<br>
              </font></code></td>
          <td valign="middle">Link to dump analysis service routine<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(29)<br>
              </font></code></td>
          <td valign="middle">Return current page number<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(30)<br>
              </font></code></td>
          <td valign="middle">Return JFCB as string<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">CALL MONITOR(31</font></code><code><font
                color="#663300"><code><font color="#663300">,<i>n</i></font></code>,<i>recnum</i>)<br>
              </font></code></td>
          <td valign="middle">Virtual-memory lookahead service.<br>
          </td>
          <td valign="middle">This function is seemingly only used
            internally by the virtual-memory system.<br>
            <br>
            In looking at the the usage in actual XPL/I code, as well as
            the assembly-language source code for the submonitor (see <font
              color="#663300"><code>VMEMSRV</code></font> in <a
              moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM/MONITOR.bal">MONITOR.bal</a>),











            which admittedly I can only follow very imperfectly,&nbsp;
            it appears to me that this function is used in three
            distinct ways:<br>
            <ul>
              <li><font color="#663300"><code>MONITOR(31,<i>n</i>,-1)</code></font>,
                <font color="#663300"><code><i>n</i> &gt; 0</code></font>,
                sets the default file number for future <font
                  color="#663300"><code>MONITOR(31,...)</code></font>
                calls to <code><font color="#663300"><code><font
                        color="#663300"><i>n</i></font></code></font></code>.&nbsp;&nbsp;&nbsp;










                The default file number is initially 2.<br>
                <font color="#663300"><code></code></font></li>
              <li><font color="#663300"><code>MONITOR(31,<i>bufferAddress</i>,<i>recnum</i>)</code></font>
                , <font color="#663300"><code><i>recnum</i> </code><code>≥
                    0</code></font>, immediately initiates an operation
                that reads record <font color="#663300"><code><i>recnum</i></code></font>
                from the default file, into a memory buffer at address <font
                  color="#663300"><code><i>bufferAddress</i></code></font>.&nbsp;











                In IBM 360 terms, that's an "XDAP" operation.&nbsp; I
                think it's like what we'd call a DMA operation now, so
                this read operation may take some time to complete, but
                it's a background operation while it's doing so.<br>
              </li>
              <li><font color="#663300"><code>MONITOR(31,0,-1)</code></font>
                waits until a previously-initiated read operation on the
                default file has completed. <br>
              </li>
            </ul>
            There's an additional subtlety — really, that's astounding?!
            —, in that the <font color="#663300"><code><i>bufferAddress</i></code></font>
            in <font color="#663300"><code>MONITOR(31,<i>bufferAddress</i>,<i>recnum</i>)
              </code></font>may sometimes have its most-significant bit
            set to 1, thus turning it into a negative number.&nbsp; I
            think in that case what happens is that the function waits
            for any background read-operation already in progress to
            complete, and then clears the sign bit of <font
              color="#663300"><code><i>bufferAddress</i></code></font>
            and commences a new read operation.<br>
            <br>
            The <b>XCOM-I</b> runtime library, doesn't really need any
            of these subtleties, so implements this function basically
            as immediate <font color="#663300"><code>FILE</code></font>
            operations, as appropriate.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300"><i>F</i>=MONITOR(32)<br>
              </font></code></td>
          <td valign="middle">Find out subpool minimum size<br>
          </td>
          <td valign="middle">The memory-allocation and -deallocation
            functions (<code><font color="#663300">MONITOR</font></code>
            6, 7, 19, and 20) are supposed to get their memory from
            something called "SUBPOOL 22".&nbsp; SUBPOOLs apparently
            have block-sizes which are either 2048 or 4096 bytes,
            depending on the operating system.&nbsp; <code><font
                color="#663300">MONITOR(32)</font></code> returns the
            appropriate block size for the operating system.&nbsp; Given
            that the block size is bigger in later versions of the
            operating system, I infer that bigger is better, within
            certain limits, and hence <b>XCOM-I</b> arbitrarily returns
            4096.<br>
          </td>
        </tr>
        <tr>
          <td nowrap="nowrap" valign="middle" align="center"><code><font
                color="#663300">MONITOR(33)<br>
              </font></code></td>
          <td valign="middle">Find out FILE max REC# and BLKSIZ<br>
          </td>
          <td valign="middle">TBD<br>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <h1><a name="debugging"></a>Debugging XPL Programs</h1>
    <p>It is admittedly unlikely that many people will be writing new
      XPL or XPL/I programs nowadays, and will instead be compiling only
      legacy XPL or XPL/I programs ... assuming that I haven't already
      compiled all of them first! (Which is a distinct possibility.)
      Since such legacy programs will presumably all have been debugged
      decades before, there's not as much need for a debugger as there
      is for computer languages in which there are many active
      developers. Nevertheless, XPL or XPL/I programs can be run under a
      debugger to a certain extent.<br>
    </p>
    The trick is to realize that while we have no debugger for the XPL
    language, we do have debuggers for C, and once <b>XCOM-I</b> has
    translated XPL or XPL-I software into C, such C debuggers can be
    used. It is merely necessary when compiling your XPL program to use
    the appropriate command-line switches for incorporating debugging
    information into the executable.&nbsp; There are actually two
    aspects to this:&nbsp; Including the debugging aids provided by <b>XCOM-I</b>,
    and including the debugging information appropriate for whatever
    debugger software you're using.&nbsp; If you're using GNU <b>gdb</b>
    or any debugger that accepts <b>gdb</b>-style data to debug your
    program then, and for the sake of discussion ignoring any other
    options you chose to use (such as <font color="#663300"><code>CC=clang</code></font>),










    you'd compile your XPL program like this:<br>
    <blockquote>
      <pre><font color="#663300">XCOM-I.py --xpl --debugging-aid <i>SOURCEFILE</i>.xpl<br>make EXTRA=-ggdb -C <i>SOURCEFILE</i></font></pre>
      <b><font size="-1">Aside:</font></b><font size="-1">&nbsp; A
        particular class of XPL/I programs that one might wish to debug
        — or at any rate that <i>I</i> unsurprisingly find myself
        debugging — consists of the executables for the individual
        passes of the HAL/S compiler, <b>HALSFC</b>, such as <b>HALSFC-PASS1</b>
        and <b>HALSFC-PASS2</b>.&nbsp; In other words, how do you build
        the HAL/S compiler passes so that those passes themselves can be
        debugged via their C translations?&nbsp; <a
          moz-do-not-send="true" href="#halsfc">Building <b>HALSFC</b>
          in a "production" configuration has been described earlier</a>.&nbsp;
        In a POSIX environment using <b>gcc</b>, building a maximal
        debugging configuration might look something like this:<br>
      </font>
      <blockquote>
        <pre><font size="-1">make -s XEXTRA="--quiet --debugging-aid" EXTRA="-ggdb -DUSE_DLADDR -rdynamic -finstrument-functions -ldl" RDYNAMIC= all regression</font><br></pre>
      </blockquote>
      <font size="-1">Among the features accommodated by this "maximal"
        debugging configuration is that you can optionally log to a file
        of all entries and exits to C functions. Control of that logging
        feature involve setting (and "exporting") several environment
        variables before running the particular HAL/S compiler pass
        you're interested in.&nbsp; (You don't want to do a <i>complete</i>
        HAL/S compilation of multiple passes, though, because each
        successive pass would overwrite the log file created by the
        preceding pass!)<br>
      </font>
      <ul>
        <li><font size="-1"><code>XCOMI_TRACE=<i>logfileName</i></code>
            is used for setting the name of the log file to be created.&nbsp;
            If <code>XCOMI_TRACE</code> isn't defined, or is blank,
            then logging is disabled.</font></li>
        <li> <font size="-1"><code>XCOMI_MAX=<i>N</i></code> sets the
            maximum number of function entries allowed during execution
            of the program being debugged.&nbsp; (Function <i>exits</i>
            don't count.)&nbsp; The program being debugged terminates
            the program after <i><code>N</code></i> function entries
            have occurred.&nbsp; The default, -1, disables this feature,
            so no forced terminations of the program will occur.&nbsp;
            This feature is used to deal with problems like endless
            loops, in which the program wouldn't terminate on its own.<br>
          </font></li>
        <li><font size="-1"><code>XCOMI_FLOOR=<i>M</i></code> and <code>XCOMI_CEILING=<i>N</i></code>
            set a range of function-entry counts to add to the
            log.&nbsp; If less than <i><code>M</code></i> function
            entries have occurred, the entries (and exits) won't be
            logged.&nbsp; Similarly, if more than <i><code>N</code></i>
            function entries have occurred.&nbsp; Setting <code>XCOMI_CEILING</code>
            to -1 (the default) means that there will be no upper
            limit.&nbsp; The point of this feature is that under some
            circumstances it may be more convenient for you to work with
            a smaller log file.<br>
          </font></li>
      </ul>
    </blockquote>
    The C compiler undoubtedly has other debugging options as well,
    which you might use in place of (or in addition to) <font
      color="#663300"><code>-ggdb</code></font>, as the "aside" above
    illustrates.&nbsp; I won't provide any more advice than I have
    already, since if you want to do this in the first place it's very
    likely you know more about it than I do.&nbsp; You can, of course,
    use graphical-interface front-ends for <b>gdb</b> as well, at least
    in Linux and Mac OS, though I'm at a loss as to how to do this in
    Windows because of probably having to work under MSYS2.&nbsp; There
    is a primitive but useful debugging interface that works in MSYS2,
    provided directly by <b>gdb</b> itself (namely <font
      color="#663300"><code>gdb --tui</code></font>), that's a step up
    from its default command-line-style interface.&nbsp; And there are
    reports of people debugging MSYS2-generated programs in Visual
    Studio, although the descriptions of how to do it are geek to
    me.&nbsp; (Ha!&nbsp; See what I did there?)<br>
    <br>
    But debugging XPL code via its C translation is not as convenient as
    using a native XPL debugger would be.&nbsp; The principal difficulty
    in debugging the code in C vs in XPL is that <b>XCOM-I</b> doesn't
    model XPL variables as C variables, but rather as numerical
    locations in a byte-array called <font color="#663300"><code>memory</code></font>.&nbsp;











    Moreover, the format of this data in "memory" is that of the IBM
    System/360 rather than the native format of the computer on which
    debugging is being performed.&nbsp; So if you had an XPL variable
    called (say) <code>MYVAR</code>, neither would the debugger
    recognize that there was a variable called <code>MYVAR</code>, nor
    would its value be interpreted by the debugger as anything
    meaningful even if it were found. &nbsp; In my opinion these design
    choices for <b>XCOM-I</b> were are all necessary and unavoidable,
    but there's no denying that they make it trickier to use a debugger
    to see the how the values of variable change during execution.&nbsp;
    <br>
    <br>
    I have provided a few C functions in the <b>XCOM-I</b> runtime
    library to make it a <i>little</i> less painful to examine XPL
    variables within a debugger.&nbsp; Those aids aren't included by
    default, and including them is the purpose of the "<tt>--debugging-aid</tt>"
    command-line option mentioned above.&nbsp; You can also use the XPL
    <font color="#663300"><code>CALL INLINE</code></font> feature to
    directly embed calls to these functions within your program, with or
    without running a debugger at all, if it's more convenient for you
    to do so.<br>
    <br>
    The most-useful debugging functions are:<br>
    <ul>
      <li><font color="#663300"><code>char *getXPL(char *identifier)</code></font>
        — Returns (as a C string) the value of a single XPL variable
        whose name is given by the <font color="#663300"><code>identifier</code></font>.
        The <font color="#663300"><code>identifier</code></font> string
        can be any identifier expression that's syntactically correct in
        XPL/I, provided that subscripts consist entirely of decimal
        digits, possibly with a leading minus sign, or else of integer
        XPL variables. This includes expressions like <font
          color="#663300"><code>"V"</code></font>, <font
          color="#663300"><code>"V(5)"</code></font>, <font
          color="#663300"><code>"B(3).V"</code></font>, or <font
          color="#663300"><code>"B(I).V(-5)"</code></font>. Recall that
        in XPL/I, subscripts can be applied to scalar variables. If you
        are querying a <font color="#663300"><code>BASED RECORD</code></font>,
        then be sure to include the desired field, since while <font
          color="#663300"><code>getXPL</code></font> knows how to print
        an individual field of a <font color="#663300"><code>RECORD</code></font>,
        it does not know how to print a <i>collection</i> of fields
        such as a <font color="#663300"><code>RECORD</code></font>. In
        a <b>gdb</b> console, you could use <font color="#663300"><code>getXPL</code></font>
        with a command like <font color="#663300"><code>print
            getXPL(...)</code></font>. For example, <font
          color="#663300"><code>print getXPL("C1(4)")</code></font>.&nbsp;










        But expressions for the subscripts are not understood.<br>
      </li>
      <li><font color="#663300"><code>int ADDR(char *base, int bIndex,
            char *field, int fIndex)</code></font> — Given the name of a
        <font color="#663300"><code>BASED</code></font> variable (or 0
        if none), an index into it, the name of field (or 0 if none),
        and an index into it, returns the "address"; i.e., the offset
        into the <font color="#663300"><code>memory</code></font>
        array.<br>
      </li>
    </ul>
    <p>There are other runtime-library functions and debugging-aid
      functions that are useful from time to time, though the ones
      listed above are the bread-and-butter, but I won't bother
      describing them here until/unless somebody asks me about
      them.&nbsp; You can see them all by examining the file
      XCOM-I/debuggingAid.c.<br>
    </p>
    <p>In using these debugging functions, note that they all require <i>mangled</i>
      forms of XPL variable names and parameters of XPL <code>PROCEDURE</code>s.










      <br>
    </p>
    <p>Mangling?&nbsp; Shmangling!&nbsp; What the heck are mangled XPL
      names?<br>
    </p>
    <p>First, recall that XPL is case-insensitive in so far as
      identifiers (and keywords are concerned), therefore:<br>
    </p>
    <ul>
      <li>All XPL identifiers are automatically capitalized when
        mangled.<br>
      </li>
    </ul>
    <p>Second, <b>XCOM-I</b> wants to use identifiers in the generated
      C code which are as close to the identifiers originally used in
      the XPL code as possible, even it's only to make it easier for we
      mere humans to read and to match against the original code.&nbsp;
      But XPL identifiers can contain not only the alphanumeric
      characters, but also the characters '#', '@', and '$', which are <i>not</i>
      legal characters for identifiers in C.&nbsp; Part of the mangling
      process is therefore to make the following substitutions in
      identifier mangling:<br>
    </p>
    <ul>
      <li>'#' → 'p'</li>
      <li>'@' → 'a'</li>
      <li>'$' → 'd'</li>
    </ul>
    <p>Additionally, though, the underscore character ('_') is
      problematic in some C compilers.&nbsp; The worst offender I'm
      aware of is the <b>cl</b> compiler from Microsoft's Visual
      Studio.&nbsp; <a moz-do-not-send="true"
href="https://learn.microsoft.com/en-us/cpp/c-language/c-identifiers?view=msvc-170">I
        quote directly from Microsoft</a> (emphasis mine):<br>
    </p>
    <blockquote><font size="-1">"<b>Don't select names for identifiers
          that begin</b> with two underscores or <b>with an underscore
          followed by an uppercase letter</b>. The ANSI C standard
        allows identifier names that begin with these character
        combinations to be reserved for compiler use. Identifiers with
        file-level scope should also not be named with an underscore and
        a lowercase letter as the first two letters. Identifier names
        that begin with these characters are also reserved. <b>By
          convention, Microsoft uses an underscore and an uppercase
          letter to begin macro names</b> and double underscores for
        Microsoft-specific keyword names. <b>To avoid any naming
          conflicts, always select identifier names that don't begin</b>
        with one or two underscores, or names that begin <b>with an
          underscore followed by an uppercase letter.</b>"</font><br>
    </blockquote>
    <p>There are a number of such XPL identifiers in the source code for
      <b>HAL/S-FC</b>, and <b>cl</b> blasts them to infinity (or
      beyond) if they appear as-is in the generated C code.&nbsp; To
      work around this problem, <b>XCOM-I</b> performs the additional
      automatic substitution in identifier mangling:<br>
    </p>
    <ul>
      <li>'_' → 'u'</li>
    </ul>
    <p>Note that these four substitutions are everywhere within an
      identifier, and not merely in the leading character.&nbsp; <b><br>
      </b></p>
    <blockquote>
      <p><font size="-1"><b>Note:</b>&nbsp; Names of fields within the <code>RECORD</code>
          of a <code>BASED</code> variable are exempt from
          mangling.&nbsp; There's no deep reason for omitting the field
          names from the mangling process, other than that I forgot to
          do it, and it turned out to be unnecessary.&nbsp; Although
          unnecessary, I did attempt to implement it later, just for
          consistency.&nbsp; But it turned out to be tricky to do, so I
          chucked the attempt.&nbsp; </font><br>
      </p>
    </blockquote>
    <p>Finally, while <code>PROCEDURE</code> definitions and variable
      declarations can be embedded inside of <code>PROCEDURE</code>
      definitions in XPL, functionally these embedded entities all act
      as if they were globally declared.&nbsp; It is only their
      namespaces which are restricted.&nbsp; Therefore:<br>
    </p>
    <ul>
      <li>Mangled names are <i>prefixed</i> by the mangled names of
        every parent <font color="#663300"><code>PROCEDURE</code></font>,
        separated by 'x' for readability. Perhaps an example would make
        this clearer. Suppose your XPL source code looked like the
        following:</li>
    </ul>
    <blockquote>
      <blockquote>
        <pre><font color="#663300">DECLARE X FIXED, Y FIXED, Z FIXED;<br></font></pre>
        <pre><font color="#663300">PROC1:<br>PROCEDURE(X, Y);<br>   DECLARE X FIXED, Y FIXED, Z FIXED;<br><br>   PROC2:<br>   PROCEDURE(X, Y);<br>      DECLARE X FIXED, Y FIXED, Z FIXED;<br>      ...<br>   END PROC2;<br><br>END PROC1;</font><br></pre>
      </blockquote>
    </blockquote>
    <blockquote>
      <p>Then the mangled variable, parameter, and <font
          color="#663300"><code>PROCEDURE</code></font> names would be:<br>
      </p>
      <blockquote>
        <pre><font color="#663300">X<br>Y<br>Z<br>PROC1<br>PROC1xX<br>PROC1xY<br>PROC1xZ<br>PROC1xPROC2<br>PROC1xPROC2xX<br>PROC1xPROC2xY<br>PROC1xPROC2xZ</font><br></pre>
      </blockquote>
      Thus while we have lots of global and local variables and function
      parameters named <font color="#663300"><code>X</code></font>, <font
        color="#663300"><code>Y</code></font>, and <font
        color="#663300"><code>Z</code></font>, their mangled names are
      all distinct. <br>
    </blockquote>
    <h1> <a name="hooks"></a>Patches for Insertion of Arbitrary Inline
      Code</h1>
    A serious difficulty in working with XPL or XPL/I code is that they
    are often not written entirely in XPL/I, but also have insertions of
    inline machine code at various junctures.&nbsp; <br>
    <br>
    For example, <b>XCOM45</b> and <b>HAL/S-FC</b> source code both
    have such inlined code.&nbsp; However good <b>XCOM-I</b> may (or
    may not) be at translating XPL or XPL/I to C, it is not capable of
    inferring the intent of arbitrary assembly language, nor of
    translating such code into C with the full level of reliability
    required for automating it.&nbsp;&nbsp; While it can <i>help</i>
    with such translation (as described in the <a
      moz-do-not-send="true" href="#inlines">next section</a>), some
    amount of manual intervention is still required on the part of the
    coder.&nbsp; The basic principles underlying the framework provided
    for that are discussed in this section.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; In reality, such
        inlined code is numerical in nature, and consists of IBM 360 <i>machine










          code</i> ... whereas the term "assembly language" implies that
        the insertions are symbolic in nature rather than just
        numbers.&nbsp; I'll continue to call the insertions BAL, because
        they undoubtedly began as BAL before somebody assembled them to
        determine which numerical values to use.&nbsp; But it is
        certainly technically incorrect to do so.<br>
      </font> </blockquote>
    Of course, one possible approach would be to replace offending
    inline code directly by C code in the XPL source-code files of the
    program being compiled, using the <b>XCOM-I</b> built-in <font
      color="#663300"><code>INLINE</code></font> function:<br>
    <blockquote>
      <pre><font color="#663300">CALL INLINE('<i>...arbitrary C code of no more than 256 characters...</i>');</font><br></pre>
    </blockquote>
    In your use case, whatever that may be, perhaps that's
    adequate.&nbsp; However, the Virtual AGC Project aims to provide a
    way to work with legacy code — i.e., code from the past, rather than
    newly-written code —, and that implies being able to compile such
    source code as-is, without syntactical or functional butchering of
    the original source code with "fixes" that may or may not be valid
    from somebody else's point of view.&nbsp; Which means that from <i>our</i>
    point of view, irreversible modification of legacy source code is
    unacceptable.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; It is, of course,
        arguable the extent to which modifications are acceptable.&nbsp;
        The Virtual AGC Project allows insertion of modern comments, as
        long as modern comments are clearly distinguishable from
        original program comments.&nbsp; It has occasionally allowed
        clearly-commented simple changes of a line or two of code, when
        it was thought impossible for modern compilers to duplicate some
        undocumented behavior of the original compilers ... although
        improvements to the modern compilers almost always eventually
        allowed reversal of such modifications.&nbsp; My personal
        judgment is that replacement of dozens or hundreds of lines of
        code by code that's not obviously functionally identical,
        written in another language, is taking it farther than I'd
        like.&nbsp; Better to leave the source code the same, so that
        it's in principle verifiable by the user as being the authentic
        source code.</font><br>
    </blockquote>
    Don't worry!&nbsp; <b>XCOM-I</b> lets us satisfy these
    criteria.&nbsp; But to understand <i>how</i>, you need to know a
    little more about this IBM Basic Assembly Language (BAL) code that's
    causing the problem.<br>
    <br>
    Let's let a real-life example guide the discussion.&nbsp; The XPL
    source-code for SUNY's <b>XCOM45</b> program — which as you'll
    recall is an XPL compiler from the State University of New York in
    the mid-1970's — contains a single block of 19 consecutive <font
      color="#663300"><code>CALL INLINE</code></font> statements that we
    need to work around if we want to compile <i>and run</i> a version
    of <b>XCOM45</b> with <b>XCOM-I</b>:<br>
    <blockquote>
      <pre><font color="#663300">SCAN_FINDS_END_OF:<br>   PROCEDURE(TABLE) BIT(1);<br>      DECLARE TABLE FIXED;<br>      DECLARE TRT(1) FIXED INITIAL("DD003000", "10000000");<br><br>      /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */<br>      CALL INLINE("58", 3, 0, TEXT);     /* LOAD STRING DESCRIPTOR */<br>      CALL INLINE("1B", 2, 2);           /* CLEAR REG. 2 */<br>      CALL INLINE("19", 3, 2);           /* CHECK FOR TEXT = NULL STRING */<br>      CALL INLINE("07", 8, 12);          /* RETURN FALSE IF TEXT IS NULL */<br>      CALL INLINE("8D", 2, 0, 0, 8);     /* SHIFT LENGTH FIELD TO REG. 2 */<br>      CALL INLINE("88", 3, 0, 0, 8);     /* RESTORE STRING ADDRESS  */<br>      CALL INLINE("58", 1, 0, TABLE);    /* LOAD BASE ADDRESS OF TRANS_TABLE */<br>      CALL INLINE("41", 12, 0, TRT);     /* LOAD ADDRESS OF TRT INSTRUCTION */<br>      CALL INLINE("44", 2, 0, 12, 0);    /* EXECUTE TRT INSTRUCTION */<br>      CALL INLINE("05", 12, 0);          /* LOAD BRANCH REGISTER  */<br>      CALL INLINE("47", 7, 0, 12, 18);   /* BRANCH ON CC~=0  */<br>      CALL INLINE("18", 1, 2);           /* LOAD REG. 1 WITH LENGTH(\) - 1 */<br>      CALL INLINE("41", 0, 0, 0, 1);     /* LOAD REG. 0 WITH 1  */<br>      CALL INLINE("1A", 1, 0);           /* ADD TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("1B", 3, 3);           /* PUT 0 INTO RETURN REGISTER */<br>      CALL INLINE("47", 15, 0, 12, 24);  /* BRANCH AROUND NEXT TWO INSTR*/<br>      CALL INLINE("1B", 1, 3);        /* SUBTRACT TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("41", 3, 0, 0, 1);     /* LOAD 1 INTO RETURN REGISTER */<br>      CALL INLINE("50", 1, 0, CP);       /* STORE IDENTIFIER LENGTH */<br>   END SCAN_FINDS_END_OF;</font><br></pre>
    </blockquote>
    Actually, to be clear, <b>XCOM-I</b> will <i>compile</i> <b>XCOM45</b>
    just fine, whether we work around this embedded assembly-language
    stuff or not; the compiled program simply won't run correctly,
    because vital IBM 360 instructions will be missing in the midst of
    the program.&nbsp; As it happens, though, part of the process of
    creating the workaround <i>depends</i> on us compiling <b>XCOM45</b>
    in advance, without any workarounds in place.&nbsp; So let's just do
    that.&nbsp; In the compilation process, the XPL procedure <font
      color="#663300"><code>SCAN_FINDS_END_OF</code></font> turns into a
    C file called SCANxSCAN_FINDS_END_OF.c that contains the following
    harmless but useless C representation of it:<br>
    <blockquote>
      <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-19 12:14:14.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>bit_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br>  ; // (0) CALL INLINE( 88, 3, 0, TEXT);<br>  ; // (1) CALL INLINE( 27, 2, 2);<br>  ; // (2) CALL INLINE( 25, 3, 2);<br>  ; // (3) CALL INLINE( 7, 8, 12);<br>  ; // (4) CALL INLINE( 141, 2, 0, 0, 8);<br>  ; // (5) CALL INLINE( 136, 3, 0, 0, 8);<br>  ; // (6) CALL INLINE( 88, 1, 0, TABLE);<br>  ; // (7) CALL INLINE( 65, 12, 0, TRT);<br>  ; // (8) CALL INLINE( 68, 2, 0, 12, 0);<br>  ; // (9) CALL INLINE( 5, 12, 0);<br>  ; // (10) CALL INLINE( 71, 7, 0, 12, 18);<br>  ; // (11) CALL INLINE( 24, 1, 2);<br>  ; // (12) CALL INLINE( 65, 0, 0, 0, 1);<br>  ; // (13) CALL INLINE( 26, 1, 0);<br>  ; // (14) CALL INLINE( 27, 3, 3);<br>  ; // (15) CALL INLINE( 71, 15, 0, 12, 24);<br>  ; // (16) CALL INLINE( 27, 1, 3);<br>  ; // (17) CALL INLINE( 65, 3, 0, 0, 1);<br>  ; // (18) CALL INLINE( 80, 1, 0, CP);<br>  return 0;<br>}</font><br></pre>
    </blockquote>
    Basically, <b>XCOM-I</b> has simply commented out each <font
      color="#663300"><code>CALL INLINE</code></font> statement, while
    replacing it with an empty statement.&nbsp; So why did we bother
    compiling it at all?&nbsp; The answer is that we want the
    parenthesized numbers that have been added to the comments!&nbsp;
    The parenthesized numbers will be the same every time we compile <b>XCOM45</b>,
    unless you take it upon yourself to mess us up by removing some of
    the <font color="#663300"><code>CALL INLINE</code></font>
    statements or adding new ones in the meantime.&nbsp; <b>Pro tip:</b>&nbsp;










    Don't do that!<br>
    <blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp;










        There is even one (!) instance in <b>HAL/S-FC</b> in which
        there is a <font color="#663300"><code>RETURN INLINE</code></font>
        statement as well, and it is treated by <b>XCOM-I</b> the same
        way as <font color="#663300"><code>CALL INLINE</code></font>s
        are treated:&nbsp; namely, it is numbered and commented
        out.&nbsp; As it happens, </font><font size="-1"><i>A Compiler
          Generator</i> does not give even the slightest hint that <font
          color="#663300"><code>INLINE</code></font> can return a
        value.&nbsp; In point of fact, I don't think the value returned
        by the </font><font size="-1"><font color="#663300"><code>RETURN










            INLINE</code></font> statement in the case I mention even
        comes from the </font><font size="-1"><font size="-1"><font
            color="#663300"><code>INLINE</code></font></font> at all,
        but is instead generated by other means.&nbsp; Technically, I
        think that if you have a block of <font color="#663300"><code>CALL










            INLINE</code></font>s terminated by a <font color="#663300"><code>RETURN










            INLINE</code></font>, then whatever value happens to remain
        in the CPU's R0 register will be returned, regardless of where
        in the block of </font><font size="-1"><font size="-1"><font
            color="#663300"><code>INLINE</code></font>s</font> R0 was
        set up.&nbsp; But regardless of the underlying details, it
        demonstrates that <i>syntactically</i>, both <font
          color="#663300"><code>CALL INLINE</code></font> and <font
          color="#663300"><code>RETURN INLINE</code></font> are possible
        in XPL/I source code.<br>
        <br>
        <b>Important note:</b>&nbsp; If you must write a C-language
        patch-file for a block of <font color="#663300"><code>INLINE</code></font>s
        that include an </font><font size="-1"><font size="-1">XPL </font><font
          size="-1"><font size="-1"><font color="#663300"><code>RETURN
                INLINE(...)</code></font></font></font>, you should use
        the C macro <font color="#663300"><code>RETURN()</code></font>
        rather than simply <font color="#663300"><code>return</code></font>,
        or </font><font size="-1"><font size="-1"><font color="#663300"><code>RETURN(<i>something</i>)</code></font></font>
        rather than <font color="#663300"><code>return <i>something</i></code></font>.&nbsp;










        That's because the </font><font size="-1"><font size="-1"><font
            color="#663300"><code>RETURN(...)</code></font></font> macro
        takes into account extra code which <b>XCOM-I</b> may need to
        insert in conjunction with XPL </font><font size="-1"><font
          size="-1"><font color="#663300"><code>RETURN</code></font></font>
        statements.&nbsp; For example, if <b>XCOM-I</b> is run with its
        <font color="#663300"><code>--reentry-guard</code></font>
        switch, then <b>XCOM-I</b> inserts code at the entry point and
        exit points of each XPL <font color="#663300"><code>PROCEDURE</code></font>
        that allows the runtime library to detect illegal
        reentries.&nbsp; (Recall that recursion is illegal in
        XPL.)&nbsp; The </font><font size="-1"><font size="-1"><font
            size="-1"><font color="#663300"><code>RETURN(...)</code></font></font></font>
        macro handles this for you transparently, and if a simple </font><font
        size="-1"><font size="-1"><font color="#663300"><code>return</code></font></font>
        is used instead, then the runtime library will falsely detect
        recursion the second time any individual </font><font size="-1"><font
          size="-1"><font color="#663300"><code>PROCEDURE</code></font></font>
        is executed.<br>
      </font></blockquote>
    In this particular example, since <b>XCOM45</b> has a single block
    of <font color="#663300"><code>CALL INLINE</code></font>
    statements, we were guaranteed in advance that the block would start
    with number 0.&nbsp; In a more-complex example like <b>HAL/S-FC</b>,
    there would be a number of blocks of inlines, strewn throughout the
    source code, and lieu of <b>XCOM-I</b> printing them all out for us
    the numbering would be unpredictable.&nbsp; But because the numbers
    never change, we can use them as unique, persistent identifiers for
    the <font color="#663300"><code>CALL INLINE</code></font>
    statements.&nbsp; <br>
    <br>
    Why is that important?&nbsp; The way we're going to work around the
    <font color="#663300"><code>CALL INLINE</code></font> statements is
    to create a series of numbered "patch files", written in C:&nbsp;
    patch0.c, patch1.c, patch2.c, and so on.&nbsp; The patch files are
    placed in the same folder that contains the source code of the XPL
    program being compiled, though <b>XCOM-I</b> does have a
    command-line option (<font color="#663300"><code>--patch=<i>PATHNAME</i></code></font>)
    that allows a different folder to be specified.&nbsp; When <b>XCOM-I</b>
    encounters a <font color="#663300"><code>CALL INLINE</code></font>
    statement, it looks for a patch file with the same number, and <i>if</i>
    it finds one, it directly inserts the contents of the patch file
    into the object code. &nbsp; If there's no matching patch file, then
    the <font color="#663300"><code>CALL INLINE</code></font> simply
    remains a comment.&nbsp; In principle, you could have a different
    patch file for each <font color="#663300"><code>CALL INLINE</code></font>,
    but it's usually more practical, more maintainable, and more
    aesthetically pleasing to have a single patch file for each
    contiguous block of <font color="#663300"><code>CALL INLINE</code></font>
    statements.&nbsp; <br>
    <blockquote><b><font size="-1">Note:</font></b><font size="-1">&nbsp;










        In working with the source code for <b>HAL/S-FC</b>
        specifically, it's a little more complex than what I just
        indicated.&nbsp; As I've mentioned previously, there are two
        different methods of compiling <b>HAL/S-FC</b> source
        code:&nbsp; One to create a compiler intended to compile Primary
        Flight Software (PFS) via <b>XCOM-I</b>'s <font
          color="#663300"><code>--cond=P</code></font> command-line
        switch, and one to create a compiler intended to compile Backup
        Flight Software (BFS) via <b>XCOM-I</b>'s <font
          color="#663300"><code>--cond=B</code></font> command-line
        switch.&nbsp; Unfortunately, the numbering of the <font
          color="#663300"><code>CALL INLINE</code></font> statements, or
        even the inlined code itself, can a bit different in these two
        cases, which makes it unwieldy to rely on the generic naming
        patch<i>N</i>.c for the patch files.&nbsp; My description above
        is what happens when neither </font><font size="-1"><font
          size="-1"><font color="#663300"><code>--cond=P</code></font></font>
        nor </font><font size="-1"><font size="-1"><font
            color="#663300"><code>--cond=B</code></font></font> is
        used.&nbsp; But if </font><font size="-1"><font size="-1"><font
            color="#663300"><code>--cond=P</code></font></font> is used,
        then <b>XCOM-I</b> actually looks for patch files with names
        like patch<i>N</i>p.c first, falling back to patch<i>N</i>.c if
        patch<i>N</i>p.c isn't found.&nbsp; And similarly, if </font><font
        size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>--cond=B</code></font></font></font>
        is used, it prefers patch files named patch<i>N</i>b.c, falling
        back to patch<i>N</i>.c.&nbsp; This method allows the generic
        names patch<i>N</i>.c to be used up the point at which the
        numbering of the </font><font size="-1"><font color="#663300"><code>INLINE</code></font>'s










        begins to differ, switching to the patch<i>N</i>p.c/patch<i>N</i>b.c










        naming thereafter, without any ambiguity or conflicts between
        the two.</font><br>
    </blockquote>
    In this real-life example, since there's a single block of <font
      color="#663300"><code>CALL INLINE</code></font> statements, we
    need a single patch file, patch0.c.<br>
    <blockquote>
      <pre><font color="#663300">/*<br> * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br> * by XCOM-I.py.<br> *<br> * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br> * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br> * the entire xcom4 program.<br> *<br> * What the procedure does is this:  It's given the address of a "translation<br> * table" of one of the following types:<br> *      `BLANKTABLE`  (Blanks)<br> *      `ALPHATABLE`  (Identifier)<br> *      `STRINGTABLE` (Quoted string)<br> *      `COMMENTABLE` (Comment)<br> * Starting at position `CP=0` (already set up upon entry so that we know the<br> * first character is of the asked-for type) in the string `TEXT`, searches<br> * for the end of the pattern of the selected type, and updates `CP` to the<br> * length of the found string.  It returns 0 on failure and 1 on success.  An<br> * empty string counts as a failure.<br> *<br> * This was apparently coded in BAL because the IBM 360 has a translation-table<br> * instruction, TRT, that does this efficiently.  But from my perspective,<br> * considering that there's no other embedded BAL code in the entire program,<br> * it seems as though it's a big price to pay, maintenance-wise and<br> * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br> * always make assembly-language go faster than a high-level language; this is<br> * news?<br> */<br><br>static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>      *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>char *s, *TEXT;<br>uint32_t TABLE;<br><br>if (mapCP == NULL)<br>  {<br>    mapCP = lookupVariable("CP");<br>    mapTEXT = lookupVariable("TEXT");<br>    mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>    mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>    mapALPHATABLE = lookupVariable("ALPHATABLE");<br>    mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>    mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>  }<br><br>TABLE = getFIXED(mapTABLE-&gt;address);<br>TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br><br>if (*TEXT == 0)<br>  return fixedToBit(1, 0);<br>if (TABLE == mapBLANKTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>  }<br>else if (TABLE == mapALPHATABLE-&gt;address)<br>  {<br>    for (s = TEXT;<br>         isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>         s++);<br>  }<br>else if (TABLE == mapSTRINGTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br><br>  }<br>else if (TABLE == mapCOMMENTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>  }<br>else<br>  abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>if (*s == 0)<br>  {<br>    putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>    return fixedToBit(1, 0);<br>  }<br>putFIXED(mapCP-&gt;address, s - TEXT);<br>return fixedToBit(1, 1);<br></font></pre>
      <font size="-1"><b>Aside:</b>&nbsp; The patch file given above
        uses a technique that I consider a bit obsolete.&nbsp; In it, I
        wrote C code that I thought expressed the same <i>intent</i> as
        the inline assembly-language it was replacing.&nbsp; It's fine
        to do that!&nbsp; But after a while I found that technique a bit
        wearing and error-prone, not to mention time-consuming when
        there are dozens of patches to consider.&nbsp; Nowadays, I would
        be much more likely to write C code that slavishly mimics each
        assembly-language instruction individually, without worrying
        much about the intent of the instruction being replaced.&nbsp;
        It is more efficient to do this than it may appear at first
        glance.&nbsp; More on this later.</font><br>
    </blockquote>
    Now that we actually have a patch file, when <b>XCOM-I</b> again
    compiles <b>XCOM45</b>, the <font color="#663300"><code>SCAN_FINDS_END_OF</code></font>
    procedure is now translated to the following C code:<br>
    <blockquote>
      <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-25 14:05:21.<br>*/<br><br>#include "runtimeC.h"<br><br>descriptor_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br><br>  { // (0) CALL INLINE ( 88, 3, 0,TEXT);<br>    /*<br>     * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br>     * by XCOM-I.py.<br>     *<br>     * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br>     * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br>     * the entire xcom4 program.<br>     *<br>     * What the procedure does is this:  It's given the address of a "translation<br>     * table" of one of the following types:<br>     *      `BLANKTABLE`  (Blanks)<br>     *      `ALPHATABLE`  (Identifier)<br>     *      `STRINGTABLE` (Quoted string)<br>     *      `COMMENTABLE` (Comment)<br>     * Starting at position `CP=0` (already set up upon entry so that we know the<br>     * first character is of the asked-for type) in the string `TEXT`, searches<br>     * for the end of the pattern of the selected type, and updates `CP` to the<br>     * length of the found string.  It returns 0 on failure and 1 on success.  An<br>     * empty string counts as a failure.<br>     *<br>     * This was apparently coded in BAL because the IBM 360 has a translation-table<br>     * instruction, TRT, that does this efficiently.  But from my perspective,<br>     * considering that there's no other embedded BAL code in the entire program,<br>     * it seems as though it's a big price to pay, maintenance-wise and<br>     * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br>     * always make assembly-language go faster than a high-level language; this is<br>     * news?<br>     */<br>    <br>    static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>          *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>    char *s, *TEXT;<br>    uint32_t TABLE;<br>    <br>    if (mapCP == NULL)<br>      {<br>        mapCP = lookupVariable("CP");<br>        mapTEXT = lookupVariable("TEXT");<br>        mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>        mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>        mapALPHATABLE = lookupVariable("ALPHATABLE");<br>        mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>        mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>      }<br>    <br>    TABLE = getFIXED(mapTABLE-&gt;address);<br>    TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br>    <br>    if (*TEXT == 0)<br>      return fixedToBit(1, 0);<br>    if (TABLE == mapBLANKTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>      }<br>    else if (TABLE == mapALPHATABLE-&gt;address)<br>      {<br>        for (s = TEXT;<br>             isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>             s++);<br>      }<br>    else if (TABLE == mapSTRINGTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br>    <br>      }<br>    else if (TABLE == mapCOMMENTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>      }<br>    else<br>      abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>    if (*s == 0)<br>      {<br>        putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>        return fixedToBit(1, 0);<br>      }<br>    putFIXED(mapCP-&gt;address, s - TEXT);<br>    return fixedToBit(1, 1);<br>  }<br>  ; // (1) CALL INLINE ( 27, 2, 2);<br>  ; // (2) CALL INLINE ( 25, 3, 2);<br>  ; // (3) CALL INLINE ( 7, 8, 12);<br>  ; // (4) CALL INLINE ( 141, 2, 0,0,8);<br>  ; // (5) CALL INLINE ( 136, 3, 0,0,8);<br>  ; // (6) CALL INLINE ( 88, 1, 0,TABLE);<br>  ; // (7) CALL INLINE ( 65, 12, 0,TRT);<br>  ; // (8) CALL INLINE ( 68, 2, 0,12,0);<br>  ; // (9) CALL INLINE ( 5, 12, 0);<br>  ; // (10) CALL INLINE ( 71, 7, 0,12,18);<br>  ; // (11) CALL INLINE ( 24, 1, 2);<br>  ; // (12) CALL INLINE ( 65, 0, 0,0,1);<br>  ; // (13) CALL INLINE ( 26, 1, 0);<br>  ; // (14) CALL INLINE ( 27, 3, 3);<br>  ; // (15) CALL INLINE ( 71, 15, 0,12,24);<br>  ; // (16) CALL INLINE ( 27, 1, 3);<br>  ; // (17) CALL INLINE ( 65, 3, 0,0,1);<br>  ; // (18) CALL INLINE ( 80, 1, 0,CP);<br>  return 0;<br>}<br></font><br></pre>
    </blockquote>
    Notice that the patch is <i>automatically</i> placed within a C <font
      color="#663300"><code>{...}</code></font> block, which is
    important if the <font color="#663333"><code>CALL INLINE(...)</code></font>
    happens to have been preceded by something like <code><font
        color="#663300">IF ... THEN</font></code> or <font
      color="#663300"><code>ELSE</code></font>. <br>
    <h1><a name="inlines"></a>More on IBM System/360 Inline Code<br>
    </h1>
    <p>Let's start with the executive summary: <br>
    </p>
    <p>In this section, we revisit the problem of inline machine code
      discussed in <a moz-do-not-send="true" href="#hooks">the
        preceding section</a>, describing a tool that may be of
      assistance in writing patch files for IBM System/360 inline
      code.&nbsp; In brief, if you run <b>XCOM-I</b> with the
      command-line switch <font color="#663300"><code>--guess=-1</code></font>,&nbsp;










      it will create a set of files (guess*.c) that are <b>XCOM-I</b>'s
      best guess of what the patch-files (patch*.c) should be
      like.&nbsp; (You can also use <font color="#663300"><code>--guess=<i>N</i><i><sub>1</sub></i>,<i>N</i><sub><i>2</i></sub>,<i>N<sub>3</sub></i>,...</code></font>
      to generate just the files for specific patch numbers, whereas -1
      generates <i>every</i> patch.)&nbsp; You can then manually tweak
      these "guessed" files with (hopefully!) much-reduced effort to get
      patch-files you're satisfied with.&nbsp; There are three ways in
      which this guessing facility is known to fail,&nbsp; and thus to
      require manual fixes:<br>
    </p>
    <ol>
      <li>Only the IBM 360 instructions I've actually encountered in
        legacy XPL programs (specifically, <b>XCOM3</b>, <b>XCOM4</b>,
        and <b>HAL/S-FC</b>) are supported.&nbsp; At this writing,
        that's about ~10% of the full IBM 360 instruction set.&nbsp; So
        the guesser will not understand anything about the 90% of
        possible-but-currently-unused instruction types.<br>
      </li>
      <li>Self-modifying code, or pseudo-self-modifying code due to the
        use of the IBM 360 instruction EX, will not work properly.&nbsp;
        Translations of the EX instruction are specifically detected and
        marked with a comment of "***FIXME***".&nbsp; In my experience,
        most manual tweaks are related to these EX instructions, and
        specifically to the use of EX to execute modified MVC
        instructions; this is covered in more detail later.<br>
      </li>
      <li>Code which accesses or modifies CPU registers associated with
        subroutine linkage requires attention, because <b>XCOM-I</b>
        does <i>not</i> set up these registers upon entry to a
        procedure, nor does it use the contents of these registers upon
        exit from a procedure.&nbsp; Or more succinctly, C translations
        of XPL procedures do not follow IBM 360 calling
        conventions.&nbsp; This is rare problem in my experience, but it
        does occur occasionally.<br>
      </li>
    </ol>
    <p>That's the summary, which may be everything you actually need to
      know.&nbsp; Here's the longer explanation.<br>
    </p>
    Having now gone through the process of manually writing many patch
    files for IBM 360 inline code, I've come to realize that I had
    overestimated the difficulty of translating that inline code to C
    code.&nbsp; With experience, I've now observed that:
    <ul>
      <li>The number of different IBM 360 instructions used in these is
        very limited, with just a handful of mostly-simple instructions
        making up the bulk of them.</li>
      <li>All those instructions do is to read and write to memory and
        to a subset of the CPU's general registers, floating-point
        registers, and the condition-code register.<br>
      </li>
      <li>And, of those particular CPU registers inlined in legacy XPL
        or XPL/I code, you can <i>mostly</i> assume that there are no
        side effects associated with doing so.</li>
    </ul>
    As part of a systematic framework for exploiting this, the <b>XCOM-I</b>
    the runtime library defines the IBM 360 CPU registers as the
    following global variables:
    <blockquote>
      <pre><font color="#663300">int32_t GR[16]; // CPU general-purpose registers.<br>double FR[16];  // CPU floating-point registers.<br></font><font color="#663300">uint8_t CC; // CPU condition code register. Only the least two bits are significant.</font><br></pre>
    </blockquote>
    <blockquote>
      <p><font size="-1"><b>Aside:</b> If unlike me you're actually
          familiar with IBM 360 programming, I'm sure you'll call the
          CPU's general-purpose registers R0, R1, R2, and so on.&nbsp;
          IBM documentation calls them that.&nbsp; It also calls the
          floating-point registers, which are completely separate and
          independent of the general-purpose registers, by those very
          same names:&nbsp; R0, R1, R2, ....&nbsp; Perhaps it's just me,
          but I found that confusing.&nbsp; And because I was so stupid
          as to be confused by this <i>apparently</i> obvious and
          trivial point, it has cost me considerable amount of
          time.&nbsp; Consequently, I now make a point of calling the
          general-purpose registers GR<i>n</i> and the floating-point
          registers FR<i>n</i>.&nbsp; Yes, it's a departure from
          tradition.&nbsp; No, in this particular case I don't care that
          I've departed from tradition.&nbsp; A foolish consistency is
          the hobgoblin of little minds.</font><br>
      </p>
    </blockquote>
    <p>Meanwhile, memory can always be accessed and/or converted from
      IBM 360 formats to native C formats, also via <b>XCOM-I</b>
      runtime-library features:<br>
    </p>
    <ul>
      <li><font color="#663300"><code>uint8_t memory[0x1000000]</code></font>
        — for reading and writing 8-bit bytes from/to memory.</li>
      <li><font color="#663300"><code>int32_t COREWORD(uint32_t <i>address</i>)</code></font>
        and <font color="#663300"><code>void COREWORD2(uint32_t <i>address</i>,
            int32_t <i>value</i>)</code></font> <font color="#663300"><code></code></font>
        — for reading and writing 32-bit words from/to memory,
        respectively.</li>
      <li><font color="#663300"><code>int16_t COREHALFWORD(uint32_t <i>address</i>)</code></font>
        and <font color="#663300"><code>void COREHALFWORD2(uint32_t <i>address</i>,
            int16_t <i>value</i>)</code></font> <font color="#663300"><code></code></font>
        — for reading and writing 16-bit half-words from/to memory,
        respectively.</li>
      <li><font color="#663300"><code>double fromFloatIBM(uint32_t <i>msw</i>,
            uint32_t <i>lsw</i>)</code></font> and <font
          color="#663300"><code>void toFloatIBM(uint32_t *<i>msw</i>,
            uint32_t *<i>lsw</i>, double <i>value</i>)</code></font> <font
          color="#663300"><code></code></font> — for converting pairs of
        32-bit words to/from C double-precision floats, respectively.</li>
      <li><font color="#663300"><code>void setCC(void)</code></font> and
        <font color="#663300"><code>void setCCd(void)</code></font> <font
          color="#663300"><code></code></font> — for adjusting the
        condition-code register after integer operations or
        floating-point operations, respectively.<br>
      </li>
    </ul>
    <p>Additional globals are provided by the runtime library for
      holding commonly-needed temporary results:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">int32_t address360A, address360B, dsw360, lsw360;<br>int64_t scratch;   // Results of integer operations; input to setCC (see above).<br>double scratchd;   // Results of floating-point operations; input to setCCd (see above).<br>int64_t dummy360;  // Use for anything you like.<br>double dummy360d; </font><font color="#663300"><font color="#663300"> // Use for anything you like.</font>
double epsilon360; // A small number, used for tolerance in some floating-point comparisons.<br></font></pre>
    </blockquote>
    For floating-point operations, native C formats and arithmetical
    operators are used.&nbsp; Conversion from/to IBM hexadecimal format
    occurs only when floating-point values are read from the memory
    array or written into the <font color="#663300"><code>memory</code></font>
    array.&nbsp; This is why the CPU's floating-point registers are
    modeled as the C <font color="#663300"><code>double</code></font>
    type.&nbsp; The alternative would have been to model them as pairs
    of <font color="#663300"><code>uint32_t</code></font> values, and
    to provide C functions that directly implemented exact IBM 360
    arithmetic (like addition, subtraction, and so on) directly upon
    such pairs.&nbsp; I admit that wisdom of my decision is arguable,
    but have no present plans to change the implementation.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Actually, there is
        one case in which this decision to use C floating-point causes
        problems, and that involves the IBM 360 instructions which
        perform "unnormalized" floating-point arithmetic.&nbsp; Recall
        that floating-point numbers have two parts, the <i>exponent</i>
        and the <i>significand</i>.&nbsp; For example, in 3.14156×10<sup><super>10</super></sup>,
        the exponent is 10 and the significand is 3.14156. &nbsp; Almost
        all floating-point arithmetic on the IBM 360 is in "normalized"
        form, which means that the exponent and significant are adjusted
        so as to produce the maximum precision (number of bits) in the
        significand, given the number of bytes of storage allocated for
        the number in memory and the nature of the format used for
        storage.&nbsp; Thus in principle, 3.14156×10<sup><super>10</super></sup>
        is more precise than 0.03142×10<sup><super>12</super></sup>, and
        is less precise than 314.15654×10<sup><super>8</super></sup>.&nbsp;











        In the case of IBM hexadecimal floating-point, the exponent
        field is 7 bits wide and represents a power of 64 (rather than
        10), and is offset by 64.&nbsp; I.e., if the exponent is (say)
        E, then the powers represented are 64<sup>-64</sup> through 64<sup>+63</sup>.&nbsp;










        The significand, meanwhile, is 56 bits wide and always positive,
        since there's a separate sign bit&nbsp; So in principle, an IBM
        hexadecimal double-precision floating-point number could
        represent exact positive or negative 56-bit integers.&nbsp;
        That'll be important in a minute.<br>
        <br>
        Supplementing the instructions for normalized arithmetic, the
        IBM 360 includes instructions for both <i>unnormalized</i>
        addition and subtraction as well, which means they perform the
        indicated operations, but the results are taken as-is, without
        any normalization.&nbsp; Whereas the choice to use C <font
          color="#663300"><code>double</code></font> for all arithmetic
        in the <b>XCOM-I</b> framework means that all arithmetical
        results have maximum precision all the time.<br>
        <br>
        Doesn't sound like a problem to you?&nbsp; Well, in practice <font
          color="#663300"><code>CALL INLINE</code></font> code uses a
        single unnormalized instruction, namely <font color="#663300"><code>AW</code></font>,
        which adds two floating-point numbers (normalized or
        unnormalized), producing an unnormalized result.&nbsp; It always
        does so in precisely the same manner, in order to perform the
        trick of converting a positive floating-point number (in IBM
        hexadeximal format) to a binary integer.&nbsp; In assembly
        language, that trick works as follows:<br>
      </font>
      <ul>
        <li><font size="-1">Somewhere — in <b>HAL/S-FC</b>, it's in the
            floating-point working area <font color="#663300"><code>DW(6)</code></font>
            and <font color="#663300"><code>DW(7)</code></font>,
            pointed to by the variable <font color="#663300"><code>ADDR_FIXER</code></font>
            — a representation of the number 0.0 is stored as the pair
            of words 0x4E000000,0x00000000.&nbsp; (Note that there's no
            unique representation of 0.0 in IBM hexadecimal floating
            point, because the exponent is indeterminate when the
            signifcand is 0, but this particular choice of exponent is
            important.)</font></li>
        <li><font size="-1"><font color="#663300"><code>AW</code></font>
            is used to perform an unnormalized addition of the </font><font
            size="-1"><font size="-1"><font color="#663300"><code>ADDR_FIXER</code></font></font>
            representation 0.0 with a non-negative floating-point number
            that represents an integer.</font></li>
        <li><font size="-1">The unnormalized result of the addition has
            an exponent field that's 0x4E and a significand that's a
            non-negative 56-bit binary integer.&nbsp; Specifically, the
            least-significant word is the least-significant 32 bits of
            the integer.<br>
          </font></li>
        <li><font size="-1">The least-significant word, being the
            desired <font color="#663300"><code>FIXED</code></font>
            data, is immediately stored someplace via the IBM 360
            instruction <font color="#663300"><code>STD </code></font>
            for whatever further use the program has for that integer.<br>
          </font></li>
      </ul>
      <p><font size="-1">You probably don't care, but the reason this
          trick works is that IBM floating-point addition functions by
          unnormalizing the operand with the smaller exponent to match
          the exponent of the other operand, and then performing a
          binary addition of the significands.&nbsp; But no 56-bit
          integer can have an exponent in IBM hexadecimal format that's
          larger than 0x4E, so the representation of 0.0 to have an
          exponent of 0x4E guarantees that it's the other operand that
          becomes unnormalized, and the way in which it's unnormalized
          is to be shifted rightward by exactly the right number of bits
          to turn into a binary representation of the integer.<br>
        </font></p>
      <p><font size="-1">Regardless of how it works, the reason this
          causes us a problem is that the native-C arithmetic we perform
          doesn't track any of this, so the </font><font size="-1"><font
            size="-1"><font color="#663300"><code>AW</code></font></font>
          is wasted, and <i>doesn't</i> produce an integer usable by
          the </font><font size="-1"><font size="-1"><font
              color="#663300"><code>STD</code></font></font>
          instructions that succeed the </font><font size="-1"><font
            size="-1"><font color="#663300"><code>AW</code></font></font>
          instructions.&nbsp; In other words, after the </font><font
          size="-1"><font size="-1"><font size="-1"><font
                color="#663300"><code>AW</code></font></font></font>
          occurs, the <font color="#663300"><code>CALL INLINE</code></font>
          for the </font><font size="-1"><font size="-1"><font
              color="#663300"><code>STD</code></font></font> instruction
          that's supposed to store the 2's-complement integer has no
          2's-complement integer to store!<br>
        </font></p>
      <p><font size="-1">The workaround for this in the <b>XCOM-I</b>
          runtime library is that the floating-point registers are
          supplemented by an additional array that tracks whether the
          register should be treated as normalized or unnormalized, and
          then interprets the value stored in that floating-point
          register accordingly when an </font><font size="-1"><font
            size="-1"><font color="#663300"><code>STD</code></font></font>
          instruction is performed that stores the value in the register
          to memory:<br>
        </font></p>
      <blockquote>
        <pre><font size="-1" color="#663300">double FR[16];<br>uint8_t unnormFR[16]; // 0 to treat FRn as normalized, 1 as unnormalized.<br></font></pre>
      </blockquote>
      <p><font size="-1">Thus an </font><font size="-1"><font size="-1"><font
              size="-1"><font color="#663300"><code>AW</code></font></font></font>
          instruction on <font color="#663300"><code>FR[<i>n</i>]</code></font>
          sets <font color="#663300"><code>unnormFR[<i>n</i>]</code></font>,
          while an </font><font size="-1"><font size="-1"><font
              color="#663300"><code>STD</code></font></font></font><font
          size="-1"> instruction storing </font><font size="-1"><font
            size="-1"><font color="#663300"><code>FR[<i>n</i>]</code></font></font>
          resets </font><font size="-1"><font size="-1"><font
              color="#663300"><code>unnormFR[<i>n</i>]</code></font></font>.<br>
          &nbsp;<br>
          Yes, it's a bit of a hack, and if you were writing new <font
            color="#663300"><code>CALL INLINE</code></font> statements
          you could easily defeat it, but <i>for right now</i> it seems
          more economical than reworking the entire floating-point
          arithemetic system for a handful (less than 10) of uses of </font><font
          size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                  color="#663300"><code>AW</code></font></font></font></font>.&nbsp;










          My advice to you is this:&nbsp; If you're writing new XPL
          code, <i>don't</i> try to subvert my hack with perverted
          usage of the </font><font size="-1"><font size="-1"><font
              size="-1"><font color="#663300"><code>AW</code></font></font></font>
          instruction in </font><font size="-1"><font size="-1"><font
              color="#663300"><code>CALL INLINE</code></font></font>
          statements; </font><font size="-1"><font size="-1"><font
              size="-1"><font color="#663300"><code>AW</code></font></font></font>
          (and </font><font size="-1"><font size="-1"><font
              color="#663300"><code>CALL INLINE</code></font></font>,
          for that matter) is perverted enough already, and doesn't need
          <i>your</i> help.</font><br>
      </p>
    </blockquote>
    Let's get the question of IBM 360 calling conventions out of the
    way.&nbsp; The conventional usage of the IBM 360 CPU's general
    registers in calling subroutines, as I understand it, is summarized
    in the bullet list below.&nbsp; But I've documented a couple of
    apparently non-traditional extensions or differences (highlighted in
    <font color="#006600">green</font>) that I've inferred from some of
    the <font color="#663300"><code>CALL INLINE</code></font>
    statements I've encountered in the legacy code; take them with a
    grain of salt!<br>
    <ul>
      <li>GR0 — Upon exit holds the return value.</li>
      <li>GR1 — Upon entry, holds the parameter (if there's only one) or
        else a pointer to a list of parameters.</li>
      <li><font color="#006600">GR3 — Upon exit holds the return value (<i>rather</i>
          than GR0).</font></li>
      <li><font color="#006600">GR12 </font><font color="#006600">—
          Upon entry holds the address at the end of the procedure's
          explicit code (prior to whatever linkage executes the actual
          return).<br>
        </font></li>
      <li>GR13 — Upon entry and exit, holds the address of an 18-word
        save area which holds the state (i.e., the general registers and
        other information) of the calling code. A procedure doesn't
        modify the contents of this save area, and must provide a
        different save area address to any procedures it calls itself<br>
      </li>
      <li>GR14 — Upon entry, holds the return address.</li>
      <li>GR15 — Upon entry, holds the beginning address of the
        procedure itself.<br>
      </li>
    </ul>
    <p>As for how a translation from IBM 360 machine code to C uses the
      various concepts described above, consider the very common
      statement <font color="#663300"><code>CALL INLINE("58", <i>n</i>,
          <i>v</i>)</code></font>, where <i><font color="#663300"><code>n</code></font></i>
      is a an integer 0-15 and <i><font color="#663300"><code>v</code></font></i>
      is the name of an XPL variable.&nbsp; This inline has IBM 360
      opcode 0x58, which has the assembly-language mnemonic L, and means
      to load register <font color="#663300"><code>GR[<i>n</i>]</code></font>
      with the contents of variable <i><font color="#663300"><code>v</code></font></i>.&nbsp;










      Such an inline can be translated into C as:<br>
    </p>
    <blockquote>
      <pre><font color="#663300">GR[<i>n</i>] = COREWORD(ADDR(<i>v</i>));</font><br></pre>
    </blockquote>
    Or consider <font color="#663300"><code>CALL INLINE("41", <i>n</i>,
        <i>v</i>)</code><font color="#000000">, which has the mnemonic
        LA, to store the address of the variable into the register:</font></font><br>
    <blockquote>
      <pre><font color="#663300">GR[<i>n</i>] = ADDR(<i>v</i>);</font><br></pre>
    </blockquote>
    <font color="#663300"><font color="#000000">Or </font></font><font
      color="#663300"><font color="#000000"><font color="#663300"><code>CALL










            INLINE("50", <i>n</i>, <i>v</i>)</code><font
            color="#000000">, mnemonic ST, </font></font>to store the
        value of a register into a variable:<br>
      </font></font>
    <blockquote>
      <pre><font color="#663300">COREWORD2(ADDR(<i>v</i>), GR[<i>n</i>]);</font><br></pre>
    </blockquote>
    In the 19-instruction patch used in the preceding section as an
    example, 6 of the instructions used are already of one or the other
    of these three types.&nbsp; Other instructions may have
    much-more-complex implementations in C than these, of course.<br>
    <br>
    Recognizing that the majority of all <font color="#663300"><code>CALL










        INLINE</code></font> statements — though unfortunately not <i>all</i>
    of them — can be handled using these simple maneuvers, <b>XCOM-I</b>
    has a built-in tool that can create guessed versions of patch-files
    for you, in which most of the <font color="#663300"><code>INLINE</code></font>s
    have been translated, but with the ones that were too difficult for
    <b>XCOM-I</b> to handle left in the draft files for you to manually
    deal with.<br>
    <br>
    To use this tool, simply run <b>XCOM-I</b> as normal, using either
    or neither of the <font color="#663300"><code>--cond=P</code></font>
    or <font color="#663300"><code>--cond=B</code></font> options, <i>plus</i>
    the <font color="#663300"><code>--guess=...</code></font> switch as
    I summarized it earlier.&nbsp; When doing so, in addition to the
    normal compilation outputs, files named guess<i>N</i>.c, guess<i>N</i>p.c,










    or guess<i>N</i>b.c are output as well.&nbsp; You can then make
    manual changes to the guess-files and rename them as patch-files
    when you're satisfied.<br>
    <br>
    Regarding the effectiveness of the procedure, in the combined source
    code for the XPL programs <b>XCOM3</b>, <b>XCOM45</b>, and <b>HAL/S-FC</b>,
    there's a total of 81 blocks of <font color="#663300"><code>CALL
        INLINE</code></font>s, and thus in principle a total of 81 patch
    files.&nbsp; In generating guess-files for these programs, <b>XCOM-I</b>
    flags 11 of those guess-files with the comment <font
      color="#663300"><code>***FIXME***</code></font>, which you can
    easily search for in order to fix the associated issue.&nbsp;
    Problems <i>not</i> detectable by <font color="#663300"><code>--guess</code></font>,
    though rare, unfortunately are neither marked nor easy to find or
    fix.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; Regarding the
        process of manually fixing up the </font><font size="-1"><font
          size="-1"><font color="#663300"><code>EX</code></font></font>
        instructions not supported by <b>XCOM-I</b> <font
          color="#663300"><code>--guess</code></font>, it's actually not
        that hard once you understand the trick involved.&nbsp;
        Admittedly, <i>right now</i> it will seem simpler to me than to
        you, given our relative positions on this particular learning
        curve.<br>
        <br>
        An <font color="#663300"><code>EX</code></font> instruction is
        syntactically of the form<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#663300">EX	R1,D2(X2,B2)</font><font size="-1"><br></font></pre>
      </blockquote>
      <font size="-1">where <font color="#663300"><code>R1</code></font>
        is the number of a CPU general register, and <font
          color="#663300"><code>D2(X2,B2)</code></font> points to an IBM
        360 machine code instruction.&nbsp; While it looks confusing,
        it's always easy to figure out which instruction is targeted,
        because in the XPL source code it will be set off by itself and
        there will be no way to reach it in C to execute it
        directly.&nbsp; Sometimes, the XPL source code will contain a
        binary representation of that target instruction, which makes
        the task a lot harder for you, but in the XPL I've seen it will
        almost always be represented as a <font color="#663300"><code>CALL










            INLINE</code></font>, which makes it much easier.&nbsp; The
        reason it's easy is because <b>XCOM-I</b> <font
          color="#663300"><code>--guess</code></font> will have made a
        guessed patch file for it, and will have printed the
        assembly-language syntax and the proposed C translation of it
        for you in the patch file.&nbsp; <br>
        <br>
        To make what I'm saying concrete, consider an example taken from
        <b>PASS1</b> of <b>HAL/S-FC</b>.&nbsp; Here's a small excerpt
        of the XPL source-code file HALINCL/VMEM.xpl:<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#663300">         ELSE DO;                                                               00102100<br>            ADDRTEMP = ADDR(MOVECHAR);                                          00102200<br>            CALL INLINE("18",0,4);           /* LR 0,4                        */00102300<br>            CALL INLINE("58",2,0,INTO);      /* L  2,INTO                     */00102400<br>            CALL INLINE("58",3,0,FROM);      /* L   3,FROM                    */00102500<br>            CALL INLINE("48",1,0,LEGNTH);    /* LH 1,LEGNTH                   */00102600<br>            CALL INLINE("06",1,0);           /* BCTR 1,0                      */00102700<br>            CALL INLINE("58",4,0,ADDRTEMP);  /* L 4,ADDRTEMP                  */00102800<br>            CALL INLINE("44",1,0,4,0);       /* EX 1,0(0,4)                   */00102900<br>            CALL INLINE("18",4,0);           /* LR 4,0                        */00103000<br>            RETURN;                                                             00103100<br>         END;                                                                   00103200<br>      END;                                                                      00103300<br>MOVECHAR:                                                                       00103400<br>      CALL INLINE("D2",0,0,2,0,3,0);  /* MVC 0(0,2),0(3)                      */00103500</font><font size="-1"><br></font></pre>
      </blockquote>
      <font size="-1"><font size="-1">Those blocks of <font
            color="#663300"><code>CALL INLINE</code></font> statements
          correspond to patches 25 and 32 respectively.&nbsp; Thus <b>XCOM-I</b>
          <font color="#663300"><code>--guess</code></font></font>
        produces guessed patch files guess25p.c for lines
        00102300-00103000 and guess32p.c for line 00103500.&nbsp; The
        latter is the target instruction for the </font><font size="-1"><font
          size="-1"><font color="#663300"><code>EX</code></font></font>
        instruction at line 00102900.&nbsp; It's visually obvious (since
        it's separated!), but you can tell it from reading the code
        too:&nbsp; Line 00102200 puts the address of the label <font
          color="#663300"><code>MOVECHAR</code></font> into the variable
        <font color="#663300"><code>ADDRTEMP</code></font>, while line
        00102800 it moves it into the CPU general register </font><font
        size="-1"><font size="-1"><code>GR4</code></font>, and then at
        line 00102900 the </font><font size="-1"><font size="-1"><font
            size="-1"><font color="#663300"><code>EX</code></font></font></font>
        instruction says that the base register <code>GR4</code> holds
        the address of the target instruction.&nbsp; Here's how <b>XCOM-I</b>
        has done its best in guess25p.c to translate the </font><font
        size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font></font>
        instruction,<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#009900">p25_24: ;<br>  // (31)       CALL INLINE("44", 2, 0, 3, 0);        /* EX  2,0(0,3)          */         <br>  address360B = GR[3] + 0;<br>  // Type RX, p. 7-74:		EX	2,0(0,3)<br>    // ***FIXME*** Unsupported opcode EX</font><font size="-1"><br></font></pre>
      </blockquote>
      <font size="-1">and in guess32p.c the target instruction,<br>
      </font>
      <blockquote>
        <pre><font size="-1" color="#663300">p32_0: ;<br>  // (32)       CALL INLINE("D2", 0, 0, 1, 1, 1, 0);  /* MVC 1(0,1),0(1)       */         <br>  address360A = GR[1] + 1;<br>  address360B = GR[1] + 0;<br>  // Type SS, p. 7-83:		MVC	1(0,1),0(1)<br>  mvc(address360A, address360B, 0);</font><font size="-1"><br></font></pre>
      </blockquote>
      <font size="-1">In fact, in my experience, most </font><font
        size="-1"><font size="-1"><font color="#663300"><code>EX</code></font></font>
        instructions have targeted </font><font size="-1"><font
          color="#663300"><code>MVC</code></font></font><font size="-1">
        instructions, as this example does, so this is great for
        covering the typical case! <br>
        <br>
        Now, the action of an </font><font size="-1"><font size="-1"><font
            color="#663300"><code>EX</code></font></font> instruction is
        to replace bits 8-15 of the target machine-code instruction by
        the contents of the general register the </font><font size="-1"><font
          size="-1"><font color="#663300"><code>EX</code></font></font>
        instruction specifies, and then to execute that modified target
        instruction (<i>without</i> actually jumping to it).&nbsp; All
        you have to figure out is what in the C translation of the
        target instruction corresponds to bits 8-15 of the machine
        code.&nbsp; It will usually be something simple.&nbsp; For a
        target <font color="#663300"><code>MVC</code></font>
        instruction, I can tell you that it's just the final parameter
        of the <font color="#663300"><code>mvc(...)</code></font>
        function in the C translation.&nbsp; Thus, the change needed to
        the guessed file guess25p.c, in which the "***FIXME***" is
        replaced by actually-executable code, is this:<br>
      </font>
      <blockquote><font size="-1"> </font>
        <pre><font color="#009900"><font size="-1">p25_24: ;<br>  // (31)       CALL INLINE("44", 2, 0, 3, 0);        /* EX  2,0(0,3)          */         <br>  address360B = GR[3] + 0;<br>  // Type RX, p. 7-74:		EX	2,0(0,3)<br>  address360A = GR[1] + 1;<br>  address360B = GR[1] + 0;<br>  // Type SS, p. 7-83:		MVC	1(0,1),0(1)<br>  mvc(address360A, address360B, GR[2]);</font>
</font></pre>
      </blockquote>
    </blockquote>
    Not perfect, of course, but not bad either.&nbsp; By my reckoning,
    close to 90% of the guessed files seem to be perfect
    as-is.&nbsp;&nbsp;&nbsp; And of the files which are not perfect,
    probably around 90% of the <font color="#663300"><code>CALL INLINE</code></font>s
    translated in those files are still perfect.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; As an example where
        <b>XCOM-I</b> fails to produce a perfect guessed result <i>not</i>
        due to an <font color="#663300"><code>EX</code></font>
        instruction, I can point to the single block of <font
          color="#663300"><code>CALL INLINE</code></font>s in the legacy
        program <b>XCOM45</b>.&nbsp; A number of its instructions
        involve use of the seemingly-uninitialized register GR12, as
        well as usage of the register </font><font size="-1"><font
          size="-1"><font color="#663300"><code>GR3</code></font></font>,
        that make sense (to me!) only if registers </font><font
        size="-1"><font size="-1"><font color="#663300"><code>GR3</code></font></font>
        and </font><font size="-1"><font size="-1"><font
            color="#663300"><code>GR12</code></font></font> are viewed
        as having a non-traditional conventional role in the subroutine
        linkage for calling their parent procedure (namely, <font
          color="#663300"><code>SCAN_FINDS_END_OF</code></font>):&nbsp;
        i.e., <font color="#663300"><code>GR3</code></font> contains
        the return value of the procedure (rather than </font><font
        size="-1"><font size="-1"><font color="#663300"><code>GR0</code></font></font>
        as documented by IBM), and </font><font size="-1"><font
          size="-1"><font color="#663300"><code>GR12</code></font></font>
        contains the size of the procedure's code (other than the
        linkage code), in bytes.<br>
        <br>
      </font><font size="-1"><font size="-1"><font size="-1"><font
              size="-1"><font size="-1"><font size="-1">As another
                  example, I'd point to the one case I know of (in the <font
                    color="#663300"><code>INTEGER_VALUED</code></font>
                  procedure of program <b>HAL/S-FC</b>) in which a <code><font
                      color="#663300">RETURN</font></code></font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font color="#663300"><code>
                      INLINE</code></font> statement is used rather than
                  a </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font color="#663300"><code>CALL










                      INLINE</code></font> statement.&nbsp; The </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font size="-1"><font
                      size="-1"><font size="-1"><font size="-1"><font
                            size="-1"><font size="-1"><font size="-1"><font
                                  size="-1"><font size="-1"><font
                                      size="-1"><font size="-1"><font
                                          size="-1"><font
                                            color="#663300"><code>INLINE</code></font></font></font></font></font></font></font></font></font></font></font></font></font>
                  XPL built-in is not specified in such a way as to
                  return a value, but the calling procedure (<font
                    color="#663300"><code>INTEGER_VALUE</code></font>)
                  does check the returned value. &nbsp; Moreover, the </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font size="-1"><font
                      color="#663300"><code>INLINE</code></font></font>s
                  in </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font size="-1"><font
                      size="-1"><font size="-1"><font size="-1"><font
                            size="-1"><font size="-1"><font
                                color="#663300"><code>INTEGER_VALUED</code></font></font></font></font></font></font></font>
                  do in fact manipulate the </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font size="-1"><font
                      color="#663300"><code>GR3</code></font></font>
                  register in such a way as to contain either a 0 or a
                  1, without there being any other evident reason to do
                  so, so it's easy to suppose once again that </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><font size="-1"><font
                      color="#663300"><code>GR3</code></font></font> is
                  indeed the return value.&nbsp; </font></font></font></font></font></font><font
        size="-1"><font size="-1"><font size="-1"><font size="-1"><font
                size="-1"><font size="-1"><br>
                </font></font></font></font></font></font></blockquote>
    <h1> <a name="appendix"></a>Appendix:&nbsp; Suitable C Compilers</h1>
    <p>Since <b>XCOM-I</b> is merely a translator from the XPL or XPL/I
      languages to C, it's necessary to have a functioning, compatible C
      compiler to use <b>XCOM-I</b> in its intended way.&nbsp; In
      theory, any reasonably-modern C compiler should be compatible with
      the C code <b>XCOM-I</b> produces.&nbsp; However, the nature of
      the <b>XCOM-I</b> runtime library is that it must necessarily
      provide some services that are system-dependent, and thus it is in
      the runtime library that there is is a much higher likelihood of
      finding C compatibility problems.<br>
    </p>
    <p>While bugs in <b>XCOM-I</b> itself are under my control and can
      in principle be fixed, within the limits of my skill and time,
      problems with C compilers themselves (or with their libraries) are
      outside of my control.&nbsp; Here I'll let you know what some of
      those problems with C compilers are.&nbsp; However, I'm in no
      position to try every C compiler everywhere, so my coverage is
      hardly extensive.&nbsp; At best, I can let you know my current
      beliefs about the compilers I've checked out.<br>
    </p>
    <h2>Linux and Mac OS<br>
    </h2>
    <p>No current problems with <b>gcc</b> or <b>clang</b>.<br>
    </p>
    <h2>Windows</h2>
    <p>For <b>gcc</b> variants in the MSYS2 development environment: <br>
    </p>
    <ul>
      <li><b>mingw-w64-ucrt-x86_64-gcc</b> (recommended for
        MSYS2):&nbsp; No current problems<br>
      </li>
      <li><b>mingw-w64-x86_64-gcc</b>:&nbsp; No current problems </li>
    </ul>
    For <b>clang</b> in the MSYS2 development environment:&nbsp; <br>
    <ul>
      <li>Not suitable!&nbsp; There is a problem with variadic
        functions, specifically <code>vsnprintf</code>, that
        disastrously impacts the <b>XCOM-I</b> runtime library.<br>
      </li>
    </ul>
    For <b>cl</b> (Visual Studio command-line compiler):<br>
    <ul>
      <li>No current problems<br>
      </li>
    </ul>
    <h2>Cross-Compile (Linux to Windows)<br>
    </h2>
    <p>For Mingw-64 variants:<br>
    </p>
    <ul>
      <li><b>x86_64-w64-mingw32-gcc</b>:&nbsp; No current problems </li>
      <li><b>i686-w64-mingw32-gcc</b>:&nbsp; No current problems </li>
    </ul>
    <hr style="width: 100%; height: 2px;">
    <center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2026-02-07<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300"
              height="100"></a><br>
        </font></i></center>
    <br>
  </body>
</html>
