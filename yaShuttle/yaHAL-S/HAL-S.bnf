-- Copyright:   Public Domain
-- Filename:    HAL-S.bnf
-- Purpose:     This is the BNF description of the HAL/S programming language,
--              taken from Appendix G of the HAL/S Language specification
--              (https://www.ibiblio.org/apollo/Shuttle/HAL_S%20Language%20Specification%20Nov%202005.pdf#page=209).
--              Some typos were corrected.
-- History:     2022-11-08 RSB  Created.
--
-- Note that this BNF is not exactly legal (I think) since | is both a terminal and
-- the BNF alternative operator, so you have stuff like 
--      <OR> ::= | | OR
-- which seems to be baloney syntactically but obviously sensible.  
-- $ may be another problem.  I don't know.  However,
-- this BNF is not used directly.  It will first be massaged into LBNF (in
-- the file HAL-S.lbnf), and hopefully those problems go away there.

-- Rules I've added ----------------------------------------------------------
-- There are some problems that don't go away so easily as the ones mentioned
-- above.  The following nonterminals are undefined in the language 
-- specification, but nevertheless appear in the BNF rules given by the 
-- language specification.  Rules for them will have to be figured out.
--
--      <EMPTY>
--      <NO ARG ARITH FUNC>
--      <ARITH FUNC>
--      <NO ARG CHAR FUNC>
--      <CHAR FUNC>
--      <NO ARG BIT FUNC>
--      <BIT FUNC>
--      <NO ARG STRUCT FUNC>
--      <STRUCT FUNC>
--      <ARITH ID>
--      <CHAR ID>
--      <BIT ID>
--      <STRUCTURE ID>
--      <LABEL>
--      <SIMPLE NUMBER>
--      <COMPOUND NUMBER>
--      <CHAR STRING>

--      <TEXT>
--      <EVENT>
--      <IDENTIFIER>
--      <LEVEL>
--      <% MACRO NAME>
--      <DCL LIST>
--      <STRUCT TEMPLATE>
<EMPTY> ::= 
-- A number of built-in functions are listed in Appendix C of the language
-- spec, and I'm supposing that their names are the terminals for 
-- <ARITH FUNC>, <CHAR FUNC>, and so on.  But I'm highly uncertain
-- as to which functions belong to which nonterminal.
<NO ARG ARITH FUNC> ::= CLOCKTIME | DATE | ERRGRP | ERRNUM | PRIO | RANDOM | RUNTIME
<ARITH FUNC> ::= NEXTTIME | ABS | CEILING | DIV | FLOOR | MIDVAL | MOD | ODD | REMAINDER | ROUND | SIGN | SIGNUM | TRUNCATE | ARCCOS | ARCCOSH | ARCSIN | ARCSINH | ARCTAN2 | ARCTAN | ARCTANH | COS | COSH | EXP | LOG | SIN | SINH | SQRT | TAN | TANH | SHL | SHR
<NO ARG CHAR FUNC> ::= <EMPTY>
<CHAR FUNC> ::= INDEX | LENGTH | LJUST | RJUST | TRIM
<NO ARG BIT FUNC> ::= <EMPTY>
<BIT FUNC> ::= XOR
<NO ARG STRUCT FUNC> ::= <EMPTY>
<STRUCT FUNC> ::= ABVAL | DET | INVERSE | TRACE | TRANSPOSE | UNIT | MAX | MIN | PROD | SUM | SIZE
<ARITH ID> ::= IDENTIFIER
<CHAR ID> ::= IDENTIFIER
<BIT ID> ::= IDENTIFIER
<STRUCTURE ID> ::= IDENTIFIER
<LABEL> ::= IDENTIFIER
<SIMPLE NUMBER> ::= <DIGIT> | <SIMPLE NUMBER> <DIGIT>
<SIGNED SIMPLE NUMBER> ::= <SIMPLE NUMBER> | -<SIMPLE NUMBER>
<SCI EXP> ::= E <SIGNED SIMPLE NUMBER> | B <SIGNED SIMPLE NUMBER> | O <SIGNED SIMPLE NUMBER> | H <SIGNED SIMPLE NUMBER>
<COMPOUND NUMBER> ::= <SIMPLE NUMBER> | . <SIMPLE NUMBER> | <SIMPLE NUMBER> . | <SIMPLE NUMBER> . <SIMPLE NUMBER> | <COMPOUND NUMBER> <SCI EXP>
<DIGIT> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<UPPER CASE LETTERS> ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
<LOWER CASE LETTERS> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
<PSEUDO ALPHABETIC> ::= _ | % 
<CHAR SPACE> ::= \040
<CHAR DOLLAR> ::= \044
<CHAR LEFT PARAN> ::= \050
<CHAR RIGHT PARAN> ::= \051
<CHAR LEFT BRACKET> ::= \133
<CHAR RIGHT BRACKET> ::= \135
<CHAR VERTICAL BAR> ::= \174
<CHAR SPECIAL> ::= + | - | * | . | / | <CHAR VERTICAL BAR> | & | ¬ | = | < | > | # | @ | <CHAR DOLLAR> | , | ; | : | <CHAR VERTICAL BAR> | <CHAR LEFT PARAN> | <CHAR RIGHT PARAN> | '' | "
<CHAR EXTENDED> ::= <CHAR LEFT BRACKET> | <CHAR RIGHT BRACKET> | { | } | ! | ?
<CHAR ALL> ::= <DIGIT> | <UPPER CASE LETTER> | <LOWER CASE LETTER> | <PSEUDO ALPHABETIC> | <CHAR SPECIAL> | <CHAR EXTENDED> 
<RAW TEXT> ::= <CHAR ALL> | <RAW TEXT> <CHAR ALL>
<CHAR STRING> ::= ' <RAW TEXT> '

-- Original rules ------------------------------------------------------------
<COMPILATION> ::= <COMPILE LIST> _|_
<COMPILE LIST> ::= <BLOCK DEFINITION> | <COMPILE LIST> <BLOCK DEFINITION>
<ARITH EXP> ::= <TERM> | + <TERM> | -1 <TERM> | <ARITH EXP> + <TERM> | <ARITH EXP> -1 <TERM>
<TERM> ::= <PRODUCT> | <PRODUCT> / <TERM>
<PRODUCT> ::= <FACTOR> | <FACTOR> * <PRODUCT> | <FACTOR> . <PRODUCT> | <FACTOR> <PRODUCT>
<FACTOR> ::= <PRIMARY> | <PRIMARY> <**> <FACTOR>
<**> ::= **
<PRE PRIMARY> ::= (<ARITH EXP>) | <NUMBER> | <COMPOUND NUMBER>
<ARITH FUNC HEAD> ::= <ARITH FUNC> | <ARITH CONV> <SUBSCRIPT>
<ARITH CONV> ::= INTEGER | SCALAR | VECTOR | MATRIX
<PRIMARY> ::= <ARITH VAR>
<PRE PRIMARY> ::= <ARITH FUNC HEAD> (<CALL LIST>)
<PRIMARY> ::= <MODIFIED ARITH FUNC> | <ARITH INLINE DEF> <BLOCK BODY> <CLOSING>; | <PRE PRIMARY> | <PRE PRIMARY> <QUALIFIER>
<OTHER STATEMENT> ::= <ON PHRASE> <STATEMENT> | <IF STATEMENT> | <LABEL DEFINITION> <OTHER STATEMENT>
<STATEMENT> ::= <BASIC STATEMENT> | <OTHER STATEMENT>
<ANY STATEMENT> ::= <STATEMENT> | <BLOCK DEFINITION>
<BASIC STATEMENT> ::= <LABEL DEFINITION> <BASIC STATEMENT> | <ASSIGNMENT>; | EXIT; | EXIT <LABEL>; | REPEAT; | REPEAT <LABEL>; | GO TO <LABEL>; | ; | <CALL KEY>; | <CALL KEY> (<CALL LIST>); | <CALL KEY> <ASSIGN> (<CALL ASSIGN LIST>); |<CALL KEY>(<CALL LIST>)<ASSIGN> (<CALL ASSIGN LIST>); | RETURN; | RETURN <EXPRESSION>; | <DO GROUP HEAD> <ENDING>; | <READ KEY>; | <READ PHRASE>; | <WRITE KEY>; | <WRITE PHRASE>; | <FILE EXP> = <EXPRESSION>; | <VARIABLE> = <FILE EXP>; | <WAIT KEY> FOR DEPENDENT; | <WAIT KEY> <ARITH EXP>; | <WAIT KEY> UNTIL <ARITH EXP>; | <WAIT KEY> FOR <BIT EXP>; | <TERMINATOR>; | <TERMINATOR> <TERMINATE LIST>; | UPDATE PRIORITY TO <ARITH EXP>; | UPDATE PRIORITY <LABEL VAR> TO <ARITH EXP>; | <SCHEDULE PHRASE>; | <SCHEDULE PHRASE> <SCHEDULE CONTROL>; | <SIGNAL CLAUSE>; | SEND ERROR <SUBSCRIPT>; | <ON CLAUSE>; | <ON CLAUSE> AND <SIGNAL CLAUSE>; | OFF ERROR <SUBSCRIPT>; | <% MACRO NAME>; | <% MACRO HEAD> <% MACRO ARG>);
<% MACRO HEAD> ::= <% MACRO NAME> ( | <% MACRO HEAD> <% MACRO ARG> ,
<% MACRO ARG> ::= <NAME VAR> | <CONSTANT>
<BIT PRIM> ::= <BIT VAR> | <LABEL VAR> | <EVENT VAR> | <BIT CONST> | (<BIT EXP>) | <MODIFIED BIT FUNC> | <BIT INLINE DEF> <BLOCK BODY> <CLOSING>; | <SUBBIT HEAD> <EXPRESSION>) | <BIT FUNC HEAD> (<CALL LIST>)
<BIT FUNC HEAD> ::= <BIT FUNC> | BIT <SUB OR QUALIFIER>
<BIT CAT> ::= <BIT PRIM> | <BIT CAT> <CAT> <BIT PRIM> | <NOT> <BIT PRIM> | <BIT CAT> <CAT> <NOT> <BIT PRIM>
<BIT FACTOR> ::= <BIT CAT> | <BIT FACTOR> <AND> <BIT CAT>
<BIT EXP> ::= <BIT FACTOR> | <BIT EXP> <OR> <BIT FACTOR>
<RELATIONAL OP> ::= = | <NOT> = | < | > | < = | > = | <NOT> < | <NOT> >
<COMPARISON> ::= <ARITH EXP> <RELATIONAL OP> <ARITH EXP> | <CHAR EXP> <RELATIONAL OP> <CHAR EXP> | <BIT CAT> <RELATIONAL OP> <BIT CAT> | <STRUCTURE EXP> <RELATIONAL OP> <STRUCTURE EXP> | <NAME EXP> <RELATIONAL OP> <NAME EXP>
<RELATIONAL FACTOR> ::= <REL PRIM> | <RELATIONAL FACTOR> <AND> <REL PRIM>
<RELATIONAL EXP> ::= <RELATIONAL FACTOR> | <RELATIONAL EXP> <OR> <RELATIONAL FACTOR>
<REL PRIM> ::= (1<RELATIONAL EXP>) | <NOT> (1<RELATIONAL EXP>) | <COMPARISON>
<CHAR PRIM> ::= <CHAR VAR> | <CHAR CONST> | <MODIFIED CHAR FUNC> | <CHAR INLINE DEF> <BLOCK BODY> <CLOSING>; | <CHAR FUNC HEAD> (<CALL LIST>) | (<CHAR EXP>)
<CHAR FUNC HEAD> ::= <CHAR FUNC> | CHARACTER <SUB OR QUALIFIER>
<SUB OR QUALIFIER> ::= <SUBSCRIPT> | <BIT QUALIFIER>
<CHAR EXP> ::= <CHAR PRIM> | <CHAR EXP> <CAT> <CHAR PRIM> | <CHAR EXP> <CAT> <ARITH EXP> | <ARITH EXP> <CAT> <ARITH EXP> | <ARITH EXP> <CAT> <CHAR PRIM>
<ASSIGNMENT> ::= <VARIABLE> <=1> <EXPRESSION> | <VARIABLE> , <ASSIGNMENT>
<IF STATEMENT> ::= <IF CLAUSE> <STATEMENT> | <TRUE PART> <STATEMENT>
<TRUE PART> ::= <IF CLAUSE> <BASIC STATEMENT> ELSE
<IF CLAUSE> ::= <IF> <RELATIONAL EXP> THEN | <IF> <BIT EXP> THEN
<IF> ::= IF
<DO GROUP HEAD> ::= DO; | DO <FOR LIST>; | DO <FOR LIST> <WHILE CLAUSE>; | DO <WHILE CLAUSE>; | DO CASE <ARITH EXP>; | <CASE ELSE> <STATEMENT> | <DO GROUP HEAD> <ANY STATEMENT> | <DO GROUP HEAD> <TEMPORARY STMT>
<CASE ELSE> ::= DO CASE <ARITH EXP>; ELSE
<WHILE KEY> ::= WHILE | UNTIL
<WHILE CLAUSE> ::= <WHILE KEY> <BIT EXP> | <WHILE KEY> <RELATIONAL EXP>
<FOR LIST> ::= <FOR KEY> <ARITH EXP> <ITERATION CONTROL> | <FOR KEY> <ITERATION BODY>
<ITERATION BODY> ::= <ARITH EXP> | <ITERATION BODY> , <ARITH EXP>
<ITERATION CONTROL> ::= TO <ARITH EXP> | TO <ARITH EXP> BY <ARITH EXP>
<FOR KEY> ::= FOR <ARITH VAR> = | FOR TEMPORARY <IDENTIFIER> =
<ENDING> ::= END | END <LABEL> | <LABEL DEFINITION> <ENDING>
<ON PHRASE> ::= ON ERROR <SUBSCRIPT>
<ON CLAUSE> ::= ON ERROR <SUBSCRIPT> SYSTEM | ON ERROR <SUBSCRIPT> IGNORE
<SIGNAL CLAUSE> ::= SET <EVENT VAR> | RESET <EVENT VAR> | SIGNAL <EVENT VAR>
<FILE EXP> ::= <FILE HEAD> , <ARITH EXP>)
<FILE HEAD> ::= FILE (<NUMBER>
<CALL KEY> ::= CALL <LABEL VAR>
<CALL LIST> ::= <LIST EXP> | <CALL LIST> , <LIST EXP>
<CALL ASSIGN LIST> ::= <VARIABLE> | <CALL ASSIGN LIST> , <VARIABLE>
<EXPRESSION> ::= <ARITH EXP> | <BIT EXP> | <CHAR EXP> | <STRUCTURE EXP> | <NAME EXP>
<STRUCTURE EXP> ::= <STRUCTURE VAR> | <MODIFIED STRUCT FUNC> | <STRUC INLINE DEF> <BLOCK BODY> <CLOSING>; | <STRUCT FUNC HEAD> (<CALL LIST>)
<STRUCT FUNC HEAD> ::= <STRUCT FUNC>
<LIST EXP> ::= <EXPRESSION> | <ARITH EXP> # <EXPRESSION>
<VARIABLE> ::= <ARITH VAR> | <STRUCTURE VAR> | <BIT VAR> | <EVENT VAR> | <SUBBIT HEAD> <VARIABLE>) | <CHAR VAR> | <NAME KEY> (<NAME VAR>)
<NAME VAR> ::= <VARIABLE> | <LABEL VAR> | <MODIFIED ARITH FUNC> | <MODIFIED BIT FUNC> | <MODIFIED CHAR FUNC> | <MODIFIED STRUCT FUNC>
<NAME EXP> ::= <NAME KEY> (<NAME VAR>) | NULL | <NAME KEY> (NULL)
<NAME KEY> ::= NAME
<LABEL VAR> ::= <PREFIX> <LABEL> <SUBSCRIPT>
<MODIFIED ARITH FUNC> ::= <PREFIX> <NO ARG ARITH FUNC> <SUBSCRIPT>
<MODIFIED BIT FUNC> ::= <PREFIX> <NO ARG BIT FUNC> <SUBSCRIPT>
<MODIFIED CHAR FUNC> ::= <PREFIX> <NO ARG CHAR FUNC> <SUBSCRIPT>
<MODIFIED STRUCT FUNC> ::= <PREFIX> <NO ARG STRUCT FUNC> <SUBSCRIPT>
<STRUCTURE VAR> ::= <QUAL STRUCT> <SUBSCRIPT>
<ARITH VAR> ::= <PREFIX> <ARITH ID> <SUBSCRIPT>
<CHAR VAR> ::= <PREFIX> <CHAR ID> <SUBSCRIPT>
<BIT VAR> ::= <PREFIX> <BIT ID> <SUBSCRIPT>
<EVENT VAR> ::= <PREFIX> <EVENT> <SUBSCRIPT>
<QUAL STRUCT> ::= <STRUCTURE ID> | <QUAL STRUCT> . <STRUCTURE ID>
<PREFIX> ::= <EMPTY> | <QUAL STRUCT> .
<SUBBIT HEAD> ::= <SUBBIT KEY> <SUBSCRIPT> (
<SUBBIT KEY> ::= SUBBIT
<SUBSCRIPT> ::= <SUB HEAD>) | <QUALIFIER> | <$> <NUMBER> | <$> <ARITH VAR> | <EMPTY>
<SUB START> ::= <$>( | <$> (@<PREC SPEC> , | <SUB HEAD>; | <SUB HEAD> : | <SUB HEAD>,
<SUB HEAD> ::= <SUB START> | <SUB START> <SUB>
<SUB> ::= <SUB EXP> | * | <SUB RUN HEAD> <SUB EXP> | <ARITH EXP> AT <SUB EXP>
<SUB RUN HEAD> ::= <SUB EXP> TO
<SUB EXP> ::= <ARITH EXP> | <# EXPRESSION>
<# EXPRESSION> ::= # | <# EXPRESSION> + <TERM> | <# EXPRESSION> -1 <TERM>
<=1> ::= =
<$> ::= <CHAR DOLLAR>
<AND> ::= & | AND
<OR> ::= <CHAR VERTICAL BAR> | OR
<NOT> ::= ¬ | NOT
<CAT> ::= <CHAR VERTICAL BAR> <CHAR VERTICAL BAR> | CAT
<QUALIFIER> ::= <$> (@<PREC SPEC>) | <$> (<SCALE HEAD><ARITH EXP>) | <$> (@<PREC SPEC>, <SCALE HEAD><ARITH EXP>)
<SCALE HEAD> ::= @ | @ @
<BIT QUALIFIER> ::= <$(@<RADIX>)
<RADIX> ::= HEX | OCT | BIN | DEC
<BIT CONST HEAD> ::= <RADIX> | <RADIX> (<NUMBER>)
<BIT CONST> ::= <BIT CONST HEAD> <CHAR STRING> | TRUE | FALSE | ON | OFF
<CHAR CONST> ::= <CHAR STRING> | CHAR (<NUMBER>) <CHAR STRING>
<IO CONTROL> ::= SKIP (<ARITH EXP>) | TAB (<ARITH EXP>) | COLUMN (<ARITH EXP>) | LINE (<ARITH EXP>) | PAGE (<ARITH EXP>)
<READ PHRASE> ::= <READ KEY> <READ ARG> | <READ PHRASE> , <READ ARG>
<WRITE PHRASE> ::= <WRITE KEY> <WRITE ARG> | <WRITE PHRASE> , <WRITE ARG>
<READ ARG> ::= <VARIABLE> | <IO CONTROL>
<WRITE ARG> ::= <EXPRESSION> | <IO CONTROL>
<READ KEY> ::= READ (<NUMBER>) | READALL (<NUMBER>)
<WRITE KEY> ::= WRITE (<NUMBER>)
<BLOCK DEFINITION> ::= <BLOCK STMT> <BLOCK BODY> <CLOSING>;
<BLOCK BODY> ::= <EMPTY> | <DECLARE GROUP> | <BLOCK BODY> <ANY STATEMENT>
<ARITH INLINE DEF> ::= FUNCTION <ARITH SPEC>; | FUNCTION;
<BIT INLINE DEF> ::= FUNCTION <BIT SPEC>;
<CHAR INLINE DEF> ::= FUNCTION <CHAR SPEC>;
<STRUC INLINE DEF> ::= FUNCTION <STRUCT SPEC>;
<BLOCK STMT> ::= <BLOCK STMT TOP>;
<BLOCK STMT TOP> ::= <BLOCK STMT TOP> ACCESS | <BLOCK STMT TOP> RIGID | <BLOCK STMT HEAD> | <BLOCK STMT HEAD> EXCLUSIVE | <BLOCK STMT HEAD> REENTRANT
<LABEL DEFINITION> ::= <LABEL>:
<LABEL EXTERNAL> ::= <LABEL DEFINITION> | <LABEL DEFINITION> EXTERNAL
<BLOCK STMT HEAD> ::= <LABEL EXTERNAL> PROGRAM | <LABEL EXTERNAL> COMPOOL | <LABEL DEFINITION> TASK | <LABEL DEFINITION> UPDATE | UPDATE | <FUNCTION NAME> | <FUNCTION NAME> <FUNC STMT BODY> | <PROCEDURE NAME> | <PROCEDURE NAME> <PROC STMT BODY>
<FUNCTION NAME> ::= <LABEL EXTERNAL> FUNCTION
<PROCEDURE NAME> ::= <LABEL EXTERNAL> PROCEDURE
<FUNC STMT BODY> ::= <PARAMETER LIST> | <TYPE SPEC> | <PARAMETER LIST> <TYPE SPEC>
<PROC STMT BODY> ::= <PARAMETER LIST> | <ASSIGN LIST> | <PARAMETER LIST> <ASSIGN LIST>
<PARAMETER LIST> ::= <PARAMETER HEAD> <IDENTIFIER>)
<PARAMETER HEAD> ::= ( | <PARAMETER HEAD> <IDENTIFIER>,
<ASSIGN LIST> ::= <ASSIGN> <PARAMETER LIST>
<ASSIGN> ::= ASSIGN
<DECLARE ELEMENT> ::= <DECLARE STATEMENT> | <REPLACE STMT>; | <STRUCTURE STMT> | EQUATE EXTERNAL <IDENTIFIER> TO <VARIABLE>;
<REPLACE STMT> ::= REPLACE <REPLACE HEAD> BY <TEXT>
<REPLACE HEAD> ::= <IDENTIFIER> | <IDENTIFIER> (<ARG LIST>)
<ARG LIST> ::= <IDENTIFIER> | <ARG LIST> , <IDENTIFIER>
<TEMPORARY STMT> ::= TEMPORARY <DECLARE BODY>;
<DECLARE STATEMENT> ::= DECLARE <DECLARE BODY>;
<DECLARE BODY> ::= <DECLARATION LIST> | <ATTRIBUTES> , <DECLARATION LIST>
<DECLARATION LIST> ::= <DECLARATION> | <DCL LIST,> <DECLARATION>
<DCL LIST ,> ::= <DECLARATION LIST>,
<DECLARE GROUP> ::= <DECLARE ELEMENT> | <DECLARE GROUP> <DECLARE ELEMENT>
<STRUCTURE STMT> ::= STRUCTURE <STRUCT STMT HEAD> <STRUCT STMT TAIL>
<STRUCT STMT HEAD> ::= <IDENTIFIER> : <LEVEL> | <IDENTIFIER> <MINOR ATTR LIST>: <LEVEL> | <STRUCT STMT HEAD> <DECLARATION> , <LEVEL>
<STRUCT STMT TAIL> ::= <DECLARATION>;
<STRUCT SPEC> ::= <STRUCT TEMPLATE> <STRUCT SPEC BODY>
<STRUCT SPEC BODY> ::= - STRUCTURE | <STRUCT SPEC HEAD> <LITERAL EXP OR *>)
<STRUCT SPEC HEAD> ::= - STRUCTURE (
<DECLARATION> ::= <NAME ID> | <NAME ID> <ATTRIBUTES>
<NAME ID> ::= <IDENTIFIER> | <IDENTIFIER> NAME
<ATTRIBUTES> ::= <ARRAY SPEC> <TYPE & MINOR ATTR> | <ARRAY SPEC> | <TYPE & MINOR ATTR>
<ARRAY SPEC> ::= <ARRAY HEAD> <LITERAL EXP OR *>) | FUNCTION | PROCEDURE | PROGRAM | TASK
<ARRAY HEAD> ::= ARRAY ( | <ARRAY HEAD> <LITERAL EXP OR *>,
<TYPE & MINOR ATTR> ::= <TYPE SPEC> | <TYPE SPEC> <MINOR ATTR LIST> | <MINOR ATTR LIST>
<TYPE SPEC> ::= <STRUCT SPEC> | <BIT SPEC> | <CHAR SPEC> | <ARITH SPEC> | EVENT
<BIT SPEC> ::= BOOLEAN | BIT (<LITERAL EXP OR *>)
<CHAR SPEC> ::= CHARACTER (<LITERAL EXP OR *>)
<ARITH SPEC> ::= <PREC SPEC> | <SQ DQ NAME> | <SQ DQ NAME> <PREC SPEC>
<SQ DQ NAME> ::= <DOUBLY QUAL NAME HEAD> <LITERAL EXP OR *>) | INTEGER | SCALAR | VECTOR | MATRIX
<DOUBLY QUAL NAME HEAD> ::= VECTOR ( | MATRIX (<LITERAL EXP OR *> ,
<LITERAL EXP OR *> ::= <ARITH EXP> | *
<PREC SPEC> ::= SINGLE | DOUBLE
<MINOR ATTR LIST> ::= <MINOR ATTRIBUTE> | <MINOR ATTR LIST> <MINOR ATTRIBUTE>
<MINOR ATTRIBUTE> ::= STATIC | AUTOMATIC | DENSE | ALIGNED | ACCESS | LOCK (<LITERAL EXP OR *>) | REMOTE | RIGID | <INIT/CONST HEAD> <REPEATED CONSTANT>) | <INIT/CONST HEAD> *) | LATCHED | NONHAL (<LEVEL>)
<INIT/CONST HEAD> ::= INITIAL ( | CONSTANT ( | <INIT/CONST HEAD> <REPEATED CONSTANT> ,
<REPEATED CONSTANT> ::= EXPRESSION | <REPEAT HEAD> <VARIABLE> | <REPEAT HEAD> <CONSTANT> | <NESTED REPEAT HEAD> <REPEATED CONSTANT>) | <REPEAT HEAD>
<REPEAT HEAD> ::= <ARITH EXP> #SIMPLE NUMBER
<NESTED REPEAT HEAD> ::= <REPEAT HEAD> ( | <NESTED REPEAT HEAD> <REPEATED CONSTANT> ,
<CONSTANT> ::= <NUMBER> | <COMPOUND NUMBER> | <BIT CONST> | <CHAR CONST>
<NUMBER> ::= <SIMPLE NUMBER> | <LEVEL>
<CLOSING> ::= CLOSE | CLOSE <LABEL> | <LABEL DEFINITION> <CLOSING>
<TERMINATOR> ::= TERMINATE | CANCEL
<TERMINATE LIST> ::= <LABEL VAR> | <TERMINATE LIST> , <LABEL VAR>
<WAIT KEY> ::= WAIT
<SCHEDULE HEAD> ::= SCHEDULE <LABEL VAR> | <SCHEDULE HEAD> AT <ARITH EXP> | <SCHEDULE HEAD> IN <ARITH EXP> | <SCHEDULE HEAD> ON <BIT EXP>
<SCHEDULE PHRASE> ::= <SCHEDULE HEAD> | <SCHEDULE HEAD> PRIORITY(<ARITH EXP>) | <SCHEDULE PHRASE> DEPENDENT
<SCHEDULE CONTROL> ::= <STOPPING> | <TIMING> | <TIMING> <STOPPING>
<TIMING> ::= <REPEAT> EVERY <ARITH EXP> | <REPEAT> AFTER <ARITH EXP> | <REPEAT>
<REPEAT> ::= , REPEAT
<STOPPING> ::= <WHILE KEY> <ARITH EXP> | <WHILE KEY> <BIT EXP>
