-- Copyright:   Public Domain
-- Filename:    HAL-S.bnf
-- Purpose:     This is the BNF description of the HAL/S programming language,
--              taken from Appendix G of the HAL/S Language specification
--              (https://www.ibiblio.org/apollo/Shuttle/HAL_S%20Language%20Specification%20Nov%202005.pdf#page=209).
--              Some typos were corrected.  And terminal | (as opposed to BNF |)
--              were replaced by <CHAR VERTICAL BAR>.
-- History:     2022-11-08 RSB  Created.
--              2022-11-14 RSB  Replaced special characters in type names, such as 
--                              <% MACRO NAME> -> <PERCENT MACRO NAME>, as these
--                              aren't allowed in LBNF.
--              2022-11-15 RSB  Various fixes, such as removal of _|_ from 
--                              COMPILATION.
--              2022-11-16 RSB  Added ~~ to the syntax for suggesting LBNF labels,
--                              and added various suggested labels.  Replaced the 
--                              absurd terminal "-1" by the rule "<MINUS> ::= -".
--
--              **********************************************************
--              * This file is now frozen and deprecated.  Work directly *
--              * the LBNF description in the file HAL_S.cf instead.     *
--              **********************************************************
--
-- Note also the separate HAL/S source file SYNTHESI.hal, a portion of the original
-- HAL/S-FC compiler, which duplicates this BNF within its comments. 

<COMPILATION> ::= <COMPILE LIST>
<COMPILE LIST> ::= <BLOCK DEFINITION> | <COMPILE LIST> <BLOCK DEFINITION>
<PLUS> ::= +
<MINUS> ::= -
<ARITH EXP> ::= <TERM> | <PLUS> <TERM> | <MINUS> <TERM> | <ARITH EXP> <PLUS> <TERM> | <ARITH EXP> <MINUS> <TERM>
<TERM> ::= <PRODUCT> | <PRODUCT> / <TERM> ~~ termNoDivide ~~ termDivide
<PRODUCT> ::= <FACTOR> | <FACTOR> * <PRODUCT> | <FACTOR> . <PRODUCT> | <FACTOR> <PRODUCT> ~~ productSingle ~~ productCross ~~ productDot ~~ productMultiplication
<EXPONENTIATION> ::= ** 
<FACTOR> ::= <PRIMARY> | <PRIMARY> <EXPONENTIATION> <FACTOR>
<ARITH FUNC HEAD> ::= <ARITH FUNC> | <ARITH CONV> <SUBSCRIPT>
<ARITH CONV> ::= INTEGER | SCALAR | VECTOR | MATRIX
<PRE PRIMARY> ::= ( <ARITH EXP> ) | <NUMBER> | <COMPOUND NUMBER> | <ARITH FUNC HEAD> ( <CALL LIST> )
<PRIMARY> ::= <ARITH VAR> | <MODIFIED ARITH FUNC> | <ARITH INLINE DEF> <BLOCK BODY> <CLOSING> ; | <PRE PRIMARY> | <PRE PRIMARY> <QUALIFIER>
<OTHER STATEMENT> ::= <ON PHRASE> <STATEMENT> | <IF STATEMENT> | <LABEL DEFINITION> <OTHER STATEMENT>
<STATEMENT> ::= <BASIC STATEMENT> | <OTHER STATEMENT>
<ANY STATEMENT> ::= <STATEMENT> | <BLOCK DEFINITION>
<EQUALS> ::= =
<BASIC STATEMENT> ::= <LABEL DEFINITION> <BASIC STATEMENT> | <ASSIGNMENT> ; | EXIT ; | EXIT <LABEL> ; | REPEAT ; | REPEAT <LABEL> ; | GO TO <LABEL> ; | ; | <CALL KEY> ; | <CALL KEY> ( <CALL LIST> ) ; | <CALL KEY> <ASSIGN> ( <CALL ASSIGN LIST> ) ; | <CALL KEY> ( <CALL LIST> ) <ASSIGN> ( <CALL ASSIGN LIST> ) ; | RETURN; | RETURN <EXPRESSION> ; | <DO GROUP HEAD> <ENDING> ; | <READ KEY> ; | <READ PHRASE> ; | <WRITE KEY> ; | <WRITE PHRASE> ; | <FILE EXP> <EQUALS> <EXPRESSION> ; | <VARIABLE> <EQUALS> <FILE EXP> ; | <WAIT KEY> FOR DEPENDENT ; | <WAIT KEY> <ARITH EXP> ; | <WAIT KEY> UNTIL <ARITH EXP> ; | <WAIT KEY> FOR <BIT EXP> ; | <TERMINATOR> ; | <TERMINATOR> <TERMINATE LIST> ; | UPDATE PRIORITY TO <ARITH EXP> ; | UPDATE PRIORITY <LABEL VAR> TO <ARITH EXP> ; | <SCHEDULE PHRASE> ; | <SCHEDULE PHRASE> <SCHEDULE CONTROL> ; | <SIGNAL CLAUSE> ; | SEND ERROR <SUBSCRIPT> ; | <ON CLAUSE> ; | <ON CLAUSE> AND <SIGNAL CLAUSE> ; | OFF ERROR <SUBSCRIPT> ; | <PERCENT MACRO NAME> ; | <PERCENT MACRO HEAD> <PERCENT MACRO ARG> ) ;
<PERCENT MACRO HEAD> ::= <PERCENT MACRO NAME> ( | <PERCENT MACRO HEAD> <PERCENT MACRO ARG> ,
<PERCENT MACRO ARG> ::= <NAME VAR> | <CONSTANT>
<BIT PRIM> ::= <BIT VAR> | <LABEL VAR> | <EVENT VAR> | <BIT CONST> | ( <BIT EXP> ) | <MODIFIED BIT FUNC> | <BIT INLINE DEF> <BLOCK BODY> <CLOSING>; | <SUBBIT HEAD> <EXPRESSION> ) | <BIT FUNC HEAD> ( <CALL LIST> )
<BIT FUNC HEAD> ::= <BIT FUNC> | BIT <SUB OR QUALIFIER>
<BIT CAT> ::= <BIT PRIM> | <BIT CAT> <CAT> <BIT PRIM> | <NOT> <BIT PRIM> | <BIT CAT> <CAT> <NOT> <BIT PRIM>
<BIT FACTOR> ::= <BIT CAT> | <BIT FACTOR> <AND> <BIT CAT>
<BIT EXP> ::= <BIT FACTOR> | <BIT EXP> <OR> <BIT FACTOR>
<RELATIONAL OP> ::= <EQUALS> | <NOT> <EQUALS> | < | > | <= | >= | <NOT> < | <NOT> >
<COMPARISON> ::= <ARITH EXP> <RELATIONAL OP> <ARITH EXP> | <CHAR EXP> <RELATIONAL OP> <CHAR EXP> | <BIT CAT> <RELATIONAL OP> <BIT CAT> | <STRUCTURE EXP> <RELATIONAL OP> <STRUCTURE EXP> | <NAME EXP> <RELATIONAL OP> <NAME EXP>
<RELATIONAL FACTOR> ::= <REL PRIM> | <RELATIONAL FACTOR> <AND> <REL PRIM>
<RELATIONAL EXP> ::= <RELATIONAL FACTOR> | <RELATIONAL EXP> <OR> <RELATIONAL FACTOR>
<REL PRIM> ::= ( 1 <RELATIONAL EXP> ) | <NOT> ( 1 <RELATIONAL EXP> ) | <COMPARISON>
<CHAR PRIM> ::= <CHAR VAR> | <CHAR CONST> | <MODIFIED CHAR FUNC> | <CHAR INLINE DEF> <BLOCK BODY> <CLOSING>; | <CHAR FUNC HEAD> ( <CALL LIST> ) | ( <CHAR EXP> )
<CHAR FUNC HEAD> ::= <CHAR FUNC> | CHARACTER <SUB OR QUALIFIER>
<SUB OR QUALIFIER> ::= <SUBSCRIPT> | <BIT QUALIFIER>
<CHAR EXP> ::= <CHAR PRIM> | <CHAR EXP> <CAT> <CHAR PRIM> | <CHAR EXP> <CAT> <ARITH EXP> | <ARITH EXP> <CAT> <ARITH EXP> | <ARITH EXP> <CAT> <CHAR PRIM>
<ASSIGNMENT> ::= <VARIABLE> <EQUALS> <EXPRESSION> | <VARIABLE> , <ASSIGNMENT>
<IF STATEMENT> ::= <IF CLAUSE> <STATEMENT> | <TRUE PART> <STATEMENT>
<TRUE PART> ::= <IF CLAUSE> <BASIC STATEMENT> ELSE
<IF CLAUSE> ::= <IF> <RELATIONAL EXP> THEN | <IF> <BIT EXP> THEN
<IF> ::= IF
<DO GROUP HEAD> ::= DO ; | DO <FOR LIST> ; | DO <FOR LIST> <WHILE CLAUSE> ; | DO <WHILE CLAUSE> ; | DO CASE <ARITH EXP> ; | <CASE ELSE> <STATEMENT> | <DO GROUP HEAD> <ANY STATEMENT> | <DO GROUP HEAD> <TEMPORARY STMT>
<CASE ELSE> ::= DO CASE <ARITH EXP> ; ELSE
<WHILE KEY> ::= WHILE | UNTIL
<WHILE CLAUSE> ::= <WHILE KEY> <BIT EXP> | <WHILE KEY> <RELATIONAL EXP>
<FOR LIST> ::= <FOR KEY> <ARITH EXP> <ITERATION CONTROL> | <FOR KEY> <ITERATION BODY>
<ITERATION BODY> ::= <ARITH EXP> | <ITERATION BODY> , <ARITH EXP>
<ITERATION CONTROL> ::= TO <ARITH EXP> | TO <ARITH EXP> BY <ARITH EXP> ~~ iteration_controlTo ~~ iteration_controlToBy
<FOR KEY> ::= FOR <ARITH VAR> <EQUALS> | FOR TEMPORARY <IDENTIFIER> =
<ENDING> ::= END | END <LABEL> | <LABEL DEFINITION> <ENDING>
<ON PHRASE> ::= ON ERROR <SUBSCRIPT>
<ON CLAUSE> ::= ON ERROR <SUBSCRIPT> SYSTEM | ON ERROR <SUBSCRIPT> IGNORE
<SIGNAL CLAUSE> ::= SET <EVENT VAR> | RESET <EVENT VAR> | SIGNAL <EVENT VAR>
<FILE EXP> ::= <FILE HEAD> , <ARITH EXP> )
<FILE HEAD> ::= FILE ( <NUMBER>
<CALL KEY> ::= CALL <LABEL VAR>
<CALL LIST> ::= <LIST EXP> | <CALL LIST> , <LIST EXP>
<CALL ASSIGN LIST> ::= <VARIABLE> | <CALL ASSIGN LIST> , <VARIABLE>
<EXPRESSION> ::= <ARITH EXP> | <BIT EXP> | <CHAR EXP> | <STRUCTURE EXP> | <NAME EXP>
<STRUCTURE EXP> ::= <STRUCTURE VAR> | <MODIFIED STRUCT FUNC> | <STRUC INLINE DEF> <BLOCK BODY> <CLOSING> ; | <STRUCT FUNC HEAD> ( <CALL LIST> )
<STRUCT FUNC HEAD> ::= <STRUCT FUNC>
<LIST EXP> ::= <EXPRESSION> | <ARITH EXP> # <EXPRESSION>
<VARIABLE> ::= <ARITH VAR> | <STRUCTURE VAR> | <BIT VAR> | <EVENT VAR> | <SUBBIT HEAD> <VARIABLE> ) | <CHAR VAR> | <NAME KEY> ( <NAME VAR> )
<NAME VAR> ::= <VARIABLE> | <LABEL VAR> | <MODIFIED ARITH FUNC> | <MODIFIED BIT FUNC> | <MODIFIED CHAR FUNC> | <MODIFIED STRUCT FUNC>
<NAME EXP> ::= <NAME KEY> ( <NAME VAR> ) | NULL | <NAME KEY> ( NULL )
<NAME KEY> ::= NAME
<LABEL VAR> ::= <PREFIX> <LABEL> <SUBSCRIPT>
<MODIFIED ARITH FUNC> ::= <NO ARG ARITH FUNC> <SUBSCRIPT> | <PREFIX> <NO ARG ARITH FUNC> <SUBSCRIPT>
<MODIFIED BIT FUNC> ::= <NO ARG BIT FUNC> <SUBSCRIPT> | <PREFIX> <NO ARG BIT FUNC> <SUBSCRIPT>
<MODIFIED CHAR FUNC> ::= <NO ARG CHAR FUNC> <SUBSCRIPT> | <PREFIX> <NO ARG CHAR FUNC> <SUBSCRIPT>
<MODIFIED STRUCT FUNC> ::= <NO ARG STRUCT FUNC> <SUBSCRIPT> | <PREFIX> <NO ARG STRUCT FUNC> <SUBSCRIPT>
<STRUCTURE VAR> ::= <QUAL STRUCT> <SUBSCRIPT>
<ARITH VAR> ::= <ARITH ID> <SUBSCRIPT> | <PREFIX> <ARITH ID> <SUBSCRIPT>
<CHAR VAR> ::= <CHAR ID> <SUBSCRIPT> | <PREFIX> <CHAR ID> <SUBSCRIPT>
<BIT VAR> ::= <BIT ID> <SUBSCRIPT> | <PREFIX> <BIT ID> <SUBSCRIPT>
<EVENT VAR> ::= <EVENT> <SUBSCRIPT> | <PREFIX> <EVENT> <SUBSCRIPT>
<QUAL STRUCT> ::= <STRUCTURE ID> | <QUAL STRUCT> . <STRUCTURE ID>
<PREFIX> ::= <EMPTY> | <QUAL STRUCT> .
<SUBBIT HEAD> ::= <SUBBIT KEY> <SUBSCRIPT> (
<SUBBIT KEY> ::= SUBBIT
<SUBSCRIPT> ::= <SUB HEAD> ) | <QUALIFIER> | $ <NUMBER> | $ <ARITH VAR> | <EMPTY>
<SUB START> ::= $ ( | $ ( @ <PREC SPEC> , | <SUB HEAD> ; | <SUB HEAD> : | <SUB HEAD> ,
<SUB HEAD> ::= <SUB START> | <SUB START> <SUB>
<SUB> ::= <SUB EXP> | * | <SUB RUN HEAD> <SUB EXP> | <ARITH EXP> AT <SUB EXP>
<SUB RUN HEAD> ::= <SUB EXP> TO
<SUB EXP> ::= <ARITH EXP> | <POUND EXPRESSION>
<POUND EXPRESSION> ::= # | <POUND EXPRESSION> <PLUS> <TERM> | <POUND EXPRESSION> <MINUS> <TERM>
<AND> ::= & | AND
<OR> ::= <CHAR VERTICAL BAR> | OR
<NOT> ::= Â¬ | NOT
<CAT> ::= <CHAR VERTICAL BAR> <CHAR VERTICAL BAR> | CAT
<QUALIFIER> ::= $ ( @ <PREC SPEC> ) | $ ( <SCALE HEAD> <ARITH EXP> ) | $ ( @ <PREC SPEC> , <SCALE HEAD> <ARITH EXP> )
<SCALE HEAD> ::= @ | @ @
<BIT QUALIFIER> ::= < $ ( @ <RADIX> )
<RADIX> ::= HEX | OCT | BIN | DEC
<BIT CONST HEAD> ::= <RADIX> | <RADIX> ( <NUMBER> )
<BIT CONST> ::= <BIT CONST HEAD> <CHAR STRING> | TRUE | FALSE | ON | OFF
<CHAR CONST> ::= <CHAR STRING> | CHAR ( <NUMBER> ) <CHAR STRING>
<IO CONTROL> ::= SKIP ( <ARITH EXP> ) | TAB ( <ARITH EXP> ) | COLUMN ( <ARITH EXP> ) | LINE ( <ARITH EXP> ) | PAGE ( <ARITH EXP> )
<READ PHRASE> ::= <READ KEY> <READ ARG> | <READ PHRASE> , <READ ARG>
<WRITE PHRASE> ::= <WRITE KEY> <WRITE ARG> | <WRITE PHRASE> , <WRITE ARG>
<READ ARG> ::= <VARIABLE> | <IO CONTROL>
<WRITE ARG> ::= <EXPRESSION> | <IO CONTROL>
<READ KEY> ::= READ ( <NUMBER> ) | READALL ( <NUMBER> )
<WRITE KEY> ::= WRITE ( <NUMBER> )
<BLOCK DEFINITION> ::= <BLOCK STMT> <BLOCK BODY> <CLOSING> ;
<BLOCK BODY> ::= <EMPTY> | <DECLARE GROUP> | <BLOCK BODY> <ANY STATEMENT>
<ARITH INLINE DEF> ::= FUNCTION <ARITH SPEC> ; | FUNCTION ;
<BIT INLINE DEF> ::= FUNCTION <BIT SPEC> ;
<CHAR INLINE DEF> ::= FUNCTION <CHAR SPEC> ;
<STRUC INLINE DEF> ::= FUNCTION <STRUCT SPEC> ;
<BLOCK STMT> ::= <BLOCK STMT TOP> ;
<BLOCK STMT TOP> ::= <BLOCK STMT TOP> ACCESS | <BLOCK STMT TOP> RIGID | <BLOCK STMT HEAD> | <BLOCK STMT HEAD> EXCLUSIVE | <BLOCK STMT HEAD> REENTRANT
<LABEL DEFINITION> ::= <LABEL> :
<LABEL EXTERNAL> ::= <LABEL DEFINITION> | <LABEL DEFINITION> EXTERNAL
<BLOCK STMT HEAD> ::= <LABEL EXTERNAL> PROGRAM | <LABEL EXTERNAL> COMPOOL | <LABEL DEFINITION> TASK | <LABEL DEFINITION> UPDATE | UPDATE | <FUNCTION NAME> | <FUNCTION NAME> <FUNC STMT BODY> | <PROCEDURE NAME> | <PROCEDURE NAME> <PROC STMT BODY>
<FUNCTION NAME> ::= <LABEL EXTERNAL> FUNCTION
<PROCEDURE NAME> ::= <LABEL EXTERNAL> PROCEDURE
<FUNC STMT BODY> ::= <PARAMETER LIST> | <TYPE SPEC> | <PARAMETER LIST> <TYPE SPEC>
<PROC STMT BODY> ::= <PARAMETER LIST> | <ASSIGN LIST> | <PARAMETER LIST> <ASSIGN LIST>
<PARAMETER LIST> ::= <PARAMETER HEAD> <IDENTIFIER> )
<PARAMETER HEAD> ::= ( | <PARAMETER HEAD> <IDENTIFIER> ,
<ASSIGN LIST> ::= <ASSIGN> <PARAMETER LIST>
<ASSIGN> ::= ASSIGN
<DECLARE ELEMENT> ::= <DECLARE STATEMENT> | <REPLACE STMT> ; | <STRUCTURE STMT> | EQUATE EXTERNAL <IDENTIFIER> TO <VARIABLE> ;
<REPLACE STMT> ::= REPLACE <REPLACE HEAD> BY <TEXT>
<REPLACE HEAD> ::= <IDENTIFIER> | <IDENTIFIER> ( <ARG LIST> )
<ARG LIST> ::= <IDENTIFIER> | <ARG LIST> , <IDENTIFIER>
<TEMPORARY STMT> ::= TEMPORARY <DECLARE BODY> ;
<DECLARE STATEMENT> ::= DECLARE <DECLARE BODY> ;
<DECLARE BODY> ::= <DECLARATION LIST> | <ATTRIBUTES> , <DECLARATION LIST>
<DECLARATION LIST> ::= <DECLARATION> | <DCL LIST COMMA> <DECLARATION>
<DCL LIST COMMA> ::= <DECLARATION LIST> ,
<DECLARE GROUP> ::= <DECLARE ELEMENT> | <DECLARE GROUP> <DECLARE ELEMENT>
<STRUCTURE STMT> ::= STRUCTURE <STRUCT STMT HEAD> <STRUCT STMT TAIL>
<STRUCT STMT HEAD> ::= <IDENTIFIER> : <LEVEL> | <IDENTIFIER> <MINOR ATTR LIST> : <LEVEL> | <STRUCT STMT HEAD> <DECLARATION> , <LEVEL>
<STRUCT STMT TAIL> ::= <DECLARATION> ;
<STRUCT SPEC> ::= <STRUCT TEMPLATE> <STRUCT SPEC BODY>
<STRUCT SPEC BODY> ::= - STRUCTURE | <STRUCT SPEC HEAD> <LITERAL EXP OR STAR> )
<STRUCT SPEC HEAD> ::= - STRUCTURE (
<DECLARATION> ::= <NAME ID> | <NAME ID> <ATTRIBUTES>
<NAME ID> ::= <IDENTIFIER> | <IDENTIFIER> NAME
<ATTRIBUTES> ::= <ARRAY SPEC> <TYPE AND MINOR ATTR> | <ARRAY SPEC> | <TYPE AND MINOR ATTR>
<ARRAY SPEC> ::= <ARRAY HEAD> <LITERAL EXP OR STAR> ) | FUNCTION | PROCEDURE | PROGRAM | TASK
<ARRAY HEAD> ::= ARRAY ( | <ARRAY HEAD> <LITERAL EXP OR STAR> ,
<TYPE AND MINOR ATTR> ::= <TYPE SPEC> | <TYPE SPEC> <MINOR ATTR LIST> | <MINOR ATTR LIST>
<TYPE SPEC> ::= <STRUCT SPEC> | <BIT SPEC> | <CHAR SPEC> | <ARITH SPEC> | EVENT
<BIT SPEC> ::= BOOLEAN | BIT ( <LITERAL EXP OR STAR> )
<CHAR SPEC> ::= CHARACTER ( <LITERAL EXP OR STAR> )
<ARITH SPEC> ::= <PREC SPEC> | <SQ DQ NAME> | <SQ DQ NAME> <PREC SPEC>
<SQ DQ NAME> ::= <DOUBLY QUAL NAME HEAD> <LITERAL EXP OR STAR> ) | INTEGER | SCALAR | VECTOR | MATRIX
<DOUBLY QUAL NAME HEAD> ::= VECTOR ( | MATRIX ( <LITERAL EXP OR STAR> ,
<LITERAL EXP OR STAR> ::= <ARITH EXP> | *
<PREC SPEC> ::= SINGLE | DOUBLE
<MINOR ATTR LIST> ::= <MINOR ATTRIBUTE> | <MINOR ATTR LIST> <MINOR ATTRIBUTE>
<MINOR ATTRIBUTE> ::= STATIC | AUTOMATIC | DENSE | ALIGNED | ACCESS | LOCK ( <LITERAL EXP OR STAR> ) | REMOTE | RIGID | <INIT OR CONST HEAD> <REPEATED CONSTANT> ) | <INIT OR CONST HEAD> * ) | LATCHED | NONHAL ( <LEVEL> )
<INIT OR CONST HEAD> ::= INITIAL ( | CONSTANT ( | <INIT OR CONST HEAD> <REPEATED CONSTANT> , ~~ init_or_const_headInitial ~~ init_or_const_headConstant ~~ init_or_const_headRepeatedConstant
<REPEATED CONSTANT> ::= <EXPRESSION> | <REPEAT HEAD> <VARIABLE> | <REPEAT HEAD> <CONSTANT> | <NESTED REPEAT HEAD> <REPEATED CONSTANT> ) | <REPEAT HEAD>
<REPEAT HEAD> ::= <ARITH EXP> # <SIMPLE NUMBER>
<NESTED REPEAT HEAD> ::= <REPEAT HEAD> ( | <NESTED REPEAT HEAD> <REPEATED CONSTANT> ,
<CONSTANT> ::= <NUMBER> | <COMPOUND NUMBER> | <BIT CONST> | <CHAR CONST>
<NUMBER> ::= <SIMPLE NUMBER> | <LEVEL>
<CLOSING> ::= CLOSE | CLOSE <LABEL> | <LABEL DEFINITION> <CLOSING>
<TERMINATOR> ::= TERMINATE | CANCEL
<TERMINATE LIST> ::= <LABEL VAR> | <TERMINATE LIST> , <LABEL VAR>
<WAIT KEY> ::= WAIT
<SCHEDULE HEAD> ::= SCHEDULE <LABEL VAR> | <SCHEDULE HEAD> AT <ARITH EXP> | <SCHEDULE HEAD> IN <ARITH EXP> | <SCHEDULE HEAD> ON <BIT EXP>
<SCHEDULE PHRASE> ::= <SCHEDULE HEAD> | <SCHEDULE HEAD> PRIORITY ( <ARITH EXP> ) | <SCHEDULE PHRASE> DEPENDENT
<SCHEDULE CONTROL> ::= <STOPPING> | <TIMING> | <TIMING> <STOPPING>
<TIMING> ::= <REPEAT> EVERY <ARITH EXP> | <REPEAT> AFTER <ARITH EXP> | <REPEAT>
<REPEAT> ::= , REPEAT
<STOPPING> ::= <WHILE KEY> <ARITH EXP> | <WHILE KEY> <BIT EXP>
