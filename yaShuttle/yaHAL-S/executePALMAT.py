#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:  None - the author (Ron Burkey) declares this software to
            be in the Public Domain, with no rights reserved.
Filename:   executePALMAT.py
Requires:   Python 3.7 or later.
Purpose:    This is a VM (admittedly, an inefficient one) for 
            running PALMAT code generated by compilation of 
            HAL/S source code.
References: https://www.ibiblio.org/apollo/hal-s-compiler.html#PALMAT
            [HPG] HAL/S Programmer's Guide.
            [PIH] Programming in HAL/S.
History:    2023-01-01 RSB  Began.

I think that this code (unlike my normal code), though perhaps not 
exactly a walk in the park to brows through it, is reasonably clean.  
I've tried to keep it that way, to minimize the difficulty later developers 
may experience in trying to use it as a model for converting PALMAT code to a 
more-efficient encoding, as well as writing an emulator for that hypothetical 
more-efficient encoding.  Another way of saying this, I suppose, is that the
design of PALMAT itself is pretty simple.  I think the principal difficulties
are associated with the various transformations of datatypes and geometries
of data objects which are needed.  That code is mostly segregated into the
module saveValueToVariable.py.  Various code I use in common with the compiler
appears in the module palmatAux.py.

Or maybe not.  The more I look at this, the less newcomer-friendly it seems.
Well, at least I tried!

"""

import re
import math
import random
import time
import datetime
import copy
from palmatAux import *
from unaryFunctions import arrayableUnaryRTL, unaryRTL
from binaryFunctions import arrayableBinaryRTL, binaryRTL
from accumulableFunctions import accumulate, accumulableFunctions
from saveValueToVariable import *

'''
Categorization of the HAL/S built-in functions by the number of arguments
they take.
'''
builtIns = [
    # No arguments
    ["CLOCKTIME", "DATE", "ERRGRP", "ERRNUM", "PRIO", "RANDOM", "RANDOMG", 
     "RUNTIME"],
    # One argument
    ["ABS", "CEILING", "FLOOR", "ODD", "ROUND", "SIGN", "SIGNUM", "TRUNCATE",
     "ARCCOS", "ARCCOSH", "ARCSIN", "ARCSINH", "ARCTAN", "ARCTANH", "COS",
     "COSH", "EXP", "LOG", "SIN", "SINH", "SQRT", "TAN", "TANH",
     "ABVAL", "DET", "INVERSE", "TRACE", "TRANSPOSE", "UNIT",
     "MAX", "MIN", "PROD", "SUM", "LENGTH", "TRIM", "NEXTIME", "SIZE"],
    # Two arguments
    ["DIV", "MOD", "REMAINDER", "ARCTAN2", "XOR", "INDEX", "LJUST", "RJUST",
     "SHL", "SHR"],
    # Three arguments
    ["MIDVAL"]
]

'''
The following is the guts of a "jump" instruction.  The parameters are:
    PALMAT          The entire PALMAT structure of which the current instruction
                    is part, obviously.
    scopeNumber     The index of the PALMAT scope in which this instruction
                    resides.
    instructionDict The instruction itself.  PALMAT instructions in this 
                    implementation have the form of Python "dictionaries", so
                    that's why it happens to be called instructionDict, do 
                    distinguish it from the name of the instruction.  It is 
                    this instructionDict which tells you the destination for
                    the jump.
    instructionName This is the name of the instruction which the jump() 
                    function is helping to implement, which will typically
                    be "goto", "iffalse", "iftrue", or something else related
                    to a jump.
This function does two things: 
    1.  It returns an (index, offset) pair giving the index of the PALMAT scope
        into which the jump is occurring, and the offset into that scope of the
        target location.  The calling code has to make use of these return
        values to perform the actual jump
    2.  It may "optimize" the instructionDict.  The nature of this optimization
        is that the instructionDict, after compilation, may simply give the
        target scope index and the symbolic label attached to the target
        address.  This is inefficient at runtime, since it involves a lookup
        of the symbolic label.  The "optimization" is that if the emulator is
        forced to look up the symbolic label, it then replaces that symbolic
        label by the numeric offset directly in the instructionDict, so that
        the lookup won't be done again if the instruction is executed again
        later.  If it does that, it creates a new key, "symbolicLabel", to 
        preserve the original symbolic label for debugging purposes.  Of course,
        if the compiler or linker did this stuff for us, then the emulator 
        would not have to do it at all.
'''
def jump(PALMAT, source, scopeNumber, instructionDict, instructionName):
    si, s = instructionDict[instructionName]
    if isinstance(s, str):
        attributes = PALMAT["scopes"][si]["identifiers"][s]
        if attributes == None or "label" not in attributes:
            printError(PALMAT, source, str(instructionDict), \
                       "Cannot find target label " + s)
            return None
        instructionDict["symbolicLabel"] = instructionDict[instructionName]
        instructionDict[instructionName] = attributes["label"]
    s = instructionDict[instructionName]
    return tuple(s)

'''
Create a PALMAT for a new process/thread.  This is related to the 
executePALMAT() function's newInstantiation parameter (see below).  The
clonePALMAT() function doesn't actually start such a new thread or process,
but merely creates a cloned PALMAT structure suitable for it, and then 
returns it.
'''
instantiationNumber = 0
def clonePALMAT(rawPALMAT):
    global instantiationNumber
    instantiationNumber += 1
    scopeIndex = 0
    
    # For the specified scope, make sure its identifiers are a deep copy
    # rather than a shallow copy.  Except for COMPOOLs.
    def deepcopyDescendents(scopeIndex):
        rawScope = rawPALMAT["scopes"][scopeIndex]
        scope = PALMAT["scopes"][scopeIndex]
        if rawScope["type"] != "compool":
            scope["identifiers"] = copy.deepcopy(rawScope["identifiers"])
        for childIndex in scope["children"]:
            deepcopyDescendents(childIndex)
    
    # After the following operation, both PALMAT and PALMAT["scopes"] are
    # entirely new, but each of the individual scopes PALMAT["scopes"][i]
    # is linked to the same object as rawPALMAT["scopes"][i]. So this is 
    # good for everything other than the "identifiers" field at scopeIndex
    # and its descendents.
    PALMAT = { 
        "scopes": [],
        "instantiation": instantiationNumber
        }
    for scope in rawPALMAT["scopes"]:
        PALMAT["scopes"].append(copy.copy(scope))
    # Now correct the shallowly-copied indentifiers to deep copies where needed.
    deepcopyDescendents(scopeIndex)
    return PALMAT

# For WRITE statements.
def printVectorOrMatrix(vOrM):
    if isinstance(vOrM, list):
        for v in vOrM:
            printVectorOrMatrix(v)
        return
    elif vOrM == None:
        value = "X.X"
    elif isinstance(vOrM, (int, float)):
        value = formatNumberAsString(vOrM)
    print(" " + value + " ", end="")

# For WRITE statements.
def printArray(array):
    if isinstance(array, list) and len(array) > 1 and array[-1] == "a":
        for a in array[:-1]:
            printArray(a)
        return
    elif array == None:
        value = 'None'
    elif isinstance(array, int):
        value = "%d" % array
    elif array == 0.0:
        value = " 0.0"
    elif isinstance(array, float):
        value = fpFormat % array
        if value[:1] == "+":
            value = " " + value[1:]
        value = value.replace("e", "E")
    elif isBitArray(array):
        value = bin(parseBitArray(array)[0])[2:]
    elif isinstance(array, str):
        value = '"' + array + '"'
    elif isVector(array) or isMatrix(array):
        printVectorOrMatrix(array)
        return
    else:
        value = "(unimplemented)"
    print(" " + value + " ", end="")

'''
For READ statements.  Read next value (in string form) from LUN 5 ... i.e., 
stdin.  The individual values in the input stream are delimited by commas 
and/or whitespace.  Commas/whitespace are used only for this purpose and are 
not returned by the function.  If a semicolon is encountered in the input
stream, it is returned whether or not it is delimited.  Semicolons are supposed
to be treated as the end of an input record and thus terminate a READ statement,
possibly prematurely.  However, this is the purview of the calling code, and
all readItemLUN5() does is to insure that the semicolon is returned.
'''
readLineFields = [] # Buffered data for READ statements
def readItemLUN5(PALMAT, source):
    global readLineFields
    while len(readLineFields) == 0:
        line = input("READ  > ").replace(";", " ; ").strip()
        if line == "":
            continue
        if "`" in line:
            printError(PALMAT, source, "{'read': True, 'lun': 5}", \
                "The back-tick (`) is not a legal character for input data in a READ statement.")
            continue
        readLineFields = re.split(r"\s*,\s*|\s+", line.strip())
    return readLineFields.pop(0)

# Apply the INTEGER or SCALAR shaping function (with no subscripts) to a 
# single INTEGER, SCALAR, BIT(N), CHARACTER(N), VECTOR(N), MATRIX(N,M), or 
# an ARRAY(N,...,M) of any of those.
def toIntegerOrScalar(object, toInteger=True):
    if object == None:
        return None
    elif isArrayQuick(object):
        for i in range(len(object)-1):
            object[i] = toIntegerOrScalar(object[i], toInteger)
        return object
    elif isinstance(object, (int, float)):
        if toInteger:
            return int(object)
        return float(object) 
    elif isBitArray(object):
        value, dummy = parseBitArray(object)
        if toInteger:
            return value
        return float(value)
    elif isinstance(object, str):
        value = stringifiedToFloat(object)
        if toInteger:
            return hround(value)
        return value
    elif isinstance(object, list):
        for i in range(len(object)):
            object[i] = toIntegerOrScalar(object[i], toInteger)
        return object

# Flatten a VECTOR or MATRIX and turn it into something more presentable by
# rounding to a specific number of significant digits after the decimal.
# This is only used by the 'typeof' function, which is of my invention
# rather than being something from the Shuttle era..
def presentify(object, digits=5):
    fmt = "%" + ".%df" % digits
    onto = []
    flatten(object, onto)
    result = ""
    for e in onto:
        if result != "":
            result += ", "
        if isinstance(e, (int, float)):
            result += fmt % e
            while result[-1:] == "0" and result[-2:] != ".0":
                result = result[:-1]
        else:
            result += str(e)
    return result

'''
This recursive function takes a data object and a subscript array, possibly 
with slices, and returns the sliced object.  The subscripts array must have the 
same or fewer dimensions as the object, and the same or smaller widths.  If 
there are less subscripts than dimensions, the remainder is filled up as if *
were used.  No conversions are performed.  Returns NaN on failure.
'''
def sliceIt(object, subscripts):
    if not isinstance(object, list) or isBitArray(object):
        if len(subscripts) == 0:
            return copy.deepcopy(object)
        else: # Too many subscripts for the object.
            return NaN
    isArray = (object[-1] == "a")
    if isArray:
        width = len(object) - 1
    else:
        width = len(object)
    if len(subscripts) == 0: # Not enough subscripts, so use entire level.
        thisLevelSubscripts = list(range(width))
    else:
        s = subscripts[0]
        if s == {'fill'}:
            thisLevelSubscripts = list(range(width))
        elif isinstance(s, list): # This is an AT-slice.
            s1 = unpound(s[1], width)
            thisLevelSubscripts = list(range(s1 - 1, s1 - 1 + s[0]))
        elif isinstance(s, tuple): # This is a TO-slice.
            thisLevelSubscripts = list(range(unpound(s[0], width) - 1, \
                                             unpound(s[1], width)))
        else: # This is a single index.
            thisLevelSubscripts = [unpound(s, width) - 1]
    newObject = []
    if len(subscripts) > 0:
        newSubscripts = subscripts[1:]
    else:
        newSubscripts = []
    for s in thisLevelSubscripts:
        try:
            newLevel = sliceIt(object[s], newSubscripts)
        except:
            return NaN
        if isNaN(newLevel):
            return NaN
        newObject.append(newLevel)
    if len(newObject) == 1:
        newObject = newObject[0]
    elif isArray:
        newObject.append("a")
    return newObject

'''
Computes the HAL/S "=" relational operator (PALMAT "==").
Returns True or False or None.  None is returned of the operands are 
incomparable (e.g., of unallowed datatypes or dimensions that don't match).

Note that operand1 and operand2 should be guaranteed to be fully initialized
before calling this function, so while we don't check for initialization here,
we don't have to worry about what happens when comparing uninitialized values.

Note:  According to [HPG] p. 9-8, it is legal to compare *either* of 
arithmetical or CHARACTER vs *either* arithmetical or CHARACTER.  For example, 
SCALAR vs CHARACTER is allowed. However, the BNF description of the HAL/S 
grammar allows for arithmetical vs arithmetical and CHARACTER vs CHARACTER,
but not arithmetical vs CHARACTER.  I'm assuming at the moment that this is
a typo in [HPG].
'''
def isEqualTo(operand1, operand2):
    
    '''
    Compare two ARRAY elements.  I.e., two values which are not themselves
    arrays.  For equality or non-equality tests, there are no conversions and
    only like vs like datatypes are compared (exception:  INTEGER vs SCALAR).
    Returns True, False, or None (for incomparable operands).
    '''
    def areLeavesEqual(leaf1, leaf2):
        isArith1 = isinstance(leaf1, (int, float))
        isArith2 = isinstance(leaf2, (int, float))
        if isArith1 != isArith2:
            return None
        if isArith1:
            return leaf1 == leaf2
        isChar1 = isinstance(leaf1, str)
        isChar2 = isinstance(leaf2, str)
        if isChar1 != isChar2:
            return None
        if isChar1:
            return leaf1 == leaf2
        isBit1 = isBitArray(leaf1)
        isBit2 = isBitArray(leaf2)
        if isBit1 != isBit2:
            return None
        if isBit1:
            value1, length1 = parseBitArray(leaf1)
            value2, length2 = parseBitArray(leaf2)
            return value1 == value2
        isVect1 = isVector(leaf1)
        isVect2 = isVector(leaf2)
        if isVect1 != isVect2:
            return None
        if isVect1:
            return leaf1 == leaf2
        isMat1 = isMatrix(leaf1)
        isMat2 = isMatrix(leaf2)
        if isMat1 != isMat2:
            return None
        if isMat1:
            return leaf1 == leaf2
        # Should do something with STRUCTURE, NAME here:  Depends if ARRAY
        # of STRUCTURE or name is possible.  TBD
        return leaf1 == leaf2
    
    def doesArrayEqualLeaf(array, leaf):
        retVal = True
        if isArrayQuick(array):
            for a in array[:-1]:
                r = doesArrayEqualLeaf(a, leaf)
                if r == None:
                    return None
                retVal &= r
            return retVal
        else:
            # "array" at this point is a leaf, and in spite of the designation
            # "array", is not itself an ARRAY.
            return areLeavesEqual(array, leaf)
    
    # We already know that the arrays match in dimensionality, so we can 
    # recurse through them at the same time.  Returns the usual True, False,
    # or None (for incomparability).
    def areTwoArraysEqual(array1, array2):
        retVal = True
        if isArrayQuick(array1):
            for i in range(len(array1)-1):
                r = areTwoArraysEqual(array1[i], array2[i])
                if r == None:
                    return None
                retVal &= r
            return retVal
        else:
            # Both arrays have recursed down to the leaves.
            return areLeavesEqual(array1, array2);
    
    isArray1 = isArrayQuick(operand1)
    isArray2 = isArrayQuick(operand2)
    if isArray1 and not isArray2:
        return doesArrayEqualLeaf(operand1, operand2)
    elif isArray2 and not isArray1:
        return doesArrayEqualLeaf(operand2, operand1)
    elif not isArray1 and not isArray2:
        return areLeavesEqual(operand1, operand2)
    return areTwoArraysEqual(operand1, operand2)

# For use with the trinaryOperation() function from the palmatAux.py module
# in implementing arrayed operation of the RTL function MIDVAL().
def simpleMIDVAL(PALMAT, operand1, operand2, operand3):
    if operand1 > operand2:
        operand1, operand2 = operand2, operand1
    # We now have operand1 <= operand2.
    if operand3 <= operand1:
        return operand1
    elif operand3 >= operand2:
        return operand2
    else:
        return operand3

# Find attributes of an identifier from an identifiers list, possibly with 
# structure qualifications.
def getAttributes(PALMAT, scopeIndex, qualifications, identifier):
    identifiers = PALMAT["scopes"][scopeIndex]["identifiers"]
    if len(qualifications) == 0:
        return identifiers[identifier]
    identifier = identifier[1:-1]
    try:
        # qualifications[0] is actually the top-level identifier we need to find
        # since it identifies the DECLARE'd STRUCTURE.  From that, we have to
        # find the structure template associated with the STRUCTURE and descend
        # down into it.
        si, attributes = findIdentifier("^s_" + qualifications[0] + "^", \
                                        PALMAT, scopeIndex)
        if attributes == None or "structure" not in attributes:
            return None
        si, template = findIdentifier("^" + attributes["structure"] + "^", \
                                        PALMAT, si)
        if template == None or "template" not in template:
            return None
        template = expandStructureTemplate(PALMAT, si, template)
        print("*1", qualifications[0], template)
        if template == None:
            return None
        for j in range(1, len(qualifications)):
            q = qualifications[j]
            if "template" in template:
                fieldNames = template["template"][0]
                fieldAttributes = template["template"][1]
                i = fieldNames.index("s_" + q)
                template = fieldAttributes[i]
            else:
                return None
        fieldNames = template["template"][0]
        fieldAttributes = template["template"][1]
        i = fieldNames.index(identifier)
        return fieldAttributes[i]
    except:
        return None

'''
This is the main emulator loop.  Basically, you feed it an entire PALMAT
structure of scopes (namely rawPALMAT) including the model of all variables
and constants for each scope, and the list of PALMAT instructions for each
scope.  You also give it a starting address (pcScope and pcOffset, defaulting
to 0, 0), and the emulation just runs until it runs out of PALMAT instructions;
i.e., until the next instruction to be executed is outside of the range of its
scope.

There are also a couple of flourishes:  If newInstantiation is True, then 
the PALMAT dataspaces are cloned prior to execution, so that any changes to
values of variables do not affect any other copies of the PALMAT structure.
In other words, you can have multiple instances running at the same time, and
they run independently.  However, PALMAT instruction lists and COMPOOLs are 
shared among instances, thus minimizing the amount of memory needed for the 
clones, as well as leaving open the possibility of sharing some memory (in the
COMPOOLs).  By default, however, newInstantiation is False, so any time that
executePALMAT() is run it can change variable values in a way that persists.

If this function returns, which in principle it might not if executing
an actual flight program, it returns the current computation stack.
That would normally be empty if full statements had been executed.
However, this allows executing (say) just a single expression without popping
the value from the stack at the end, which is useful for the compiler
since it can then use it to compute things like INITIAL(...) or 
CONSTANT(...) for DECLARE statements.  If there is failure, for example
the use of an unimplemented built-in function or referencing an 
uninitialized variable, then None is returned instead.
'''
def executePALMAT(rawPALMAT, pcScope=0, pcOffset=0, newInstantiation=False, \
                  trace=False, indent=0):
    # Some values needed for RTL functions.
    timeOrigin = time.time_ns() # For RUNTIME
    errorGroup = 0              # For ERRGRP
    errorNum = 0                # For ERRNUM
    
    if newInstantiation:
        PALMAT = clonePALMAT(rawPALMAT)
    else:
        PALMAT = rawPALMAT
    scopes = PALMAT["scopes"]
    for scope in scopes:
        if "return" in scope:
            scope.pop("return")
        if "returnoffset" in scope:
            scope.pop("returnoffset")
    scopeNumber = pcScope
    instructionIndex = pcOffset
    scope = scopes[scopeNumber]
    scope0 = scopes[0]
    computationStack = []
    source = [0, -1, -1]
    # Execute the PALMAT instructions, one by one.
    while instructionIndex < len(scope["instructions"]):
        identifiers = scope["identifiers"]
        instructions = scope["instructions"]
        instruction = instructions[instructionIndex]
        if "source" in instruction:
            source = instruction["source"]
        # As originally designed, both structure qualifications and and 
        # subscripts are intended to persist only until the very next 
        # instruction (usually, 'fetch').  But what if there are both?
        # We need to do something here to account for the possibility that 
        # both subscripts and structure qualifications are present; but for 
        # now, I'm just pretending that at most one of those two is present.
        qualifications = []
        if "qualifications" in scope0:
            qualifications = scope0["qualifications"]
            scope0.pop("qualifications")
        fullSubscripts = []
        if "subscripts" in scope0:
            fullSubscripts.extend(scope0["subscripts"])
        if "subscripts2" in scope0:
            fullSubscripts.extend(scope0["subscripts2"])
        if len(fullSubscripts) > 0 and "fetch" not in instruction and \
                "fetchp" not in instruction and "shaping" not in instruction \
                and "unravel" not in instruction:
            printError(PALMAT, source, instruction, 
                "Implementation error, subscript (%s) without variable in instruction" \
                % scope0["subscripts"])
            return None
        if "subscripts" in scope0:
            subscripts = scope0.pop("subscripts")
        else:
            subscripts = []
        if "subscripts2" in scope0:
            subscripts2 = scope0.pop("subscripts2")
        else:
            subscripts2 = []
        if trace:
            print("\tTRACE:  ", computationStack, \
                  " (%d,%d):" % (scopeNumber, instructionIndex), instruction)
        instructionIndex += 1
        stackSize = len(computationStack)
        if "debug" in instruction:
            pass
        elif "empty" in instruction:
            computationStack.append(None)
        elif "fill" in instruction:
            computationStack.append({"fill"})
        elif "string" in instruction:
            computationStack.append(instruction["string"])
        elif "boolean" in instruction:
            computationStack.append(instruction["boolean"])
        elif "number" in instruction:
            try:
                value = int(instruction["number"])
            except:
                value = stringifiedToFloat(instruction["number"])
            computationStack.append(value)
        elif "vector" in instruction:
            computationStack.append(instruction["vector"])
        elif "matrix" in instruction:
            computationStack.append(instruction["matrix"])
        elif "array" in instruction:
            computationStack.append(instruction["array"])
        #elif "bitarray" in instruction:
        #    computationStack.append(parseBitArray(instruction["bitarray"])[0])
        elif "+><" in instruction:
            si, identifier = instruction["+><"]
            identifier = "^" + identifier + "^"
            if stackSize < 2:
                printError(PALMAT, source, instruction, \
                        "Implementation error, not enough operands for '+><'.")
                return None
            operand1 = computationStack.pop()
            negativeIncrement = (operand1 < 0)
            operand2 = computationStack[-1]
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                printError(PALMAT, source, instruction, \
                    "Implementation error, variable (%s) not found." \
                      % identifier[1:-1])
                return None
            if "integer" not in attributes and "scalar" not in attributes:
                printError(PALMAT, source, instruction, \
                           "Implementation error in '+><': Not a number.")
                return None
            if "value" not in attributes:
                printError(PALMAT, source, instruction, \
                    "Implementation error in '+><': Uninitialized variable.")
                return None
            operand1 += attributes["value"]
            if "integer" in attributes:
                attributes["value"] = hround(operand1)
            else:
                attributes["value"] = operand1
            if negativeIncrement:
                computationStack[-1] = convertToBitArray(operand1 < operand2)
            else:
                computationStack[-1] = convertToBitArray(operand1 > operand2)
        elif "sentinel" in instruction:
            computationStack.append({"sentinel"})
        elif "operator" in instruction:
            operator = instruction["operator"]
            if False:
                pass
            elif operator == "#":
                if stackSize < 2:
                    printError(PALMAT, source, instruction, \
                        ("\tImplementation error, not enough operands " + \
                        "for operator \"%s\"") % operator)
                    return None
                operand1 = hround(computationStack.pop())
                # Recall that if a single item is being repeated, it is present
                # as itself, but if a group of items are being repeated then
                # that group appears on the computation stack in the form of 
                # a single item because the group is wrapped in [(...)].  That
                # particular wrapping is chosen because it's distinguishable 
                # from VECTOR, MATRIX, and ARRAY.
                if computationStack[-1] == {'sentinel'}:
                    computationStack.pop()
                    operands2 = [None]
                else:
                    operands2 = []
                    while True:
                        value = computationStack.pop()
                        if value == {'sentinel'}:
                            break
                        flatten(value, operands2)
                while operand1 > 0:
                    # I want to insert all the elements in operands2 into
                    # computation stack.  If I use the list .extend method
                    # for this, I find they end up in reversed order, so I
                    # want to do the insertion at the beginning rather than
                    # at the end.  I want to do this in place, without 
                    # creating a new computationStack object.
                    #computationStack.extend(operands2)
                    #computationStack[0:0] = operands2
                    computationStack.extend(reversed(operands2))
                    operand1 -= 1
            elif operator == "dotted":
                # Structure qualifications.  These are the strings "A", "B", "C"
                # in structure refrences like A.B.C.X.
                q = []
                while True:
                    value = computationStack.pop()
                    if value == {"sentinel"}:
                        break
                    q[0:0] = [value] # Insert the qualification at position 0.
                scope0["qualifications"] = q
            elif operator == "subscripts":
                subscripts = []
                subscripts2 = []
                s = subscripts
                while True:
                    value = computationStack.pop()
                    if value == {"sentinel"}:
                        break
                    if value == {"semicolon"}:
                        s = subscripts2
                        continue
                    s.append(value)
                if len(subscripts + subscripts2) < 1:
                    printError(PALMAT, source, instruction, \
                               "Subscript operator without subscripts.")
                    return None
                scope0["subscripts"] = subscripts
                scope0["subscripts2"] = subscripts2
            elif operator in ["U-", "NOT"]: # Unary operators.
                if stackSize < 1:
                    printError(PALMAT, source, instruction, \
                        ("\tImplementation error, not enough operands " + \
                        "for operator \"%s\"") % operator)
                    return None
                operand = computationStack[-1]
                #arrayDim, v = getArrayDimensions(operand)
                #isi,iss,isv,ism = checkArithmeticalDatatype(v)
                #isn = isi or iss
                if operator == "U-":
                    result = arrayableUnaryRTL(PALMAT, "Negation", operand, \
                                               source, instruction)
                    if isNaN(result):
                        return None
                elif operator == "NOT":
                    if not isBitArray(operand):
                        printError(PALMAT, source, instruction, \
                                   "Not bit array: " + operand)
                        return None
                    value, length = parseBitArray(operand)
                    result = formBitArray(~value, length)
                else:
                    printError(PALMAT, source, instruction, \
                            ("Implementation error, unary operator (%s) " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            elif operator in ["+", "-", "", "/", "**", ".", "*", "C||", "OR", 
                              "AND", "==", "!=", "<", ">", "<=", ">=", "B||",
                              "ORNOT"]: 
                # binary operators.
                if stackSize < 2:
                    printError(PALMAT, source, instruction, \
                        ("Implementation error, not enough operands " + \
                        "for operator \"%s\"") % operator)
                    return None
                result = None
                operand1 = computationStack[-1]
                operand2 = computationStack[-2]
                computationStack.pop()
                computationStack[-1] = None
                if operator in ["==", "!=", "<", ">", "<=", ">="] and \
                        (not isCompletelyInitialized(operand1) or \
                         not isCompletelyInitialized(operand2)):
                    printError(PALMAT, source, instruction, \
                        "Cannot compare uninitialized values")
                    return None
                # Common arithmetical operators ... both arrayed and
                # non-arrayed operations.
                if operator in binaryRTL:
                    result = arrayableBinaryRTL(PALMAT, operator, operand1, \
                                                operand2, \
                                                source, instruction)
                    if isNaN(result):
                        return None
                else:
                    if operator == "C||": # string concatenation.
                        result = operand1 + operand2
                    elif operator in ["AND", "OR", "ORNOT", "B|N" ]:
                        if not isBitArray(operand1):
                            printError(PALMAT, source, instruction, \
                                       "Not bit array: " + str(operand1))
                            return None
                        if not isBitArray(operand2):
                            printError(PALMAT, source, instruction, \
                                       "Not bit array: " + str(operand2))
                            return None
                        value1, length1 = parseBitArray(operand1)
                        value2, length2 = parseBitArray(operand2)
                        if operator == "OR":
                            numbits = min(length1, length2)
                            result = formBitArray(value1 | value2, numbits)
                        elif operator == "AND":
                            numbits = min(length1, length2)
                            result = formBitArray(value1 & value2, numbits)
                        elif operator == "ORNOT":
                            numbits = min(length1, length2)
                            result = formBitArray(value1 | ~value2, numbits)
                        elif operator == "B||":
                            numbits = length1 + length2
                            result = formBitArray((value1 << length2) | value2,\
                                                   numbits)
                    elif operator == "==":
                        result = \
                            convertToBitArray(isEqualTo(operand1, operand2))
                    elif operator == "!=":
                        result = \
                            convertToBitArray(not isEqualTo(operand1, operand2))
                    elif operator == "<":
                        result = convertToBitArray(operand1 < operand2)
                    elif operator == ">":
                        result = convertToBitArray(operand1 > operand2)
                    elif operator == "<=":
                        result = convertToBitArray(operand1 <= operand2)
                    elif operator == ">=":
                        result = convertToBitArray(operand1 >= operand2)
                    elif operator == ".":
                        if isv1 and isv2 \
                                and len(operand1) == len(operand2):
                            result = 0
                            for i in range(len(operand1)):
                                result += operand1[i] * operand2[i]
                    elif operator == "*":
                        if isv1 and isv2 \
                                and len(operand1) == 3 and len(operand2) == 3:
                            result = [
                                operand1[1]*operand2[2]-operand1[2]*operand2[1],
                                operand1[2]*operand2[0]-operand1[0]*operand2[2],
                                operand1[0]*operand2[1]-operand1[1]*operand2[0]                                
                                ]
                        else:
                            printError(PALMAT, source, instruction, \
                                "Operands of * must be initialized 3-vectors.")
                            return None
                    else:
                        printError(PALMAT, source, instruction, \
                            ("Implementation error, binary operator \"%s\" " + \
                            "not yet implemented") % operator)
                        return None
                    if result == None:
                        printError(PALMAT, source, instruction, \
                                   "Uninitialized values in expression.")
                        return None
                computationStack[-1] = result
            else:
                printError(PALMAT, source, instruction, \
                           "Unknown operator \"%s\"" % operator)
        elif "fetch" in instruction or "unravel" in instruction \
                or "fetchp" in instruction or \
                "store" in instruction or "storepop" in instruction or \
                "substore" in instruction or "substorepop" in instruction:
            erroredUp = False
            fetch = False
            fetchp = False
            pop = False
            unravel = False
            lhsSubscripts = False
            stackPos = 1
            if "fetch" in instruction:
                si, identifier = instruction["fetch"]
                fetch = True
            elif "unravel" in instruction:
                si, identifier = instruction["unravel"]
                fetch = True
                unravel = True
            elif "fetchp" in instruction:
                si, identifier = instruction["fetchp"]
                fetchp = True
            elif "store" in instruction:
                si, identifier = instruction["store"]
            elif "storepop" in instruction:
                si, identifier = instruction["storepop"]
                pop = True
            elif "substore" in instruction:
                si, identifier = instruction["substore"]
                lhsSubscripts = True
            elif "substorepop" in instruction:
                si, identifier = instruction["substorepop"]
                pop = True
                lhsSubscripts = True
            lhsSubscriptList = []
            if lhsSubscripts:
                subscript = computationStack.pop()
                while subscript != {"sentinel"}:
                    if subscript != {"semicolon"}:
                        lhsSubscriptList.append(subscript)
                    subscript = computationStack.pop()
            dummyScope = scope
            while si == -1:
                '''
                If si == -1, then the variable being assigned is itself a
                local alias in a procedure call.  So we have to seek upstream
                to find the variable to which it's actually referring.
                
                The reason we're in a "while si" rather than an "if si" is that
                we may have *nested* procedure calls, so once we find the 
                upstream variable to which our alias refers, it may itself be
                an alias for another variable upstream of the calling code
                (which may be a scope that's not necessarily an ancestor of 
                the procedure's scope), and so on. 
                '''
                while "assignments" not in dummyScope:
                    if dummyScope["parent"] == None:
                        printError(PALMAT, source, instruction, \
                                   "Cannot find identifier " + identifier)
                        return None
                    dummyScope = PALMAT["scopes"][dummyScope["parent"]]
                if identifier not in dummyScope["assignments"]:
                    printError(PALMAT, source, instruction, \
                        ("Identifier \"%s\" " + \
                        "not found") % identifier[1:-1])
                    return None
                si, identifier = dummyScope["assignments"][identifier]
                if si == -1:
                    if "return" not in dummyScope:
                        printError(PALMAT, source, instruction, \
                            "Cannot trace nested assignments (%s in %s)" % \
                            (identifier, dummyScope["name"]))
                        return None
                    dummyScope = PALMAT["scopes"][dummyScope["return"][0]]
            identifier = "^" + identifier + "^"
            try:
                attributes = getAttributes(PALMAT, si, qualifications, identifier)
                if attributes == None:
                    raise Exception("Problem fetching attributes")
            except:
                printError(PALMAT, source, instruction, \
                           "Undiagnosed problem with PALMAT instruction")
                print("\t\tnum scopes =", len(PALMAT["scopes"]))
                print("\t\ttype of si =", type(si))
                print("\t\tscope number =", si, " identifier =", identifier)
                print("\t\tidentifiers =", PALMAT["scopes"][si]["identifiers"])
                print("\t\tqualifications =", qualifications)
                return None
            erroredUp = True
            if fetch:
                print("!!", attributes)
                if "constant" in attributes:
                    value = sliceIt(attributes["constant"], fullSubscripts)
                else:
                    value = sliceIt(attributes["value"], fullSubscripts)
                if isNaN(value):
                    printError(PALMAT, source, instruction, \
                        "Slicing error %s%s." % (identifier, str(fullSubscripts)))
                    return None
                if unravel:
                    onto = []
                    flatten(value, onto)
                    computationStack.extend(reversed(onto))
                else:
                    computationStack.append(value)
            elif fetchp:
                computationStack.append( [si, identifier, 'p'] )
            else: # store
                if len(computationStack) < stackPos:
                    printError(PALMAT, source, instruction, \
                               "Implementation error, stack too short for " +
                               "STOREXXX instruction")
                    return None
                value = copy.deepcopy(computationStack[-stackPos])
                if pop:
                    computationStack.pop(-stackPos)
                if "constant" in attributes:
                    printError(PALMAT, source, instruction, \
                               "Cannot change value of constant %s." \
                               % identifier[1:-1])
                    return None
                if True:
                    if "array" in attributes and "parameter" in attributes \
                            and len(attributes["array"]) == 1 and \
                            isArrayQuick(value) and \
                            len(getArrayDimensions(value)[0]) == 1 and \
                            (attributes["array"][0] == "*" \
                             or "flex" in attributes):
                        attributes["value"] = value
                        attributes["array"], dummy = getArrayDimensions(value)
                        attributes["flex"] = True
                    # This is my new, possibly-improved method.
                    elif not saveValueToVariable(PALMAT, source, value, \
                                               identifier[1:-1], \
                                               attributes, \
                                               lhsSubscriptList):
                        return None
                else:
                    # This my original, incomplete, imperfect method.
                    # Apply conversions to the data as necessary, if the datatype
                    # found on the computation stack was not precisely what the
                    # variable being assigned expects.
                    dimensions = []
                    if value == None:
                        pass
                    elif isinstance(value, str):
                        if "character" not in attributes:
                            printError(PALMAT, source, instruction, \
                                       "Cannot store string in non-CHARACTER " +
                                       "variable %s." % identifier[1:-1])
                            return None
                        maxlen = attributes["character"]
                        value = value[:maxlen]
                    elif isinstance(value, (float, int)):
                        if "integer" in attributes:
                            value = hround(value)
                        elif "scalar" in attributes or \
                                ("vector" in attributes and len(lhsSubscriptList) == 1) or \
                                ("matrix" in attributes and len(lhsSubscriptList) == 2):
                            value = float(value)
                        elif "bit" in attributes:
                            value = hround(value) & ((1 << attributes["bit"])-1)
                        elif "character" in attributes:
                            # TBD
                            printError(PALMAT, source, instruction, \
                                "Storing number in CHARACTER not yet implemented.")
                            value = "?"
                    elif isBitArray(value) and "bit" in attributes:
                        value = formBitArray(parseBitArray(value)[0], \
                                             attributes["bit"])
                    elif isVector(value, False) and "vector" in attributes \
                            and not lhsSubscripts:
                        numRows = len(value)
                        dimensions = [numRows]
                        if numRows != attributes["vector"]:
                            printError(PALMAT, source, instruction, \
                                    "Vector length mismatch in store operation: " \
                                    + identifier[1:-1])
                            return None
                    elif isMatrix(value, False) and "matrix" in attributes \
                            and not lhsSubscripts:
                        dimensions = [len(value), len(value[0])]
                        if dimensions != attributes["matrix"]:
                            printError(PALMAT, source, instruction, \
                                "Matrix geometry mismatch in store operation: " + \
                                identifier[1:-1])
                            return None
                    elif "array" in attributes:
                        dimensions = attributes["array"]
                        if not lhsSubscripts and \
                                not isArrayGeometry(value, dimensions):
                            printError(PALMAT, source, instruction, \
                                    "Array geometry wrong in store operation: " \
                                    + identifier[1:-1])
                            return None
                    else:
                        printError(PALMAT, source, instructions, \
                                   "Mismatched datatypes in instruction: %s vs %s" \
                                   % (str(instruction), str(value)))
                        return None
                    if lhsSubscriptList == []:
                        if "bit" in attributes and not isBitArray(value):
                            value = formBitArray(value, attributes["bit"])
                        elif "character" in attributes and \
                                "array" not in attributes and \
                                "vector" not in attributes and \
                                "matrix" not in attributes:
                            value = str(value)[:attributes["character"]]
                        attributes["value"] = value
                    else:
                        if "array" in attributes:
                            sdimensions = attributes["array"]
                        elif "vector" in attributes:
                            sdimensions = [attributes["vector"]]
                        elif "matrix" in attributes:
                            sdimensions = attributes["matrix"]
                        else:
                            sdimensions = []
                        if dimensions != sdimensions[len(lhsSubscriptList):]:
                            printError(PALMAT, source, instruction, \
                                       "Dimensionality mismatch in assignment.")
                            return None
                        if len(lhsSubscriptList) != len(sdimensions):
                            printError(PALMAT, source, instruction, \
                                    "Dimensionality of value and variable differ.")
                            return None
                        for i in range(len(dimensions)):
                            if lhsSubscriptList[i] < 1 or \
                                    lhsSubscriptList[i] > dimensions[i]:
                                printError(PALMAT, source, instruction, \
                                           "Subscript out of range in assignment")
                                return None
                        # Recall that in python, the following manipulations of 
                        # "row" operate on pointers.  So the final "row" we end up 
                        # with is actually a pointer to a stored row existing 
                        # already in the VECTOR, MATRIX, or ARRAY variable.
                        # Recall also that HAL/S indexes from 1 while Python indexes
                        # from 0.  Recall finally that even uninitialized composite
                        # data in our HAL/S scopes have the proper dimensionality,
                        # but with unused elements set to None, so the sought row
                        # does actually exist.
                        row = attributes["value"]
                        for i in range(len(dimensions)-1):
                            row = row[lhsSubscriptList[i]-1]
                        row[lhsSubscriptList[-1]-1] = value
            if not erroredUp:
                printError(PALMAT, source, instruction, \
                    "Identifier (%s) not in any accessible scope" \
                    % identifier[1:-1])
                return None
        elif "pop" in instruction:
            value = instruction["pop"]
            if value <= stackSize:
                while value > 0:
                    computationStack.pop()
                    value -= 1
            else:
                printError(PALMAT, source, instruction, \
                    "Implementation error, too many POPs: %d vs %d" \
                    % (value, stackSize))
                return None
        elif "read" in instruction:
            lun = instruction["read"]
            if lun == '5':
                # If this instruction is within a subroutine, then we can 
                # only regress in the computation stack until finding the 
                # return address, because we want to use that later (for 
                # returning!) rather than using it now for printing.
                start = 0
                for i in range(len(computationStack)-1, -1, -1):
                    entry = computationStack[i]
                    if isinstance(entry, list) and len(entry) == 3 and \
                            isinstance(entry[0], int) and \
                            isinstance(entry[1], str) and \
                            entry[2] == 'p':
                        continue
                    start = i + 1
                    break
                if start < len(computationStack):
                    semicolon = False
                    for value in computationStack[start:]:
                        if semicolon:
                            break
                        # In reality, we could have subscripted VECTOR, MATRIX,
                        # or ARRAY variables here. For now, I'm just ignoring 
                        # that possibility and implementing unsubscripted
                        # variables.
                        # Recall that "pointers" to variables, which is what
                        # should be on the computation stack at this point,
                        # are of the form [index, identifier, 'p'].
                        si = value[0]
                        identifier = value[1]
                        attributes = \
                            PALMAT["scopes"][si]["identifiers"][identifier]
                        if "vector" in attributes:
                            rowLength = attributes["vector"]
                            for i in range(rowLength):
                                value = readItemLUN5(PALMAT, source)
                                if value == ";":
                                    semicolon = True
                                    break
                                if value == "":
                                    continue
                                attributes["value"][i] = float(value)
                        elif "matrix" in attributes:
                            numRows, numCols = attributes["matrix"]
                            for i in range(numRows):
                                if semicolon:
                                    break
                                for j in range(numCols):
                                    value = readItemLUN5(source)
                                    if value == ";":
                                        semicolon = True
                                        break
                                    if value == "":
                                        continue
                                    attributes["value"][i][j] = float(value)
                        elif "integer" in attributes:
                            value = readItemLUN5(source)
                            if value == ";":
                                semicolon = True
                            elif value == "":
                                attributes["value"] == None
                            else:
                                attributes["value"] = int(value)
                        elif "scalar" in attributes:
                            value = readItemLUN5(source)
                            if value == ";":
                                semicolon = True
                            elif value == "":
                                attributes["value"] == None
                            else:
                                attributes["value"] = float(value)
                        elif "bit" in attributes:
                            value = readItemLUN5(PALMAT, source)
                            bitLength = attributes["bit"]
                            if value == ";":
                                semicolon = True
                            elif value == "":
                                attributes["value"] == [(None, bitLength)]
                            else:
                                value = int(value) & ((1 << bitLength) - 1)
                                attributes["value"] = [(value, bitLength)]
                while len(computationStack) > start:
                    computationStack.pop()
        elif "write" in instruction:
            lun = instruction["write"]
            if lun == '6':
                print("%*s" % (indent, ""), end="")
                for value in computationStack:
                    if value == None:
                        print(" None ", end="")
                    elif isArrayQuick(value):
                        printArray(value)
                    elif isBitArray(value):
                        print(" " + bin(parseBitArray(value)[0])[2:], end="")
                    elif isinstance(value, (int, float, list)):
                        printVectorOrMatrix(value)
                    elif isinstance(value, str):
                        print(value.replace("''", "'"), end="")
                    else:
                        print(value, end="")
                computationStack.clear()
                print()
        elif "iocontrol" in instruction:
            # We just ignore all i/o controls in WRITE for now.
            if len(computationStack) > 0:
                computationStack.pop()
        elif "shaping" in instruction:
            shapingFunction = instruction["shaping"]
            if shapingFunction == "sliceAT":
                sliceLength = hround(computationStack.pop())
                sliceStart = hround(computationStack[-1])
                computationStack[-1] = [sliceLength, sliceStart]
            elif shapingFunction == "sliceTO":
                sliceStart = hround(computationStack.pop())
                sliceEnd = hround(computationStack[-1])
                computationStack[-1] = (sliceStart, sliceEnd)
            elif shapingFunction in ["integer", "scalar", "vector", "matrix",
                                   "doubleinteger", "doublescalar",
                                   "doublevector", "doublematrix"]:
                dimensions = subscripts + subscripts2
                if len(dimensions) == 0:
                    if shapingFunction in ["vector", "doublevector"]:
                        dimensions.append(3)
                    elif shapingFunction in ["matrix", "doublematrix"]:
                        dimensions.append(3)
                        dimensions.append(3)
                # We now have the dimensionality, so let's create a Python
                # object to hold the data.  If the dimension list is empty,
                # there are a number of special cases (presumably originally
                # intended as convenience features for the code) that we need
                # to consider.
                if len(dimensions) == 0:
                        # The shaping function has no subscripts, and the 
                        # shaping function is integer or scalar, single or 
                        # double precision, though in this Python implementation
                        # single and double precision are treated as identical.
                        object = []
                        operand = computationStack.pop()
                        if computationStack[-1] == {"sentinel"}:
                            # If we're here, it's because there's a single
                            # argument to the shaping function, currently 
                            # stored in operand.
                            computationStack[-1] = \
                                toIntegerOrScalar(operand, \
                                                  shapingFunction in \
                                                  ["integer", "doubleinteger"])
                        else:
                            # If we're here, then there are multiple arguments
                            # to the shaping functions, none of which we've yet
                            # pulled from the stack and we're supposed to 
                            # produce a variable-length ARRAY by unraveling all
                            # of the arguments.
                            fill = False # TBD ... *do* something with fill!
                            while operand != {"sentinel"}:
                                if operand == {"fill"}:
                                    fill = True
                                    operand = computationStack.pop()
                                    continue
                                flatten(operand, object)
                                operand = computationStack.pop()
                            if shapingFunction in ["integer", "doubleinteger"]:
                                for i in range(len(object)):
                                    if object[i] != None:
                                        object[i] = int(object[i])
                            elif shapingFunction in ["scalar", "doublescalar"]:
                                for i in range(len(object)):
                                    if object[i] != None:
                                        object[i] = float(object[i])
                            computationStack.append(object + ["a"])
                        continue
                '''
                So if we've gotten to here, then the object we're trying to
                construct has dimensionality; i.e., it's one of VECTOR, 
                MATRIX, ARRAY INTEGER|SCALAR, ARRAY VECTOR, or ARRAY MATRIX.  
                The function assignCompositeSubscripted()
                in the module saveValueToVariable is ideal for initializing
                such an object starting from an unraveled set of data, except
                for the fact that it requires an object of the correct 
                dimensionality but with uninitialized elements as input.
                Fortunately, the function uninitializedComposite() in the 
                palmatAux module can be used to construct the uninitialized
                object.
                '''
                if shapingFunction in ["vector", "doublevector",
                                       "matrix", "doublematrix"]:
                    datatype = "scalar"
                    subscripts2 = dimensions
                    subscripts = []
                elif shapingFunction in ["integer", "doubleinteger"]:
                    datatype = "integer"
                elif shapingFunction in ["scalar", "doublescalar"]:
                    datatype = "scalar"
                else:
                    printError(PALMAT, source, instruction, \
                               "Unimplemented shaping function.")
                    return None
                composite = uninitializedComposite(subscripts, subscripts2)
                unraveled = []
                while True:
                    value = computationStack.pop()
                    if value == {'sentinel'}:
                        break
                    flatten(value, unraveled)
                subscriptedLHS = []
                for i in subscripts + subscripts2:
                    subscriptedLHS.append(list(range(1, i + 1)))
                if not assignCompositeSubscripted(None, composite, \
                                                  subscriptedLHS, \
                               datatype, -1, unraveled):
                    printError(PALMAT, source, instruction, \
                               "Cannot convert or too few values")
                    return None
                computationStack.append(composite)
                continue
            else:
                printError(PALMAT, source, instruction, \
                    "Implementation error, unknown shaping function: " + \
                    shapingFunction)
                return None
        elif "modern" in instruction:
            # These are like RTL built-in functions, but are invented by me for
            # the "modern" compiler/interpreter.  They do things to make 
            # debugging the compiler or performing validation testing on it
            # easier.  Note that in distinction to real RTL built-in functions,
            # in HAL/S their names are always lower-case, so they hopefully 
            # won't collide with any actual HAL/S code.  We'll see eventually,
            # I suppose.
            modern = instruction["modern"]
            if modern == "INITIALIZED":
                if stackSize < 1:
                    printError(PALMAT, source, instruction, \
                            "Not enough arguments on stack.")
                    return None
                if isCompletelyInitialized(computationStack[-1]):
                    computationStack[-1] = hTRUE
                else:
                    computationStack[-1] = hFALSE
            elif modern == "TYPEOF":
                if stackSize < 1:
                    printError(PALMAT, source, instruction, \
                               "Not enough arguments on stack.")
                    return None
                operand = computationStack[-1]
                if not isinstance(operand, str):
                    printError(PALMAT, source, instruction, \
                               "Argument must be a string.")
                    return None
                result = [""]*20
                i, mangled = flexFindIdentifier(operand, PALMAT, scopeNumber)
                if i == -1:
                    a = None
                else:
                    i, a = findIdentifier(mangled, PALMAT, i)
                if a == None:
                    a = {}
                    result[0] = "MISSING"
                elif "bit" in a:
                    result[0] = "BIT"
                    result[1] = str(a["bit"])
                elif "character" in a:
                    result[0] = "CHARACTER"
                    result[1] = str(a["character"])
                elif "vector" in a:
                    result[0] = "VECTOR"
                    result[1] = str(a["vector"])
                elif "matrix" in a:
                    result[0] = "MATRIX"
                    result[1] = str(a["matrix"][0])
                    result[2] = str(a["matrix"][1])
                elif "scalar" in a:
                    result[0] = "SCALAR"
                elif "integer" in a:
                    result[0] = "INTEGER"
                elif "structure" in a:
                    result[0] = "STRUCTURE"
                elif "label" in a:
                    result[0] = "LABEL"
                else:
                    result[0] = "?"
                if "constant" in a:
                    if result[0] == "BIT":
                        value, length = parseBitArray(a["constant"])
                        result[3] = "%d, %d" % (value, length)
                    elif result[0] in ["VECTOR", "MATRIX"]:
                        result[3] = str(a["constant"])
                        result[3] = presentify(a['constant'])
                    else:
                        result[3] = str(a["constant"])
                if "initial" in a:
                    if result[0] == "BIT":
                        value, length = parseBitArray(a["initial"])
                        result[4] = "%d, %d" % (value, length)
                    elif result[0] in ["VECTOR", "MATRIX"]:
                        result[4] = str(a["initial"])
                        result[4] = presentify(a['initial'])
                    else:
                        result[4] = str(a["initial"])
                if "double" in a:
                    result[5] = "DOUBLE"
                if "array" in a:
                    dimensions = a["array"]
                    i = 15
                    for d in dimensions:
                        if i > 20:
                            break
                        result[i] = str(d)
                        i += 1
                computationStack[-1] = result + ["a"]
            elif modern == "TYPEOFV":
                # Same as TYPEOF, except analyzes the value atop the 
                # computation stack, rather than an identifier.
                if stackSize < 1:
                    printError(PALMAT, source, instruction, \
                               "Not enough arguments on stack")
                    return None
                operand = computationStack[-1]
                result = [""]*20
                if isinstance(operand, list) and len(operand) == 3 and \
                        operand[-1] == 'p':
                    result[0] = "POINTER"
                elif isinstance(operand, list) and operand[-1:] == ['a']:
                    dummy = operand
                    dimensions = []
                    while isinstance(dummy, list) and dummy[-1:] == ['a']:
                        dimensions.append(len(dummy)-1)
                        dummy = dummy[0]
                    if isArrayGeometry(operand, dimensions):
                        i = 15
                        for d in dimensions:
                            result[i] = str(d)
                            i += 1
                            if i > 20:
                                break
                        operand = dummy
                    else:
                        result[0] = "?"
                if operand == None:
                    result[0] = "NONE"
                elif isinstance(operand, int):
                    result[0] = "INTEGER"
                elif isinstance(operand, float):
                    result[0] = "SCALAR"
                elif isinstance(operand, str):
                    result[0] = "CHARACTER"
                    result[1] = str(len(operand))
                elif isBitArray(operand):
                    result[0] = "BIT"
                    dummy, result[1] = parseBitArray(operand)
                elif isVector(operand, False):
                    result[0] = "VECTOR"
                    result[1] = str(len(operand))
                elif isMatrix(operand, False):
                    result[0] = "MATRIX"
                    result[1] = str(len(operand))
                    result[2] = str(len(operand[0]))
                elif isinstance(operand, dict):
                    result[0] = "STRUCTURE"
                elif operand == {"sentinel"}:
                    result[0] = "SENTINEL"
                elif operand == {"fill"}:
                    result[0] = "*"
                elif result[0] == "":
                    result[0] = "?"
                computationStack[-1] = result + ["a"]
        elif "function" in instruction:
            function = instruction["function"]
            # First check all of the no-argument functions.
            if function in builtIns[0]:
                if function == "RANDOM":
                    # Note that this returns a number in the range [0, 1),
                    # and therefore cannot return exactly 1.  The HAL/S
                    # documentation isn't entirely clear whether values
                    # that are *exactly* 0 or 1 should be returned.
                    computationStack.append(random.random())
                elif function == "RANDOMG":
                    computationStack.append(random.gauss(0.0, 1.0))
                elif function == "RUNTIME":
                    computationStack.append(1.0e-9 * \
                                            (time.time_ns() - timeOrigin))
                elif function == "CLOCKTIME":
                    rightNow = datetime.datetime.now(datetime.timezone.utc)
                    timeOfDay = 3600 * rightNow.hour + \
                                60 * rightNow.minute + rightNow.second + \
                                rightNow.microsecond * 1E-6
                    computationStack.append(timeOfDay)
                elif function == "DATE":
                    rightNow = datetime.datetime.now(datetime.timezone.utc)
                    d = 10000 * rightNow.year + 100 * rightNow.month + \
                        rightNow.day
                    computationStack.append(d)
                elif function == "ERRGRP":
                    computationStack.append(errorGroup)
                elif function == "ERRNUM":
                    computationStack.append(errorNum)
                else:
                    printError(PALMAT, source, instruction, \
                            "HAL/S built-in function " + function + \
                            " not yet implemented")
                    return None
            # Now all of the one-argument functions.
            elif function in builtIns[1]:
                if stackSize < 1:
                    printError(PALMAT, source, instruction, \
                        "Not enough arguments on stack for function " + \
                        function)
                    return None
                operand = computationStack[-1]
                if function in unaryRTL: # See unaryFunctions.py module.
                    result = arrayableUnaryRTL(PALMAT, function, \
                                               operand, \
                                               source, instruction)
                    if isNaN(result):
                        return None
                    computationStack[-1] = result
                elif function in accumulableFunctions: # See accumulableFunctions.py
                    result = accumulate(PALMAT, operand, function, source, \
                                        instruction)
                    if isNaN(result):
                        return None
                    computationStack[-1] = result
                elif function == "SIZE":
                    if isArrayQuick(operand):
                        dimensions, value = getArrayDimensions(operand)
                        if len(dimensions) == 1:
                            computationStack[-1] = dimensions[0]
                        else:
                            printError(PALMAT, source, instruction, \
                                "Array for SIZE must be one-dimensional.")
                            return None
                    else:
                        printError(PALMAT, source, instruction, \
                                   "SIZE function requires an array")
                        return None
                elif function == "LENGTH":
                    operand = str(operand)
                    computationStack[-1] = len(operand)
                elif function == "TRIM":
                    operand = str(operand)
                    computationStack[-1] = operand.strip()
                else:
                    printError(PALMAT, source, instruction, \
                               "HAL/S built-in function " + function + \
                               "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[2]:
                if stackSize < 2:
                    printError(PALMAT, source, instruction, \
                               "Not enough arguments on stack for function " + \
                               function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack[-1]
                if function in binaryRTL:
                    result = arrayableBinaryRTL(PALMAT, function, operand1, \
                                                operand2, \
                                                source, instruction)
                    if isNaN(result):
                        return None
                    computationStack[-1] = result
                elif function == "XOR":
                    if not isBitArray(operand1):
                        printError(PALMAT, source, instruction, \
                                   "Not bit array: " + str(operand1))
                        return None
                    if not isBitArray(operand2):
                        printError(PALMAT, source, instruction, \
                                   "Not bit array: " + str(operand2))
                        return None
                    value1, length1 = parseBitArray(operand1)
                    value2, length2 = parseBitArray(operand2)
                    numbits = max(length1, length2)
                    computationStack[-1] = formBitArray(value1^value2, numbits)
                elif function == "SHL":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 << operand2
                elif function == "SHR":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 >> operand2
                elif function == "INDEX":
                    # In Python, the character positions within the string are
                    # indexed from 0 (with -1 being "not present"), while in 
                    # HAL/S indexing is from 1 (with 0 being "not present").
                    operand1 = str(operand1)
                    operand2 = str(operand2)
                    computationStack[-1] = 1 + operand1.find(operand2)
                elif function == "LJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (-operand2, operand1)
                elif function == "RJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (operand2, operand1)
                else:
                    printError(PALMAT, source, instruction, \
                               "HAL/S built-in function " + function + \
                               " not yet implemented")
                    return None
            # Now all of the three-argument functions.
            elif function in builtIns[3]:
                if stackSize < 3:
                    printError(PALMAT, source, instruction, \
                               "Not enough arguments on stack for function " \
                               + function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack.pop()
                operand3 = computationStack[-1]
                if function == "MIDVAL":
                    result = trinaryOperation(PALMAT, simpleMIDVAL, operand1, \
                                              operand2, operand3)
                    if isNaN(result):
                        printError(PALMAT, source, instruction, \
                                   "Incompatible operands for MIDVAL function")
                        return None
                    computationStack[-1] = result
                else:
                    printError(PALMAT, source, instruction, \
                               "HAL/S built-in function " + function \
                               + "not yet implemented")
                    return None
            else:
                printError(PALMAT, source, instruction, \
                           "Implementation error, function " + function)
                return None
        elif "goto" in instruction:
            scopeNumber, instructionIndex = \
                    jump(PALMAT, source, scopeNumber, instruction, "goto")
            scope = scopes[scopeNumber]
        elif "calloffset" in instruction:
            identifier = instruction["calloffset"]
            if identifier not in identifiers:
                printError(PALMAT, source, instruction, \
                           "Implementation error, identifier %s not found" \
                           % identifier)
                return None
            scope["returnoffset"] = instructionIndex;
            instructionIndex = identifiers[identifier]["label"][1]
        elif "returnoffset" in instruction:
            i = instruction["returnoffset"]
            if i == -1:
                i = scopeNumber
                while i != None and "returnoffset" not in scopes[i]:
                    i = scopes[i]["parent"]
                if i == None:
                    printError(PALMAT, source, instruction, \
                               "Implementation error, cannot find returnoffset.")
                    return None
            scope = scopes[i]
            if "returnoffset" in scope:
                instructionIndex = scope.pop("returnoffset")
                scopeNumber = i
            else:
                printError(PALMAT, source, instruction, \
                           "Implementation error, returnoffset not in scope.")
                for key in sorted(scope):
                    print("\t%s:" % key, scope[key])
                return None
        elif "case" in instruction:
            if len(computationStack) < 1:
                printError(PALMAT, source, instruction, \
                           "Computation stack too short in CASE.")
                return None
            prefix = instruction["case"]
            caseNumber = computationStack.pop()
            if isinstance(caseNumber, float):
                caseNumber = hround(caseNumber)
            if not isinstance(caseNumber, int):
                printError(PALMAT, source, instruction, "Non-numeric CASE key.")
                return None
            if caseNumber >= 1:
                identifier = "^%s%d^" % (prefix, caseNumber)
                if identifier not in identifiers:
                    identifier = "^" + prefix + "else^"
            else:
                identifier = "^" + prefix + "else^"
            if identifier not in identifiers:
                identifier = "^" + prefix + "exit^"
            if identifier not in identifiers:
                printError(PALMAT, source, instruction, \
                    "Implementation error, no accessible labels in CASE")
                return None
            instructionIndex = identifiers[identifier]["label"][1]
        elif "iffalse" in instruction:
            value, dummy = parseBitArray(computationStack.pop())
            if (value & 1) == 0:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, source, scopeNumber, instruction, "iffalse")
                scope = scopes[scopeNumber]
        elif "iftrue" in instruction:
            value, dummy = parseBitArray(computationStack.pop())
            if (value & 1) != 0:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, source, scopeNumber, instruction, "iftrue")
                scope = scopes[scopeNumber]
        elif "noop" in instruction:
            pass # Nothing to do!
        elif "run" in instruction:
            si, identifier = instruction["run"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                printError(PALMAT, source, instruction, \
                           "Target of RUN not found: " + identifier)
                return None
            if "program" not in attributes:
                printError(PALMAT, source, instruction, \
                           "RUN target is not a PROGRAM: " + identifier)
                return None
            scopeNumber = attributes["scope"]
            instructionIndex = 0;
            scope = scopes[scopeNumber]
        elif "call" in instruction:
            si, identifier = instruction["call"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                printError(PALMAT, source, instruction, \
                           "Target of CALL not found: " + identifier)
                return None
            if "function" not in attributes and "procedure" not in attributes:
                printError(PALMAT, source, instruction, \
                           "CALL to neither a FUNCTION nor PROCEDURE: " \
                           + identifier)
                return None
            si = attributes["scope"]
            s = scopes[si]
            if "return" in s:
                printError(PALMAT, source, identifier, \
                           "Recursion in subroutine %s not allowed." \
                           % identifier[1:-1])
                return None
            # The return address.
            returnAddress = (scopeNumber, instructionIndex)
            #computationStack.append((scopeNumber, instructionIndex))
            # Transfer control.
            scopeNumber = si
            instructionIndex = 0
            scope = s
            if "assignments" in instruction:
                scope["assignments"] = copy.deepcopy(instruction["assignments"])
            scope["return"] = returnAddress
        elif "return" in instruction:
            enclosure = scope
            while enclosure != None:
                if "return" in enclosure:
                    scopeNumber, instructionIndex = enclosure["return"]
                    enclosure.pop("return")
                    if "assignments" in enclosure:
                        enclosure.pop("assignments")
                    break
                enclosure = PALMAT["scopes"][enclosure["parent"]]
            if enclosure == None:
                printError(PALMAT, source, instruction, \
                           "Implementation error, no return address")
                return None
            #scopeNumber, instructionIndex = computationStack.pop(-stackPos)
            scope = scopes[scopeNumber]
        elif "halt" in instruction:
            # Ends emulation.
            printError(PALMAT, source, None, "Normal program termination")
            return None
        elif "automatics" in instruction:
            for identifier in identifiers:
                attributes = identifiers[identifier]
                if "initial" in attributes and "automatic" in attributes:
                    attributes["value"] = copy.deepcopy(attributes["initial"])
        elif "partition" in instruction:
            computationStack.append({"semicolon"})
        else:
            printError(PALMAT, source, instruction, \
                       "Implementation error, unknown PALMAT: " + instruction)
            return None
    if trace:
        print("\tTRACE:  ", computationStack, \
              " (%d,%d):" % (scopeNumber, instructionIndex), "(end)")
    return computationStack
