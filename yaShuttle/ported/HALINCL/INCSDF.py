#!/usr/bin/env python
"""
   Access:     Public Domain, no restrictions believed to exist.
   Filename:   INCSDF.py
   Purpose:    Part of the HAL/S-FC compiler.
   Contact:    The Virtual AGC Project (www.ibiblio.org/apollo).
   History:    2023-10-28 RSB  Created just a stub, which at present will never
                               be called.
"""

from xplBuiltins import *
import g
import HALINCL.CERRDECL as d
import HALINCL.COMMON as h
from ERROR import ERROR

# ROUTINE TO INCLUDE VARIABLES FROM AN EXTERNAL UNIT'S SDF

def INCLUDE_SDF(UNIT, INCL_FLAGS):
    
    return

    '''
    #DECLARE UNIT CHARACTER,
    #INCL_FLAGS BIT(8);
    #DECLARE  (NEXT_SYMBOL,CUR_SYMBOL,LAST_COMSUB_SYMB,UNIT_SYMBp) BIT(16),
    #ACCESS_COMPOOL BIT(1) INITIAL(g.FALSE),
    #TEMP_PTR FIXED,
    #(g.I,g.J) BIT(16),
    #SDF_NAME CHARACTER,
    #(BLK_TYPE, pBLK_SYMBS, pSDF_PAGES) BIT(16);
    #DECLARE  FLAGS FIXED,
    #REV BIT(16),
    #CAT BIT(16),
    #REVSTR CHARACTER,
    #pBLK_FLAGS LITERALLY '3';
    ARRAY    IN_BLK_FLAG(pBLK_FLAGS) BIT(8) 
    CONSTANT(0x80,0x40,0x20,0x10),
    OUT_BLK_FLAG(pBLK_FLAGS) FIXED
    CONSTANT(g.REENTRANT_FLAG,g.EXCLUSIVE_FLAG,g.ACCESS_FLAG,g.RIGID_FLAG);
    # DECLARATIONS FOR %COPY CHECKING
    #DECLARE  CSECT_LENGTH(2) BIT(16), # LENGTHS OF APPROPRIATE CSECTS
    #PRIMARY_LENGTH LITERALLY 'CSECT_LENGTH(0)',
    #REMOTE_LENGTH  LITERALLY 'CSECT_LENGTH(1)',
    #SDF_VAR_CLASS LITERALLY '1';
    # INDICATES A VARIABLE
    #DECLARE  MAKESTRING(2) LITERALLY 'STRING(SHL(%1%-1,24)+%2%)',
    #NEW_STRING(1) LITERALLY 'SUBSTR(X1 + %1%,1)',
    #INCLUDABLE_VERSIONp LITERALLY '26';
    #DECLARE SDF_VERSIONp BIT(16);
    #-CR11120 ----------------- #DFLAG -------------------------
    ##DFLAG - MUST LOOK AT SDF ROOT DATA_REMOTE FLAG TO TELL IF
    ##DFLAG - MODULE WE'RE INCLUDING GOES REMOTE IN PRELINKER.
    #DECLARE SDF_ROOT_FLAGS BIT(16);
    #-----------------------------------------------------------
    # SDF DECLARES
    BASED SDF_B BIT(8), SDF_H BIT(16), SDF_F FIXED;
    #DECLARE  # FIELDS WITHIN AN SDF SYMBOL NODE
    #SDF_SYMB_FLAGS        LITERALLY 'SDF_F(2)',
    #SDF_SYMB_LINK1        LITERALLY 'SDF_H(SDF_B(5)/2+1)',
    #SDF_SYMB_LINK2        LITERALLY 'SDF_H(SDF_B(5)/2+2)',
    SDF_SYMB_DECLARE_LINK LITERALLY 'SDF_H(-5)',
    #SDF_SYMB_ADDR         LITERALLY '(SDF_F(3)&0xFFFFFF)',
    #SDF_SYMB_EXTENT       LITERALLY '(SDF_F(5)&0x00FFFFFF)',
    #SDF_SYMB_LOCKp        LITERALLY 'SDF_B(20)',
    #SDF_SYMB_ARRAY_OFF    LITERALLY 'SDF_B(4)',
    #SDF_SYMB_ARRAY(1)     LITERALLY 'SDF_H(SHR(SDF_B(4),1)+1+%1%)',
    #SDF_SYMB_NDIM         LITERALLY 'SDF_H(SHR(SDF_B(4),1))',
    #SDF_SYMB_LIT_PTR      LITERALLY 'SDF_F(5)',
    #SDF_SYMB_TYPE         LITERALLY 'SDF_B(7)',
    #SDF_SYMB_VAR_LENGTH   LITERALLY 'SDF_H(9)',
    #SDF_SYMB_CLASS        LITERALLY 'SDF_B(6)',
    #SDF_SYMB_REPL_PTR     LITERALLY 'SDF_F(5)';
    #DECLARE  # DEFINE SYMB_FLAGS BITS
    #SDF_MISC_NAME_FLAG   LITERALLY '0x00000010',
    #SDF_EXCLUSIVE_FLAG   LITERALLY '0x00000040',
    #SDF_EXTERNAL_FLAG    LITERALLY '0x00000800',
    #SDF_LIT_FLAG         LITERALLY '0x00001000',
    #SDF_RIGID_FLAG       LITERALLY '0x00002000',
    #SDF_INIT_FLAG        LITERALLY '0x00004000',
    #SDF_REMOTE_FLAG      LITERALLY '0x00010000',
    #SDF_LOCK_FLAG        LITERALLY '0x00020000',
    #SDF_LATCH_FLAG       LITERALLY '0x00040000',
    #SDF_ACCESS_FLAG      LITERALLY '0x00100000',
    #SDF_CONSTANT_FLAG    LITERALLY '0x00200000',
    #SDF_DENSE_FLAG       LITERALLY '0x00400000',
    #SDF_REENTRANT_FLAG   LITERALLY '0x00800000',
    #SDF_TPL_HDR_FLAG     LITERALLY '0x02000000',
    #SDF_NAME_FLAG        LITERALLY '0x04000000',
    #SDF_AUTO_FLAG        LITERALLY '0x08000000',
    #SDF_TEMPORARY_FLAG   LITERALLY '0x10000000',
    #SDF_ASSIGN_PARM_FLAG LITERALLY '0x20000000',
    #SDF_INPUT_PARM_FLAG  LITERALLY '0x40000000',
    #SDF_PARM_FLAGS LITERALLY
    #'(SDF_INPUT_PARM_FLAG|SDF_ASSIGN_PARM_FLAG)';
    #DECLARE  # FIELDS AND VALUES WITHIN THE SDF DIRECTORY ROOT
    #SDF_ROOT_COMSUB_END LITERALLY 'SDF_H(59)',
    #SDF_FC_FLAG         LITERALLY '0x1000',
    #SDF_ROOT_LAST_PAGE  LITERALLY 'SDF_H(1)',
    #SDF_ROOT_UNIT_SYMBp LITERALLY 'SDF_H(14)',
    #SDF_ROOT_UNIT_BLKp  LITERALLY 'SDF_H(44)',
    #SDF_ROOT_COMPILER   LITERALLY 'MAKESTRING(4,SDFPKG_LOC_ADDR+140)';
    #DECLARE  # FIELDS WITHIN AN SDF REPLACE CELL
    #SDF_REPL_ARG_CNT     LITERALLY '(-SDF_H(2)-1)',
    #SDF_REPL_ARG_NAME(1) LITERALLY
    #'STRING(SDFPKG_LOC_ADDR+SDF_F(1+%1%))',
    #SDF_REPL_NEXT_PTR    LITERALLY 'SDF_F(0)',
    #SDF_REPL_pBYTES      LITERALLY 'SDF_H(2)',
    #SDF_REPL_TEXT_ADDR   LITERALLY 'SDFPKG_LOC_ADDR+6';
    #DECLARE  # FIELDS WITHIN AN SDF BLOCK DATA CELL
    #SDF_BLK_FIRST_SYMBp  LITERALLY 'SDF_H(16)',
    #SDF_BLK_LAST_SYMBp   LITERALLY 'SDF_H(17)',
    #SDF_BLK_VERSIONp     LITERALLY 'SDF_B(25)',
    #SDF_BLK_FLAGS        LITERALLY 'SDF_B(24)',
    #SDF_BLK_CATEGORY     LITERALLY 'SDF_B(30)';
    # DECLARES FOR SDFPKG
    #DECLARE  COMMTABL(29) FIXED;
    #BASED    COMMTABL_BYTE BIT(8),
    #COMMTABL_HALFWORD BIT(16),
    #COMMTABL_FULLWORD FIXED;
    #DECLARE  COMMTABL_ADDR FIXED;
    #DECLARE  SDFPKG_APGAREA       LITERALLY 'COMMTABL_FULLWORD(0)',
    #SDFPKG_AFCBAREA      LITERALLY 'COMMTABL_FULLWORD(1)',
    #SDFPKG_NPAGES        LITERALLY 'COMMTABL_HALFWORD(4)',
    #SDFPKG_NBYTES        LITERALLY 'COMMTABL_HALFWORD(5)',
    #SDFPKG_MISC          LITERALLY 'COMMTABL_HALFWORD(6)',
    #SDFPKG_CRETURN       LITERALLY 'COMMTABL_HALFWORD(7)',
    #SDFPKG_BLKNO         LITERALLY 'COMMTABL_HALFWORD(8)',
    #SDFPKG_SYMBNO        LITERALLY 'COMMTABL_HALFWORD(9)',
    #SDFPKG_STMTNO        LITERALLY 'COMMTABL_HALFWORD(10)',
    #SDFPKG_BLKNLEN       LITERALLY 'COMMTABL_BYTE(22)',
    #SDFPKG_SYMBNLEN      LITERALLY 'COMMTABL_BYTE(23)',
    #SDFPKG_LOC_PTR       LITERALLY 'COMMTABL_FULLWORD(6)',
    #SDFPKG_LOC_ADDR      LITERALLY 'COMMTABL_FULLWORD(7)',
    #SDFPKG_SDFNAM_ADDR   LITERALLY 'COMMTABL_ADDR+32',
    #SDFPKG_SDFNAM        LITERALLY 'MAKESTRING(8,SDFPKG_SDFNAM_ADDR)',
    #SDFPKG_CSECTNAM_ADDR LITERALLY 'COMMTABL_ADDR+40',
    #SDFPKG_CSECTNAM      LITERALLY 'MAKESTRING(8,SDFPKG_CSECTNAM_ADDR)',
    #SDFPKG_SREFNO_ADDR   LITERALLY 'COMMTABL_ADDR+48',
    #SDFPKG_SREFNO        LITERALLY 'MAKESTRING(6,SDFPKG_SREFNO_ADDR)',
    #SDFPKG_INCLCNT       LITERALLY 'COMMTABL_HALFWORD(27)',
    #SDFPKG_BLKNAM_ADDR   LITERALLY 'COMMTABL_ADDR+56',
    #SDFPKG_BLKNAM        LITERALLY
    #'MAKESTRING(SDFPKG_BLKNLEN,SDFPKG_BLKNAM_ADDR)',
    #SDFPKG_SYMBNAM_ADDR  LITERALLY 'COMMTABL_ADDR+88',
    #SDFPKG_SYMBNAM       LITERALLY
    #'MAKESTRING(SDFPKG_SYMBNLEN,SDFPKG_SYMBNAM_ADDR)',
    #SDFPKG_PAGES_LEFT    BIT(16);
    BASED  PGING   RECORD:
    PAGEADDR   (420)    FIXED,
#END
BASED FORFCB   RECORD:
FCBADDR   (128)  FIXED,
#END
# SDFPKG CALLS
#DECLARE _SDFPKG(1) LITERALLY 'CALL MONITOR(22,%1%)',
#SET_SDF_BASED LITERALLY 'COREWORD(ADDR(SDF_B)),COREWORD(ADDR(SDF_H)),
#COREWORD(ADDR(SDF_F))=SDFPKG_LOC_ADDR;',
#LOCATE_SDF_SYMBp(1) LITERALLY 'DO;SDFPKG_SYMBNO=%1%;CALL MONITOR(22,
#9);SET_SDF_BASED;END;',
#LOCATE_SDF_PTR(1) LITERALLY 'DO;SDFPKG_LOC_PTR=%1%;CALL MONITOR(22,
#5);SET_SDF_BASED;END;',
#LOCATE_SDF_SYMBNAME(1) LITERALLY 'DO;SDFPKG_SYMBNLEN=LENGTH(%1%);
CALL MOVE(SDFPKG_SYMBNLEN,%1%,SDFPKG_SYMBNAM_ADDR);CALL MONITOR(22,13);
SET_SDF_BASED;END;',
LOCATE_SDF_ROOT LITERALLY
'DO;CALL MONITOR(22,7);SET_SDF_BASED;END;',
LOCATE_SDF_BLOCKp(1) LITERALLY 'DO;SDFPKG_BLKNO=%1%;CALL MONITOR(22,
8);SET_SDF_BASED;END;',
TERMINATE_SDFPKG LITERALLY 'DO;CALL MONITOR(22,1);SDF_OPEN=FALSE;END
';

def FIND(NAME):
    # FIND SYMBOL WITH GIVEN NAME, RETURNING ITS INDEX OR 0 IF NOT FOUND
    #DECLARE NAME CHARACTER;
    #DECLARE g.I BIT(16);
    g.NAME_HASH = HASH(NAME, g.SYT_HASHSIZE);
    g.I = g.SYT_HASHSTART[g.NAME_HASH];
    while g.I > 0:
        if NAME == g.SYT_NAME(g.I): return g.I;
        g.I = g.SYT_HASHLINK(g.I);
    #END
    return 0;
# END FIND;

def DUPLICATE_NAME(NAME):
    # CHECK TO SEE IF NAME ALREADY EXISTS IN THE SYMBOL TABLE IN A FORM
    # THAT IMPLIES A MULTIPLE DECLARATION ERROR.  SET STRUC. FLAGS
    #DECLARE NAME CHARACTER;
    #DECLARE g.I BIT(16);
    g.NAME_HASH = HASH(NAME, g.SYT_HASHSIZE);
    g.I = g.SYT_HASHSTART[g.NAME_HASH];
    while g.I > 0:
        if NAME == g.SYT_NAME(g.I): #DO
            if g.I < g.PROCMARK: return g.FALSE;
            if ^g.BUILDING_TEMPLATE: #DO
                if g.SYT_CLASS(g.I) < g.TEMPLATE_CLASS:
                return g.TRUE;
                else: SET_DUPL_FLAG(g.I);
            #END
            else: #DO
                g.SYT_FLAGS(g.REF_ID_LOC) = g.SYT_FLAGS(g.REF_ID_LOC) | g.DUPL_FLAG;
                if g.SYT_CLASS(g.I) >= g.TEMPLATE_CLASS:
                SET_DUPL_FLAG(g.I);
            #END
        #END
        g.I = g.SYT_HASHLINK(g.I);
    #END
    return g.FALSE;
# END DUPLICATE_NAME;

def SET_SYT_FLAGS(NDX):
    # SET SYT_FLAGS BASED ON SDF_SYMB_FLAGS
    #DECLARE NDX BIT(16);
    #DECLARE g.I BIT(16);
    #DECLARE (SDFFLAGS,FLAGS) FIXED;
    #DECLARE pFLAGS LITERALLY '13',
    #IN_FLAG(pFLAGS-1) FIXED CONSTANT(SDF_EXCLUSIVE_FLAG,SDF_RIGID_FLAG,
    #SDF_INIT_FLAG,SDF_REMOTE_FLAG,SDF_LOCK_FLAG,SDF_LATCH_FLAG,
    #SDF_ACCESS_FLAG,SDF_CONSTANT_FLAG,SDF_NAME_FLAG,SDF_AUTO_FLAG,
    #SDF_TEMPORARY_FLAG,SDF_ASSIGN_PARM_FLAG,SDF_INPUT_PARM_FLAG),
    #OUT_FLAG(pFLAGS-1) FIXED CONSTANT(g.EXCLUSIVE_FLAG,g.RIGID_FLAG,
    #g.INIT_FLAG,g.REMOTE_FLAG,g.LOCK_FLAG,g.LATCHED_FLAG,
    #g.ACCESS_FLAG,g.CONSTANT_FLAG,g.NAME_FLAG,g.AUTO_FLAG,
    #g.TEMPORARY_FLAG,g.ASSIGN_PARM,g.INPUT_PARM);
    SDFFLAGS = SDF_SYMB_FLAGS;
    #-------------------------------------------------------------
    #----------------- DANNY STRAUSS DR102949 --------------------
    # IF A 16-BIT NAME VARIABLE WAS INITIALIZED TO A NON-REMOTE
    # VARIABLE IN A REMOTELY INCLUDED COMPOOL, IT'S NOW INVALID
    SDF_INITIAL_CHECK: PROCEDURE;
        if (INCL_FLAGS & INCL_REMOTE_FLAG) != 0  # REMOTE COMPOOL
        # IF VARIABLE IS REFERENCED BY A NAME VARIABLE
: if (SDFFLAGS & SDF_MISC_NAME_FLAG) != 0
: if g.SYT_TYPE(NDX) != g.TEMPL_NAME # NOT A STRUC TEMPL
: if (SDFFLAGS & SDF_REMOTE_FLAG) = 0 # NON-REMOTE
:  #DO
            ERROR(d.CLASS_DI,21);
            #OUTPUT = 'DANNY>>> CUR_SYM= ' + CUR_SYMBOL;
        #END
    # END SDF_INITIAL_CHECK;
    SDF_INITIAL_CHECK;
    #-------------------------------------------------------------
    if g.CONTROL[0x3]: OUTPUT == 'SET_SYT_FLAGS: SDFFLAGS = ' + 
    HEX(SDFFLAGS, 8) + ' INCL_FLAGS = ' + HEX(INCL_FLAGS, 2);
    if ACCESS_COMPOOL: FLAGS = g.READ_ACCESS_FLAG;
    else: FLAGS = 0;
    if (SDFFLAGS & SDF_DENSE_FLAG) != 0:
    FLAGS = FLAGS | g.DENSE_FLAG;
    else: FLAGS = FLAGS | g.ALIGNED_FLAG;
    #********** FIX FOR DR100579, ROBERT HANDLEY 12/88  ************
    # SET THE VARIABLE'S REMOTE FLAG IF THE COMPOOL IS INCLUDED
    REMOTELY. EXCLUDE STRUCTURE TEMPLATE SYMBOL NAMES AND NAME
    VARIABLES.*/
    #------------------- DANNY STRAUSS DR100579 ------------------------
    # INCLUDED_REMOTE MEANS VARIABLE LIVES REMOTE ONLY BECAUSE
    # IT WAS INCLUDED REMOTE. (IT RESIDES IN #P, NOT IN #R)
    if (INCL_FLAGS & INCL_REMOTE_FLAG) != 0: # REMOTE COMPOOL
    if (g.SYT_CLASS(NDX) != g.TEMPLATE_CLASS): #DO
        # NOT A NAME VARIABLE & NOT INITIALLY DECLARED REMOTE
        if ((SDFFLAGS & SDF_NAME_FLAG) = 0) &
        ((SDFFLAGS & SDF_REMOTE_FLAG) = 0):
        FLAGS = FLAGS | g.REMOTE_FLAG | g.INCLUDED_REMOTE;
        # FOR NAME VARIABLES, SET THAT THEY NOW LIVE REMOTE
        if ((SDFFLAGS & SDF_NAME_FLAG) != 0):
        FLAGS = FLAGS | g.INCLUDED_REMOTE;
    #END
    #*************** END OF FIX FOR DR100579  **********************
    for g.I  in range(0, pFLAGS - 1 + 1):
        if (SDFFLAGS & IN_FLAG(g.I)) != 0:
        FLAGS = FLAGS | OUT_FLAG(g.I);
    #END
    g.SYT_FLAGS(NDX) = FLAGS;
    g.NAME_IMPLIED = ((FLAGS & g.NAME_FLAG) != 0);
    g.TEMPORARY_IMPLIED = ((FLAGS & g.TEMPORARY_FLAG) != 0);
    if g.CONTROL[0x3]: OUTPUT == 'SET_SYT_FLAGS:    FLAGS = ' + 
    HEX(FLAGS, 8);
    return;
# END SET_SYT_FLAGS;

def SET_TYPE_AND_LEN(NDX):
    # SET SYT_TYPE AND VAR_LENGTH FOR VARIABLES AND FUNCTIONS
    #DECLARE NDX BIT(16);
    #DECLARE g.TYPE BIT(16);
    ARRAY P1_TYPE(17) BIT(8) CONSTANT(0,g.BIT_TYPE,g.CHAR_TYPE,g.MAT_TYPE,#C13335
    g.VEC_TYPE,g.SCALAR_TYPE,g.INT_TYPE,0,0,g.BIT_TYPE,g.BIT_TYPE,g.MAT_TYPE,
    g.VEC_TYPE,g.SCALAR_TYPE,g.INT_TYPE,0,g.MAJ_STRUC,g.EVENT_TYPE);
    #DECLARE STRUC_NAME CHARACTER;
    g.SYT_TYPE(NDX), g.TYPE = P1_TYPE(SDF_SYMB_TYPE);
    if (g.TYPE >=g.MAT_TYPE) & (g.TYPE<=g.INT_TYPE): #DO
        if SDF_SYMB_TYPE > 8:
        g.SYT_FLAGS(NDX) = g.SYT_FLAGS(NDX) | g.DOUBLE_FLAG;
        else: g.SYT_FLAGS(NDX) = g.SYT_FLAGS(NDX) | g.SINGLE_FLAG;
    #END
    if (g.TYPE == g.CHAR_TYPE) | (g.TYPE == g.MAT_TYPE):
    g.VAR_LENGTH(NDX) = SDF_SYMB_VAR_LENGTH;
    elif (g.TYPE == g.BIT_TYPE) | (g.TYPE == g.VEC_TYPE):
    g.VAR_LENGTH(NDX) = SDF_SYMB_VAR_LENGTH & 0xFF;
    elif (g.TYPE == g.MAJ_STRUC) & (SDF_SYMB_VAR_LENGTH != 0): #DO
        TEMP_PTR = SDFPKG_LOC_PTR;
        LOCATE_SDF_SYMBp(SDF_SYMB_VAR_LENGTH);
        STRUC_NAME = NEW_STRING(SDFPKG_SYMBNAM);
        LOCATE_SDF_PTR(TEMP_PTR);
        g.STRUC_PTR = FIND(STRUC_NAME);
        if g.STRUC_PTR == 0: #DO
            ERROR(d.CLASS_DU, 5, SUBSTR(STRUC_NAME,1));
            g.STRUC_PTR = ENTER(STRUC_NAME, g.TEMPLATE_CLASS);
            g.SYT_TYPE(g.STRUC_PTR) = g.TEMPL_NAME;
            g.SYT_FLAGS(g.STRUC_PTR) = g.EVIL_FLAG;
            if g.BUILDING_TEMPLATE:
            g.SYT_FLAGS(g.REF_ID_LOC) = g.SYT_FLAGS(g.REF_ID_LOC) | g.EVIL_FLAG;
        #END
        g.STRUC_DIM = 0;
        # SO NO ARRAY CHECKS IN CHECK_STRUC_CONFLICT
        CHECK_STRUC_CONFLICTS;
        g.VAR_LENGTH(NDX) = g.STRUC_PTR;
        g.SYT_XREF(g.STRUC_PTR) = ENTER_XREF(g.SYT_XREF(g.STRUC_PTR), g.XREF_REF);
    #END
    if g.CONTROL[0x3]:
    OUTPUT = 'SET_TYPE_AND_LEN: TYPE = ' + g.TYPE + ', LENGTH = ' + 
    g.VAR_LENGTH(NDX);
    return;
# END SET_TYPE_AND_LEN;

def ENTER_SDF_VAR(CLASS):
    # ENTER A VARIABLE OR FUNCTION FROM AN SDF INTO THE SYMBOL TABLE
    #DECLARE g.CLASS BIT(16);
    #DECLARE g.I BIT(16);
    if DUPLICATE_NAME(g.BCD): #DO
        ERROR(d.CLASS_PM, 1, g.BCD);
        return;
    #END
    g.ID_LOC = ENTER(g.BCD, g.CLASS);
    if g.CONTROL[0x3]:
    OUTPUT = 'ENTER_SDF_VAR: ID_LOC = ' + g.ID_LOC + ', NAME = ' + g.BCD + 
    ', CLASS = ' + g.CLASS;
    SET_SYT_FLAGS(g.ID_LOC);
    SET_TYPE_AND_LEN(g.ID_LOC);
    g.SYT_ADDR(g.ID_LOC) = SDF_SYMB_ADDR;
    SYT_LOCKp(g.ID_LOC) = SDF_SYMB_LOCKp;
    if SDF_SYMB_ARRAY_OFF == 0: g.SYT_ARRAY(g.ID_LOC) = 0;
    elif g.SYT_TYPE(g.ID_LOC) == g.MAJ_STRUC: #DO
        g.I = SDF_SYMB_ARRAY(0);
        if g.I < 0: g.SYT_ARRAY(g.ID_LOC) = -g.ID_LOC;
        elif g.I == 1: g.SYT_ARRAY(g.ID_LOC) = 0;
        else: g.SYT_ARRAY(g.ID_LOC) = g.I;
    #END
    else: #DO
        # ENTER ARRAY VALUES
        g.N_DIM = SDF_SYMB_NDIM;
        for g.I  in range(0, g.N_DIM - 1 + 1):
            g.S_ARRAY[g.I] = SDF_SYMB_ARRAY(g.I);
        #END
        if g.S_ARRAY[0] < 0: g.S_ARRAY[0] = -g.ID_LOC;
        ENTER_DIMS;
        g.SYT_FLAGS(g.ID_LOC) = g.SYT_FLAGS(g.ID_LOC) | g.ARRAY_FLAG;
    #END
    if (SDF_SYMB_FLAGS & SDF_LIT_FLAG) != 0: #DO
        # ENTER LITERAL
        TEMP_PTR = SDFPKG_LOC_PTR;
        LOCATE_SDF_PTR(SDF_SYMB_LIT_PTR);
        if g.SYT_TYPE(g.ID_LOC) == g.CHAR_TYPE:
        SAVE_LITERAL(0,MAKESTRING(SDF_B + 1, SDFPKG_LOC_ADDR + 1));
        # ARITH. LIT
        else: SAVE_LITERAL(1, SDFPKG_LOC_ADDR,0,1);
        #MOD-DR109083
        g.SYT_PTR(g.ID_LOC) = -g.LIT_TOP;
        LOCATE_SDF_PTR(TEMP_PTR);
    #END
    return;
# END ENTER_SDF_VAR;

def ENTER_SDF_LABEL(CLASS):
    # ENTER A LABEL INTO THE SYMBOL TABLE FROM AN SDF
    # COMPILATION UNIT IS TREATED SEPARATELY IN INCLUDE_SDF PROPER
    #DECLARE g.CLASS BIT(16);
    ARRAY   P1_TYPE(7) BIT(8)                            #CR13335
    CONSTANT(0,g.PROG_LABEL,g.PROC_LABEL,0,g.COMPOOL_LABEL, 
    g.TASK_LABEL,0,0);
    if DUPLICATE_NAME(g.BCD):
    #COMPOOL CLOSE LABELS CAN BE DUPLICATED
    if SDF_SYMB_TYPE != 7: 
    ERROR(d.CLASS_PL, 2, g.BCD);
    g.ID_LOC = ENTER(g.BCD, g.CLASS);
    if g.CONTROL[0x3]:
    OUTPUT = 'ENTER_SDF_LABEL: ID_LOC = ' + g.ID_LOC + ', NAME = ' + 
    g.BCD + ', CLASS = ' + g.CLASS;
    SET_SYT_FLAGS(g.ID_LOC);
    g.SYT_TYPE(g.ID_LOC) = P1_TYPE(SDF_SYMB_TYPE);
    g.SYT_ADDR(g.ID_LOC) = SDF_SYMB_ADDR;
    return;
# END ENTER_SDF_LABEL;

def ENTER_SDF_TEMPLATE():
    # ENTER A TEMPLATE FROM AN SDF
    ARRAY   FATHER(g.MAX_STRUC_LEVEL) BIT(16);
    #DECLARE g.CLASS BIT(16), g.LEVEL BIT(16);
    if DUPLICATE_NAME(g.BCD):
    ERROR(d.CLASS_PM, 2, SUBSTR(g.BCD,1));
    g.REF_ID_LOC = ENTER(g.BCD, g.TEMPLATE_CLASS);
    if g.CONTROL[0x3]:
    OUTPUT = 'ENTER_SDF_TEMPLATE: ID_LOC = ' + g.REF_ID_LOC + 
    ', NAME = ' + g.BCD;
    g.SYT_TYPE(g.REF_ID_LOC) = g.TEMPL_NAME;
    SET_SYT_FLAGS(g.REF_ID_LOC);
    if (SDF_SYMB_FLAGS & SDF_MISC_NAME_FLAG) != 0:
    g.SYT_FLAGS(g.REF_ID_LOC) = g.SYT_FLAGS(g.REF_ID_LOC) | g.MISC_NAME_FLAG;
    g.STRUC_SIZE = 0;
    g.BUILDING_TEMPLATE = g.TRUE;
    g.LEVEL = 0;
    FATHER(0) = g.REF_ID_LOC;
    g.SYT_LINK1(g.REF_ID_LOC) = g.REF_ID_LOC + 1;
    WALK: DO UNTIL g.LEVEL < 0;
        LOCATE_SDF_SYMBp(NEXT_SYMBOL);
        CUR_SYMBOL = NEXT_SYMBOL;
        NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
        g.BCD = NEW_STRING(SDFPKG_SYMBNAM);
        g.CLASS = SDF_SYMB_CLASS;
        if g.CLASS == 4: ENTER_SDF_VAR(g.TEMPLATE_CLASS);
        elif g.CLASS == 5: ENTER_SDF_LABEL(g.TPL_LAB_CLASS);
        else: ENTER_SDF_VAR(g.TPL_FUNC_CLASS);
        if SDF_SYMB_LINK1 != 0: #DO
            if SDF_SYMB_LINK2 < 0: g.SYT_LINK2(g.ID_LOC) = -FATHER(g.LEVEL);
            else: g.SYT_LINK2(g.ID_LOC) = 0;
            # TO BE FILLED IN LATER
            g.LEVEL = g.LEVEL + 1;
            FATHER(g.LEVEL) = g.ID_LOC;
            g.SYT_LINK1(g.ID_LOC) = g.ID_LOC + 1;
        #END
        else: #DO
            g.SYT_LINK1(g.ID_LOC) = 0;
            if SDF_SYMB_LINK2 > 0: g.SYT_LINK2(g.ID_LOC) = g.ID_LOC + 1;
            else: #DO
                g.SYT_LINK2(g.ID_LOC) = -FATHER(g.LEVEL);
                while g.SYT_LINK2(FATHER(g.LEVEL)) < 0:
                    g.LEVEL = g.LEVEL - 1;
                #END
                if g.LEVEL > 0: #DO
                    g.SYT_LINK2(FATHER(g.LEVEL)) = g.ID_LOC + 1;
                    if g.CONTROL[0x3]:
                    OUTPUT = 'ENTER_SDF_TEMPLATE: LINK2(' + FATHER(g.LEVEL) + 
                    ') = ' + g.ID_LOC + 1;
                #END
                g.LEVEL = g.LEVEL - 1;
            #END
            g.STRUC_SIZE = g.STRUC_SIZE + ICQ_TERMp(g.ID_LOC) * ICQ_ARRAYp(g.ID_LOC);
        #END
        if g.CONTROL[0x3]:
        OUTPUT = 'ENTER_SDF_TEMPLATE: LINK1 = ' + g.SYT_LINK1(g.ID_LOC) + 
        ', LINK2 = ' + g.SYT_LINK2(g.ID_LOC);
    # END WALK;
    g.BUILDING_TEMPLATE = g.FALSE;
    g.SYT_ADDR(g.REF_ID_LOC) = g.STRUC_SIZE;
    return;
# END ENTER_SDF_TEMPLATE;

def ENTER_SDF_MACRO():
    # ENTER A REPLACE MACRO FROM AN SDF
    #DECLARE MACRO_NDX BIT(16), pBYTES BIT(16);
    #DECLARE g.I BIT(16);
    if DUPLICATE_NAME(g.BCD): #DO
        ERROR(d.CLASS_PM, 1, g.BCD);
        return;
    #END
    MACRO_NDX = ENTER(g.BCD, g.REPL_CLASS);
    if g.CONTROL[0x3]:
    OUTPUT = 'ENTER_SDF_MACRO: ID_LOC = ' + MACRO_NDX + ', MACRO = ' + 
    g.BCD;
    TEMP_PTR = SDFPKG_LOC_PTR;
    LOCATE_SDF_PTR(SDF_SYMB_REPL_PTR);
    g.MACRO_ARG_COUNT = SDF_REPL_ARG_CNT;
    for g.I  in range(1, g.MACRO_ARG_COUNT + 1):
        g.BCD = NEW_STRING(SDF_REPL_ARG_NAME(g.I));
        g.ID_LOC = ENTER(g.BCD, g.REPL_ARG_CLASS);
        if g.CONTROL[0x3]:
        OUTPUT = 'ENTER_SDF_MACRO: ID_LOC = ' + g.ID_LOC + 
        ', ARG = ' + g.BCD;
        g.SYT_FLAGS(g.ID_LOC) = g.INACTIVE_FLAG;
    #END
    g.VAR_LENGTH(MACRO_NDX) = g.MACRO_ARG_COUNT;
    g.START_POINT, g.SYT_ADDR(MACRO_NDX) = g.FIRST_FREE;
    MOVE_TEXT:
    while SDF_REPL_NEXT_PTR != 0:
        LOCATE_SDF_PTR(SDF_REPL_NEXT_PTR);
        pBYTES = SDF_REPL_pBYTES;
        for g.I in range(1, pBYTES + 1):
            NEXT_ELEMENT(MACRO_TEXTS);
        #END
        MOVE(pBYTES, SDF_REPL_TEXT_ADDR, ADDR(g.MACRO_TEXTS[g.FIRST_FREE]));
        g.FIRST_FREE = g.FIRST_FREE + pBYTES;
    #END
    FINISH_MACRO_TEXT;
    g.EXTENT(MACRO_NDX) = g.REPLACE_TEXT_PTR;
    LOCATE_SDF_PTR(TEMP_PTR);
    return;
# END ENTER_SDF_MACRO;

def ENTER_SDF_THING():
    # ENTERS LAST SDF VARIABLE LOCATED INTO THE SYMBOL TABLE BY CALLING THE
    # APPROPRIATE ROUTINE
    if g.CONTROL[0x3]: OUTPUT == 'ENTER_SDF_THING: ENTERED';
    g.BCD = NEW_STRING(SDFPKG_SYMBNAM);
    DO CASE SDF_SYMB_CLASS;
        ;
        # NOT USED
        ENTER_SDF_VAR(g.VAR_CLASS);
        # SDF VARIABLE CLASS
        #DO
            #SDF LABEL CLASS
            if SDF_SYMB_TYPE == 9: ENTER_SDF_MACRO;
            elif SDF_SYMB_TYPE != 8: ENTER_SDF_LABEL(g.LABEL_CLASS);
        #END
        ENTER_SDF_VAR(g.FUNC_CLASS);
        # SDF FUNCTION CLASS
        #DO
            # SDF TEMPLATE CLASS
            if (SDF_SYMB_FLAGS & SDF_TPL_HDR_FLAG) != 0:
            ENTER_SDF_TEMPLATE;
            else: ERROR(d.CLASS_XI, 8, g.BCD);
        #END
        ERROR(d.CLASS_XI, 8, g.BCD);
        # SDF TEMPLATE LABEL CLASS
        ERROR(d.CLASS_XI, 8, g.BCD);
        # SDF TEMPLATE FUNCTION
    #END
    return;
# END ENTER_SDF_THING;

def ENTER_COMSUB_ARGS():
    # LOGIC TO ENTER APPROPRIATE STUFF AND THEN ARGUMENTS FOR COMSUBS
    #DECLARE SAVE_FIRST BIT(16);
    if g.CONTROL[0x3]: OUTPUT == 'ENTER_COMSUB_ARGS: ENTERED';
    # PASS OVER PARAMETERS AND ENTER TEMPLATES, IF ANY
    SAVE_FIRST = NEXT_SYMBOL;
    DO UNTIL CUR_SYMBOL = LAST_COMSUB_SYMB;
        CUR_SYMBOL = NEXT_SYMBOL;
        LOCATE_SDF_SYMBp(CUR_SYMBOL);
        NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
        if (SDF_SYMB_FLAGS & SDF_PARM_FLAGS) == 0: #DO
            g.BCD = NEW_STRING(SDFPKG_SYMBNAM);
            if BYTE(g.BCD) == BYTE(' '):
            ENTER_SDF_TEMPLATE;
        #END
    #END
    # NOW ENTER PARAMETERS
    NEXT_SYMBOL = SAVE_FIRST;
    g.SYT_PTR(g.BLOCK_SYTREF[g.NEST]) = g.NDECSY + 1;
    # POINT TO FIRST ARG
    DO UNTIL CUR_SYMBOL = LAST_COMSUB_SYMB;
        CUR_SYMBOL = NEXT_SYMBOL;
        LOCATE_SDF_SYMBp(CUR_SYMBOL);
        NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
        if (SDF_SYMB_FLAGS & SDF_PARM_FLAGS) == 0: ESCAPE;
        ENTER_SDF_THING;
    #END
    return;
# END ENTER_COMSUB_ARGS;

def ENTER_COMPOOL_VARS():
    # ENTER VARIABLES FROM A COMPOOL SDF
    #DECLARE g.TEMP BIT(8);
    if g.CONTROL[0x3]: OUTPUT == 'ENTER_COMPOOL_VARS: ENTERED';
    ACCESS_COMPOOL = ((g.SYT_FLAGS(g.BLOCK_SYTREF[g.NEST]) & g.ACCESS_FLAG) != 0);
    g.PROCMARK = 1;
    # AUGMENT SDFPKG PAGING AREA IF NECESSARY/POSSIBLE
    g.TEMP=RECORD_ALLOC(SYM_TAB)-RECORD_USED(SYM_TAB);
    if g.TEMP <= pBLK_SYMBS: #DO
        g.TEMP = RECORD_USED(SYM_TAB) + pBLK_SYMBS;
        while RECORD_ALLOC(SYM_TAB)<=g.TEMP:
            NEEDMORE_SPACE(SYM_TAB);
        #END
    #END
    SDFPKG_NPAGES=(FREELIMIT-FREESTRING_MIN-g.FREEPOINT-32*pBLK_SYMBS)/1680;
    SDFPKG_NPAGES = MIN(SDFPKG_NPAGES, pSDF_PAGES - 3);
    SDFPKG_NPAGES = MIN(SDFPKG_NPAGES, SDFPKG_PAGES_LEFT);
    if SDFPKG_NPAGES > 0: #DO
        RECORD_CONSTANT(PGING,SDFPKG_NPAGES,g.UNMOVEABLE);
        SDFPKG_APGAREA=ADDR(PGING(0).PAGEADDR(0));
        SDFPKG_AFCBAREA, SDFPKG_NBYTES = 0;
        _SDFPKG(2);
        # AUGMENT PAGING AREA
    #END
    #ENTER EVERYTHING
    while NEXT_SYMBOL != 0:
        LOCATE_SDF_SYMBp(NEXT_SYMBOL);
        #CUR_SYMBOL = NEXT_SYMBOL;  DANNY STRAUSS
        NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
        if SDF_SYMB_CLASS == SDF_VAR_CLASS:  # A VARIABLE OR CONSTANT
        if (SDF_SYMB_FLAGS & SDF_LIT_FLAG) == 0: # ITS A VARIABLE
        CSECT_LENGTH((SDF_SYMB_FLAGS&SDF_REMOTE_FLAG)!=0) =
        MAX(CSECT_LENGTH((SDF_SYMB_FLAGS&SDF_REMOTE_FLAG)!=0),
        (SDF_SYMB_ADDR+SDF_SYMB_EXTENT));
        # INCLUDE_OK SETS C TO FIRST TOKEN AFTER INCLUDE OPTIONS
        if C != ':': ENTER_SDF_THING;
    #END
    # INCLUDE_OK SETS C TO FIRST TOKEN AFTER INCLUDE OPTIONS
    if C == ':': #DO
        # ENTER FROM A LIST
        g.SYT_FLAGS(g.BLOCK_SYTREF[g.NEST]) = g.SYT_FLAGS(g.BLOCK_SYTREF[g.NEST])
        | g.SDF_INCL_LIST;
        # FLAG AS PARTIAL INCLUDE
        D_CONTINUATION_OK = g.TRUE;
        C = D_TOKEN;
        LIST:    while C != '':
            if C == ',': #DO
                C = D_TOKEN;
                REPEAT LIST;
            #END
            if C == ';': ESCAPE LIST;
            if C == 'STRUCTURE':
            C = g.X1 + D_TOKEN;
            LOCATE_SDF_SYMBNAME(C);
            if SDFPKG_CRETURN == 0: #DO
                NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
                ENTER_SDF_THING;
            #END
            elif BYTE(C) == BYTE(' '):
            ERROR(d.CLASS_XI, 6, SUBSTR(C,1));
            else: ERROR(d.CLASS_XI, 7, C);
            C = D_TOKEN;
        # END LIST;
        D_CONTINUATION_OK = g.FALSE;
    #END
    ACCESS_COMPOOL = g.FALSE;
    return;
# END ENTER_COMPOOL_VARS;

def SDF_FOUND(SDF_FOUND: PROCEDURE BIT(1)):
    # ROUTINE THAT TRIES TO FIND APPLICABLE SDF FOR AN INCLUDE
    #DECLARE COMPILER CHARACTER,
    #DDBAD(1) BIT(1) INITIAL(g.FALSE,g.FALSE),
    #MISC_VAL(1) BIT(16) CONSTANT(8,12),
    #SOURCE_FLAG(1) BIT(8) CONSTANT(0x80,0x40),
    #OLD_SDF BIT(1), g.I BIT(16);
    #DECLARE REASON(1) CHARACTER CONSTANT(' TOO OLD', ' NOT FOUND');
    # ALLOCATE SPACE FOR SDFPKG
    COREWORD(ADDR(COMMTABL_BYTE)),
    COREWORD(ADDR(COMMTABL_HALFWORD)),
    COREWORD(ADDR(COMMTABL_FULLWORD)) = ADDR(COMMTABL);
    COMMTABL_ADDR = ADDR(COMMTABL);
    if RECORD_ALLOC(INIT_APGAREA) == 0: #DO
        SDFPKG_NPAGES = 3;
        # PAGING AREA SIZE
        RECORD_CONSTANT(INIT_APGAREA,0,g.UNMOVEABLE);
        RECORD_USED(INIT_APGAREA) = RECORD_ALLOC(INIT_APGAREA);
        SDFPKG_NBYTES = 512;
        # SIZE OF INITIAL FCB AREA
        RECORD_CONSTANT(INIT_AFCBAREA,0,g.UNMOVEABLE);
        RECORD_USED(INIT_AFCBAREA) = RECORD_ALLOC(INIT_AFCBAREA);
    #END
    # INITIALIZE
    COMPILER = SUBSTR(STRING(MONITOR(23)),0,4);
    SDF_NAME = '##' + SUBSTR(DESCORE(UNIT),2,6);
    OLD_SDF = g.FALSE;
    # TRY HALSDF, THEN OUTPUT5.  AN SDF IS GOOD IF:
    #    THE DDNAME HAS BEEN DEFINED
    #    THE SDF EXISTS
    #    THE SDF WAS MADE BY A COMPILATION FOR THE APPROPRIATE OBJECT
    #       MACHINE, AND
    #    THE SDF WAS CREATED BY A PHASE3 OF VERSION >= INCLUDABLE_VERSION#
    for g.I  in range(0, 1 + 1):
        if DDBAD(g.I): REPEAT;
        SDFPKG_NPAGES = 3;
        SDFPKG_APGAREA = ADDR(g.INIT_APGAREA[0].AREAPG(0));
        SDFPKG_NBYTES = 512;
        SDFPKG_AFCBAREA = ADDR(g.INIT_AFCBAREA[0].AREAFCB(0));
        SDFPKG_MISC = MISC_VAL(g.I);
        MONITOR(22, 0, COMMTABL_ADDR);
        if SDFPKG_CRETURN != 0: DDBAD(g.I) = g.TRUE;
        else: #DO
            # DDNAME EXISTS
            g.SDF_OPEN = g.TRUE;
            SDFPKG_PAGES_LEFT = SDFPKG_NPAGES;
            MOVE(8, SDF_NAME, SDFPKG_SDFNAM_ADDR);
            _SDFPKG(4);
            if SDFPKG_CRETURN == 12: #DO
                # INSUFFICIENT FCB AREA
                SDFPKG_NPAGES, SDFPKG_APGAREA = 0;
                # SDFPKG SETS SDFPKG_NBYTES TO AMOUNT NEEDED
                RECORD_CONSTANT(FORFCB,SHR(SDFPKG_NBYTES+511,9),g.UNMOVEABLE);
                SDFPKG_AFCBAREA=ADDR(FORFCB(0).FCBADDR(0));
                _SDFPKG(2);
                # TELL SDFPKG ABOUT EXTRA SPACE
                _SDFPKG(4);
                # RE-TRY SELECT
            #END
            REV = SDFPKG_BLKNO;
            CAT = SDFPKG_SYMBNO;
            if SDFPKG_CRETURN == 0: #DO
                # SDF FOUND
                LOCATE_SDF_ROOT;
                if COMPILER == SDF_ROOT_COMPILER: #DO
                    # CORRECT OBJECT
                    LOCATE_SDF_PTR(0);
                    SDF_VERSIONp=SDF_H;
                    if SDF_H >= INCLUDABLE_VERSIONp: #DO
                        # GOOD SDF
                        INCL_FLAGS = INCL_FLAGS | SOURCE_FLAG(g.I);
                        REVSTR = 'RVL ' + STRING(0x01000000 | ADDR(REV)) + 
                        ' CATENATION NUMBER ' + CAT;
                        return g.TRUE;
                    #END
                    else: OLD_SDF = g.TRUE;
                #END
            #END
            TERMINATE_SDFPKG;
        #END
        # OF DDNAME OK
    #END
    # OF DO I =
    # IF WE GET HERE, WE HAVE FAILED
    if RECORD_ALLOC(FORFCB) >0:
    RECORD_FREE(FORFCB);
    if OLD_SDF: g.I = 0;
    else: g.I = 1;
    COMPILER = COMPILER + ' SDF ' + SDF_NAME;
    if (INCL_FLAGS & INCL_TEMPLATE_FLAG) !=0:
    OUTPUT = g.X8 + g.STARS + 'INCLUDED FROM TEMPLATE: ' + COMPILER + 
    REASON(g.I);
    else: ERROR(d.CLASS_XI, g.I+9, COMPILER);
    return g.FALSE;
# END SDF_FOUND;
# THIS IS THE START OF INCLUDE_SDF PROPER
# CHECK FOR LEGAL INCLUDE
if g.NEST > 0: #DO
    ERROR(d.CLASS_PE, 1);
    return g.TRUE;
    # DON'T TRY THE TEMPLATE
#END
elif BLOCK_MODE > 0: #DO
    ERROR(d.CLASS_PE, 2);
    return g.TRUE;
#END
# CHECK TO SEE IF AN SDF EXISTS
if ^SDF_FOUND: return g.FALSE;
# ENTER THE COMPILATION UNIT INTO THE SYMBOL TABLE
LOCATE_SDF_ROOT;
SDF_ROOT_FLAGS = SDF_H(0);
##DFLAG LOOK AT ROOT FLAGS
LAST_COMSUB_SYMB = SDF_ROOT_COMSUB_END;
UNIT_SYMBp = SDF_ROOT_UNIT_SYMBp;
pSDF_PAGES = SDF_ROOT_LAST_PAGE + 1;
LOCATE_SDF_BLOCKp(SDF_ROOT_UNIT_BLKp);
if SDFPKG_BLKNAM != UNIT: #DO
    UNIT = NEW_STRING(SDFPKG_BLKNAM);
    # ERROR CALL DELETED AT IBM REQUEST
#END
if DUPLICATE_NAME(UNIT):
ERROR(d.CLASS_PL, 2, UNIT);
# BUT CONTINUE ANYWAY
pBLK_SYMBS = SDF_BLK_LAST_SYMBp - SDF_BLK_FIRST_SYMBp + 1;
g.ID_LOC = ENTER(UNIT, g.LABEL_CLASS);
BLK_TYPE = SDF_BLK_CATEGORY;
FLAGS = g.EXTERNAL_FLAG | g.DEFINED_LABEL | g.SDF_INCL_FLAG;
if (INCL_FLAGS & INCL_REMOTE_FLAG) != 0: #DO
    if BLK_TYPE == 4 /* COMPOOL */:
    FLAGS = FLAGS | g.REMOTE_FLAG;
    else: ERROR(d.CLASS_XI, 5);
    g.TPL_REMOTE = g.FALSE;
#END
for g.I  in range(0, pBLK_FLAGS + 1):
    if (SDF_BLK_FLAGS & IN_BLK_FLAG(g.I)) != 0:
    FLAGS = FLAGS | OUT_BLK_FLAG(g.I);
#END
g.SYT_FLAGS(g.ID_LOC) = FLAGS;
# DO BLOCK "ENTRY"
g.NEST = 1;
g.SCOPEp_STACK[g.NEST] = SCOPEp;
g.SYT_SCOPE(g.ID_LOC), SCOPEp, MAX_SCOPEp = MAX_SCOPEp + 1;
NEXT_ELEMENT(CSECT_LENGTHS);
g.PROCMARK_STACK[g.NEST] = g.PROCMARK;
g.PROCMARK, g.REGULAR_PROCMARK = g.NDECSY + 1;
g.BLOCK_SYTREF[g.NEST] = g.ID_LOC;
g.SYT_PTR(g.ID_LOC) = g.PROCMARK;
ENTER_LAYOUT(g.ID_LOC);
SYT_LOCKp(g.ID_LOC) = SDF_BLK_VERSIONp;
# ENTER SYMBOLS BASED ON BLOCK TYPE
LOCATE_SDF_SYMBp(UNIT_SYMBp);
NEXT_SYMBOL = SDF_SYMB_DECLARE_LINK;
DO CASE BLK_TYPE;
    ;
    # UNDEFINED
    #DO
        # PROGRAM
        g.BLOCK_MODE[g.NEST] = g.PROG_MODE;
        g.SYT_TYPE(g.ID_LOC) = g.PROG_LABEL;
        g.SYT_FLAGS(g.ID_LOC) = g.SYT_FLAGS(g.ID_LOC) | g.LATCHED_FLAG;
    #END
    #DO
        # PROCEDURE
        #- CR11120 ----------------- #DFLAG ------------------------------
        # IF DATA_REMOTE FLAG SET IN SDF, THEN SET THE COMSUB'S REMOTE
        # FLAG SO THAT OBJECT GENERATOR KNOWS TO SET BIT IN ESD CARD FOR
        # AUTOMATED PRELINKER PLACEMENT IN THE REMOTE #D CSECT.
        if ((SDF_ROOT_FLAGS & 0x0004) != 0):
        g.SYT_FLAGS(g.ID_LOC) = g.SYT_FLAGS(g.ID_LOC) | g.REMOTE_FLAG;
        #-----------------------------------------------------------------
        g.BLOCK_MODE[g.NEST] = g.PROC_MODE;
        g.SYT_TYPE(g.ID_LOC) = g.PROC_LABEL;
        if LAST_COMSUB_SYMB != UNIT_SYMBp:
        ENTER_COMSUB_ARGS;
    #END
    #DO
        # FUNCTION
        #- CR11120 ----------------- #DFLAG ------------------------------
        # IF DATA_REMOTE FLAG SET IN SDF, THEN SET THE COMSUB'S REMOTE
        # FLAG SO THAT OBJECT GENERATOR KNOWS TO SET BIT IN ESD CARD FOR
        # AUTOMATED PRELINKER PLACEMENT IN THE REMOTE #D CSECT.
        if ((SDF_ROOT_FLAGS & 0x0004) != 0):
        g.SYT_FLAGS(g.ID_LOC) = g.SYT_FLAGS(g.ID_LOC) | g.REMOTE_FLAG;
        #-----------------------------------------------------------------
        g.BLOCK_MODE[g.NEST] = g.FUNC_MODE;
        g.SYT_CLASS(g.ID_LOC) = g.FUNC_CLASS;
        SET_TYPE_AND_LEN(g.ID_LOC);
        if LAST_COMSUB_SYMB != UNIT_SYMBp:
        ENTER_COMSUB_ARGS;
    #END
    #DO
        # COMPOOL
        g.BLOCK_MODE[g.NEST] = g.CMPL_MODE;
        g.SYT_TYPE(g.ID_LOC) = g.COMPOOL_LABEL;
        CSECT_LENGTHS(SCOPEp).PRIMARY = PRIMARY_LENGTH;
        CSECT_LENGTHS(SCOPEp).REMOTE = REMOTE_LENGTH;
        CSECT_LENGTH(0),CSECT_LENGTH(1) = 0;
        ENTER_COMPOOL_VARS;
        CSECT_LENGTHS(SCOPEp).PRIMARY = PRIMARY_LENGTH;
        CSECT_LENGTHS(SCOPEp).REMOTE = REMOTE_LENGTH;
    #END
    ;
    ;
    # TASK, UPDATE
#END
# OF DO CASE BLK_TYPE
# PERFORM BLOCK "CLOSING"
g.SYT_FLAGS(g.NDECSY) = g.SYT_FLAGS(g.NDECSY) | g.ENDSCOPE_FLAG;
if g.REGULAR_PROCMARK > g.NDECSY:
g.SYT_PTR(g.BLOCK_SYTREF[g.NEST]) = 0;
# NO LOCAL SYMBOLS
else: for g.I  in range(0, g.NDECSY - g.REGULAR_PROCMARK + 1):
    g.J = g.NDECSY - g.I;
    if (g.SYT_FLAGS(g.J) & g.INACTIVE_FLAG) != 0: REPEAT;
    g.CLOSE_BCD = g.SYT_NAME(g.J);
    DISCONNECT(g.J);
#END
g.SYT_ARRAY(g.BLOCK_SYTREF[g.NEST]) = 0xE000;
g.PROCMARK, g.REGULAR_PROCMARK = g.PROCMARK_STACK[g.NEST];
SCOPEp = g.SCOPEp_STACK[g.NEST];
g.NEST = 0;
# CLEAN UP
for g.I  in range(0, g.FACTOR_LIM + 1):
    # DON'T LEAVE TRACKS
    g.TYPE(g.I) = 0;
#END
g.NAME_IMPLIED, g.TEMPORARY_IMPLIED = g.FALSE;
g.MACRO_ARG_COUNT, g.STRUC_PTR, g.STRUC_DIM, g.STRUC_SIZE = 0;
g.ID_LOC, g.REF_ID_LOC = 0;
g.INCLUDE_STMT = g.g.STMT_NUM();
g.g.STMT_NUM() = g.g.STMT_NUM() + 1;
# TREAT EACH INCLUDE AS ONE STMT
OUTPUT = g.X8 + g.STARS + 'INCLUDED FROM SDF ' + SDF_NAME + g.X1 + g.STARS;
OUTPUT = g.X8 + g.STARS + REVSTR + g.X1 + g.STARS;
OUTPUT = g.X1;
TERMINATE_SDFPKG;
if RECORD_ALLOC(FORFCB) > 0:
RECORD_FREE(FORFCB);
if RECORD_ALLOC(PGING) > 0:
RECORD_FREE(PGING);
if g.SIMULATING:
MAKE_INCL_CELL(SDF_NAME, INCL_FLAGS,
SHL(REV,16) | CAT);
return g.TRUE;
    '''
# END INCLUDE_SDF 

