#!/usr/bin/env python3
'''
License:    The author, Ron Burkey, declares this program to be in the Public
            Domain, and may be used or modified in any way desired.
Filename:   SPACELIB.py
Purpose:    This is part of the port of the original XPL source code for 
            HAL/S-FC into Python.
Contact:    The Virtual AGC Project (www.ibiblio.org/apollo).
History:    2023-08-28 RSB  Began porting process from XPL.
'''

import sys
import g
import HALINCL.COMMON as h
import HALINCL.VMEM1 as v1

'''
/**********************************************************************/        00000010
/* MEMBER NAME:     SPACELIB                                          */        00000020
/* FUNCTION:        THIS FILE CONTAINS THE SPACE MANAGEMENT PROCEDURES*/        00000030
/*          AND DECLARATIONS AS WELL AS A NEW COMPACTIFY.             */        00000040
/*          IT SHOULD BE USED AS INPUT2 TO XPL.                       */        00000050
/*                                                                    */        00000060
/**********************************************************************/        00000070
'''

'''
What most of this library is for remains a mystery to me, partially because
I suspect that most of it relates to memory structures specific to the
IBM hardware and operating system, and no longer present in the modern
implementation in Python.  However, some entities can be ported "in spirit"
to the Python implementation, and that's what I'm doing here.  

On the other hand, even if I've implemented something below, it shouldn't be
assumed that I had a clear idea (or any) of what it was supposed to do.  I
may simply have thought I could get away with making it a "no operation".

Finally, I've included the original XPL, commented out, as a more-convenient 
reference than having to pull it up as a separate file when I want to refer to 
it.
'''

'''
   /%DEBUG N+ L+ %/
DECLARE _AS LITERALLY 'LITERALLY',
         _TRUE _AS '1',
         _FALSE _AS '0',
         _ANDIF _AS 'THEN IF';

DECLARE _IFA(1) _AS '/?A,%1%?/',
        _IFAQ(1) _AS '/?A,''%1%''?/';
/*DOPE VECTOR COMPONENTS FOLLOW*/
DECLARE _DOPE_POINTER(1) _AS 'COREWORD(%1%)',
        _DOPE_WIDTH(1) _AS 'COREHALFWORD(%1%+4)',
        _DOPE_#DESCRIPTORS(1) _AS 'COREHALFWORD(%1%+6)',
        _DOPE_ALLOC(1) _AS 'COREWORD(%1%+8)',
        _DOPE_USED(1) _AS 'COREWORD(%1%+12)',
        _DOPE_NEXT(1) _AS 'COREWORD(%1%+16)',
        _DOPE_ASSOC(1) _AS 'COREWORD(%1%+20)',
        _DOPE_GLOBAL_FACTOR(1) _AS 'COREHALFWORD(%1%+24)',
        _DOPE_GROUP_FACTOR(1) _AS 'COREHALFWORD(%1%+26)';

DECLARE _NUM_TIMES_ZEROED(1) _AS '_DOPE_GLOBAL_FACTOR(%1%)',
   /*GLOBAL FACTOR NOT USED, SO WE USE IT AS TERMINATION CONDITION COUNT*/
       _MAX_ZEROED _AS '2';  /*ABORT IF ANY RECORD ZEROED MORE THAN THIS*/

DECLARE _FREEBLOCK_NEXT(1) _AS 'COREWORD(%1%)',
        _FREEBLOCK_SIZE(1) _AS 'COREWORD(%1%-4)';
DECLARE _RF(1) _AS '((%1%^=0)*(%1%-FREEBASE-3))';  /*FOR PRINT STATEMENTS*/
COMMON (FIRSTRECORD,FIRSTBLOCK,FREEBYTES,RECBYTES,TOTAL_RDESC) FIXED;
DECLARE FREESTRING_TARGET FIXED INITIAL(5000),  /*WHAT TO TRY FOR*/
        FREESTRING_TRIGGER FIXED INITIAL(2000), /*WHEN TO TRY FOR MORE*/
        FREESTRING_MIN     FIXED INITIAL(1000);  /*WHEN TO GIVE UP*/
COMMON  CORELIMIT FIXED;

DECLARE _RECORD#BYTES(1) _AS '_SPACE_ROUND(_DOPE_ALLOC(%1%)*_DOPE_WIDTH(%1%))';
'''

# Return the total number of records so far allocated for an array.
def RECORD_ALLOC(array):
    return len(array)

# I think that a block of allocated memory may have an attribute telling how
# much of the allocation has been "used", and that this is called to set that
# value. It appears to be irrelevant to *us*, so it's a no-op.
def RECORD_USED(integer, value):
    return

# So ... I've implemented this as the highest available index in an array,
# but that can't be right.  There's a place in IDENTIFY, for example, where
# it's clearly the next element after that.  So I don't know what the deal is
# with it.  
def RECORD_TOP(array):
    return len(array) - 1

''' [DECLARE]
        SET_RECORD_WIDTH(2) _AS '_DOPE_WIDTH(ADDR(%1%))=%2%',
'''

'''
The following implementation of ALLOCATE_SPACE() *seemed* like a good idea at
the time, but it's really not.  It defeats the RECORD_TOP() implementation 
above.  To keep RECORD_TOP() working, we can't really allocate any new elements
of an array until the new element is actually used for something.  However,
any array we want to support in ALLOCATE_SPACE() would already have been 
implemented (as a function rather than a simple list) so as to do that anyway.

def ALLOCATE_SPACE(array, records):
    if array is h.CSECT_LENGTHS:
        while len(array) < records:
            array.append(h.csect_lengths())
    elif array is g.LINK_SORT:
        while len(array) < records:
            array.append(g.link_sort())
    elif array is h.SYM_TAB:
        while len(array) < records:
            array.append(h.sym_tab())
    else:
        print("Unknown array in ALLOCATE_SPACE", file=sys.stderr)
        sys.exit(1)
'''
def ALLOCATE_SPACE(array, records):
    return

# Allocates space to add one element to an array.
def NEXT_ELEMENT(array):
    if array is g.MACRO_TEXTS:
        array.append(g.macro_texts())
    elif array is g.OUTER_REF_TABLE:
        array.append(g.outer_ref_table())
    elif array is g.SAVE_PATCH:
        array.append(g.save_patch())
    elif array is h.DOWN_INFO:
        array.append(h.down_info())
    elif array is h.CSECT_LENGTHS:
        array.append(h.csect_lengths())
    elif array is h.SYM_TAB:
        array.append(h.sym_tab())
    elif array is g.LINK_SORT:
        array.append(g.link_sort())
    elif array is h.CROSS_REF:
        array.append(h.cross_ref())
    elif array is h.ADVISE:
        array.append(h.advise())
    else:
        print("Unknown array type in call to NEXT_ELEMENT")
        array.append(None)

''' [DECLARE]
        NEEDMORE_SPACE(1) _AS 'CALL _NEEDMORE_SPACE(ADDR(%1%) _IFAQ(%1%))',
'''

def RECORD_FREE(array):
    array.clear()

# No idea what this does, but I hope it's safe to ignore.
def RECORD_SEAL(array):
    return

# No idea what this does, but I hope it's safe to ignore.
def RECORD_UNSEAL(array):
    return

# I suspect that what the following does is to allocate an array with a given
# number of records, so that number can later be extended.
def RECORD_CONSTANT(array, topIndex, options):
    size = topIndex + 1
    if array is h.FOR_DW:
        # DW is aliased to FOR_DW, which has no other purpose.  We just use
        # DW directly, and it has a fixed size so we don't need to worry 
        # about it.
        return
    elif array is h.FOR_ATOMS:
        for i in range(size):
            array.append(h.for_atoms())
    elif array is h.LIT_PG:
        for i in range(size):
            array.append(h.lit_pg())
    elif array is h.VMEMREC:
        for i in range(size):
            array.append(bytearray([0] * v1.VMEM_PAGE_SIZE))
    else:
        for i in range(size):
            array.append(None)

''' [DECLARE]
        RECORD_GROUPHEAD(3) _AS 'CALL _RECORD_GROUPHEAD(ADDR(%1%),%2%,%3%)',
        RECORD_COORDINATED(3) _AS
       'CALL _RECORD_COORDINATED(ADDR(%1%),ADDR(%2%),%3%)';

DECLARE _IS_REC_CONSTANT(1) _AS '((_DOPE_ASSOC(%1%)&"3000000")^=0)',
       _MAKE_REC_CONSTANT(1) _AS '_DOPE_ASSOC(%1%)=_DOPE_ASSOC(%1%)|"1000000"',
        _IS_REC_UNMOVEABLE(1) _AS '((_DOPE_ASSOC(%1%)&"2000000")^=0)',
     _MAKE_REC_UNMOVEABLE(1) _AS '_DOPE_ASSOC(%1%)=_DOPE_ASSOC(%1%)|"2000000"';
'''

COMPACTIFIES = [0] * (1 + 1)
REALLOCATIONS = 0

'''
DECLARE _IN_COMPACTIFY BIT(1);  /*TRUE IF COMPACTIFY CALLS SPMANAGE*/
DECLARE _CONDOUTPUT(1) _AS 'DO; IF ^_IN_COMPACTIFY _ANDIF (FREELIMIT >
FREEPOINT+650) THEN OUTPUT=%1%; END',
    _CONDSPMANERR(1) _AS 'DO; CALL _SPMANERR(%1%); END';
DECLARE (_DX_TOTAL,_PREV_DX_TOTAL,_LAST_COMPACTIFY_FOUND) FIXED;
DECLARE FORCE_MAJOR BIT(1);  /*IF _TRUE, NEXT COMPACTIFY WILL BE MAJOR*/
BASED DX FIXED;
DESCRIPTOR_MONITOR:
   PROCEDURE(CODE, LOCN, SIZE) BIT(1);
      DECLARE (LOCN, SIZE) FIXED, (CODE, I,J) BIT(16);
      DO CASE CODE & 1;
         DO;  /* GET DESCRIPTORS  */
            DO I = 0 TO 6 BY 2;
               IF DESCRIPTOR_DESCRIPTOR(I+1) = 0 THEN
                  DO;  /* FOUND A HOLE  */
                     DX_SIZE = DX_SIZE + SHR(SIZE, 2);
                     J = MONITOR(6, LOCN, SIZE);
                     IF ^J THEN DO;
                        DESCRIPTOR_DESCRIPTOR(I) = COREWORD(LOCN);
                        DESCRIPTOR_DESCRIPTOR(I+1) = SIZE;
                     END;
                     RETURN J;
                  END;
            END;
            OUTPUT = 'BI000 SEVERITY 3   NOTICE FROM DESCRIPTOR_MONITOR:  ' ||
  ' UNABLE TO ALLOCATE ADDITIONAL DESCRIPTORS. JOB ABANDONED. ';
            CALL EXIT;   /* DR104706 */
         END;
         DO;  /* FREE DESCRIPTORS  */
            DO I = 0 TO 6 BY 2;
               IF COREWORD(LOCN) = DESCRIPTOR_DESCRIPTOR(I) THEN
                  IF SIZE = DESCRIPTOR_DESCRIPTOR(I+1) THEN
                     DO;
                        CALL MONITOR(7, LOCN, SIZE);
                        DESCRIPTOR_DESCRIPTOR(I+1) = 0;
                        DX_SIZE=DX_SIZE-SHR(SIZE,2);
                        RETURN J;
                     END;
            END;
            OUTPUT = 'BI001 SEVERITY 3 INVALID CALL TO '||
                     'RETURN DESCRIPTORS';
            CALL EXIT;   /* DR104706 */
         END;
      END;
   END DESCRIPTOR_MONITOR;

_SPMANERR: PROCEDURE(MSG);
   DECLARE MSG CHARACTER;
   DECLARE NUMERRORS BIT(16), MAX_NUM_ERRORS _AS '50';
   IF ^_IN_COMPACTIFY _ANDIF (FREELIMIT > FREEPOINT+650) THEN DO;
 OUTPUT/?A,OUTPUT(2)?/='BI002 SEVERITY 3 BUG IN SPACE MANAGEMENT SYSTEM ->->'||
         MSG;
      CALL EXIT; /* DR104706 */
   END;
   ELSE DO;
      OUTPUT/?A,OUTPUT(2)?/='BI003 SEVERITY 3  BUG IN SPACE MANAGEMENT SYSTEM';
      CALL EXIT; /* DR104706 */
   END;
   NUMERRORS=NUMERRORS+1;
   IF NUMERRORS >  MAX_NUM_ERRORS THEN DO;
   OUTPUT/?A,OUTPUT(2)?/='BI004 SEVERITY 3 TOO MANY SPACE MANAGEMENT ERRORS '
          || '-- ABORTING.';
      CALL EXIT; /* DR104706 */
    END;
END _SPMANERR;

_SPACE_ROUND: PROCEDURE(BYTES) FIXED;
   DECLARE BYTES FIXED;
   RETURN (BYTES&"FFFFF8")+SHL((BYTES&"7")^=0,3);
END _SPACE_ROUND;

_ACTIVE_DESCRIPTORS: PROCEDURE(DOPE) FIXED;
  /*RETURNS NUMBER OF ACTIVE DESCRIPTORS*/
   DECLARE DOPE FIXED;
   DECLARE (DP,DW,DLAST,DND,I,J,ANS) FIXED;
   ANS=0;
   IF (_DOPE_USED(DOPE) = 0) | (_DOPE_#DESCRIPTORS(DOPE)=0) THEN RETURN 0;
   DW=_DOPE_WIDTH(DOPE);
   DND=SHL(_DOPE_#DESCRIPTORS(DOPE),2);
   DP=_DOPE_POINTER(DOPE);  DLAST=DP+(DW*(_DOPE_USED(DOPE)-1));
   DO I=DP TO DLAST BY DW;
      DO J=I TO I+DND-4 BY 4;
         IF COREWORD(J) ^= 0 THEN ANS=ANS+1;
      END;
   END;
   RETURN ANS;
END _ACTIVE_DESCRIPTORS;

DECLARE _OLDFREELIMIT FIXED; /*WILL DETECT UNAUTHORIZED THEFT OF FREESTRING*/

_CHECK_FOR_THEFT: PROCEDURE;  /*COMPLAINS IF THEFT FROM FREE STRING AREA*/
   IF _OLDFREELIMIT=0 THEN _OLDFREELIMIT=FREELIMIT;
   IF _OLDFREELIMIT ^= FREELIMIT THEN _CONDSPMANERR(
      'UNAUTHORIZED THEFT FROM FREE STRING AREA, WAS='||_OLDFREELIMIT||
      ', IS NOW='||FREELIMIT);
END _CHECK_FOR_THEFT;

DECLARE FREEPRINT BIT(1);

_FREEBLOCK_CHECK: PROCEDURE;
   DECLARE (UPLIM,DOWNLIM,  /*FOR CHECKING BLOCK SIZES*/
            FBYTES,RBYTES,
            RDOPE,RPNTR,RSIZE,  /*FOR RECORD DOPE VECTOR, POINTER,SIZE*/
            BPNTR,BSIZE) FIXED,  /*FOR FREE BLOCK POINTER, SIZE*/
           (BLKNO,RECNO) BIT(16);

   ADDRESS_CHECK: PROCEDURE(ADDRESS);  /*SCREAM IF NOT DOUBLE WORD ALIGNED*/
      DECLARE ADDRESS FIXED;
      IF ADDRESS >= 0 _ANDIF (ADDRESS&"7")=0 THEN RETURN;
      _CONDSPMANERR('IN FREEBLOCK_CHECK, NOT ALIGNED ON DOUBLE WORD, ADDRESS='
          ||_RF(ADDRESS));
   END ADDRESS_CHECK;

   BLKPROC:  PROCEDURE;
      IF BPNTR > 0 THEN
       DO;
         BLKNO=BLKNO+1;
         BSIZE=_FREEBLOCK_SIZE(BPNTR);
         FBYTES=FBYTES+BSIZE;
         IF FREEPRINT THEN _CONDOUTPUT('BLOCK #'||BLKNO||',FROM='||_RF(BPNTR)||
          ',FOR='||BSIZE||',TO='||_RF(BPNTR-BSIZE+4));
         CALL ADDRESS_CHECK(BPNTR-4);
         IF (BPNTR+4) ^= UPLIM THEN _CONDSPMANERR(
          'BLOCK WRONG SIZE, BPNTR='||BPNTR||',UPLIM='||_RF(UPLIM));
         UPLIM=UPLIM-BSIZE;
         BPNTR=_FREEBLOCK_NEXT(BPNTR);
         IF BPNTR > 0 _ANDIF BPNTR > RPNTR THEN _CONDSPMANERR(
          '2 CONSECUTIVE BLOCKS.');
       END;
   END BLKPROC;

   CALL _CHECK_FOR_THEFT;
   FBYTES,RBYTES,BLKNO,RECNO=0;
   UPLIM=CORELIMIT; DOWNLIM=FREELIMIT+512;
   RDOPE=FIRSTRECORD;
   BPNTR=FIRSTBLOCK;
   IF FREEPRINT THEN
      _CONDOUTPUT('***  DUMP OF RECORDS AND BLOCKS, CORELIMIT='||_RF(CORELIMIT)
       ||',FREELIMIT='||_RF(FREELIMIT)||',FIRSTRECORD='||FIRSTRECORD||
            ',FIRSTBLOCK='||_RF(FIRSTBLOCK));
     /*PROLOGUE DONE, START THROUGH STRUCTURES*/
   DO WHILE RDOPE > 0;
      RPNTR=_DOPE_POINTER(RDOPE);
      IF (RPNTR>0) & (RPNTR > BPNTR) THEN
       DO;  /*PROCESS A RECORD*/
         RECNO=RECNO+1;
         RSIZE=_RECORD#BYTES(RDOPE);
         RBYTES=RBYTES+RSIZE;
       IF FREEPRINT _ANDIF ^_IN_COMPACTIFY _ANDIF FREELIMIT > FREEPOINT+650 THEN
            OUTPUT='RECORD #'||RECNO||',WIDTH='||_DOPE_WIDTH(RDOPE)
          ||',ALLOC='||_DOPE_ALLOC(RDOPE)||',USED='||_DOPE_USED(RDOPE)||
          ', START='||_RF(RPNTR)||', TOTAL BYTES ALLOC='||RSIZE||', DOPE AT '||
             RDOPE||', ACTIVE DESCRIPTORS='||_ACTIVE_DESCRIPTORS(RDOPE)||
             ', C='||SHR(_DOPE_ASSOC(RDOPE),24);
         CALL ADDRESS_CHECK(_DOPE_POINTER(RDOPE));
         IF (RPNTR+RSIZE)^=UPLIM THEN _CONDSPMANERR(
            'RECORD HAS WRONG SIZE,UPLIM='||_RF(UPLIM));
         UPLIM=UPLIM-RSIZE;
         RDOPE=_DOPE_NEXT(RDOPE);
       END;
       ELSE CALL BLKPROC;
   END;
   CALL BLKPROC;
   IF BPNTR ^= 0 THEN _CONDSPMANERR('CONSECUTIVE FREEBLOCKS.');
   IF UPLIM ^= DOWNLIM THEN _CONDSPMANERR('FINAL BLOCK WRONG SIZE, UPLIM='||
     UPLIM||',DOWNLIM='||DOWNLIM);
   IF FREEPRINT THEN _CONDOUTPUT(FBYTES||' BYTES OF FREEBYTES, '||RBYTES||
      ' ALLOCATED, TOTAL OF '||RBYTES+FBYTES);
   CALL _CHECK_FOR_THEFT;
   IF (FBYTES^=FREEBYTES) | (RBYTES^=RECBYTES) THEN _CONDSPMANERR(
      'FBYTES='||FBYTES||', FREEBYTES='||FREEBYTES||', RBYTES='||
       RBYTES||', RECBYTES='||RECBYTES);
END _FREEBLOCK_CHECK;

_UNUSED_BYTES: PROCEDURE FIXED; /*RETURNS NUMBER OF UNUSED BYTES
     IN ALLOCATED RECORDS (OTHER THAN CONSTANT)*/
   DECLARE (CUR,ANS) FIXED;
   CUR=FIRSTRECORD;   ANS=0;
   DO WHILE CUR > 0;
      IF ^_IS_REC_CONSTANT(CUR) THEN
       ANS=ANS+
         ("FFFFFFF8" & (_DOPE_WIDTH(CUR)*(_DOPE_ALLOC(CUR)-_DOPE_USED(CUR))));
      CUR=_DOPE_NEXT(CUR);
   END;
   /?A _CONDOUTPUT('UNUSED BYTES='||ANS); ?/
   RETURN ANS;
END _UNUSED_BYTES;

_MOVE_WORDS: PROCEDURE(SOURCE,DEST,NUMBYTES);  /*MOVES WHOLE WORDS
   IF DEST > SOURCE, THEN MOVE UP WITH SOURCE,DEST THE
   BYTE ADDRESSES OF THE TOP WORD OF EACH RECORD;
      IF SOURCE < DEST, THEN MOVE DOWN, WITH SOURCE,DEST THE BYTE ADDRESSES
     OF THE BOTTOM WORD OF EACH  BLOCK*/
   DECLARE (SOURCE,DEST,NUMBYTES) FIXED;
   DECLARE I FIXED;
  /?A _CONDOUTPUT(
     'MOVE_WORDS, '||NUMBYTES||', FROM='||_RF(SOURCE)||', TO='||_RF(DEST));?/
    /?A IF (((SOURCE&"3") | (DEST&"3")) ^= 0) |(SOURCE<=0)|(DEST<=0) THEN  DO;
         _CONDSPMANERR('IN MOVEWORDS, FROM='
       ||SOURCE||', TO='||DEST||', NUMBYTES='||NUMBYTES);
       CALL EXIT;
       END;  ?/
   IF DEST > SOURCE THEN /*MOVE UP */
      DO I=0 TO NUMBYTES-4 BY 4;
         COREWORD(DEST-I) = COREWORD(SOURCE-I);
      END;
      ELSE DO I=0 TO NUMBYTES -4 BY 4;
         COREWORD(DEST+I)=COREWORD(SOURCE+I);
      END;
END _MOVE_WORDS;

_SQUASH_RECORDS: PROCEDURE;
   DECLARE (CURDOPE,RECPTR,LAST_RECPTR,
            CURBLOCK,NEXTBLOCK,BYTES_TO_MOVE_BY) FIXED;
   DECLARE SQUASHED FIXED;
     SQUASHED=0;
     /?A OUTPUT='SQUASHING'; ?/
   BYTES_TO_MOVE_BY=0;
   CURBLOCK=FIRSTBLOCK;  CURDOPE=FIRSTRECORD;
   DO WHILE CURDOPE > 0;
      IF ^_IS_REC_UNMOVEABLE(CURDOPE) THEN ESCAPE;
      CURDOPE=_DOPE_NEXT(CURDOPE);
   END;  /*ESCAPED FROM ABOVE AT FIRST MOVEABLE RECORD*/
   IF CURDOPE <= 0 THEN RETURN;
   RECPTR=_DOPE_POINTER(CURDOPE);
BLOCKLOOP:
   DO WHILE CURBLOCK > 0;
      BYTES_TO_MOVE_BY=BYTES_TO_MOVE_BY+_FREEBLOCK_SIZE(CURBLOCK);
      NEXTBLOCK=_FREEBLOCK_NEXT(CURBLOCK);
      DO WHILE RECPTR>CURBLOCK; /*PASS THROUGH RECORDS NOT TO BE MOVED*/
         CURDOPE=_DOPE_NEXT(CURDOPE);
         IF CURDOPE=0 THEN ESCAPE BLOCKLOOP;
         RECPTR=_DOPE_POINTER(CURDOPE);
         IF _IS_REC_UNMOVEABLE(CURDOPE) THEN _CONDSPMANERR(
          'IN _SQUASH_RECORDS, UNMOVEABLE AFTER MOVEABLES, DOPE='||CURDOPE);
      END;
      DO UNTIL RECPTR<NEXTBLOCK; /*MOVE RECORDS BEFORE NEXT FREEBLOCK*/
         DECLARE (RECBYTES,I) FIXED;
         RECBYTES=_RECORD#BYTES(CURDOPE);
         CALL _MOVE_WORDS(RECPTR+RECBYTES-4,RECPTR+RECBYTES-4+BYTES_TO_MOVE_BY,
            RECBYTES);
        SQUASHED=SQUASHED+RECBYTES;
         _DOPE_POINTER(CURDOPE)=_DOPE_POINTER(CURDOPE)+BYTES_TO_MOVE_BY;
         CURDOPE=_DOPE_NEXT(CURDOPE);
         IF CURDOPE <= 0 THEN ESCAPE BLOCKLOOP;
         LAST_RECPTR=RECPTR;
         RECPTR=_DOPE_POINTER(CURDOPE);
      END;
      CURBLOCK=NEXTBLOCK;
   END BLOCKLOOP;
   IF BYTES_TO_MOVE_BY > 0 THEN
    DO;  /*IF ANY MOVING HAPPENED, NEW FREEBLOCK*/
      FIRSTBLOCK=FREELIMIT+FREEBYTES-4+512;
      _FREEBLOCK_SIZE(FIRSTBLOCK)=FREEBYTES;
      _FREEBLOCK_NEXT(FIRSTBLOCK)=0;
    END;
   /?A _CONDOUTPUT('SQUASH SQUASHED '||SQUASHED);?/
   IF SQUASHED > 0 THEN CALL _FREEBLOCK_CHECK;
END _SQUASH_RECORDS;

_PREV_FREEBLOCK: PROCEDURE(BLOCK) FIXED;
   /*RETURNS A POINTER TO THE FREEBLOCK WHOSE NEXT BLOCK IS BLOCK*/
   DECLARE BLOCK FIXED;
   DECLARE (PREV,CUR) FIXED;
   PREV=0; CUR=FIRSTBLOCK;
   DO WHILE (CUR > 0) & (CUR ^= BLOCK);
      PREV=CUR;
      CUR=_FREEBLOCK_NEXT(CUR);
   END;
   RETURN PREV;
END _PREV_FREEBLOCK;

_PREV_RECORD: PROCEDURE(DOPE) FIXED;
   /*RETURNS POINTER TO THE DOPE VECTOR OF RECORD WHOSE NEXT RECORD IS DOPE*/
   DECLARE DOPE FIXED;
   DECLARE (PREV,CUR) FIXED;
   PREV=0;  CUR=FIRSTRECORD;
   DO WHILE (CUR > 0) & (CUR ^= DOPE);
      PREV=CUR;
      CUR=_DOPE_NEXT(CUR);
   END;
   RETURN PREV;
END _PREV_RECORD;

_ATTACH_BLOCK: PROCEDURE(BLOCK);
  /*BLOCK IS A BLOCK OF FREE STORAGE, ATTACH IT TO FREEBLOCK LIST*/
   DECLARE BLOCK FIXED;
   DECLARE (PREV,CUR) FIXED;
   JOIN: PROCEDURE(B1,B2); /*JOIN BLOCKS B1 TO B2*/
      DECLARE (B1,B2) FIXED;
      IF B1^=0 THEN DO;
          _FREEBLOCK_NEXT(B1)=B2;
          IF (B1-_FREEBLOCK_SIZE(B1)) = B2 THEN
           DO;
             _FREEBLOCK_NEXT(B1)=_FREEBLOCK_NEXT(B2);
             _FREEBLOCK_SIZE(B1)=_FREEBLOCK_SIZE(B1)+_FREEBLOCK_SIZE(B2);
           END;
      END;
   END JOIN;

   PREV=0; CUR=FIRSTBLOCK;
   DO WHILE CUR > 0;
      IF CUR < BLOCK THEN ESCAPE;
      PREV=CUR; CUR=_FREEBLOCK_NEXT(CUR);
   END;
   _FREEBLOCK_NEXT(BLOCK)=CUR;
   CALL JOIN(BLOCK,CUR);
   IF PREV=0 THEN FIRSTBLOCK=BLOCK;
    ELSE CALL JOIN(PREV,BLOCK);
   /?A OUTPUT='_ATTACH_BLOCK DONE.';?/  CALL _FREEBLOCK_CHECK;
END _ATTACH_BLOCK;

_ATTACH_RECORD: PROCEDURE(DOPE);
   /*DOPE IS POINTER TO DOPE VECTOR OF NEW RECORD -- ATTACH IT TO RECORD LIST*/
   DECLARE DOPE FIXED;
   DECLARE (PREV,CUR,LOC) FIXED;
  /?A _CONDOUTPUT('_ATTACH_RECORD '||DOPE||',WIDTH='||_DOPE_WIDTH(DOPE)||
       ',ALLOC='||_DOPE_ALLOC(DOPE)); ?/
   IF FIRSTRECORD = 0 THEN FIRSTRECORD=DOPE;
    ELSE DO;
      PREV=0;CUR=FIRSTRECORD; LOC=_DOPE_POINTER(DOPE);
      DO UNTIL CUR = 0;
         IF _DOPE_POINTER(CUR) < LOC THEN ESCAPE;
         PREV=CUR;  CUR=_DOPE_NEXT(CUR);
      END;
      _DOPE_NEXT(DOPE)=CUR;
      IF PREV=0 THEN FIRSTRECORD=DOPE;
       ELSE _DOPE_NEXT(PREV) =DOPE;
    END;
   TOTAL_RDESC=TOTAL_RDESC+(_DOPE_#DESCRIPTORS(DOPE)*_DOPE_ALLOC(DOPE));
   /?A _CONDOUTPUT('_ATTACH_RECORD DONE, RDESC='||TOTAL_RDESC);?/
   CALL _FREEBLOCK_CHECK;
END _ATTACH_RECORD;

_DETACH_RECORD: PROCEDURE(DOPE);
   DECLARE DOPE FIXED;
   DECLARE PREV FIXED;
   PREV=_PREV_RECORD(DOPE);
   IF PREV=0 THEN FIRSTRECORD=_DOPE_NEXT(DOPE);
    ELSE _DOPE_NEXT(PREV)=_DOPE_NEXT(DOPE);
   TOTAL_RDESC=TOTAL_RDESC-(_DOPE_#DESCRIPTORS(DOPE)*_DOPE_ALLOC(DOPE));
   /?A _CONDOUTPUT('RECORD DETACHED, DOPE='||DOPE||',RDESC='||TOTAL_RDESC); ?/
END _DETACH_RECORD;

_REDUCE_BLOCK: PROCEDURE(BLOCK,REMBYTES,TOP);
   DECLARE (BLOCK,REMBYTES) FIXED,
    TOP BIT(1);  /*TOP TRUE IF BYTES TAKEN FROM TOP*/
   DECLARE (PREV,OLDNBYTES,NEWBLOCK) FIXED;
   OLDNBYTES=_FREEBLOCK_SIZE(BLOCK);
   IF REMBYTES > OLDNBYTES THEN DO;
      _CONDSPMANERR('IN REDUCE_BLOCK, REMBYTES='||REMBYTES||', OLDNBYTES='
        ||OLDNBYTES);
      CALL EXIT;
    END;
   IF ^TOP & (REMBYTES < OLDNBYTES) THEN
       _FREEBLOCK_SIZE(BLOCK)=OLDNBYTES-REMBYTES;
    ELSE DO;
      PREV=_PREV_FREEBLOCK(BLOCK);
      IF REMBYTES=OLDNBYTES THEN
       DO;  /*ELIMINATE THE BLOCK */
         IF PREV=0 THEN FIRSTBLOCK=_FREEBLOCK_NEXT(BLOCK);
          ELSE _FREEBLOCK_NEXT(PREV)=_FREEBLOCK_NEXT(BLOCK);
       END;
       ELSE DO;  /*SHORTEN THIS BLOCK FROM TOP */
         NEWBLOCK=BLOCK-REMBYTES;
         _FREEBLOCK_NEXT(NEWBLOCK)=_FREEBLOCK_NEXT(BLOCK);
         _FREEBLOCK_SIZE(NEWBLOCK)=OLDNBYTES-REMBYTES;
         IF PREV=0 THEN FIRSTBLOCK=NEWBLOCK;
          ELSE _FREEBLOCK_NEXT(PREV)=NEWBLOCK;
       END;
   END;
END _REDUCE_BLOCK;

_RETURN_TO_FREESTRING: PROCEDURE(NBYTES);
  /*RETURN NBYTES FROM THE BOTTOM OF THE BOTTOM BLOCK TO THE FREESTRING AREA*/
   DECLARE NBYTES FIXED;
  /?A _CONDOUTPUT('RETURN TO FREESTRING='||NBYTES||', FREEBYTES='||FREEBYTES);?/
   IF NBYTES=0 THEN RETURN;
   IF NBYTES > FREEBYTES THEN _CONDSPMANERR(
     'IN RETURN_TO_FREESTRING, NBYTES='||NBYTES||', FREEBYTES='||FREEBYTES);
    ELSE DO;
      CALL _SQUASH_RECORDS;
      /* FIRSTBLOCK (BECAUSE OF SQUASH) IS THE ONLY BLOCK*/
      IF FIRSTBLOCK <= 0 THEN _CONDSPMANERR(
        'IN RETURN_TO_FREESTRING, FIRSTBLOCK='||FIRSTBLOCK);
      CALL _REDUCE_BLOCK(FIRSTBLOCK,NBYTES,_FALSE);
      _OLDFREELIMIT,FREELIMIT=FREELIMIT+NBYTES;
      FREEBYTES=FREEBYTES-NBYTES;
    END;
END _RETURN_TO_FREESTRING;

_RECORD_FREE: PROCEDURE(DOPE _IFA(NAME));
  /*REATTACHES THE RECORD FOR WHICH DOPE IS THE DOPE VECTOR --
     FREEBYTES WILL GROW AND RECBYTES WILL SHRINK*/
   DECLARE DOPE FIXED /?A,NAME CHARACTER?/ ;
   DECLARE (SIZE,PREV,NEWBLOCK) FIXED;
    /*DETACH RECORD FROM RECORD LIST*/
   /?A _CONDOUTPUT('RETURNING '||NAME||', DOPE='||DOPE); ?/
   CALL _CHECK_FOR_THEFT;
   IF _DOPE_ALLOC(DOPE) <= 0 THEN
    DO;
      _CONDSPMANERR('IN RECORD_FREE, NOT ALLOCATED: '
         ||/?ANAME||', DOPE='||?/DOPE);
      RETURN;
    END;
   CALL _DETACH_RECORD(DOPE);
   SIZE=_RECORD#BYTES(DOPE);
   _DOPE_ALLOC(DOPE)=0;
   FREEBYTES=FREEBYTES+SIZE;  RECBYTES=RECBYTES-SIZE;
    /*NOW ATTACH THE SPACE TO FREEBLOCK*/
   NEWBLOCK=_DOPE_POINTER(DOPE)+SIZE-4; /*NOTE THAT RECORDS USE LAST TWO WORDS*/
   _FREEBLOCK_SIZE(NEWBLOCK)=SIZE;
   CALL _ATTACH_BLOCK(NEWBLOCK);
END _RECORD_FREE;

_RETURN_UNUSED: PROCEDURE(DOPE,NRECS _IFA(NAME));  /*RETURN NRECS UNUSED RECORDS
    OF THE RECORD WHOSE DOPE VECTOR IS DOPE.  NRECS=0 MEANS RETURN ALL UNUSED*/
   DECLARE (DOPE,NRECS) FIXED  /?A ,NAME CHARACTER?/ ;
   DECLARE (NEWBLOCK,OLDNBYTES,NEWNBYTES,DIF) FIXED;
   DIF=_DOPE_ALLOC(DOPE)-_DOPE_USED(DOPE);
   /?A _CONDOUTPUT('RETURN_UNUSED, DOPE='||DOPE||',NRECS='||NRECS||',ALLOC='
       ||_DOPE_ALLOC(DOPE)||',USED='||_DOPE_USED(DOPE));  ?/
   IF NRECS=0 THEN
    DO;  /*RETURN ALL UNUSED BLOCKS*/
      NRECS=DIF;
      _NUM_TIMES_ZEROED(DOPE)=0;
      IF NRECS=0 THEN RETURN;
    END;
    ELSE IF NRECS=DIF THEN
     DO;
      _NUM_TIMES_ZEROED(DOPE)=_NUM_TIMES_ZEROED(DOPE)+1;
      IF _NUM_TIMES_ZEROED(DOPE)>_MAX_ZEROED THEN DO;
         OUTPUT/?A,OUTPUT(2)?/='BI010 SEVERITY 3  SPACE MANAGEMENT ' ||
         'YOYOING -- TRY LARGER REGION.';
         CALL EXIT;   /* DR104706 */
       END;
    END;
   ELSE IF NRECS > DIF THEN
    DO;
      _CONDSPMANERR('TRIED TO RETURN '||NRECS||' BUT ONLY '||DIF||
         'ARE UNUSED IN '||DOPE);
      NRECS=DIF;
    END;
   IF DIF=_DOPE_ALLOC(DOPE) THEN CALL _RECORD_FREE(DOPE _IFA(NAME));
   ELSE DO;
      TOTAL_RDESC=TOTAL_RDESC-NRECS*_DOPE_#DESCRIPTORS(DOPE);
      OLDNBYTES=_RECORD#BYTES(DOPE);
      _DOPE_ALLOC(DOPE)=_DOPE_ALLOC(DOPE)-NRECS;
      NEWNBYTES=_RECORD#BYTES(DOPE);
      DIF=OLDNBYTES-NEWNBYTES;
      /*DO NOT TRY TO RETURN FREE SPACE WHEN DIF IS ZERO*/
      IF DIF=0 THEN RETURN; /*DR111339*/
      NEWBLOCK=_DOPE_POINTER(DOPE)+OLDNBYTES-4;
      _FREEBLOCK_NEXT(NEWBLOCK)=0;
      _FREEBLOCK_SIZE(NEWBLOCK)=DIF;
      FREEBYTES=FREEBYTES+DIF;  RECBYTES=RECBYTES-DIF;
 /?A _CONDOUTPUT('RECORD REDUCED, DOPE='||DOPE||',ALLOC='||_DOPE_ALLOC(DOPE)||
        ',RDESC='||TOTAL_RDESC);?/
      CALL _ATTACH_BLOCK(NEWBLOCK);
   END;
END _RETURN_UNUSED;

_TAKE_BACK: PROCEDURE(NBYTES);  /*RESTORE TO FREEBLOCKS UP TO NBYTES*/
   DECLARE NBYTES FIXED;
   DECLARE (CUR,RET_RECS,DIF_RECS,POSSIBLE,LEFTBYTES) FIXED,
     PREV_FREEBYTES FIXED, PREV_FREEPRINT BIT(1);
   /?A _CONDOUTPUT('TAKING BACK '||NBYTES);?/
   REALLOCATIONS=REALLOCATIONS+1;
   PREV_FREEPRINT=FREEPRINT;  FREEPRINT=_FALSE;
   POSSIBLE=_UNUSED_BYTES;
   IF NBYTES > POSSIBLE THEN NBYTES=POSSIBLE; LEFTBYTES=NBYTES;
   CUR=FIRSTRECORD;
   DO WHILE (CUR > 0) & (LEFTBYTES > 0);
      IF ^_IS_REC_CONSTANT(CUR) THEN
       DO;
         DIF_RECS,RET_RECS=_DOPE_ALLOC(CUR)-_DOPE_USED(CUR);
         IF RET_RECS > 0 THEN
          DO;
            RET_RECS=(NBYTES*RET_RECS)/POSSIBLE + 1;
            IF RET_RECS*_DOPE_WIDTH(CUR) > LEFTBYTES THEN
             RET_RECS=LEFTBYTES/_DOPE_WIDTH(CUR) + 1;
            IF RET_RECS > DIF_RECS THEN RET_RECS=DIF_RECS;
            PREV_FREEBYTES=FREEBYTES;
            CALL _RETURN_UNUSED(CUR,RET_RECS /?A ,'?'?/);
            LEFTBYTES=LEFTBYTES-(FREEBYTES-PREV_FREEBYTES);
          END;
       END;
      CUR=_DOPE_NEXT(CUR);
    END;
   FREEPRINT=PREV_FREEPRINT;
   /?A IF LEFTBYTES > 0 THEN _CONDOUTPUT('BUT TOOK BACK ALL BUT '||LEFTBYTES);?/
END _TAKE_BACK;

COMPACTIFY:
   PROCEDURE;
   DECLARE (I, J, K, L, ND, TC, BC, DELTA, MODE,ACTUAL_DX_TOTAL) FIXED;
   DECLARE MASK FIXED INITIAL ("FFFFFF"), (LOWER_BOUND, UPPER_BOUND) FIXED,
           TRIED BIT(1);
ADD_DESC: PROCEDURE(I);
   DECLARE(I,L) FIXED;
     L = COREWORD(I) & MASK;
      IF (L >= LOWER_BOUND) & (L <= UPPER_BOUND) THEN
         DO;
            ND = ND + 1;
            IF ND = ACTUAL_DX_TOTAL THEN
               DO;  /* WE HAVE TOO MANY POTENTIALLY COLLECTABLE STRINGS  */
                  OUTPUT = 'BI005 SEVERITY 3  NOTICE FROM COMPACTIFY:'||
                  '  INSUFFICIENT SORT AREA. JOB ABANDONED.';
                  CALL EXIT;   /* DR104706 */
               END;
            DX(ND) = I;
         END;
END ADD_DESC;

   /* FIRST WE MUST SET THE LOWER BOUND OF THE COLLECTABLE AREA */
   IF LOWER_BOUND = 0 THEN LOWER_BOUND = FREEBASE;
   GO TO START;
   CALL INLINE("50", 2, 0, LOWER_BOUND);
   MODE = 1;  /* LINKING */
   START:
     /?COUTPUT='COMPACTIFY CALLED';?/
   UPPER_BOUND = FREELIMIT + 512;
   _DX_TOTAL=DX_SIZE+TOTAL_RDESC;
    IF _DX_TOTAL ^= _PREV_DX_TOTAL THEN
    DO;
     /?C OUTPUT='CHANGING _DX_TOTAL';?/
 IF ACTUAL_DX_TOTAL>0 THEN CALL MONITOR(7,ADDR(DX),SHL(ACTUAL_DX_TOTAL,2));
   I=MONITOR(21);  /*I NOW HAS THE MAXIMUM NUMBER OF AVAILABLE BYTES*/
   J=SHL(_DX_TOTAL+1,2);  /*J NOW HAS THE MAXIMUM NUMBER OF NEEDED BYTES*/
   IF I>J THEN I=J; /*GET LOWER OF AVAILABLE AND NEEDED BYTES*/
   ACTUAL_DX_TOTAL=SHR(I,2);
   IF MONITOR(6,ADDR(DX),I) THEN DO;
      OUTPUT='BI006 SEVERITY 3  BUG IN COMPACTIFY***  ABORTING';
      CALL EXIT;   /* DR104706 */
    END;
       _PREV_DX_TOTAL=_DX_TOTAL;
     END;
 DO TRIED = 0 TO 1;
     IF FORCE_MAJOR THEN DO;
         FORCE_MAJOR=_FALSE;
         LOWER_BOUND=FREEBASE;
         TRIED=1;
      END;
    COMPACTIFIES(TRIED) = COMPACTIFIES(TRIED) + 1;
   ND = -1;
   /* FIND THE COLLECTABLE DESCRIPTORS  */
   DO J = 0 TO 6 BY 2;
    K = DESCRIPTOR_DESCRIPTOR(J);
    DO I = K TO K + DESCRIPTOR_DESCRIPTOR(J + 1) - 1 BY 4;
      CALL ADD_DESC(I);
    END;
   END;
   L=FIRSTRECORD;
   DO WHILE L ^= 0;
      IF _DOPE_#DESCRIPTORS(L) > 0 _ANDIF _DOPE_USED(L) > 0 THEN
       DO;
         DECLARE (DP,DW) FIXED;
         DP=_DOPE_POINTER(L);  DW=_DOPE_WIDTH(L);
         DO J=DP TO DP+DW*(_DOPE_USED(L)-1) BY DW;
            DO K=J TO J+4*(_DOPE_#DESCRIPTORS(L)-1) BY 4;
               CALL ADD_DESC(K);
            END;
         END;
       END;
      L=_DOPE_NEXT(L);
   END;
   FREEPOINT = LOWER_BOUND;
  IF ND >= 0 THEN DO;
   /* SORT IN ASCENDING ORDER  */
   K = SHR(ND+1,1);
   DO WHILE K > 0;
      DO J = 0 TO ND-K;
         I = J;
         DO WHILE (COREWORD(DX(I)) & MASK) > (COREWORD(DX(I+K)) & MASK);
            L = DX(I);
            DX(I) = DX(I+K);
            DX(I+K) = L;
            I = I - K;
            IF I < 0 THEN ESCAPE;
         END;
      END;
      K = SHR(K,1);
   END;
   /* MOVE THE ACTIVE STRINGS DOWN  */
   TC, DELTA = 0;
   BC = 1;   /* SETUP INITIAL CONDITION  */
   DO I = 0 TO ND;
      J = COREWORD(DX(I));
      IF (J & MASK) - 1 > TC THEN
         DO;
           IF DELTA > 0 THEN
            DO K = BC TO TC;
               COREBYTE(K-DELTA) = COREBYTE(K);
            END;
            FREEPOINT = FREEPOINT + TC - BC + 1;
            BC = J & MASK;
            DELTA = BC - FREEPOINT;
         END;
      COREWORD (DX(I)) = J - DELTA;
      L = (J & MASK) + SHR(J, 24);
      IF TC < L THEN TC = L;
   END;
   DO K = BC TO TC;
      COREBYTE(K-DELTA) = COREBYTE(K);
   END;
   FREEPOINT = FREEPOINT + TC - BC + 1;
  END;
   IF MODE THEN
      DO;
         /?C OUTPUT='LINKING TO NEXT PHASE.'; ?/
         IF ACTUAL_DX_TOTAL>0 THEN
         CALL MONITOR(7, ADDR(DX), SHL(ACTUAL_DX_TOTAL , 2));
         I = ADDR(DESCRIPTOR_DESCRIPTOR);
         K=FIRSTRECORD;
         IF K ^= 0 THEN K=K|"80000000";
         CALL INLINE("58", 0, 0, LOWER_BOUND);
         CALL INLINE("58", 2, 0, I);
         CALL INLINE("58", 4, 0, UPPER_BOUND);  /* CORETOP PASSED IN R4 */
         CALL INLINE("58", 5, 0, K);
         RETURN FREEPOINT;
      END;
   _LAST_COMPACTIFY_FOUND=FREELIMIT-FREEPOINT;
   IF (SHL(FREELIMIT-FREEPOINT, 4) < FREELIMIT-FREEBASE) |
      FREELIMIT-FREEPOINT <  FREESTRING_TRIGGER THEN
     DO;
      LOWER_BOUND = FREEBASE;
      /?C OUTPUT='MAJOR COMPACTIFY WILL BE TRIED.';?/
     END;
   ELSE
      DO;
         LOWER_BOUND = FREEPOINT;
          /?C OUTPUT='COMPACTIFY DONE.'; ?/
         RETURN ND;
      END;
   /* THE HOPE IS THAT WE WON'T HAVE TO COLLECT ALL THE STRINGS EVERY TIME */
   END;  /* OF THE DO TRIED LOOP       */
   IF _LAST_COMPACTIFY_FOUND < FREESTRING_TRIGGER THEN
    DO;
      _IN_COMPACTIFY=_TRUE;
      /?C OUTPUT='COMPACTIFY WILL STEAL BACK.'; ?/
      K=_SPACE_ROUND(FREESTRING_TARGET - _LAST_COMPACTIFY_FOUND);
      IF FREEBYTES < K THEN
       CALL _TAKE_BACK(K-FREEBYTES);
      IF FREEBYTES+_LAST_COMPACTIFY_FOUND < FREESTRING_MIN THEN
       DO;
         OUTPUT='BI007 SEVERITY 3 NOT ENOUGH SPACE AVAILABLE -- ' ||
                'TRY LARGER REGION.';
         CALL EXIT;   /* DR104706 */
       END;
      IF K > FREEBYTES THEN K=FREEBYTES;
      CALL _RETURN_TO_FREESTRING(K);
      _IN_COMPACTIFY=_FALSE;
    END;
      _LAST_COMPACTIFY_FOUND=FREELIMIT-FREEPOINT;
      IF _LAST_COMPACTIFY_FOUND < FREESTRING_MIN THEN
            DO;
               OUTPUT = 'BI008 SEVERITY 3 NOTICE FROM COMPACTIFY: ' ||
               'INSUFFICIENT MEMORY FOR STRING STORAGE. JOB ABANDONED.';
               CALL EXIT;   /* DR104706 */
            END;
   RETURN ND;
END COMPACTIFY;

_STEAL: PROCEDURE(NBYTES); /*STEAL NBYTES FROM FREE STRING AREA*/
   DECLARE NBYTES FIXED;
   DECLARE BLOCKLOC FIXED;
  /?A OUTPUT='STEALING '||NBYTES||'  FROM STRINGS, FREELIMIT='||_RF(FREELIMIT)||
    ',FREEPOINT='||_RF(FREEPOINT)||',DIFF='||FREELIMIT-FREEPOINT; ?/
   IF CORELIMIT=0 THEN CORELIMIT=FREELIMIT+512;
   IF FREELIMIT-FREEPOINT < NBYTES THEN
    DO;
      FORCE_MAJOR=_TRUE;
      CALL COMPACTIFY;
    END;
   IF FREELIMIT-FREEPOINT < NBYTES THEN
    DO;
   /?A OUTPUT=FREELIMIT-FREEPOINT||' BYTES AVAILABLE, REQUIRED='||NBYTES;?/
      OUTPUT/?A,OUTPUT(2)?/= 'BI011 SEVERITY 3 ' ||
         'NOT ENOUGH FREE STRING AVAILABLE, RERUN WITH LARGER REGION.';
      CALL EXIT;   /* DR104706 */
    END;
   _OLDFREELIMIT,FREELIMIT=FREELIMIT-NBYTES;
   FREEBYTES=FREEBYTES+NBYTES;
   BLOCKLOC=FREELIMIT+NBYTES+512-4;
   _FREEBLOCK_NEXT(BLOCKLOC)=0;
   _FREEBLOCK_SIZE(BLOCKLOC)=NBYTES;
   CALL _ATTACH_BLOCK(BLOCKLOC);
END _STEAL;

DECLARE _GUARANTEE_FREE(1) _AS
     'DO;IF FREEBYTES < %1% THEN CALL _STEAL(%1%-FREEBYTES);END;';

_MOVE_RECS: PROCEDURE(DOPE,BYTES_TO_MOVE_BY);
   DECLARE (DOPE,BYTES_TO_MOVE_BY) FIXED;
   DECLARE (NBYTES,SOURCE,CURDOPE) FIXED;
   /?A OUTPUT=' MOVERECS OF DOPE='||DOPE||' FOR '||BYTES_TO_MOVE_BY; ?/
   CURDOPE=DOPE;
   NBYTES=0;
   IF FIRSTBLOCK ^= 0 _ANDIF _FREEBLOCK_NEXT(FIRSTBLOCK)=0
    _ANDIF _FREEBLOCK_SIZE(FIRSTBLOCK) >= BYTES_TO_MOVE_BY
    THEN DO;  /*ASSUMES SQUASH -- TEMPORARILY -- WILL FIX*/
      DO UNTIL CURDOPE=0;
         SOURCE=_DOPE_POINTER(CURDOPE);
         NBYTES=NBYTES+ _RECORD#BYTES(CURDOPE);
         _DOPE_POINTER(CURDOPE)=_DOPE_POINTER(CURDOPE)-BYTES_TO_MOVE_BY;
         CURDOPE=_DOPE_NEXT(CURDOPE);
      END;
      CALL _REDUCE_BLOCK(FIRSTBLOCK,BYTES_TO_MOVE_BY,_TRUE);
      CALL _MOVE_WORDS(SOURCE,SOURCE-BYTES_TO_MOVE_BY,NBYTES);
      RETURN;
    END;
   CALL _SPMANERR('IN MOVE_RECS,FIRSTBLOCK='||_RF(FIRSTBLOCK)||' SIZE= '||
      _FREEBLOCK_SIZE(FIRSTBLOCK));
END _MOVE_RECS;

_FIND_FREE: PROCEDURE(NBYTES,UNMOVEABLE) FIXED;
    /*RETURNS POINTER TO BLOCK CONTAINING AT LEAST NBYTES FREE BYTES*/
   DECLARE NBYTES FIXED, UNMOVEABLE BIT(1);
   DECLARE I BIT(16), CURBLOCK FIXED;
   /?A OUTPUT='_FIND_FREE, NBYTES='||NBYTES||',FREEBYTES='||FREEBYTES; ?/
   _GUARANTEE_FREE(NBYTES);
   IF UNMOVEABLE THEN
    DO;  /*GET SPACE BEFORE FIRST MOVEABLE*/
      CALL _SQUASH_RECORDS;
      DECLARE DOPE FIXED;
      DOPE=FIRSTRECORD;
      DO WHILE DOPE^=0;
         IF ^_IS_REC_UNMOVEABLE(DOPE) THEN
          DO;
            CURBLOCK=_DOPE_POINTER(DOPE)+_RECORD#BYTES(DOPE)-4;
            CALL _MOVE_RECS(DOPE,NBYTES);
            _FREEBLOCK_SIZE(CURBLOCK)=NBYTES;
            _FREEBLOCK_NEXT(CURBLOCK)=0;
            CALL _ATTACH_BLOCK(CURBLOCK);
            RETURN CURBLOCK;
          END;
         DOPE=_DOPE_NEXT(DOPE);
       END;
      RETURN FIRSTBLOCK; /*ALL RECORDS UNMOVEABLE*/
    END;
   DO I = 0 TO 1;
      CURBLOCK=FIRSTBLOCK;
      DO WHILE CURBLOCK ^= 0;
        IF _FREEBLOCK_SIZE(CURBLOCK) >= NBYTES THEN RETURN CURBLOCK;
        CURBLOCK=_FREEBLOCK_NEXT(CURBLOCK);
      END;
      CALL _SQUASH_RECORDS;
      RETURN FIRSTBLOCK;
    END;
END _FIND_FREE;

_INCREASE_RECORD: PROCEDURE(DOPE,NRECSMORE);
   DECLARE (DOPE,NRECSMORE) FIXED;
   DECLARE (OLDNRECS,OLDNBYTES,NEWNRECS,NEWNBYTES,NBYTESMORE,I) FIXED;
   /?A OUTPUT='INCREASE ALLOCATION OF '||DOPE||' BY '||NRECSMORE; ?/
   REALLOCATIONS=REALLOCATIONS+1;
   NEWNRECS=_DOPE_ALLOC(DOPE)+NRECSMORE;
   NEWNBYTES=_SPACE_ROUND(NEWNRECS*_DOPE_WIDTH(DOPE));
   OLDNBYTES=_RECORD#BYTES(DOPE);
   NBYTESMORE=NEWNBYTES-OLDNBYTES;
   IF NBYTESMORE > FREEBYTES THEN CALL _STEAL(NBYTESMORE-FREEBYTES);
   CALL _SQUASH_RECORDS;
   CALL _MOVE_RECS(DOPE,NBYTESMORE);
   DO I = _DOPE_POINTER(DOPE)+OLDNBYTES TO _DOPE_POINTER(DOPE)
      +NEWNBYTES-4 BY 4;
      COREWORD(I)=0;
   END;
   _DOPE_ALLOC(DOPE)=NEWNRECS;
   RECBYTES=RECBYTES+NBYTESMORE;
   FREEBYTES=FREEBYTES-NBYTESMORE;
   TOTAL_RDESC=TOTAL_RDESC+NRECSMORE*_DOPE_#DESCRIPTORS(DOPE);
   CALL _FREEBLOCK_CHECK;
END _INCREASE_RECORD;

_GET_SPACE: PROCEDURE(NBYTES,UNMOVEABLE) FIXED;
    /*GETS NBYTES BYTES OF FREE SPACE*/
   DECLARE NBYTES FIXED, UNMOVEABLE BIT(1);
   DECLARE (FREEB,NEWREC) FIXED;
   IF (NBYTES&"7") ^= 0 THEN CALL _SPMANERR(
    'IN _GET_SPACE, NBYTES='||NBYTES);
   FREEB=_FIND_FREE(NBYTES,UNMOVEABLE);
   /*FREEB NOW POINTS TO FREE BLOCK WITH AT LEAST NBYTES BYTES*/
   NEWREC=FREEB-NBYTES+4;
   CALL _REDUCE_BLOCK(FREEB,NBYTES,_TRUE);
   DECLARE I FIXED;
   DO I=0 TO NBYTES-4 BY 4;
      COREWORD(NEWREC+I)=0;
   END;
   RECBYTES=RECBYTES+NBYTES;
   FREEBYTES=FREEBYTES-NBYTES;
   RETURN NEWREC;
END _GET_SPACE;

_HOW_MUCH: PROCEDURE(DOPE,ANS) FIXED;
  /*RETURNS NUMBER OF RECORDS TO INCREASE ALLOCATION OF DOPE BY*/
   DECLARE (DOPE,ANS) FIXED;
   DECLARE (ANSBYTES,NSTRBYTES,ANSMIN) FIXED;
   IF ANS=0 THEN ANS=_DOPE_ALLOC(DOPE)/2 + 10;
   ANSMIN=ANS/2;
   ANSBYTES=_SPACE_ROUND(_DOPE_WIDTH(DOPE)*ANS);
   NSTRBYTES=FREELIMIT-FREEPOINT-FREESTRING_TRIGGER;
   IF NSTRBYTES < 0 THEN NSTRBYTES=0;
   IF ANSBYTES <= NSTRBYTES+FREEBYTES THEN RETURN ANS;
   CALL _TAKE_BACK(ANSBYTES-NSTRBYTES-FREEBYTES);
   IF ANSBYTES > NSTRBYTES+FREEBYTES _ANDIF ^_IS_REC_CONSTANT(DOPE) THEN
    DO;
      FORCE_MAJOR=_TRUE; CALL COMPACTIFY;
      /?A OUTPUT='MAJOR FOUND '||FREELIMIT-FREEPOINT;?/
      NSTRBYTES=FREELIMIT-FREEPOINT-FREESTRING_TRIGGER;
      IF ANSBYTES > NSTRBYTES+FREEBYTES THEN
         ANS=((NSTRBYTES+FREEBYTES)/_DOPE_WIDTH(DOPE)) -1;
      IF ANS < ANSMIN THEN ANS=((NSTRBYTES+FREEBYTES+FREESTRING_TRIGGER
                       -FREESTRING_MIN))/_DOPE_WIDTH(DOPE)-1;
      IF ANS < ANSMIN THEN DO;
         OUTPUT='BI009 SEVERITY 3  NOT ENOUGH SPACE FOR INCREASED ' ||
                ' ALLOCATION, GIVING UP.';
         CALL EXIT;   /* DR104706 */
       END;
    END;
   RETURN ANS;
END _HOW_MUCH;

_ALLOCATE_SPACE: PROCEDURE(DOPE,HIREC _IFA(NAME));
   DECLARE (DOPE,HIREC,NREC,OREC) FIXED /?A,NAME CHARACTER?/ ;
   OREC,NREC=HIREC+1;
   /?A OUTPUT='ALLOCATING RECORD='||NAME||' ,DOPE='||DOPE||
       ', WIDTH='||_DOPE_WIDTH(DOPE)||
     ',NUMDESC='||_DOPE_#DESCRIPTORS(DOPE)||',ALLOC='||NREC; ?/
   IF _DOPE_WIDTH(DOPE) <= 0 THEN DO;
      CALL _SPMANERR('RECORD HAS WIDTH=0, DOPE='||DOPE/?A||', NAME='||NAME?/);
      RETURN;
    END;
   IF _DOPE_ALLOC(DOPE) > 0 THEN
    DO;
      CALL _SPMANERR('IN ALLOCATE_SPACE, ALREADY ALLOCATED: '||
         /?A NAME||', DOPE='||?/DOPE);
      RETURN;
    END;
   NREC=_HOW_MUCH(DOPE,NREC);
   /?A IF OREC^=NREC THEN OUTPUT='BUT ACTUALLY ALLOCATING '||NREC||
         ' FOR '||NAME; ?/
   _DOPE_POINTER(DOPE)=_GET_SPACE(_SPACE_ROUND(_DOPE_WIDTH(DOPE) * NREC),
         _IS_REC_UNMOVEABLE(DOPE));
   _DOPE_ALLOC(DOPE)=NREC;
   _DOPE_USED(DOPE)=0;
   _NUM_TIMES_ZEROED(DOPE)=0;
   CALL _ATTACH_RECORD(DOPE);
END _ALLOCATE_SPACE;

_RECORD_CONSTANT: PROCEDURE(DOPE,HIREC,MOVEABLE _IFA(NAME));
   DECLARE (DOPE,HIREC) FIXED, MOVEABLE BIT(1) /?A,NAME CHARACTER ?/;
   _MAKE_REC_CONSTANT(DOPE);  IF ^MOVEABLE THEN _MAKE_REC_UNMOVEABLE(DOPE);
   CALL _ALLOCATE_SPACE(DOPE,HIREC _IFA(NAME));
   _DOPE_USED(DOPE) = _DOPE_ALLOC(DOPE);
END _RECORD_CONSTANT;


_NEEDMORE_SPACE: PROCEDURE(DOPE _IFA(NAME));
   DECLARE DOPE FIXED /?A,NAME CHARACTER?/ ;
   /?A OUTPUT='NEEDMORE SPACE FOR '||NAME||', DOPE='||DOPE; ?/
   CALL _CHECK_FOR_THEFT;
   IF _IS_REC_CONSTANT(DOPE) THEN CALL _SPMANERR(
    'TRIED TO INCREASE CONSTANT RECORD, DOPE='||DOPE);
  IF _DOPE_ALLOC(DOPE)=0 THEN
   CALL _ALLOCATE_SPACE(DOPE,-1 _IFA(NAME));
    ELSE CALL _INCREASE_RECORD(DOPE,_HOW_MUCH(DOPE,0));
END _NEEDMORE_SPACE;

_RECORD_SEAL: PROCEDURE(DOPE _IFA(NAME));    /*SEAL THE RECORD*/
   DECLARE DOPE FIXED /?A,NAME CHARACTER?/ ;
  /?A OUTPUT='SEALING RECORD '||NAME||', DOPE='||DOPE; ?/
   CALL _RETURN_UNUSED(DOPE,0 _IFA(NAME));
   _MAKE_REC_CONSTANT(DOPE);
END _RECORD_SEAL;

_RECORD_UNSEAL: PROCEDURE(DOPE _IFA(NAME));
   DECLARE DOPE FIXED /?A, NAME CHARACTER?/;
   /?A OUTPUT='UNSEAL '||NAME||' ,DOPE='||DOPE; ?/
   IF ^_IS_REC_CONSTANT(DOPE) THEN CALL _SPMANERR(
    'IN RECORD UNSEAL, RECORD NOT CONSTANT: '||/?ANAME||' ,DOPE='||?/DOPE);
   _DOPE_ASSOC(DOPE)=_DOPE_ASSOC(DOPE)&"FFFFFF";
END _RECORD_UNSEAL;

_RECORD_GROUPHEAD: PROCEDURE(DOPE,GLOBFACT,GROUPFACT);
   DECLARE DOPE FIXED, (GLOBFACT,GROUPFACT) BIT(16);
   _DOPE_GLOBAL_FACTOR(DOPE)=GLOBFACT;
   /* _DOPE_GROUP_FACTOR(DOPE)=GROUPFACT; */
END _RECORD_GROUPHEAD;

_RECORD_COORDINATED: PROCEDURE(DOPE,REFDOPE,GROUPFACT);
   DECLARE (DOPE,REFDOPE) FIXED, GROUPFACT BIT(16);
   _DOPE_ASSOC(DOPE)=REFDOPE;
   /* _DOPE_GROUP_FACTOR(DOPE)=GROUPFACT; */
END _RECORD_COORDINATED;
'''

def RECORD_LINK():
    sys.exit(0)

'''
   /% DEBUG N@ S@  %/
'''