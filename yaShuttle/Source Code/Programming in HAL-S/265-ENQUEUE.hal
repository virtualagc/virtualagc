C/ From PDF p. 265 of "Programming in HAL/S".

D INCLUDE TEMPLATE CPL269 # For PROCESS_CONTROL
D INCLUDE TEMPLATE CPL264 # For TQE


  ENQUEUE:
  PROCEDURE(WHEN, WHAT, PROCNAME);
     DECLARE WHEN SCALAR,
             WHAT INTEGER,
             PROCNAME NAME PROCESS_CONTROL-STRUCTURE;
     DECLARE FREE_Q NAME TQE-STRUCTURE;
     DECLARE ACTV_Q NAME TQE-STRUCTURE;
     DECLARE NEW NAME TQE-STRUCTURE;
     
C  THE FOLLOWING NAME VARIABLE IS USED LIKE A LOOP
C  VARIABLE IN A SEACH

     DECLARE ENT NAME TQE-STRUCTURE;
     
C  IF NO FREE ENTRY THEN AN ERROR
     IF NAME(FREE_Q) = NULL THEN
        RETURN;
        
C    ELSE USE TOP FREE ENTRY FOR NEW ACTIVE Q ELEMENT
     NAME(NEW) = NAME(FREE_Q);

C    REMOVE NEW ENTRY FROM FREE_Q
     NAME(FREE_Q) = NAME(FREE_Q.NEXT);

C  PUT INFO INTO NEW ENTRY

     NEW.TIME = WHEN;
     NEW.ACTION = WHAT;

     NAME(NEW.AFFECTED_PROCESS) = NAME(PROCNAME);

C     NOW INSERT NEW ENTRY IN APPROPRIATE POINT OF ACTV QUEUE
C           EITHER BEFORE FIRST,
C           BETWEEN ENT AND ENT.NEXT FOR SOME ENT
C           OR AT END OF QUEUE

     IF NEW.TIME < ACTV_Q.TIME THEN
        DO;

           NAME(NEW.NEXT) = NAME(ACTV_Q);	/* PUT FIRST */

           NAME(ACTV_Q) = NAME(NEW);

	   RETURN;
	END;

     NAME(ENT) = NAME(ACTV_Q);			/*START AT TOP*/

     DO UNTIL NAME(ENT.NEXT) = NAME(NULL);	/* SEARCH Q*/

        NAME(ENT) = NAME(ACTV_Q);		/*START AT TOP*/
        IF ENT.NEXT.TIME > NEW.TIME THEN
           DO;
              NAME(NEW.NEXT) = NAME(ENT.NEXT);
              NAME(ENT.NEXT) = NAME(NEW);
              RETURN;				/*NEW ENTRY INSERTED*/
	   END;

 	NAME(ENT) = NAME(ENT.NEXT);		/* TRY NEXT ENTRY*/     
     END;
     
C  AT THIS POINT, THE WHOLE Q HAS BEEN SEARCHED UNSUCCESSFULLY,
C  SO ADD NEW TO THE END
     NAME(ENT.NEXT) = NAME(NEW);
     NAME(NEW.NEXT) = NULL;
     
  CLOSE ENQUEUE;
  