@echo off >NUL
:: This Windows batch script compiles a HAL/S program using the HAL/S-FC program,
:: which is assumed to be in the PATH.  ERRORLIB is assumed to be in the same
:: folder as HALSFC-PASS1.exe.

:: I've made this batch file as close to functionally identical to the 
:: BASH script HALSFC as feasible, but there are some differences:
::   1. HALSFC has an optional 5th command-line parameter, namely the filename 
::      extension for the compiler executables.  Not so for HALSFC.bat.
::      That's because the BASH script can be used to cross-compile from
::      Linux to Windows, but that shouldn't happen with this batch file.
::   2. HALSFC includes the files &&TEMPLIB and &&TEMPINC generated by 
::      HAL_S_FC.py in the results folder, but HALSFC.bat does not.  That's
::      because the character '&' in the filename introduces big problems in 
::      Windows that I didn't feel like working around.  And there just seemed 
::      to be no point in doing so.  Perhaps at some point I will.

for /f "tokens=*" %%i in ('where HAL_S_FC.py') do set HAL_S_FC=%%i
for /f "tokens=*" %%i in ('where HALSFC-PASS1.exe') do set "ERRORLIB=%%~piERRORLIB"
for /f "delims=" %%i in ("%HAL_S_FC%") do set ported=%%~dpi
setlocal enabledelayedexpansion

set HALS_FILE=%~1
for %%f in ("%HALS_FILE%) do (
	set "NORM_FILE=%%~nxf"
)
set TEST=%~2
set PARM_STRING=%~3
set TARGET=%~4
:: Parameter 5, if any, is ignored.
set COMMAND_LINE=%*

set PYTHONUTF8=1
set NOW=%DATE% %TIME%

set FILES_PORTED="FILE1.bin FILE2.bin FILE3.bin FILE4.bin FILE5.bin FILE6.bin"
set FILES_PORTED="%FILES_PORTED:"=% SOURCECO.txt"
set FILES_PORTED="%FILES_PORTED:"=% LIT_CHAR.bin SYM_TAB.json"
set FILES_PORTED="%FILES_PORTED:"=% CROSS_REF.json"
set FILES_LOCAL="LISTING2.txt"
set FILES_LOCAL="%FILES_LOCAL:"=% vmem.bin COMMON1.out COMMON2.out"
set FILES_LOCAL="%FILES_LOCAL:"=% COMMON3.out COMMON4.out auxmat.bin objcode.bin"
set FILES_LOCAL="%FILES_LOCAL:"=% COMMON1.gz COMMON2.gz COMMON3.gz COMMON4.gz"
set FILES_LOCAL="%FILES_LOCAL:"=% pass1A.rpt"
set FILES_LOCAL="%FILES_LOCAL:"=% pass1pA.rpt flo.rpt aux.rpt"
set FILES_LOCAL="%FILES_LOCAL:"=% pass3.rpt pass4.rpt monitor13.parms"
set FILES_LOCAL="%FILES_LOCAL:"=% auxp.rpt deck.bin extra.txt"
set FILES_PRESERVE="litfile.bin cards COMMON0.out COMMON0.gz TEMPLIB.json TEMPLIB TEMPLIBB.json TEMPLIBB pass1.rpt pass1p.rpt opt.rpt pass2.rpt cards.bin listing2.txt optmat.bin halmat.bin
del %FILES_PORTED:"=% %FILES_LOCAL:"=% pass*.rpt cards.bin listing2.txt "&&TEMPLIB.json" "&&TEMPINC.json" >NUL 2>NUL

::if "%COMMON_EXT%"=="" (
::	set COMMON_EXT=out
::)
set COMMON_EXT=out

goto :main

:: Move all generated files to a *.results folder.
:move_all
	set results="HALSFC %NORM_FILE% %NOW%.results"
	set results=%results:"=%
	set results=%results:/=-%
	set results=%results::=-%
	mkdir "%results%" >NUL 2>NUL
	echo %* >"%results%\comment.txt"
	copy "&&TEMPLIB.json" TEMPLIB.json >NUL 2>NUL
	for %%i in ( %FILES_PORTED:"=% %FILES_LOCAL:"=% ) do move %%i "%results%" >NUL 2>NUL
	for %%i in ( %FILES_PRESERVE:"=% ) do copy %%i "%results%" >NUL 2>NUL
	copy "%HALS_FILE%" "%results%" >NUL 2>NUL
	exit /B 0

:: The arguments comprise an error message, which is printed, and then the
:: entire script is exited with an error code of 1.  The trick for aborting
:: a batch script from within a function came from here:
:: https://stackoverflow.com/questions/3227796/exit-batch-script-from-inside-a-function.
:: Note that this particular trick apparently aborts all parent scripts that
:: run HALSFC.bat as well.  The same hyperlink points out a different trick 
:: that aborts *only* HALSFC.bat but remains within its parent scripts, but that
:: trick is pretty incomprehensible in comparison to this one, and I see no
:: great need for it, so I haven't implemented it here.
:error_exit
	echo %*
	call :move_all %*: %COMMAND_LINE%
	echo Results in "%results%"
	call :__ErrorExit 2>NUL
	exit /B 1
:: The actual exit from the script is caused by the syntax error below.
:__ErrorExit
	()
	exit /B 0

:main

if not exist "%HALS_FILE%" (
        echo.
        echo. This script compiles a HAL/S file to an AP-101S object-code file.
        echo.
        echo.      HALSFC SOURCE.hal [ TEST [ "PARMS" [ TARGET ]]]
        echo.
        echo. Parameters appear in the indicated order.  Missing parameters
        echo. in the middle of the list can use \"\" as place markers for the.
        echo. defaults.  The parameters are interpreted as follows:
        echo.
        echo.      SOURCE.hal   The HAL/S source-code file.
        echo.      TEST         Perform all available validity tests if non-blank.
        echo.      "PARMS"      Quoted list of comma-separated compiler options.
        echo.      TARGET       Use either PFS, the default, or BFS.
        echo.
        exit /B 1
)

if "%TARGET%". == "BFS". (
    set PASS1=HALSFC-PASS1B
    set FLO=HALSFC-FLO
    set OPT=HALSFC-OPTB
    set AUXP=HALSFC-AUXP
    set PASS2=HALSFC-PASS2B
    set PASS3=HALSFC-PASS3B
    set PASS4=HALSFC-PASS4
    set TEMPLIB=TEMPLIBB
    set CARDS=--pdso=3,cards,E
    set TARGET=--bfs
) else (
    set PASS1=HALSFC-PASS1
    set FLO=HALSFC-FLO
    set OPT=HALSFC-OPT
    set AUXP=HALSFC-AUXP
    set PASS2=HALSFC-PASS2
    set PASS3=HALSFC-PASS3
    set PASS4=HALSFC-PASS4
    set TEMPLIB=TEMPLIB
    set CARDS=--ddo=3,cards.bin,E
    set TARGET=--pfs
)
set PARM_LIST=
if not "%PARM_STRING%." == "." set PARM_LIST=%PARM_STRING:,= %

%PASS1% ^
        --parm="%PARM_STRING%" ^
        --ddi=0,"%HALS_FILE%" ^
        --ddo=2,listing2.txt ^
        --pdsi=4,%TEMPLIB%,E ^
        --pdsi=5,"%ERRORLIB%" ^
        --pdsi=6,ACCESS  ^
        --pdso=6,%TEMPLIB%,E ^
        --commono=COMMON0.%COMMON_EXT% ^
        --raf=B,7200,1,halmat.bin ^
        --raf=B,1560,2,litfile.bin ^
        --raf=B,3360,6,vmem.bin ^
        >pass1.rpt
if errorlevel 1 ( call :error_exit Aborted after PASS1 )

set IGNORE_LINES=(HAL/S^|FREE STRING AREA^|NUMBER OF FILE 6^|PROCESSING RATE^|CPU TIME FOR^|TODAY IS^|COMPOOL.*VERSION)
::echo IGNORE_LINES=%IGNORE_LINES%
if %TEST%x == TESTx (
echo ======================================================
( egrep -V >NUL 2>NUL && diff -v >NUL 2>NUL ) && echo Utilities egrep/diff available || call :error_exit Utilities egrep/diff unavailable
python "%HAL_S_FC%" %PARM_LIST% %TARGET% --templib --hal="%HALS_FILE%" >pass1p.rpt && echo PASS1 cross-comparison test ... || call :error_exit Failed PASS1 cross-comparison test
for %%i in ( %FILES_PORTED:"=% ) do copy %ported%..\%%i . >NUL 2>NUL
egrep -v "%IGNORE_LINES%" pass1.rpt  >pass1A.rpt
egrep -v "%IGNORE_LINES%" pass1p.rpt >pass1pA.rpt
diff --strip-trailing-cr -q -s pass1A.rpt pass1pA.rpt
diff --strip-trailing-cr -s FILE1.bin halmat.bin
if not "%PARM_LIST%" == "%PARM_LIST:LISTING2=%" diff -q -s LISTING2.txt listing2.txt
echo ======================================================
)

%FLO% ^
        --commoni=COMMON0.%COMMON_EXT% ^
        --commono=COMMON1.%COMMON_EXT% ^
        --raf=B,7200,1,halmat.bin ^
        --raf=B,1560,2,litfile.bin ^
        --raf=B,3360,6,vmem.bin ^
        >flo.rpt
if errorlevel 1 ( call :error_exit Aborted after FLO )


%OPT% ^
        --commoni=COMMON1.%COMMON_EXT% ^
        --commono=COMMON2.%COMMON_EXT% ^
        --raf=B,7200,1,halmat.bin ^
        --raf=B,1560,2,litfile.bin ^
        --raf=B,7200,4,optmat.bin ^
        --raf=B,3360,6,vmem.bin ^
        >opt.rpt
if errorlevel 1 ( call :error_exit Aborted after OPT )

%AUXP% ^
        --commoni=COMMON2.%COMMON_EXT% ^
        --commono=COMMON3.%COMMON_EXT% ^
        --raf=B,7200,1,auxmat.bin ^
        --raf=B,1560,2,litfile.bin ^
        --raf=B,7200,4,optmat.bin ^
        --raf=B,3360,6,vmem.bin ^
        >auxp.rpt
if errorlevel 1 ( call :error_exit Aborted after AUXP )


%PASS2% ^
        %CARDS% ^
        --ddo=4,deck.bin,E ^
        --pdsi=5,"%ERRORLIB%" ^
        --ddo=7,extra.txt ^
        --commoni=COMMON3.%COMMON_EXT% ^
        --commono=COMMON4.%COMMON_EXT% ^
        --raf=B,7200,1,auxmat.bin ^
        --raf=B,1560,2,litfile.bin ^
        --raf=B,1600,3,objcode.bin ^
        --raf=B,7200,4,optmat.bin ^
        --raf=B,3360,6,vmem.bin ^
        >pass2.rpt
if errorlevel 1 ( call :error_exit Aborted after PASS2 )

:: PASS3 and PASS4 aren't ready for use yet.

call :move_all Success: %COMMAND_LINE%
echo Compilation successful. Results in "%results%".
